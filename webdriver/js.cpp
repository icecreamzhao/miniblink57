// Copyright 2018 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file was generated by running:
//     ../../chrome/test/chromedriver/embed_js_in_cpp.py --directory gen/chrome/test/chromedriver/chrome ../../chrome/test/chromedriver/js/call_function.js ../../chrome/test/chromedriver/js/dispatch_touch_event.js ../../chrome/test/chromedriver/js/execute_async_script.js ../../chrome/test/chromedriver/js/execute_script.js ../../chrome/test/chromedriver/js/focus.js ../../chrome/test/chromedriver/js/get_element_location.js ../../chrome/test/chromedriver/js/get_element_region.js ../../chrome/test/chromedriver/js/is_option_element_toggleable.js

#include "webdriver/js.h"

namespace webdriver {
const char kCallFunctionScript[] =
    "function() { // Copyright 2012 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "/**\n"
    " * Enum for WebDriver status codes.\n"
    " * @enum {number}\n"
    " */\n"
    "var StatusCode = {\n"
    "  STALE_ELEMENT_REFERENCE: 10,\n"
    "  JAVA_SCRIPT_ERROR: 17,\n"
    "  NO_SUCH_SHADOW_ROOT: 65,\n"
    "  DETACHED_SHADOW_ROOT: 66\n"
    "};\n"
    "\n"
    "/**\n"
    " * Enum for node types.\n"
    " * @enum {number}\n"
    " */\n"
    "var NodeType = {\n"
    "  ELEMENT: 1,\n"
    "  DOCUMENT: 9,\n"
    "};\n"
    "\n"
    "/**\n"
    " * Dictionary key to use for holding an element ID.\n"
    " * @const\n"
    " * @type {string}\n"
    " */\n"
    "var ELEMENT_KEY = 'ELEMENT';\n"
    "\n"
    "/**\n"
    " * Dictionary key to use for holding a shadow element ID.\n"
    " * @const\n"
    " * @type {string}\n"
    " */\n"
    " var SHADOW_ROOT_KEY = 'shadow-6066-11e4-a52e-4f735466cecf';\n"
    "\n"
    "/**\n"
    " * True if using W3C Element references.\n"
    " * @const\n"
    " * @type {boolean}\n"
    " */\n"
    "var w3cEnabled = false;\n"
    "\n"
    "/**\n"
    " * True if shadow dom is enabled.\n"
    " * @const\n"
    " * @type {boolean}\n"
    " */\n"
    "var SHADOW_DOM_ENABLED = typeof ShadowRoot === 'function';\n"
    "\n"
    "/**\n"
    " * Generates a unique ID to identify an element.\n"
    " * @void\n"
    " * @return {string} Randomly generated ID.\n"
    " */\n"
    "function generateUUID() {\n"
    "  var array = new Uint8Array(16);\n"
    "  window.crypto.getRandomValues(array);\n"
    "  array[6] = 0x40 | (array[6] & 0x0f);\n"
    "  array[8] = 0x80 | (array[8] & 0x3f);\n"
    "\n"
    "  var UUID = \"\";\n"
    "  for (var i = 0; i < 16; i++) {\n"
    "    var temp = array[i].toString(16);\n"
    "    if (temp.length < 2)\n"
    "      temp = \"0\" + temp;\n"
    "    UUID += temp;\n"
    "    if (i == 3 || i == 5 || i == 7 || i == 9)\n"
    "      UUID += \"-\";\n"
    "  }\n"
    "  return UUID;\n"
    "};\n"
    "\n"
    "/**\n"
    " * Constructs new error to be thrown with given code and message.\n"
    " * @param {string} message Message reported to user.\n"
    " * @param {StatusCode} code StatusCode for error.\n"
    " * @return {!Error} Error object that can be thrown.\n"
    " */\n"
    "function newError(message, code) {\n"
    "  const error = new Error(message);\n"
    "  error.code = code;\n"
    "  return error;\n"
    "}\n"
    "\n"
    "/**\n"
    " * A cache which maps IDs <-> cached objects for the purpose of identifying\n"
    " * a script object remotely. Uses UUIDs for identification.\n"
    " * @constructor\n"
    " */\n"
    "function CacheWithUUID() {\n"
    "  this.cache_ = Object.create(null);\n"
    "}\n"
    "\n"
    "CacheWithUUID.prototype = {\n"
    "  /**\n"
    "   * Stores a given item in the cache and returns a unique UUID.\n"
    "   *\n"
    "   * @param {!Object} item The item to store in the cache.\n"
    "   * @return {number} The UUID for the cached item.\n"
    "   */\n"
    "  storeItem: function(item) {\n"
    "    for (var i in this.cache_) {\n"
    "      if (item == this.cache_[i])\n"
    "        return i;\n"
    "    }\n"
    "    var id = generateUUID();\n"
    "    this.cache_[id] = item;\n"
    "    return id;\n"
    "  },\n"
    "\n"
    "  /**\n"
    "   * Retrieves the cached object for the given ID.\n"
    "   *\n"
    "   * @param {number} id The ID for the cached item to retrieve.\n"
    "   * @return {!Object} The retrieved item.\n"
    "   */\n"
    "  retrieveItem: function(id) {\n"
    "    var item = this.cache_[id];\n"
    "    if (item && this.isNodeReachable_(item))\n"
    "      return item;\n"
    "    throw newError('element is not attached to the page document',\n"
    "                   StatusCode.STALE_ELEMENT_REFERENCE);\n"
    "  },\n"
    "\n"
    "  isNodeReachable_: function(node) {\n"
    "    var nodeRoot = getNodeRootThroughAnyShadows(node);\n"
    "    return (nodeRoot == document.documentElement.parentNode);\n"
    "  }\n"
    "};\n"
    "\n"
    "/**\n"
    " * A cache which maps IDs <-> cached objects for the purpose of identifying\n"
    " * a script object remotely.\n"
    " * @constructor\n"
    " */\n"
    "function Cache() {\n"
    "  this.cache_ = Object.create(null);\n"
    "  this.nextId_ = 1;\n"
    "  this.idPrefix_ = Math.random().toString();\n"
    "}\n"
    "\n"
    "Cache.prototype = {\n"
    "\n"
    "  /**\n"
    "   * Stores a given item in the cache and returns a unique ID.\n"
    "   *\n"
    "   * @param {!Object} item The item to store in the cache.\n"
    "   * @return {number} The ID for the cached item.\n"
    "   */\n"
    "  storeItem: function(item) {\n"
    "    for (var i in this.cache_) {\n"
    "      if (item == this.cache_[i])\n"
    "        return i;\n"
    "    }\n"
    "    var id = this.idPrefix_  + '-' + this.nextId_;\n"
    "    this.cache_[id] = item;\n"
    "    this.nextId_++;\n"
    "    return id;\n"
    "  },\n"
    "\n"
    "  /**\n"
    "   * Retrieves the cached object for the given ID.\n"
    "   *\n"
    "   * @param {number} id The ID for the cached item to retrieve.\n"
    "   * @return {!Object} The retrieved item.\n"
    "   */\n"
    "  retrieveItem: function(id) {\n"
    "    var item = this.cache_[id];\n"
    "    if (item && this.isNodeReachable_(item))\n"
    "      return item;\n"
    "    throw newError('element is not attached to the page document',\n"
    "                   StatusCode.STALE_ELEMENT_REFERENCE);\n"
    "  },\n"
    "\n"
    "  isNodeReachable_: function(node) {\n"
    "    var nodeRoot = getNodeRootThroughAnyShadows(node);\n"
    "    return (nodeRoot == document.documentElement.parentNode);\n"
    "  }\n"
    "};\n"
    "\n"
    "/**\n"
    " * Returns the root element of the node.  Found by traversing parentNodes until\n"
    " * a node with no parent is found.  This node is considered the root.\n"
    " * @param {?Node} node The node to find the root element for.\n"
    " * @return {?Node} The root node.\n"
    " */\n"
    "function getNodeRoot(node) {\n"
    "  while (node && node.parentNode) {\n"
    "    node = node.parentNode;\n"
    "  }\n"
    "  return node;\n"
    "}\n"
    "\n"
    "/**\n"
    " * Returns the root element of the node, jumping up through shadow roots if\n"
    " * any are found.\n"
    " */\n"
    "function getNodeRootThroughAnyShadows(node) {\n"
    "  var root = getNodeRoot(node);\n"
    "  while (SHADOW_DOM_ENABLED && root instanceof ShadowRoot) {\n"
    "    root = getNodeRoot(root.host);\n"
    "  }\n"
    "  return root;\n"
    "}\n"
    "\n"
    "/**\n"
    " * Returns the global object cache for the page.\n"
    " * @param {Document=} opt_doc The document whose cache to retrieve. Defaults to\n"
    " *     the current document.\n"
    " * @return {!Cache} The page's object cache.\n"
    " */\n"
    "function getPageCache(opt_doc, opt_w3c) {\n"
    "  var doc = opt_doc || document;\n"
    "  var w3c = opt_w3c || false;\n"
    "  // |key| is a long random string, unlikely to conflict with anything else.\n"
    "  var key = '$cdc_asdjflasutopfhvcZLmcfl_';\n"
    "  if (w3c) {\n"
    "    if (!(key in doc))\n"
    "      doc[key] = new CacheWithUUID();\n"
    "    return doc[key];\n"
    "  } else {\n"
    "    if (!(key in doc))\n"
    "      doc[key] = new Cache();\n"
    "    return doc[key];\n"
    "  }\n"
    "}\n"
    "\n"
    "/**\n"
    " * Returns whether given value is an element.\n"
    " * @param {*} value The value to identify as object.\n"
    " * @return {boolean} True if value is a cacheable element.\n"
    " */\n"
    "function isElement(value) {\n"
    "  // As of crrev.com/1316933002, typeof() for some elements will return\n"
    "  // 'function', not 'object'. So we need to check for both non-null objects, as\n"
    "  // well Elements that also happen to be callable functions (e.g. <embed> and\n"
    "  // <object> elements). Note that we can not use |value instanceof Object| here\n"
    "  // since this does not work with frames/iframes, for example\n"
    "  // frames[0].document.body instanceof Object == false even though\n"
    "  // typeof(frames[0].document.body) == 'object'.\n"
    "  return ((typeof(value) == 'object' && value != null) ||\n"
    "            (typeof(value) == 'function' && value.nodeName &&\n"
    "            value.nodeType == NodeType.ELEMENT)) &&\n"
    "          (value.nodeType == NodeType.ELEMENT   ||\n"
    "           value.nodeType == NodeType.DOCUMENT  ||\n"
    "           (SHADOW_DOM_ENABLED && value instanceof ShadowRoot));\n"
    "}\n"
    "\n"
    "/**\n"
    " * Returns whether given value is a collection (iterable with\n"
    " * 'length' property).\n"
    " * @param {*} value The value to identify as a collection.\n"
    " * @return {boolean} True if value is an iterable collection.\n"
    " */\n"
    "function isCollection(value) {\n"
    "  const Symbol = window.cdc_adoQpoasnfa76pfcZLmcfl_Symbol || window.Symbol;\n"
    "  return (typeof value[Symbol.iterator] === 'function');\n"
    "}\n"
    "\n"
    "/**\n"
    " * Deep-clones item, given object references in seen, using cloning algorithm\n"
    " * algo. Implements \"clone an object\" from W3C-spec (#dfn-clone-an-object).\n"
    " * @param {*} item Object or collection to deep clone.\n"
    " * @param {!Array<*>} seen Object references that have already been seen.\n"
    " * @param {function(*, Array<*>, ?Cache) : *} algo Cloning algorithm to use to\n"
    " *     deep clone properties of item.\n"
    " * @param {?Cache} opt_cache Optional cache to use for cloning.\n"
    " * @return {*} Clone of item with status of cloning.\n"
    " */\n"
    "function cloneWithAlgorithm(item, seen, algo, opt_cache) {\n"
    "  let tmp = null;\n"
    "  function maybeCopyProperty(prop) {\n"
    "    let sourceValue = null;\n"
    "    try {\n"
    "      sourceValue = item[prop];\n"
    "    } catch(e) {\n"
    "      throw newError('error reading property', StatusCode.JAVA_SCRIPT_ERROR);\n"
    "    }\n"
    "    return algo(sourceValue, seen, opt_cache);\n"
    "  }\n"
    "\n"
    "  if (isCollection(item)) {\n"
    "    const Array = window.cdc_adoQpoasnfa76pfcZLmcfl_Array || window.Array;\n"
    "    tmp = new Array(item.length);\n"
    "    for (let i = 0; i < item.length; ++i)\n"
    "      tmp[i] = maybeCopyProperty(i);\n"
    "  } else {\n"
    "    tmp = {};\n"
    "    for (let prop in item)\n"
    "      tmp[prop] = maybeCopyProperty(prop);\n"
    "  }\n"
    "  return tmp;\n"
    "}\n"
    "\n"
    "/**\n"
    " * Wrapper to cloneWithAlgorithm, with circular reference detection logic.\n"
    " * @param {*} item Object or collection to deep clone.\n"
    " * @param {!Array<*>} seen Object references that have already been seen.\n"
    " * @param {function(*, Array<*>, ?Cache) : *} algo Cloning algorithm to use to\n"
    " *     deep clone properties of item.\n"
    " * @return {*} Clone of item with status of cloning.\n"
    " */\n"
    "function cloneWithCircularCheck(item, seen, algo) {\n"
    "  if (seen.includes(item))\n"
    "    throw newError('circular reference', StatusCode.JAVA_SCRIPT_ERROR);\n"
    "  seen.push(item);\n"
    "  const result = cloneWithAlgorithm(item, seen, algo);\n"
    "  seen.pop();\n"
    "  return result;\n"
    "}\n"
    "\n"
    "/**\n"
    " * Returns deep clone of given value, replacing element references with a\n"
    " * serialized string representing that element.\n"
    " * @param {*} item Object or collection to deep clone.\n"
    " * @param {!Array<*>} seen Object references that have already been seen.\n"
    " * @return {*} Clone of item with status of cloning.\n"
    " */\n"
    "function jsonSerialize(item, seen) {\n"
    "  if (item === undefined || item === null)\n"
    "    return null;\n"
    "  if (typeof item === 'boolean' ||\n"
    "      typeof item === 'number' ||\n"
    "      typeof item === 'string')\n"
    "    return item;\n"
    "  if (isElement(item)) {\n"
    "    const root = getNodeRootThroughAnyShadows(item);\n"
    "    const cache = getPageCache(root, w3cEnabled);\n"
    "    if (!cache.isNodeReachable_(item)) {\n"
    "      if (item instanceof ShadowRoot)\n"
    "        throw newError('detached shadow root', StatusCode.DETACHED_SHADOW_ROOT);\n"
    "      throw newError('stale element not found',\n"
    "                     StatusCode.STALE_ELEMENT_REFERENCE);\n"
    "    }\n"
    "    const ret = {};\n"
    "    let key = ELEMENT_KEY;\n"
    "    if (item instanceof ShadowRoot) {\n"
    "      if (!item.nodeType ||\n"
    "          item.nodeType !== item.DOCUMENT_FRAGMENT_NODE ||\n"
    "          !item.host) {\n"
    "        throw newError('no such shadow root', StatusCode.NO_SUCH_SHADOW_ROOT);\n"
    "      }\n"
    "      key = SHADOW_ROOT_KEY;\n"
    "    }\n"
    "    ret[key] = cache.storeItem(item);\n"
    "    return ret;\n"
    "  }\n"
    "  if (isCollection(item))\n"
    "    return cloneWithCircularCheck(item, seen, jsonSerialize);\n"
    "  // http://crbug.com/chromedriver/2995: Placed here because some element\n"
    "  // (above) are type 'function', so this check must be performed after.\n"
    "  if (typeof item === 'function')\n"
    "    return item;\n"
    "  // TODO(crbug.com/1337415): Implement WindowProxy serialization.\n"
    "  if (typeof item.toJSON === 'function' &&\n"
    "      (item.hasOwnProperty('toJSON') ||\n"
    "       Object.getPrototypeOf(item).hasOwnProperty('toJSON')))\n"
    "    return item.toJSON();\n"
    "\n"
    "  // Deep clone Objects.\n"
    "  return cloneWithCircularCheck(item, seen, jsonSerialize);\n"
    "}\n"
    "\n"
    "/**\n"
    " * Returns deserialized deep clone of given value, replacing serialized string\n"
    " * references to elements with a element reference, if found.\n"
    " * @param {*} item Object or collection to deep clone.\n"
    " * @param {?Array<*>} opt_seen Object references that have already been seen.\n"
    " * @param {?Cache} opt_cache Document cache containing serialized elements.\n"
    " * @return {*} Clone of item with status of cloning.\n"
    " */\n"
    "function jsonDeserialize(item, opt_seen, opt_cache) { console.log('jsonDeserialize:::' + item);\n"
    "  if (opt_seen === undefined || opt_seen === null)\n"
    "    opt_seen = []\n"
    "  if (item === undefined ||\n"
    "      item === null ||\n"
    "      typeof item === 'boolean' ||\n"
    "      typeof item === 'number' ||\n"
    "      typeof item === 'string' ||\n"
    "      typeof item === 'function')\n"
    "    return item;\n"
    "  if (item.hasOwnProperty(ELEMENT_KEY) ||\n"
    "      item.hasOwnProperty(SHADOW_ROOT_KEY)) {\n"
    "    if (opt_cache === undefined || opt_cache === null) {\n"
    "      const root = getNodeRootThroughAnyShadows(item);\n"
    "      opt_cache = getPageCache(root, w3cEnabled);\n"
    "    }\n"
    "    try {\n"
    "      let ret = opt_cache.retrieveItem(item[ELEMENT_KEY] ||\n"
    "                                     item[SHADOW_ROOT_KEY]); console.log('ret:::' + ret); return ret;\n"
    "    } catch(err) {\n"
    "      if (err.message &&\n"
    "          err.message === 'element is not attached to the page document' &&\n"
    "          item.hasOwnProperty(SHADOW_ROOT_KEY))\n"
    "        throw newError('detached shadow root', StatusCode.DETACHED_SHADOW_ROOT);\n"
    "      throw err;\n"
    "    }\n"
    "  }\n"
    "  if (isCollection(item) || typeof item === 'object')\n"
    "    return cloneWithAlgorithm(item, opt_seen, jsonDeserialize, opt_cache);\n"
    "  throw newError('unhandled object', StatusCode.JAVA_SCRIPT_ERROR);\n"
    "}\n"
    "\n"
    "/**\n"
    " * Calls a given function and returns its value.\n"
    " *\n"
    " * The inputs to and outputs of the function will be unwrapped and wrapped\n"
    " * respectively, unless otherwise specified. This wrapping involves converting\n"
    " * between cached object reference IDs and actual JS objects. The cache will\n"
    " * automatically be pruned each call to remove stale references.\n"
    " *\n"
    " * @param {function(...[*]) : *} func The function to invoke.\n"
    " * @param {!Array<*>} args The array of arguments to supply to the function,\n"
    " *     which will be unwrapped before invoking the function.\n"
    " * @param {boolean} w3c Whether to return a W3C compliant element reference.\n"
    " * @param {boolean=} opt_unwrappedReturn Whether the function's return value\n"
    " *     should be left unwrapped.\n"
    " * @return {*} An object containing a status and value property, where status\n"
    " *     is a WebDriver status code and value is the wrapped value. If an\n"
    " *     unwrapped return was specified, this will be the function's pure return\n"
    " *     value.\n"
    " */\n"
    "function callFunction(func, args, w3c, opt_unwrappedReturn) {\n"
    "  if (w3c) {\n"
    "    w3cEnabled = true;\n"
    "    ELEMENT_KEY = 'element-6066-11e4-a52e-4f735466cecf';\n"
    "\n"
    "  }\n"
    "  const cache = getPageCache(null, w3cEnabled);\n"
    "\n"
    "  function buildError(error) {\n"
    "    return {\n"
    "      status: error.code || StatusCode.JAVA_SCRIPT_ERROR,\n"
    "      value: error.message || error\n"
    "    };\n"
    "  }\n"
    "\n"
    "  let status = 0;\n"
    "  let returnValue;\n"
    "  const Promise = window.cdc_adoQpoasnfa76pfcZLmcfl_Promise || window.Promise;\n"
    "  try {\n"
    "    const unwrappedArgs = jsonDeserialize(args, [], cache);\n"
    "    const tmp = func.apply(null, unwrappedArgs);\n"
    "    return Promise.resolve(tmp).then((result) => {\n"
    "      if (opt_unwrappedReturn)\n"
    "        return result;\n"
    "      const clone = jsonSerialize(result, []);\n"
    "      return {\n"
    "        status: 0,\n"
    "        value: clone\n"
    "      };\n"
    "    }).catch(buildError);\n"
    "  } catch (error) {\n"
    "    return Promise.resolve(buildError(error));\n"
    "  }\n"
    "}\n"
    "; return callFunction.apply(null, arguments) }\n";

const char kDispatchTouchEventScript[] =
    "function() { // Copyright 2017 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "/**\n"
    " * Dispatches a fake touch event with a single touch point.\n"
    " *\n"
    " * @param {number} x X-coordinate of the touch point relative to viewport\n"
    " *     in CSS pixels.\n"
    " * @param {number} y Y-coordinate of the touch point relative to viewport\n"
    " *     in CSS pixels.\n"
    " * @param {string} type Touch event type, e.g. touchstart.\n"
    " */\n"
    "function dispatchTouchEvent(x, y, type) {\n"
    "  var element = window.document.elementFromPoint(x, y);\n"
    "  var inputDeviceCapabilities =\n"
    "    new InputDeviceCapabilities({firesTouchEvents: true});\n"
    "  var touch = new Touch({\n"
    "    identifier: 0,\n"
    "    target: element,\n"
    "    clientX: x,\n"
    "    clientY: y,\n"
    "    pageX: x + window.document.scrollingElement.scrollLeft,\n"
    "    pageY: y + window.document.scrollingElement.scrollTop,\n"
    "    force: 1,\n"
    "    radiusX: 1,\n"
    "    radiusY: 1,\n"
    "    screenX: x + window.screenX,\n"
    "    screenY: y + window.screenY,\n"
    "  });\n"
    "  var event = new TouchEvent(type, {\n"
    "    touches: [touch],\n"
    "    targetTouches: [touch],\n"
    "    changedTouches: [touch],\n"
    "    ctrlKey: false,\n"
    "    shiftKey: false,\n"
    "    altKey: false,\n"
    "    metaKey: false,\n"
    "    view: window,\n"
    "    bubbles: true,\n"
    "    cancelable: false,\n"
    "    composed: true,\n"
    "    sourceCapabilities: inputDeviceCapabilities,\n"
    "  });\n"
    "  element.dispatchEvent(event);\n"
    "}\n"
    "; return dispatchTouchEvent.apply(null, arguments) }\n";
const char kExecuteAsyncScriptScript[] =
    "function() { // Copyright 2013 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "/**\n"
    " * Enum for WebDriver status codes.\n"
    " * @enum {number}\n"
    " */\n"
    "var StatusCode = {\n"
    "  OK: 0,\n"
    "  UNKNOWN_ERROR: 13,\n"
    "  JAVASCRIPT_ERROR: 17,\n"
    "  SCRIPT_TIMEOUT: 28,\n"
    "};\n"
    "\n"
    "/**\n"
    " * Dictionary key for asynchronous script info.\n"
    " * @const\n"
    " */\n"
    "var ASYNC_INFO_KEY = '$chrome_asyncScriptInfo';\n"
    "\n"
    "/**\n"
    "* Return the information of asynchronous script execution.\n"
    "*\n"
    "* @return {Object<?>} Information of asynchronous script execution.\n"
    "*/\n"
    "function getAsyncScriptInfo() {\n"
    "  if (!(ASYNC_INFO_KEY in document))\n"
    "    document[ASYNC_INFO_KEY] = {'id': 0};\n"
    "  return document[ASYNC_INFO_KEY];\n"
    "}\n"
    "\n"
    "/**\n"
    "* Execute the given script and save its asynchronous result.\n"
    "*\n"
    "* If script1 finishes after script2 is executed, then script1's result will be\n"
    "* discarded while script2's will be saved.\n"
    "*\n"
    "* @param {string} script The asynchronous script to be executed. The script\n"
    "*     should be a proper function body. It will be wrapped in a function and\n"
    "*     invoked with the given arguments and, as the final argument, a callback\n"
    "*     function to invoke to report the asynchronous result.\n"
    "* @param {!Array<*>} args Arguments to be passed to the script.\n"
    "* @param {boolean} isUserSupplied Whether the script is supplied by the user.\n"
    "*     If not, UnknownError will be used instead of JavaScriptError if an\n"
    "*     exception occurs during the script, and an additional error callback will\n"
    "*     be supplied to the script.\n"
    "*/\n"
    "function executeAsyncScript(script, args, isUserSupplied) {\n"
    "  let resolveHandle;\n"
    "  let rejectHandle;\n"
    "  const Promise = window.cdc_adoQpoasnfa76pfcZLmcfl_Promise || window.Promise;\n"
    "  var promise = new Promise((resolve, reject) => {\n"
    "    resolveHandle = resolve;\n"
    "    rejectHandle = reject;\n"
    "  });\n"
    "  const info = getAsyncScriptInfo();\n"
    "  info.id++;\n"
    "  delete info.result;\n"
    "  const id = info.id;\n"
    "\n"
    "  function isThenable(value) {\n"
    "    return typeof value === 'object' && typeof value.then === 'function';\n"
    "  }\n"
    "  function report(status, value) { console.log('executeAsyncScript, report: ' + status);\n"
    "    if (id != info.id)\n"
    "      return;\n"
    "    info.id++;\n"
    "    // Undefined value is skipped when the object is converted to JSON.\n"
    "    // Replace it with null so we don't lose the value.\n"
    "    if (value === undefined)\n"
    "      value = null;\n"
    "    info.result = {status: status, value: value};\n"
    "  }\n"
    "  function reportValue(value) {\n"
    "    report(StatusCode.OK, value);\n"
    "  }\n"
    "  function reportScriptError(error) {\n"
    "    var code = isUserSupplied ? StatusCode.JAVASCRIPT_ERROR :\n"
    "                                (error.code || StatusCode.UNKNOWN_ERROR);\n"
    "    var message = error.message;\n"
    "    if (error.stack) {\n"
    "      message += \"\\n js.cpp, JavaScript stack:\\n\" + error.stack;\n"
    "    }\n"
    "    report(code, message);\n"
    "  }\n"
    "  promise.then(reportValue).catch(reportScriptError);\n"
    "  args.push(resolveHandle);\n"
    "  if (!isUserSupplied)\n"
    "    args.push(rejectHandle);\n"
    "  try {\n"
    "    const scriptResult = new Function(script).apply(null, args);\n"
    "    // The return value is only considered if it is a promise.\n"
    "    if (isThenable(scriptResult)) {\n"
    "      const resolvedPromise = Promise.resolve(scriptResult);\n"
    "      resolvedPromise.then((value) => {\n"
    "        // Must be thenable if user-supplied.\n"
    "        if (!isUserSupplied || isThenable(value))\n"
    "          resolveHandle(value);\n"
    "      })\n"
    "      .catch(rejectHandle);\n"
    "    }\n"
    "  } catch (error) {\n"
    "    rejectHandle(error);\n"
    "  }\n"
    "}\n"
    "; return executeAsyncScript.apply(null, arguments) }\n";
const char kExecuteScriptScript[] =
    "function() { // Copyright 2019 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "/**\n"
    "* Execute the given script following the Execute-Script specification laid out\n"
    "* in the W3C WebDriver spec, except for serialization/deserialization of args,\n"
    "* which is handled by callFunction.\n"
    "*\n"
    "* @param {string} script The script to be executed.\n"
    "* @param {!Array<*>} args Arguments to be passed to the script.\n"
    "*/\n"
    "function executeScript(script, args) {\n"
    "  try {\n"
    "    // Convert script (as a string) into an async function.\n"
    "    const f = (new Function('return async function(){' + script + '}'))();\n"
    "    const Promise = window.cdc_adoQpoasnfa76pfcZLmcfl_Promise || window.Promise;\n"
    "    return Promise.resolve(f.apply(null, args));\n"
    "  } catch (e) {\n"
    "    return Promise.reject(e);\n"
    "  }\n"
    "}\n"
    "; return executeScript.apply(null, arguments) }\n";
const char kFocusScript[] =
    "function() { // Copyright 2013 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "function focus(element) {\n"
    "  // Focus the target element in order to send keys to it.\n"
    "  // First, the currently active element is blurred, if it is different from\n"
    "  // the target element. We do not want to blur an element unnecessarily,\n"
    "  // because this may cause us to lose the current cursor position in the\n"
    "  // element.\n"
    "  // Secondly, we focus the target element.\n"
    "  // Thirdly, we check if the new active element is the target element. If not,\n"
    "  // we throw an error.\n"
    "  // Additional notes:\n"
    "  //   - |document.activeElement| is the currently focused element, or body if\n"
    "  //     no element is focused\n"
    "  //   - Even if |document.hasFocus()| returns true and the active element is\n"
    "  //     the body, sometimes we still need to focus the body element for send\n"
    "  //     keys to work. Not sure why\n"
    "  //   - You cannot focus a descendant of a content editable node\n"
    "  //   - V8 throws a TypeError when calling setSelectionRange for a non-text\n"
    "  //     input, which still have setSelectionRange defined. For chrome 29+, V8\n"
    "  //     throws a DOMException with code InvalidStateError.\n"
    "  var doc = element.ownerDocument || element;\n"
    "  var prevActiveElement = doc.activeElement;\n"
    "  if (element != prevActiveElement && prevActiveElement)\n"
    "    prevActiveElement.blur();\n"
    "  element.focus();\n"
    "\n"
    "  var activeElement = doc.activeElement;\n"
    "  // If the element is in a shadow DOM, then as far as the document is\n"
    "  // concerned, the shadow host is the active element. We need to go through the\n"
    "  // tree of shadow DOMs to check that the element we gave focus to is now\n"
    "  // active.\n"
    "  if (element != activeElement && !element.contains(activeElement)) {\n"
    "    var shadowRoot = activeElement.shadowRoot;\n"
    "    while (shadowRoot) {\n"
    "      var activeElement = shadowRoot.activeElement;\n"
    "      if (element == activeElement) {\n"
    "        // the shadow DOM's active element is our requested element. We're good.\n"
    "        break;\n"
    "      }\n"
    "      // The shadow DOM's active element isn't our requested element, check to\n"
    "      // see if there's a nested shadow DOM.\n"
    "      shadowRoot = activeElement.shadowRoot;\n"
    "    }\n"
    "  }\n"
    "  if (element != activeElement && !element.contains(activeElement))\n"
    "    throw new Error('cannot focus element');\n"
    "}\n"
    "; return focus.apply(null, arguments) }\n";
const char kGetElementLocationScript[] =
    "function() { // Copyright 2019 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "/**\n"
    " * Constructs new error to be thrown with given code and message.\n"
    " *\n"
    " * @param {string} message Message reported to user.\n"
    " * @param {StatusCode} code StatusCode for error.\n"
    " * @return {!Error} Error object that can be thrown.\n"
    " */\n"
    "function newError(message, code) {\n"
    "  const error = new Error(message);\n"
    "  error.code = code;\n"
    "  return error;\n"
    "}\n"
    "\n"
    "/**\n"
    " * Get the root node for the given element, jumping up through any ShadowRoots\n"
    " * if they are found.\n"
    " *\n"
    " * @param {Node} node The node to find the root of\n"
    " * @return {Node} The root node\n"
    " */\n"
    "function getNodeRootThroughAnyShadows(node) {\n"
    "  // Fetch the root node for the current node.\n"
    "  let root = node.getRootNode()\n"
    "\n"
    "  // Keep jumping to the root node for the attachment host of any ShadowRoot.\n"
    "  while (root.host) {\n"
    "    root = root.host.getRootNode()\n"
    "  }\n"
    "\n"
    "  return root;\n"
    "}\n"
    "\n"
    "/**\n"
    " * Check whether the specified node is attached to the DOM, either directly or\n"
    " * via any attached ShadowRoot.\n"
    " *\n"
    " * @param {Node} node The node to test\n"
    " * @return {boolean} Whether the node is attached to the DOM.\n"
    " */\n"
    "function isNodeReachable(node) {\n"
    "  const nodeRoot = getNodeRootThroughAnyShadows(node);\n"
    "\n"
    "  // Check whether the root is the Document or Proxy node.\n"
    "  return (nodeRoot == document.documentElement.parentNode);\n"
    "}\n"
    "\n"
    "function getFirstNonZeroWidthHeightRect(rects) {\n"
    "  for (const rect of rects) {\n"
    "    if (rect.height > 0 && rect.width > 0) {\n"
    "      return rect;\n"
    "    }\n"
    "  }\n"
    "  return rects[0];\n"
    "}\n"
    "\n"
    "function getParentRect(element) {\n"
    "  var parent = element.parentElement;\n"
    "  var parentRect = getFirstNonZeroWidthHeightRect(parent.getClientRects());\n"
    "  return parentRect;\n"
    "}\n"
    "\n"
    "function getInViewPoint(element) {\n"
    "  var rectangles = element.getClientRects();\n"
    "  if (rectangles.length === 0) {\n"
    "    return false;\n"
    "  }\n"
    "\n"
    "  var rect = getFirstNonZeroWidthHeightRect(rectangles);\n"
    "  var left = Math.max(0, rect.left);\n"
    "  var right = Math.min(window.innerWidth, rect.right);\n"
    "  var top = Math.max(0, rect.top);\n"
    "  var bottom = Math.min(window.innerHeight, rect.bottom);\n"
    "\n"
    "  // Find the view boundary of the element by checking itself and all of its\n"
    "  // ancestor's boundary.\n"
    "  while (element.parentElement != null &&\n"
    "         element.parentElement != document.body &&\n"
    "         element.parentElement.getClientRects().length > 0) {\n"
    "    var parentStyle = window.getComputedStyle(element.parentElement);\n"
    "    var overflow = parentStyle.getPropertyValue(\"overflow\");\n"
    "    var overflowX = parentStyle.getPropertyValue(\"overflow-x\");\n"
    "    var overflowY = parentStyle.getPropertyValue(\"overflow-y\");\n"
    "    var parentRect = getParentRect(element);\n"
    "    // Only consider about overflow cases when the parent area overlaps with\n"
    "    // the element's area.\n"
    "    if (parentRect.right > left && parentRect.bottom > top &&\n"
    "        right > parentRect.left && bottom > parentRect.top) {\n"
    "      if (overflow == \"auto\" || overflow == \"scroll\" || overflow == \"hidden\") {\n"
    "        left = Math.max(left, parentRect.left);\n"
    "        right = Math.min(right, parentRect.right);\n"
    "        top = Math.max(top, parentRect.top);\n"
    "        bottom = Math.min(bottom, parentRect.bottom);\n"
    "      } else {\n"
    "        if (overflowX == \"auto\" || overflowX == \"scroll\" ||\n"
    "            overflowX == \"hidden\") {\n"
    "          left = Math.max(left, parentRect.left);\n"
    "          right = Math.min(right, parentRect.right);\n"
    "        }\n"
    "        if (overflowY == \"auto\" || overflowY == \"scroll\" ||\n"
    "            overflowY == \"hidden\") {\n"
    "          top = Math.max(top, parentRect.top);\n"
    "          bottom = Math.min(bottom, parentRect.bottom);\n"
    "        }\n"
    "      }\n"
    "    }\n"
    "    element = element.parentElement;\n"
    "  }\n"
    "\n"
    "  var x = 0.5 * (left + right);\n"
    "  var y = 0.5 * (top + bottom);\n"
    "  return [x, y, left, top];\n"
    "}\n"
    "\n"
    "function rootNodeIncludes(element, elementPoint) {\n"
    "  if (!element)\n"
    "    return false;\n"
    "  let rootNode = element.getRootNode();\n"
    "  if (rootNode.elementsFromPoint(elementPoint[0], elementPoint[1])\n"
    "      .includes(element)) {\n"
    "    if (rootNode == document)\n"
    "      return true;\n"
    "    return rootNodeIncludes(rootNode.host, elementPoint);\n"
    "  }\n"
    "  return false;\n"
    "}\n"
    "\n"
    "function inView(element) {\n"
    "  var elementPoint = getInViewPoint(element);\n"
    "  if (!elementPoint ||\n"
    "      elementPoint[0] <= 0 || elementPoint[1] <= 0 ||\n"
    "      elementPoint[0] >= window.innerWidth ||\n"
    "      elementPoint[1] >= window.innerHeight ||\n"
    "      !rootNodeIncludes(element, elementPoint)) {\n"
    "    return false;\n"
    "  }\n"
    "\n"
    "  return true;\n"
    "}\n"
    "\n"
    "function getElementLocation(element, center) {\n"
    "  // Check that node type is element.\n"
    "  if (element.nodeType != 1)\n"
    "    throw new Error(element + ' is not an element');\n"
    "\n"
    "  if (!isNodeReachable(element)) {\n"
    "    // errorCode 10: StaleElementException\n"
    "    throw newError('element is not attached to the page document', 10);\n"
    "  }\n"
    "\n"
    "  if (!inView(element)) {\n"
    "    element.scrollIntoView({behavior: \"instant\",\n"
    "                            block: \"end\",\n"
    "                            inline: \"nearest\"});\n"
    "  }\n"
    "\n"
    "  var clientRects = element.getClientRects();\n"
    "  if (clientRects.length === 0) {\n"
    "    // errorCode 60: ElementNotInteractableException\n"
    "    throw newError(element + ' has no size and location', 60);\n"
    "  }\n"
    "\n"
    "  var elementPoint = getInViewPoint(element);\n"
    "  if (center) {\n"
    "    return {\n"
    "        'x': elementPoint[0],\n"
    "        'y': elementPoint[1]\n"
    "    };\n"
    "  } else {\n"
    "    return {\n"
    "        'x': elementPoint[2],\n"
    "        'y': elementPoint[3]\n"
    "    };\n"
    "  }\n"
    "}\n"
    "; return getElementLocation.apply(null, arguments) }\n";
const char kGetElementRegionScript[] =
    "function() { // Copyright 2013 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "// Return the portion of the element that should be made visible.\n"
    "// Based on the WebDriver spec, this function only considers the first rectangle\n"
    "// returned by element.getClientRects function.\n"
    "// * When the rectangle is already partially visible in the enclosing viewport,\n"
    "//   return the portion that is currently visible. According to WebDriver spec,\n"
    "//   no scrolling should be done to bring more of the element into view.\n"
    "// * When the rectangle is completely outside of the enclosing viewport,\n"
    "//   return the entire rectangle, as WebDriver spec requires us to scroll the\n"
    "//   entire rectangle into view. (However, scrolling is NOT the responsibility\n"
    "//   of this function.)\n"
    "//\n"
    "// The returned value is an object with the following properties about the\n"
    "// region mentioned above: left, top, height, width. Note that left and top are\n"
    "// relative to the upper-left corner of the element's bounding client rect (as\n"
    "// returned by element.getBoundingClientRect).\n"
    "function getElementRegion(element) {\n"
    "  // Check that node type is element.\n"
    "  if (element.nodeType != 1)\n"
    "    throw new Error(element + ' is not an element');\n"
    "\n"
    "  // We try 2 methods to determine element region. Try the first client rect,\n"
    "  // and then the bounding client rect.\n"
    "  // SVG is one case that doesn't have a first client rect.\n"
    "  const clientRects = element.getClientRects();\n"
    "\n"
    "  // Determines if region is partially in viewport, returning visible region\n"
    "  // if so. If not, returns null. If fully visible, returns original region.\n"
    "  function getVisibleSubregion(region) {\n"
    "    // Given two regions, determines if any intersection occurs.\n"
    "    // Overlapping edges are not considered intersections.\n"
    "    function getIntersectingSubregion(region1, region2) {\n"
    "      if (!(Math.round(region2.right)  <= Math.round(region1.left)   ||\n"
    "            Math.round(region2.left)   >= Math.round(region1.right)  ||\n"
    "            Math.round(region2.top)    >= Math.round(region1.bottom) ||\n"
    "            Math.round(region2.bottom) <= Math.round(region1.top))) {\n"
    "        // Determines region of intersection.\n"
    "        // If region2 contains region1, returns region1.\n"
    "        // If region1 contains region2, returns region2.\n"
    "        return {\n"
    "          'left': Math.max(region1.left, region2.left),\n"
    "          'right': Math.min(region1.right, region2.right),\n"
    "          'bottom': Math.min(region1.bottom, region2.bottom),\n"
    "          'top': Math.max(region1.top, region2.top)\n"
    "        };\n"
    "      }\n"
    "      return null;\n"
    "    }\n"
    "    const visualViewport = window.visualViewport;\n"
    "    // We need to disregard any scrollbars therefore instead of innerSize\n"
    "    // of the window we should use the viewport size.\n"
    "    // This size can be affected (scaled) by user's pinch.\n"
    "    // We need to undo this scaling because client rects are calculated\n"
    "    // relatively to the original unscaled viewport.\n"
    "    const viewport = new DOMRect(0, 0,\n"
    "      visualViewport.width * visualViewport.scale,\n"
    "      visualViewport.height * visualViewport.scale\n"
    "    );\n"
    "    return getIntersectingSubregion(viewport, region);\n"
    "  }\n"
    "\n"
    "  let boundingRect = null;\n"
    "  let clientRect = null;\n"
    "  // Element area of a map has same first ClientRect and BoundingClientRect\n"
    "  // after blink roll at chromium commit position 290738 which includes blink\n"
    "  // revision 180610. Thus handle area as a special case.\n"
    "  if (clientRects.length == 0 || element.tagName.toLowerCase() == 'area') {\n"
    "    // Area clicking is technically not supported by W3C standard but is a\n"
    "    // desired feature. Returns region containing the area instead of subregion\n"
    "    // so that whole area is visible and always clicked correctly.\n"
    "    if (element.tagName.toLowerCase() == 'area') {\n"
    "      const coords = element.coords.split(',');\n"
    "      if (element.shape.toLowerCase() == 'rect') {\n"
    "        if (coords.length != 4)\n"
    "          throw new Error('failed to detect the region of the area');\n"
    "        const leftX = Number(coords[0]);\n"
    "        const topY = Number(coords[1]);\n"
    "        const rightX = Number(coords[2]);\n"
    "        const bottomY = Number(coords[3]);\n"
    "        return {\n"
    "            'left': leftX,\n"
    "            'top': topY,\n"
    "            'width': rightX - leftX,\n"
    "            'height': bottomY - topY\n"
    "        };\n"
    "      } else if (element.shape.toLowerCase() == 'circle') {\n"
    "        if (coords.length != 3)\n"
    "          throw new Error('failed to detect the region of the area');\n"
    "        const centerX = Number(coords[0]);\n"
    "        const centerY = Number(coords[1]);\n"
    "        const radius = Number(coords[2]);\n"
    "        return {\n"
    "            'left': Math.max(0, centerX - radius),\n"
    "            'top': Math.max(0, centerY - radius),\n"
    "            'width': radius * 2,\n"
    "            'height': radius * 2\n"
    "        };\n"
    "      } else if (element.shape.toLowerCase() == 'poly') {\n"
    "        if (coords.length < 2)\n"
    "          throw new Error('failed to detect the region of the area');\n"
    "        let minX = Number(coords[0]);\n"
    "        let minY = Number(coords[1]);\n"
    "        let maxX = minX;\n"
    "        let maxY = minY;\n"
    "        for (i = 2; i < coords.length; i += 2) {\n"
    "          const x = Number(coords[i]);\n"
    "          const y = Number(coords[i + 1]);\n"
    "          minX = Math.min(minX, x);\n"
    "          minY = Math.min(minY, y);\n"
    "          maxX = Math.max(maxX, x);\n"
    "          maxY = Math.max(maxY, y);\n"
    "        }\n"
    "        return {\n"
    "            'left': minX,\n"
    "            'top': minY,\n"
    "            'width': maxX - minX,\n"
    "            'height': maxY - minY\n"
    "        };\n"
    "      } else {\n"
    "        throw new Error('shape=' + element.shape + ' is not supported');\n"
    "      }\n"
    "    } else {\n"
    "      clientRect = boundingRect = element.getBoundingClientRect();\n"
    "    }\n"
    "  } else {\n"
    "    boundingRect = element.getBoundingClientRect();\n"
    "    clientRect = clientRects[0];\n"
    "    for (let i = 0; i < clientRects.length; i++) {\n"
    "      if (clientRects[i].height != 0 && clientRects[i].width != 0) {\n"
    "        clientRect = clientRects[i];\n"
    "        break;\n"
    "      }\n"
    "    }\n"
    "  }\n"
    "  const visiblePortion = getVisibleSubregion(clientRect) || clientRect;\n"
    "  // Returned region is relative to boundingRect's left,top.\n"
    "  return {\n"
    "    'left': visiblePortion.left - boundingRect.left,\n"
    "    'top': visiblePortion.top - boundingRect.top,\n"
    "    'height': visiblePortion.bottom - visiblePortion.top,\n"
    "    'width': visiblePortion.right - visiblePortion.left\n"
    "  };\n"
    "}\n"
    "; return getElementRegion.apply(null, arguments) }\n";
const char kIsOptionElementToggleableScript[] =
    "function() { // Copyright 2013 The Chromium Authors\n"
    "// Use of this source code is governed by a BSD-style license that can be\n"
    "// found in the LICENSE file.\n"
    "\n"
    "function isOptionElementToggleable(option) {\n"
    "  if (option.tagName.toLowerCase() != 'option')\n"
    "    throw new Error('element is not an option');\n"
    "  for (var parent = option.parentElement;\n"
    "       parent;\n"
    "       parent = parent.parentElement) {\n"
    "    if (parent.tagName.toLowerCase() == 'select') {\n"
    "      return parent.multiple;\n"
    "    }\n"
    "  }\n"
    "  throw new Error('option element is not in a select');\n"
    "}\n"
    "; return isOptionElementToggleable.apply(null, arguments) }\n";

}