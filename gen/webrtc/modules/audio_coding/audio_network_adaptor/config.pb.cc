// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace webrtc {
namespace audio_network_adaptor {
    namespace config {

        void protobuf_ShutdownFile_config_2eproto()
        {
            delete FecController::default_instance_;
            delete FecController_Threshold::default_instance_;
            delete FrameLengthController::default_instance_;
            delete ChannelController::default_instance_;
            delete DtxController::default_instance_;
            delete BitrateController::default_instance_;
            delete Controller::default_instance_;
            delete Controller_ScoringPoint::default_instance_;
            delete ControllerManager::default_instance_;
        }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        void protobuf_AddDesc_config_2eproto_impl()
        {
            GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
        void protobuf_AddDesc_config_2eproto()
        {
            static bool already_here = false;
            if (already_here)
                return;
            already_here = true;
            GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
            FecController::default_instance_ = new FecController();
            FecController_Threshold::default_instance_ = new FecController_Threshold();
            FrameLengthController::default_instance_ = new FrameLengthController();
            ChannelController::default_instance_ = new ChannelController();
            DtxController::default_instance_ = new DtxController();
            BitrateController::default_instance_ = new BitrateController();
            Controller::default_instance_ = new Controller();
            Controller_ScoringPoint::default_instance_ = new Controller_ScoringPoint();
            ControllerManager::default_instance_ = new ControllerManager();
            FecController::default_instance_->InitAsDefaultInstance();
            FecController_Threshold::default_instance_->InitAsDefaultInstance();
            FrameLengthController::default_instance_->InitAsDefaultInstance();
            ChannelController::default_instance_->InitAsDefaultInstance();
            DtxController::default_instance_->InitAsDefaultInstance();
            BitrateController::default_instance_->InitAsDefaultInstance();
            Controller::default_instance_->InitAsDefaultInstance();
            Controller_ScoringPoint::default_instance_->InitAsDefaultInstance();
            ControllerManager::default_instance_->InitAsDefaultInstance();
            ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_config_2eproto);
        }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_config_2eproto_once_);
        void protobuf_AddDesc_config_2eproto()
        {
            ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_config_2eproto_once_,
                &protobuf_AddDesc_config_2eproto_impl);
        }
#else
        // Force AddDescriptors() to be called at static initialization time.
        struct StaticDescriptorInitializer_config_2eproto {
            StaticDescriptorInitializer_config_2eproto()
            {
                protobuf_AddDesc_config_2eproto();
            }
        } static_descriptor_initializer_config_2eproto_;
#endif

        namespace {

            static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
            GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line)
            {
                GOOGLE_CHECK(false) << __FILE__ << ":" << line;
            }

        } // namespace

        // ===================================================================

        static ::std::string* MutableUnknownFieldsForFecController(
            FecController* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

        static ::std::string* MutableUnknownFieldsForFecController_Threshold(
            FecController_Threshold* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int FecController_Threshold::kLowBandwidthBpsFieldNumber;
        const int FecController_Threshold::kLowBandwidthPacketLossFieldNumber;
        const int FecController_Threshold::kHighBandwidthBpsFieldNumber;
        const int FecController_Threshold::kHighBandwidthPacketLossFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        FecController_Threshold::FecController_Threshold()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.FecController.Threshold)
        }

        void FecController_Threshold::InitAsDefaultInstance()
        {
        }

        FecController_Threshold::FecController_Threshold(const FecController_Threshold& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.FecController.Threshold)
        }

        void FecController_Threshold::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            low_bandwidth_bps_ = 0;
            low_bandwidth_packet_loss_ = 0;
            high_bandwidth_bps_ = 0;
            high_bandwidth_packet_loss_ = 0;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        FecController_Threshold::~FecController_Threshold()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.FecController.Threshold)
            SharedDtor();
        }

        void FecController_Threshold::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
            }
        }

        void FecController_Threshold::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const FecController_Threshold& FecController_Threshold::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        FecController_Threshold* FecController_Threshold::default_instance_ = NULL;

        FecController_Threshold* FecController_Threshold::New(::google::protobuf::Arena* arena) const
        {
            FecController_Threshold* n = new FecController_Threshold;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void FecController_Threshold::Clear()
        {
// @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.FecController.Threshold)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                             \
    _Pragma("clang diagnostic push")                                                                              \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(FecController_Threshold, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<FecController_Threshold*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

            ZR_(low_bandwidth_bps_, high_bandwidth_packet_loss_);

#undef ZR_HELPER_
#undef ZR_

            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool FecController_Threshold::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForFecController_Threshold, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.FecController.Threshold)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional int32 low_bandwidth_bps = 1;
                case 1: {
                    if (tag == 8) {
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &low_bandwidth_bps_)));
                        set_has_low_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(21))
                        goto parse_low_bandwidth_packet_loss;
                    break;
                }

                // optional float low_bandwidth_packet_loss = 2;
                case 2: {
                    if (tag == 21) {
                    parse_low_bandwidth_packet_loss:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                            input, &low_bandwidth_packet_loss_)));
                        set_has_low_bandwidth_packet_loss();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(24))
                        goto parse_high_bandwidth_bps;
                    break;
                }

                // optional int32 high_bandwidth_bps = 3;
                case 3: {
                    if (tag == 24) {
                    parse_high_bandwidth_bps:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &high_bandwidth_bps_)));
                        set_has_high_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(37))
                        goto parse_high_bandwidth_packet_loss;
                    break;
                }

                // optional float high_bandwidth_packet_loss = 4;
                case 4: {
                    if (tag == 37) {
                    parse_high_bandwidth_packet_loss:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                            input, &high_bandwidth_packet_loss_)));
                        set_has_high_bandwidth_packet_loss();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.FecController.Threshold)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.FecController.Threshold)
            return false;
#undef DO_
        }

        void FecController_Threshold::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.FecController.Threshold)
            // optional int32 low_bandwidth_bps = 1;
            if (has_low_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->low_bandwidth_bps(), output);
            }

            // optional float low_bandwidth_packet_loss = 2;
            if (has_low_bandwidth_packet_loss()) {
                ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->low_bandwidth_packet_loss(), output);
            }

            // optional int32 high_bandwidth_bps = 3;
            if (has_high_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->high_bandwidth_bps(), output);
            }

            // optional float high_bandwidth_packet_loss = 4;
            if (has_high_bandwidth_packet_loss()) {
                ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->high_bandwidth_packet_loss(), output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.FecController.Threshold)
        }

        int FecController_Threshold::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.FecController.Threshold)
            int total_size = 0;

            if (_has_bits_[0 / 32] & 15u) {
                // optional int32 low_bandwidth_bps = 1;
                if (has_low_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->low_bandwidth_bps());
                }

                // optional float low_bandwidth_packet_loss = 2;
                if (has_low_bandwidth_packet_loss()) {
                    total_size += 1 + 4;
                }

                // optional int32 high_bandwidth_bps = 3;
                if (has_high_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->high_bandwidth_bps());
                }

                // optional float high_bandwidth_packet_loss = 4;
                if (has_high_bandwidth_packet_loss()) {
                    total_size += 1 + 4;
                }
            }
            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void FecController_Threshold::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const FecController_Threshold*>(&from));
        }

        void FecController_Threshold::MergeFrom(const FecController_Threshold& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.FecController.Threshold)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
                if (from.has_low_bandwidth_bps()) {
                    set_low_bandwidth_bps(from.low_bandwidth_bps());
                }
                if (from.has_low_bandwidth_packet_loss()) {
                    set_low_bandwidth_packet_loss(from.low_bandwidth_packet_loss());
                }
                if (from.has_high_bandwidth_bps()) {
                    set_high_bandwidth_bps(from.high_bandwidth_bps());
                }
                if (from.has_high_bandwidth_packet_loss()) {
                    set_high_bandwidth_packet_loss(from.high_bandwidth_packet_loss());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void FecController_Threshold::CopyFrom(const FecController_Threshold& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.FecController.Threshold)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool FecController_Threshold::IsInitialized() const
        {

            return true;
        }

        void FecController_Threshold::Swap(FecController_Threshold* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void FecController_Threshold::InternalSwap(FecController_Threshold* other)
        {
            std::swap(low_bandwidth_bps_, other->low_bandwidth_bps_);
            std::swap(low_bandwidth_packet_loss_, other->low_bandwidth_packet_loss_);
            std::swap(high_bandwidth_bps_, other->high_bandwidth_bps_);
            std::swap(high_bandwidth_packet_loss_, other->high_bandwidth_packet_loss_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string FecController_Threshold::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.FecController.Threshold";
        }

        // -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int FecController::kFecEnablingThresholdFieldNumber;
        const int FecController::kFecDisablingThresholdFieldNumber;
        const int FecController::kTimeConstantMsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        FecController::FecController()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.FecController)
        }

        void FecController::InitAsDefaultInstance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            fec_enabling_threshold_ = const_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(
                ::webrtc::audio_network_adaptor::config::FecController_Threshold::internal_default_instance());
#else
            fec_enabling_threshold_ = const_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(&::webrtc::audio_network_adaptor::config::FecController_Threshold::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            fec_disabling_threshold_ = const_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(
                ::webrtc::audio_network_adaptor::config::FecController_Threshold::internal_default_instance());
#else
            fec_disabling_threshold_ = const_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(&::webrtc::audio_network_adaptor::config::FecController_Threshold::default_instance());
#endif
        }

        FecController::FecController(const FecController& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.FecController)
        }

        void FecController::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            fec_enabling_threshold_ = NULL;
            fec_disabling_threshold_ = NULL;
            time_constant_ms_ = 0;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        FecController::~FecController()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.FecController)
            SharedDtor();
        }

        void FecController::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
                delete fec_enabling_threshold_;
                delete fec_disabling_threshold_;
            }
        }

        void FecController::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const FecController& FecController::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        FecController* FecController::default_instance_ = NULL;

        FecController* FecController::New(::google::protobuf::Arena* arena) const
        {
            FecController* n = new FecController;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void FecController::Clear()
        {
            // @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.FecController)
            if (_has_bits_[0 / 32] & 7u) {
                if (has_fec_enabling_threshold()) {
                    if (fec_enabling_threshold_ != NULL)
                        fec_enabling_threshold_->::webrtc::audio_network_adaptor::config::FecController_Threshold::Clear();
                }
                if (has_fec_disabling_threshold()) {
                    if (fec_disabling_threshold_ != NULL)
                        fec_disabling_threshold_->::webrtc::audio_network_adaptor::config::FecController_Threshold::Clear();
                }
                time_constant_ms_ = 0;
            }
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool FecController::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForFecController, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.FecController)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
                case 1: {
                    if (tag == 10) {
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_fec_enabling_threshold()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(18))
                        goto parse_fec_disabling_threshold;
                    break;
                }

                // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
                case 2: {
                    if (tag == 18) {
                    parse_fec_disabling_threshold:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_fec_disabling_threshold()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(24))
                        goto parse_time_constant_ms;
                    break;
                }

                // optional int32 time_constant_ms = 3;
                case 3: {
                    if (tag == 24) {
                    parse_time_constant_ms:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &time_constant_ms_)));
                        set_has_time_constant_ms();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.FecController)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.FecController)
            return false;
#undef DO_
        }

        void FecController::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.FecController)
            // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
            if (has_fec_enabling_threshold()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    1, *this->fec_enabling_threshold_, output);
            }

            // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
            if (has_fec_disabling_threshold()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    2, *this->fec_disabling_threshold_, output);
            }

            // optional int32 time_constant_ms = 3;
            if (has_time_constant_ms()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->time_constant_ms(), output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.FecController)
        }

        int FecController::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.FecController)
            int total_size = 0;

            if (_has_bits_[0 / 32] & 7u) {
                // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
                if (has_fec_enabling_threshold()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->fec_enabling_threshold_);
                }

                // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
                if (has_fec_disabling_threshold()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->fec_disabling_threshold_);
                }

                // optional int32 time_constant_ms = 3;
                if (has_time_constant_ms()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->time_constant_ms());
                }
            }
            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void FecController::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const FecController*>(&from));
        }

        void FecController::MergeFrom(const FecController& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.FecController)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
                if (from.has_fec_enabling_threshold()) {
                    mutable_fec_enabling_threshold()->::webrtc::audio_network_adaptor::config::FecController_Threshold::MergeFrom(from.fec_enabling_threshold());
                }
                if (from.has_fec_disabling_threshold()) {
                    mutable_fec_disabling_threshold()->::webrtc::audio_network_adaptor::config::FecController_Threshold::MergeFrom(from.fec_disabling_threshold());
                }
                if (from.has_time_constant_ms()) {
                    set_time_constant_ms(from.time_constant_ms());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void FecController::CopyFrom(const FecController& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.FecController)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool FecController::IsInitialized() const
        {

            return true;
        }

        void FecController::Swap(FecController* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void FecController::InternalSwap(FecController* other)
        {
            std::swap(fec_enabling_threshold_, other->fec_enabling_threshold_);
            std::swap(fec_disabling_threshold_, other->fec_disabling_threshold_);
            std::swap(time_constant_ms_, other->time_constant_ms_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string FecController::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.FecController";
        }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
        // FecController_Threshold

        // optional int32 low_bandwidth_bps = 1;
        bool FecController_Threshold::has_low_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        void FecController_Threshold::set_has_low_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000001u;
        }
        void FecController_Threshold::clear_has_low_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000001u;
        }
        void FecController_Threshold::clear_low_bandwidth_bps()
        {
            low_bandwidth_bps_ = 0;
            clear_has_low_bandwidth_bps();
        }
        ::google::protobuf::int32 FecController_Threshold::low_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
            return low_bandwidth_bps_;
        }
        void FecController_Threshold::set_low_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_low_bandwidth_bps();
            low_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
        }

        // optional float low_bandwidth_packet_loss = 2;
        bool FecController_Threshold::has_low_bandwidth_packet_loss() const
        {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        void FecController_Threshold::set_has_low_bandwidth_packet_loss()
        {
            _has_bits_[0] |= 0x00000002u;
        }
        void FecController_Threshold::clear_has_low_bandwidth_packet_loss()
        {
            _has_bits_[0] &= ~0x00000002u;
        }
        void FecController_Threshold::clear_low_bandwidth_packet_loss()
        {
            low_bandwidth_packet_loss_ = 0;
            clear_has_low_bandwidth_packet_loss();
        }
        float FecController_Threshold::low_bandwidth_packet_loss() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
            return low_bandwidth_packet_loss_;
        }
        void FecController_Threshold::set_low_bandwidth_packet_loss(float value)
        {
            set_has_low_bandwidth_packet_loss();
            low_bandwidth_packet_loss_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
        }

        // optional int32 high_bandwidth_bps = 3;
        bool FecController_Threshold::has_high_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        void FecController_Threshold::set_has_high_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000004u;
        }
        void FecController_Threshold::clear_has_high_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000004u;
        }
        void FecController_Threshold::clear_high_bandwidth_bps()
        {
            high_bandwidth_bps_ = 0;
            clear_has_high_bandwidth_bps();
        }
        ::google::protobuf::int32 FecController_Threshold::high_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
            return high_bandwidth_bps_;
        }
        void FecController_Threshold::set_high_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_high_bandwidth_bps();
            high_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
        }

        // optional float high_bandwidth_packet_loss = 4;
        bool FecController_Threshold::has_high_bandwidth_packet_loss() const
        {
            return (_has_bits_[0] & 0x00000008u) != 0;
        }
        void FecController_Threshold::set_has_high_bandwidth_packet_loss()
        {
            _has_bits_[0] |= 0x00000008u;
        }
        void FecController_Threshold::clear_has_high_bandwidth_packet_loss()
        {
            _has_bits_[0] &= ~0x00000008u;
        }
        void FecController_Threshold::clear_high_bandwidth_packet_loss()
        {
            high_bandwidth_packet_loss_ = 0;
            clear_has_high_bandwidth_packet_loss();
        }
        float FecController_Threshold::high_bandwidth_packet_loss() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
            return high_bandwidth_packet_loss_;
        }
        void FecController_Threshold::set_high_bandwidth_packet_loss(float value)
        {
            set_has_high_bandwidth_packet_loss();
            high_bandwidth_packet_loss_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
        }

        // -------------------------------------------------------------------

        // FecController

        // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
        bool FecController::has_fec_enabling_threshold() const
        {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        void FecController::set_has_fec_enabling_threshold()
        {
            _has_bits_[0] |= 0x00000001u;
        }
        void FecController::clear_has_fec_enabling_threshold()
        {
            _has_bits_[0] &= ~0x00000001u;
        }
        void FecController::clear_fec_enabling_threshold()
        {
            if (fec_enabling_threshold_ != NULL)
                fec_enabling_threshold_->::webrtc::audio_network_adaptor::config::FecController_Threshold::Clear();
            clear_has_fec_enabling_threshold();
        }
        const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_enabling_threshold() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            return fec_enabling_threshold_ != NULL ? *fec_enabling_threshold_ : *default_instance().fec_enabling_threshold_;
#else
            return fec_enabling_threshold_ != NULL ? *fec_enabling_threshold_ : *default_instance_->fec_enabling_threshold_;
#endif
        }
        ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::mutable_fec_enabling_threshold()
        {
            set_has_fec_enabling_threshold();
            if (fec_enabling_threshold_ == NULL) {
                fec_enabling_threshold_ = new ::webrtc::audio_network_adaptor::config::FecController_Threshold;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
            return fec_enabling_threshold_;
        }
        ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::release_fec_enabling_threshold()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
            clear_has_fec_enabling_threshold();
            ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = fec_enabling_threshold_;
            fec_enabling_threshold_ = NULL;
            return temp;
        }
        void FecController::set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_enabling_threshold)
        {
            delete fec_enabling_threshold_;
            fec_enabling_threshold_ = fec_enabling_threshold;
            if (fec_enabling_threshold) {
                set_has_fec_enabling_threshold();
            } else {
                clear_has_fec_enabling_threshold();
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
        }

        // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
        bool FecController::has_fec_disabling_threshold() const
        {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        void FecController::set_has_fec_disabling_threshold()
        {
            _has_bits_[0] |= 0x00000002u;
        }
        void FecController::clear_has_fec_disabling_threshold()
        {
            _has_bits_[0] &= ~0x00000002u;
        }
        void FecController::clear_fec_disabling_threshold()
        {
            if (fec_disabling_threshold_ != NULL)
                fec_disabling_threshold_->::webrtc::audio_network_adaptor::config::FecController_Threshold::Clear();
            clear_has_fec_disabling_threshold();
        }
        const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_disabling_threshold() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            return fec_disabling_threshold_ != NULL ? *fec_disabling_threshold_ : *default_instance().fec_disabling_threshold_;
#else
            return fec_disabling_threshold_ != NULL ? *fec_disabling_threshold_ : *default_instance_->fec_disabling_threshold_;
#endif
        }
        ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::mutable_fec_disabling_threshold()
        {
            set_has_fec_disabling_threshold();
            if (fec_disabling_threshold_ == NULL) {
                fec_disabling_threshold_ = new ::webrtc::audio_network_adaptor::config::FecController_Threshold;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
            return fec_disabling_threshold_;
        }
        ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::release_fec_disabling_threshold()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
            clear_has_fec_disabling_threshold();
            ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = fec_disabling_threshold_;
            fec_disabling_threshold_ = NULL;
            return temp;
        }
        void FecController::set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_disabling_threshold)
        {
            delete fec_disabling_threshold_;
            fec_disabling_threshold_ = fec_disabling_threshold;
            if (fec_disabling_threshold) {
                set_has_fec_disabling_threshold();
            } else {
                clear_has_fec_disabling_threshold();
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
        }

        // optional int32 time_constant_ms = 3;
        bool FecController::has_time_constant_ms() const
        {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        void FecController::set_has_time_constant_ms()
        {
            _has_bits_[0] |= 0x00000004u;
        }
        void FecController::clear_has_time_constant_ms()
        {
            _has_bits_[0] &= ~0x00000004u;
        }
        void FecController::clear_time_constant_ms()
        {
            time_constant_ms_ = 0;
            clear_has_time_constant_ms();
        }
        ::google::protobuf::int32 FecController::time_constant_ms() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
            return time_constant_ms_;
        }
        void FecController::set_time_constant_ms(::google::protobuf::int32 value)
        {
            set_has_time_constant_ms();
            time_constant_ms_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
        }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

        // ===================================================================

        static ::std::string* MutableUnknownFieldsForFrameLengthController(
            FrameLengthController* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int FrameLengthController::kFlIncreasingPacketLossFractionFieldNumber;
        const int FrameLengthController::kFlDecreasingPacketLossFractionFieldNumber;
        const int FrameLengthController::kFl20MsTo60MsBandwidthBpsFieldNumber;
        const int FrameLengthController::kFl60MsTo20MsBandwidthBpsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        FrameLengthController::FrameLengthController()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.FrameLengthController)
        }

        void FrameLengthController::InitAsDefaultInstance()
        {
        }

        FrameLengthController::FrameLengthController(const FrameLengthController& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.FrameLengthController)
        }

        void FrameLengthController::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            fl_increasing_packet_loss_fraction_ = 0;
            fl_decreasing_packet_loss_fraction_ = 0;
            fl_20ms_to_60ms_bandwidth_bps_ = 0;
            fl_60ms_to_20ms_bandwidth_bps_ = 0;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        FrameLengthController::~FrameLengthController()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.FrameLengthController)
            SharedDtor();
        }

        void FrameLengthController::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
            }
        }

        void FrameLengthController::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const FrameLengthController& FrameLengthController::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        FrameLengthController* FrameLengthController::default_instance_ = NULL;

        FrameLengthController* FrameLengthController::New(::google::protobuf::Arena* arena) const
        {
            FrameLengthController* n = new FrameLengthController;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void FrameLengthController::Clear()
        {
// @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.FrameLengthController)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                           \
    _Pragma("clang diagnostic push")                                                                            \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(FrameLengthController, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<FrameLengthController*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

            ZR_(fl_increasing_packet_loss_fraction_, fl_60ms_to_20ms_bandwidth_bps_);

#undef ZR_HELPER_
#undef ZR_

            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool FrameLengthController::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForFrameLengthController, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.FrameLengthController)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional float fl_increasing_packet_loss_fraction = 1;
                case 1: {
                    if (tag == 13) {
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                            input, &fl_increasing_packet_loss_fraction_)));
                        set_has_fl_increasing_packet_loss_fraction();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(21))
                        goto parse_fl_decreasing_packet_loss_fraction;
                    break;
                }

                // optional float fl_decreasing_packet_loss_fraction = 2;
                case 2: {
                    if (tag == 21) {
                    parse_fl_decreasing_packet_loss_fraction:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                            input, &fl_decreasing_packet_loss_fraction_)));
                        set_has_fl_decreasing_packet_loss_fraction();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(24))
                        goto parse_fl_20ms_to_60ms_bandwidth_bps;
                    break;
                }

                // optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
                case 3: {
                    if (tag == 24) {
                    parse_fl_20ms_to_60ms_bandwidth_bps:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &fl_20ms_to_60ms_bandwidth_bps_)));
                        set_has_fl_20ms_to_60ms_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(32))
                        goto parse_fl_60ms_to_20ms_bandwidth_bps;
                    break;
                }

                // optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
                case 4: {
                    if (tag == 32) {
                    parse_fl_60ms_to_20ms_bandwidth_bps:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &fl_60ms_to_20ms_bandwidth_bps_)));
                        set_has_fl_60ms_to_20ms_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.FrameLengthController)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.FrameLengthController)
            return false;
#undef DO_
        }

        void FrameLengthController::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.FrameLengthController)
            // optional float fl_increasing_packet_loss_fraction = 1;
            if (has_fl_increasing_packet_loss_fraction()) {
                ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->fl_increasing_packet_loss_fraction(), output);
            }

            // optional float fl_decreasing_packet_loss_fraction = 2;
            if (has_fl_decreasing_packet_loss_fraction()) {
                ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->fl_decreasing_packet_loss_fraction(), output);
            }

            // optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
            if (has_fl_20ms_to_60ms_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->fl_20ms_to_60ms_bandwidth_bps(), output);
            }

            // optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
            if (has_fl_60ms_to_20ms_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->fl_60ms_to_20ms_bandwidth_bps(), output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.FrameLengthController)
        }

        int FrameLengthController::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.FrameLengthController)
            int total_size = 0;

            if (_has_bits_[0 / 32] & 15u) {
                // optional float fl_increasing_packet_loss_fraction = 1;
                if (has_fl_increasing_packet_loss_fraction()) {
                    total_size += 1 + 4;
                }

                // optional float fl_decreasing_packet_loss_fraction = 2;
                if (has_fl_decreasing_packet_loss_fraction()) {
                    total_size += 1 + 4;
                }

                // optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
                if (has_fl_20ms_to_60ms_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->fl_20ms_to_60ms_bandwidth_bps());
                }

                // optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
                if (has_fl_60ms_to_20ms_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->fl_60ms_to_20ms_bandwidth_bps());
                }
            }
            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void FrameLengthController::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const FrameLengthController*>(&from));
        }

        void FrameLengthController::MergeFrom(const FrameLengthController& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.FrameLengthController)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
                if (from.has_fl_increasing_packet_loss_fraction()) {
                    set_fl_increasing_packet_loss_fraction(from.fl_increasing_packet_loss_fraction());
                }
                if (from.has_fl_decreasing_packet_loss_fraction()) {
                    set_fl_decreasing_packet_loss_fraction(from.fl_decreasing_packet_loss_fraction());
                }
                if (from.has_fl_20ms_to_60ms_bandwidth_bps()) {
                    set_fl_20ms_to_60ms_bandwidth_bps(from.fl_20ms_to_60ms_bandwidth_bps());
                }
                if (from.has_fl_60ms_to_20ms_bandwidth_bps()) {
                    set_fl_60ms_to_20ms_bandwidth_bps(from.fl_60ms_to_20ms_bandwidth_bps());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void FrameLengthController::CopyFrom(const FrameLengthController& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.FrameLengthController)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool FrameLengthController::IsInitialized() const
        {

            return true;
        }

        void FrameLengthController::Swap(FrameLengthController* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void FrameLengthController::InternalSwap(FrameLengthController* other)
        {
            std::swap(fl_increasing_packet_loss_fraction_, other->fl_increasing_packet_loss_fraction_);
            std::swap(fl_decreasing_packet_loss_fraction_, other->fl_decreasing_packet_loss_fraction_);
            std::swap(fl_20ms_to_60ms_bandwidth_bps_, other->fl_20ms_to_60ms_bandwidth_bps_);
            std::swap(fl_60ms_to_20ms_bandwidth_bps_, other->fl_60ms_to_20ms_bandwidth_bps_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string FrameLengthController::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.FrameLengthController";
        }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
        // FrameLengthController

        // optional float fl_increasing_packet_loss_fraction = 1;
        bool FrameLengthController::has_fl_increasing_packet_loss_fraction() const
        {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        void FrameLengthController::set_has_fl_increasing_packet_loss_fraction()
        {
            _has_bits_[0] |= 0x00000001u;
        }
        void FrameLengthController::clear_has_fl_increasing_packet_loss_fraction()
        {
            _has_bits_[0] &= ~0x00000001u;
        }
        void FrameLengthController::clear_fl_increasing_packet_loss_fraction()
        {
            fl_increasing_packet_loss_fraction_ = 0;
            clear_has_fl_increasing_packet_loss_fraction();
        }
        float FrameLengthController::fl_increasing_packet_loss_fraction() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
            return fl_increasing_packet_loss_fraction_;
        }
        void FrameLengthController::set_fl_increasing_packet_loss_fraction(float value)
        {
            set_has_fl_increasing_packet_loss_fraction();
            fl_increasing_packet_loss_fraction_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
        }

        // optional float fl_decreasing_packet_loss_fraction = 2;
        bool FrameLengthController::has_fl_decreasing_packet_loss_fraction() const
        {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        void FrameLengthController::set_has_fl_decreasing_packet_loss_fraction()
        {
            _has_bits_[0] |= 0x00000002u;
        }
        void FrameLengthController::clear_has_fl_decreasing_packet_loss_fraction()
        {
            _has_bits_[0] &= ~0x00000002u;
        }
        void FrameLengthController::clear_fl_decreasing_packet_loss_fraction()
        {
            fl_decreasing_packet_loss_fraction_ = 0;
            clear_has_fl_decreasing_packet_loss_fraction();
        }
        float FrameLengthController::fl_decreasing_packet_loss_fraction() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
            return fl_decreasing_packet_loss_fraction_;
        }
        void FrameLengthController::set_fl_decreasing_packet_loss_fraction(float value)
        {
            set_has_fl_decreasing_packet_loss_fraction();
            fl_decreasing_packet_loss_fraction_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
        }

        // optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
        bool FrameLengthController::has_fl_20ms_to_60ms_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        void FrameLengthController::set_has_fl_20ms_to_60ms_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000004u;
        }
        void FrameLengthController::clear_has_fl_20ms_to_60ms_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000004u;
        }
        void FrameLengthController::clear_fl_20ms_to_60ms_bandwidth_bps()
        {
            fl_20ms_to_60ms_bandwidth_bps_ = 0;
            clear_has_fl_20ms_to_60ms_bandwidth_bps();
        }
        ::google::protobuf::int32 FrameLengthController::fl_20ms_to_60ms_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
            return fl_20ms_to_60ms_bandwidth_bps_;
        }
        void FrameLengthController::set_fl_20ms_to_60ms_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_fl_20ms_to_60ms_bandwidth_bps();
            fl_20ms_to_60ms_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
        }

        // optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
        bool FrameLengthController::has_fl_60ms_to_20ms_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000008u) != 0;
        }
        void FrameLengthController::set_has_fl_60ms_to_20ms_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000008u;
        }
        void FrameLengthController::clear_has_fl_60ms_to_20ms_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000008u;
        }
        void FrameLengthController::clear_fl_60ms_to_20ms_bandwidth_bps()
        {
            fl_60ms_to_20ms_bandwidth_bps_ = 0;
            clear_has_fl_60ms_to_20ms_bandwidth_bps();
        }
        ::google::protobuf::int32 FrameLengthController::fl_60ms_to_20ms_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
            return fl_60ms_to_20ms_bandwidth_bps_;
        }
        void FrameLengthController::set_fl_60ms_to_20ms_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_fl_60ms_to_20ms_bandwidth_bps();
            fl_60ms_to_20ms_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
        }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

        // ===================================================================

        static ::std::string* MutableUnknownFieldsForChannelController(
            ChannelController* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int ChannelController::kChannel1To2BandwidthBpsFieldNumber;
        const int ChannelController::kChannel2To1BandwidthBpsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        ChannelController::ChannelController()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.ChannelController)
        }

        void ChannelController::InitAsDefaultInstance()
        {
        }

        ChannelController::ChannelController(const ChannelController& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.ChannelController)
        }

        void ChannelController::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            channel_1_to_2_bandwidth_bps_ = 0;
            channel_2_to_1_bandwidth_bps_ = 0;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        ChannelController::~ChannelController()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.ChannelController)
            SharedDtor();
        }

        void ChannelController::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
            }
        }

        void ChannelController::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const ChannelController& ChannelController::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        ChannelController* ChannelController::default_instance_ = NULL;

        ChannelController* ChannelController::New(::google::protobuf::Arena* arena) const
        {
            ChannelController* n = new ChannelController;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void ChannelController::Clear()
        {
// @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.ChannelController)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                       \
    _Pragma("clang diagnostic push")                                                                        \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ChannelController, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ChannelController*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

            ZR_(channel_1_to_2_bandwidth_bps_, channel_2_to_1_bandwidth_bps_);

#undef ZR_HELPER_
#undef ZR_

            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool ChannelController::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForChannelController, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.ChannelController)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional int32 channel_1_to_2_bandwidth_bps = 1;
                case 1: {
                    if (tag == 8) {
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &channel_1_to_2_bandwidth_bps_)));
                        set_has_channel_1_to_2_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(16))
                        goto parse_channel_2_to_1_bandwidth_bps;
                    break;
                }

                // optional int32 channel_2_to_1_bandwidth_bps = 2;
                case 2: {
                    if (tag == 16) {
                    parse_channel_2_to_1_bandwidth_bps:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &channel_2_to_1_bandwidth_bps_)));
                        set_has_channel_2_to_1_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.ChannelController)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.ChannelController)
            return false;
#undef DO_
        }

        void ChannelController::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.ChannelController)
            // optional int32 channel_1_to_2_bandwidth_bps = 1;
            if (has_channel_1_to_2_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->channel_1_to_2_bandwidth_bps(), output);
            }

            // optional int32 channel_2_to_1_bandwidth_bps = 2;
            if (has_channel_2_to_1_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->channel_2_to_1_bandwidth_bps(), output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.ChannelController)
        }

        int ChannelController::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.ChannelController)
            int total_size = 0;

            if (_has_bits_[0 / 32] & 3u) {
                // optional int32 channel_1_to_2_bandwidth_bps = 1;
                if (has_channel_1_to_2_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->channel_1_to_2_bandwidth_bps());
                }

                // optional int32 channel_2_to_1_bandwidth_bps = 2;
                if (has_channel_2_to_1_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->channel_2_to_1_bandwidth_bps());
                }
            }
            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void ChannelController::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const ChannelController*>(&from));
        }

        void ChannelController::MergeFrom(const ChannelController& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.ChannelController)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
                if (from.has_channel_1_to_2_bandwidth_bps()) {
                    set_channel_1_to_2_bandwidth_bps(from.channel_1_to_2_bandwidth_bps());
                }
                if (from.has_channel_2_to_1_bandwidth_bps()) {
                    set_channel_2_to_1_bandwidth_bps(from.channel_2_to_1_bandwidth_bps());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void ChannelController::CopyFrom(const ChannelController& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.ChannelController)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool ChannelController::IsInitialized() const
        {

            return true;
        }

        void ChannelController::Swap(ChannelController* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void ChannelController::InternalSwap(ChannelController* other)
        {
            std::swap(channel_1_to_2_bandwidth_bps_, other->channel_1_to_2_bandwidth_bps_);
            std::swap(channel_2_to_1_bandwidth_bps_, other->channel_2_to_1_bandwidth_bps_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string ChannelController::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.ChannelController";
        }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
        // ChannelController

        // optional int32 channel_1_to_2_bandwidth_bps = 1;
        bool ChannelController::has_channel_1_to_2_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        void ChannelController::set_has_channel_1_to_2_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000001u;
        }
        void ChannelController::clear_has_channel_1_to_2_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000001u;
        }
        void ChannelController::clear_channel_1_to_2_bandwidth_bps()
        {
            channel_1_to_2_bandwidth_bps_ = 0;
            clear_has_channel_1_to_2_bandwidth_bps();
        }
        ::google::protobuf::int32 ChannelController::channel_1_to_2_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
            return channel_1_to_2_bandwidth_bps_;
        }
        void ChannelController::set_channel_1_to_2_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_channel_1_to_2_bandwidth_bps();
            channel_1_to_2_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
        }

        // optional int32 channel_2_to_1_bandwidth_bps = 2;
        bool ChannelController::has_channel_2_to_1_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        void ChannelController::set_has_channel_2_to_1_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000002u;
        }
        void ChannelController::clear_has_channel_2_to_1_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000002u;
        }
        void ChannelController::clear_channel_2_to_1_bandwidth_bps()
        {
            channel_2_to_1_bandwidth_bps_ = 0;
            clear_has_channel_2_to_1_bandwidth_bps();
        }
        ::google::protobuf::int32 ChannelController::channel_2_to_1_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
            return channel_2_to_1_bandwidth_bps_;
        }
        void ChannelController::set_channel_2_to_1_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_channel_2_to_1_bandwidth_bps();
            channel_2_to_1_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
        }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

        // ===================================================================

        static ::std::string* MutableUnknownFieldsForDtxController(
            DtxController* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int DtxController::kDtxEnablingBandwidthBpsFieldNumber;
        const int DtxController::kDtxDisablingBandwidthBpsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        DtxController::DtxController()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.DtxController)
        }

        void DtxController::InitAsDefaultInstance()
        {
        }

        DtxController::DtxController(const DtxController& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.DtxController)
        }

        void DtxController::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            dtx_enabling_bandwidth_bps_ = 0;
            dtx_disabling_bandwidth_bps_ = 0;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        DtxController::~DtxController()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.DtxController)
            SharedDtor();
        }

        void DtxController::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
            }
        }

        void DtxController::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const DtxController& DtxController::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        DtxController* DtxController::default_instance_ = NULL;

        DtxController* DtxController::New(::google::protobuf::Arena* arena) const
        {
            DtxController* n = new DtxController;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void DtxController::Clear()
        {
// @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.DtxController)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                   \
    _Pragma("clang diagnostic push")                                                                    \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(DtxController, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<DtxController*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

            ZR_(dtx_enabling_bandwidth_bps_, dtx_disabling_bandwidth_bps_);

#undef ZR_HELPER_
#undef ZR_

            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool DtxController::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForDtxController, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.DtxController)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional int32 dtx_enabling_bandwidth_bps = 1;
                case 1: {
                    if (tag == 8) {
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &dtx_enabling_bandwidth_bps_)));
                        set_has_dtx_enabling_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(16))
                        goto parse_dtx_disabling_bandwidth_bps;
                    break;
                }

                // optional int32 dtx_disabling_bandwidth_bps = 2;
                case 2: {
                    if (tag == 16) {
                    parse_dtx_disabling_bandwidth_bps:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &dtx_disabling_bandwidth_bps_)));
                        set_has_dtx_disabling_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.DtxController)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.DtxController)
            return false;
#undef DO_
        }

        void DtxController::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.DtxController)
            // optional int32 dtx_enabling_bandwidth_bps = 1;
            if (has_dtx_enabling_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->dtx_enabling_bandwidth_bps(), output);
            }

            // optional int32 dtx_disabling_bandwidth_bps = 2;
            if (has_dtx_disabling_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->dtx_disabling_bandwidth_bps(), output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.DtxController)
        }

        int DtxController::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.DtxController)
            int total_size = 0;

            if (_has_bits_[0 / 32] & 3u) {
                // optional int32 dtx_enabling_bandwidth_bps = 1;
                if (has_dtx_enabling_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->dtx_enabling_bandwidth_bps());
                }

                // optional int32 dtx_disabling_bandwidth_bps = 2;
                if (has_dtx_disabling_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->dtx_disabling_bandwidth_bps());
                }
            }
            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void DtxController::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const DtxController*>(&from));
        }

        void DtxController::MergeFrom(const DtxController& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.DtxController)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
                if (from.has_dtx_enabling_bandwidth_bps()) {
                    set_dtx_enabling_bandwidth_bps(from.dtx_enabling_bandwidth_bps());
                }
                if (from.has_dtx_disabling_bandwidth_bps()) {
                    set_dtx_disabling_bandwidth_bps(from.dtx_disabling_bandwidth_bps());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void DtxController::CopyFrom(const DtxController& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.DtxController)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool DtxController::IsInitialized() const
        {

            return true;
        }

        void DtxController::Swap(DtxController* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void DtxController::InternalSwap(DtxController* other)
        {
            std::swap(dtx_enabling_bandwidth_bps_, other->dtx_enabling_bandwidth_bps_);
            std::swap(dtx_disabling_bandwidth_bps_, other->dtx_disabling_bandwidth_bps_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string DtxController::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.DtxController";
        }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
        // DtxController

        // optional int32 dtx_enabling_bandwidth_bps = 1;
        bool DtxController::has_dtx_enabling_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        void DtxController::set_has_dtx_enabling_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000001u;
        }
        void DtxController::clear_has_dtx_enabling_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000001u;
        }
        void DtxController::clear_dtx_enabling_bandwidth_bps()
        {
            dtx_enabling_bandwidth_bps_ = 0;
            clear_has_dtx_enabling_bandwidth_bps();
        }
        ::google::protobuf::int32 DtxController::dtx_enabling_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
            return dtx_enabling_bandwidth_bps_;
        }
        void DtxController::set_dtx_enabling_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_dtx_enabling_bandwidth_bps();
            dtx_enabling_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
        }

        // optional int32 dtx_disabling_bandwidth_bps = 2;
        bool DtxController::has_dtx_disabling_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        void DtxController::set_has_dtx_disabling_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000002u;
        }
        void DtxController::clear_has_dtx_disabling_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000002u;
        }
        void DtxController::clear_dtx_disabling_bandwidth_bps()
        {
            dtx_disabling_bandwidth_bps_ = 0;
            clear_has_dtx_disabling_bandwidth_bps();
        }
        ::google::protobuf::int32 DtxController::dtx_disabling_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
            return dtx_disabling_bandwidth_bps_;
        }
        void DtxController::set_dtx_disabling_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_dtx_disabling_bandwidth_bps();
            dtx_disabling_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
        }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

        // ===================================================================

        static ::std::string* MutableUnknownFieldsForBitrateController(
            BitrateController* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        BitrateController::BitrateController()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.BitrateController)
        }

        void BitrateController::InitAsDefaultInstance()
        {
        }

        BitrateController::BitrateController(const BitrateController& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.BitrateController)
        }

        void BitrateController::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        BitrateController::~BitrateController()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.BitrateController)
            SharedDtor();
        }

        void BitrateController::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
            }
        }

        void BitrateController::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const BitrateController& BitrateController::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        BitrateController* BitrateController::default_instance_ = NULL;

        BitrateController* BitrateController::New(::google::protobuf::Arena* arena) const
        {
            BitrateController* n = new BitrateController;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void BitrateController::Clear()
        {
            // @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.BitrateController)
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool BitrateController::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForBitrateController, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.BitrateController)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.BitrateController)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.BitrateController)
            return false;
#undef DO_
        }

        void BitrateController::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.BitrateController)
            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.BitrateController)
        }

        int BitrateController::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.BitrateController)
            int total_size = 0;

            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void BitrateController::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const BitrateController*>(&from));
        }

        void BitrateController::MergeFrom(const BitrateController& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.BitrateController)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void BitrateController::CopyFrom(const BitrateController& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.BitrateController)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool BitrateController::IsInitialized() const
        {

            return true;
        }

        void BitrateController::Swap(BitrateController* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void BitrateController::InternalSwap(BitrateController* other)
        {
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string BitrateController::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.BitrateController";
        }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
        // BitrateController

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

        // ===================================================================

        static ::std::string* MutableUnknownFieldsForController(
            Controller* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

        static ::std::string* MutableUnknownFieldsForController_ScoringPoint(
            Controller_ScoringPoint* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int Controller_ScoringPoint::kUplinkBandwidthBpsFieldNumber;
        const int Controller_ScoringPoint::kUplinkPacketLossFractionFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        Controller_ScoringPoint::Controller_ScoringPoint()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
        }

        void Controller_ScoringPoint::InitAsDefaultInstance()
        {
        }

        Controller_ScoringPoint::Controller_ScoringPoint(const Controller_ScoringPoint& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
        }

        void Controller_ScoringPoint::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            uplink_bandwidth_bps_ = 0;
            uplink_packet_loss_fraction_ = 0;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        Controller_ScoringPoint::~Controller_ScoringPoint()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            SharedDtor();
        }

        void Controller_ScoringPoint::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
            }
        }

        void Controller_ScoringPoint::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const Controller_ScoringPoint& Controller_ScoringPoint::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        Controller_ScoringPoint* Controller_ScoringPoint::default_instance_ = NULL;

        Controller_ScoringPoint* Controller_ScoringPoint::New(::google::protobuf::Arena* arena) const
        {
            Controller_ScoringPoint* n = new Controller_ScoringPoint;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void Controller_ScoringPoint::Clear()
        {
// @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                             \
    _Pragma("clang diagnostic push")                                                                              \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(Controller_ScoringPoint, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<Controller_ScoringPoint*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

            ZR_(uplink_bandwidth_bps_, uplink_packet_loss_fraction_);

#undef ZR_HELPER_
#undef ZR_

            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool Controller_ScoringPoint::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForController_ScoringPoint, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional int32 uplink_bandwidth_bps = 1;
                case 1: {
                    if (tag == 8) {
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &uplink_bandwidth_bps_)));
                        set_has_uplink_bandwidth_bps();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(21))
                        goto parse_uplink_packet_loss_fraction;
                    break;
                }

                // optional float uplink_packet_loss_fraction = 2;
                case 2: {
                    if (tag == 21) {
                    parse_uplink_packet_loss_fraction:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                            input, &uplink_packet_loss_fraction_)));
                        set_has_uplink_packet_loss_fraction();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            return false;
#undef DO_
        }

        void Controller_ScoringPoint::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            // optional int32 uplink_bandwidth_bps = 1;
            if (has_uplink_bandwidth_bps()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uplink_bandwidth_bps(), output);
            }

            // optional float uplink_packet_loss_fraction = 2;
            if (has_uplink_packet_loss_fraction()) {
                ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->uplink_packet_loss_fraction(), output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
        }

        int Controller_ScoringPoint::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            int total_size = 0;

            if (_has_bits_[0 / 32] & 3u) {
                // optional int32 uplink_bandwidth_bps = 1;
                if (has_uplink_bandwidth_bps()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->uplink_bandwidth_bps());
                }

                // optional float uplink_packet_loss_fraction = 2;
                if (has_uplink_packet_loss_fraction()) {
                    total_size += 1 + 4;
                }
            }
            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void Controller_ScoringPoint::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const Controller_ScoringPoint*>(&from));
        }

        void Controller_ScoringPoint::MergeFrom(const Controller_ScoringPoint& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
                if (from.has_uplink_bandwidth_bps()) {
                    set_uplink_bandwidth_bps(from.uplink_bandwidth_bps());
                }
                if (from.has_uplink_packet_loss_fraction()) {
                    set_uplink_packet_loss_fraction(from.uplink_packet_loss_fraction());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void Controller_ScoringPoint::CopyFrom(const Controller_ScoringPoint& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool Controller_ScoringPoint::IsInitialized() const
        {

            return true;
        }

        void Controller_ScoringPoint::Swap(Controller_ScoringPoint* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void Controller_ScoringPoint::InternalSwap(Controller_ScoringPoint* other)
        {
            std::swap(uplink_bandwidth_bps_, other->uplink_bandwidth_bps_);
            std::swap(uplink_packet_loss_fraction_, other->uplink_packet_loss_fraction_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string Controller_ScoringPoint::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.Controller.ScoringPoint";
        }

        // -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int Controller::kScoringPointFieldNumber;
        const int Controller::kFecControllerFieldNumber;
        const int Controller::kFrameLengthControllerFieldNumber;
        const int Controller::kChannelControllerFieldNumber;
        const int Controller::kDtxControllerFieldNumber;
        const int Controller::kBitrateControllerFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        Controller::Controller()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.Controller)
        }

        void Controller::InitAsDefaultInstance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            scoring_point_ = const_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(
                ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint::internal_default_instance());
#else
            scoring_point_ = const_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(&::webrtc::audio_network_adaptor::config::Controller_ScoringPoint::default_instance());
#endif
        }

        Controller::Controller(const Controller& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.Controller)
        }

        void Controller::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            scoring_point_ = NULL;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            clear_has_controller();
        }

        Controller::~Controller()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.Controller)
            SharedDtor();
        }

        void Controller::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            if (has_controller()) {
                clear_controller();
            }
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
                delete scoring_point_;
            }
        }

        void Controller::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const Controller& Controller::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        Controller* Controller::default_instance_ = NULL;

        Controller* Controller::New(::google::protobuf::Arena* arena) const
        {
            Controller* n = new Controller;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void Controller::clear_controller()
        {
            // @@protoc_insertion_point(one_of_clear_start:webrtc.audio_network_adaptor.config.Controller)
            switch (controller_case()) {
            case kFecController: {
                delete controller_.fec_controller_;
                break;
            }
            case kFrameLengthController: {
                delete controller_.frame_length_controller_;
                break;
            }
            case kChannelController: {
                delete controller_.channel_controller_;
                break;
            }
            case kDtxController: {
                delete controller_.dtx_controller_;
                break;
            }
            case kBitrateController: {
                delete controller_.bitrate_controller_;
                break;
            }
            case CONTROLLER_NOT_SET: {
                break;
            }
            }
            _oneof_case_[0] = CONTROLLER_NOT_SET;
        }

        void Controller::Clear()
        {
            // @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.Controller)
            if (has_scoring_point()) {
                if (scoring_point_ != NULL)
                    scoring_point_->::webrtc::audio_network_adaptor::config::Controller_ScoringPoint::Clear();
            }
            clear_controller();
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool Controller::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForController, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.Controller)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
                case 1: {
                    if (tag == 10) {
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_scoring_point()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(170))
                        goto parse_fec_controller;
                    break;
                }

                // optional .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
                case 21: {
                    if (tag == 170) {
                    parse_fec_controller:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_fec_controller()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(178))
                        goto parse_frame_length_controller;
                    break;
                }

                // optional .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
                case 22: {
                    if (tag == 178) {
                    parse_frame_length_controller:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_frame_length_controller()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(186))
                        goto parse_channel_controller;
                    break;
                }

                // optional .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
                case 23: {
                    if (tag == 186) {
                    parse_channel_controller:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_channel_controller()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(194))
                        goto parse_dtx_controller;
                    break;
                }

                // optional .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
                case 24: {
                    if (tag == 194) {
                    parse_dtx_controller:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_dtx_controller()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(202))
                        goto parse_bitrate_controller;
                    break;
                }

                // optional .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
                case 25: {
                    if (tag == 202) {
                    parse_bitrate_controller:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_bitrate_controller()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.Controller)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.Controller)
            return false;
#undef DO_
        }

        void Controller::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.Controller)
            // optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
            if (has_scoring_point()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    1, *this->scoring_point_, output);
            }

            // optional .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
            if (has_fec_controller()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    21, *controller_.fec_controller_, output);
            }

            // optional .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
            if (has_frame_length_controller()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    22, *controller_.frame_length_controller_, output);
            }

            // optional .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
            if (has_channel_controller()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    23, *controller_.channel_controller_, output);
            }

            // optional .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
            if (has_dtx_controller()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    24, *controller_.dtx_controller_, output);
            }

            // optional .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
            if (has_bitrate_controller()) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    25, *controller_.bitrate_controller_, output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.Controller)
        }

        int Controller::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.Controller)
            int total_size = 0;

            // optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
            if (has_scoring_point()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->scoring_point_);
            }

            switch (controller_case()) {
            // optional .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
            case kFecController: {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*controller_.fec_controller_);
                break;
            }
            // optional .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
            case kFrameLengthController: {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*controller_.frame_length_controller_);
                break;
            }
            // optional .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
            case kChannelController: {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*controller_.channel_controller_);
                break;
            }
            // optional .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
            case kDtxController: {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*controller_.dtx_controller_);
                break;
            }
            // optional .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
            case kBitrateController: {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*controller_.bitrate_controller_);
                break;
            }
            case CONTROLLER_NOT_SET: {
                break;
            }
            }
            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void Controller::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const Controller*>(&from));
        }

        void Controller::MergeFrom(const Controller& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.Controller)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            switch (from.controller_case()) {
            case kFecController: {
                mutable_fec_controller()->::webrtc::audio_network_adaptor::config::FecController::MergeFrom(from.fec_controller());
                break;
            }
            case kFrameLengthController: {
                mutable_frame_length_controller()->::webrtc::audio_network_adaptor::config::FrameLengthController::MergeFrom(from.frame_length_controller());
                break;
            }
            case kChannelController: {
                mutable_channel_controller()->::webrtc::audio_network_adaptor::config::ChannelController::MergeFrom(from.channel_controller());
                break;
            }
            case kDtxController: {
                mutable_dtx_controller()->::webrtc::audio_network_adaptor::config::DtxController::MergeFrom(from.dtx_controller());
                break;
            }
            case kBitrateController: {
                mutable_bitrate_controller()->::webrtc::audio_network_adaptor::config::BitrateController::MergeFrom(from.bitrate_controller());
                break;
            }
            case CONTROLLER_NOT_SET: {
                break;
            }
            }
            if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
                if (from.has_scoring_point()) {
                    mutable_scoring_point()->::webrtc::audio_network_adaptor::config::Controller_ScoringPoint::MergeFrom(from.scoring_point());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void Controller::CopyFrom(const Controller& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.Controller)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool Controller::IsInitialized() const
        {

            return true;
        }

        void Controller::Swap(Controller* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void Controller::InternalSwap(Controller* other)
        {
            std::swap(scoring_point_, other->scoring_point_);
            std::swap(controller_, other->controller_);
            std::swap(_oneof_case_[0], other->_oneof_case_[0]);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string Controller::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.Controller";
        }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
        // Controller_ScoringPoint

        // optional int32 uplink_bandwidth_bps = 1;
        bool Controller_ScoringPoint::has_uplink_bandwidth_bps() const
        {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        void Controller_ScoringPoint::set_has_uplink_bandwidth_bps()
        {
            _has_bits_[0] |= 0x00000001u;
        }
        void Controller_ScoringPoint::clear_has_uplink_bandwidth_bps()
        {
            _has_bits_[0] &= ~0x00000001u;
        }
        void Controller_ScoringPoint::clear_uplink_bandwidth_bps()
        {
            uplink_bandwidth_bps_ = 0;
            clear_has_uplink_bandwidth_bps();
        }
        ::google::protobuf::int32 Controller_ScoringPoint::uplink_bandwidth_bps() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
            return uplink_bandwidth_bps_;
        }
        void Controller_ScoringPoint::set_uplink_bandwidth_bps(::google::protobuf::int32 value)
        {
            set_has_uplink_bandwidth_bps();
            uplink_bandwidth_bps_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
        }

        // optional float uplink_packet_loss_fraction = 2;
        bool Controller_ScoringPoint::has_uplink_packet_loss_fraction() const
        {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        void Controller_ScoringPoint::set_has_uplink_packet_loss_fraction()
        {
            _has_bits_[0] |= 0x00000002u;
        }
        void Controller_ScoringPoint::clear_has_uplink_packet_loss_fraction()
        {
            _has_bits_[0] &= ~0x00000002u;
        }
        void Controller_ScoringPoint::clear_uplink_packet_loss_fraction()
        {
            uplink_packet_loss_fraction_ = 0;
            clear_has_uplink_packet_loss_fraction();
        }
        float Controller_ScoringPoint::uplink_packet_loss_fraction() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
            return uplink_packet_loss_fraction_;
        }
        void Controller_ScoringPoint::set_uplink_packet_loss_fraction(float value)
        {
            set_has_uplink_packet_loss_fraction();
            uplink_packet_loss_fraction_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
        }

        // -------------------------------------------------------------------

        // Controller

        // optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
        bool Controller::has_scoring_point() const
        {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        void Controller::set_has_scoring_point()
        {
            _has_bits_[0] |= 0x00000001u;
        }
        void Controller::clear_has_scoring_point()
        {
            _has_bits_[0] &= ~0x00000001u;
        }
        void Controller::clear_scoring_point()
        {
            if (scoring_point_ != NULL)
                scoring_point_->::webrtc::audio_network_adaptor::config::Controller_ScoringPoint::Clear();
            clear_has_scoring_point();
        }
        const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& Controller::scoring_point() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.scoring_point)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            return scoring_point_ != NULL ? *scoring_point_ : *default_instance().scoring_point_;
#else
            return scoring_point_ != NULL ? *scoring_point_ : *default_instance_->scoring_point_;
#endif
        }
        ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::mutable_scoring_point()
        {
            set_has_scoring_point();
            if (scoring_point_ == NULL) {
                scoring_point_ = new ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.scoring_point)
            return scoring_point_;
        }
        ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::release_scoring_point()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.scoring_point)
            clear_has_scoring_point();
            ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* temp = scoring_point_;
            scoring_point_ = NULL;
            return temp;
        }
        void Controller::set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* scoring_point)
        {
            delete scoring_point_;
            scoring_point_ = scoring_point;
            if (scoring_point) {
                set_has_scoring_point();
            } else {
                clear_has_scoring_point();
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.scoring_point)
        }

        // optional .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
        bool Controller::has_fec_controller() const
        {
            return controller_case() == kFecController;
        }
        void Controller::set_has_fec_controller()
        {
            _oneof_case_[0] = kFecController;
        }
        void Controller::clear_fec_controller()
        {
            if (has_fec_controller()) {
                delete controller_.fec_controller_;
                clear_has_controller();
            }
        }
        const ::webrtc::audio_network_adaptor::config::FecController& Controller::fec_controller() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.fec_controller)
            return has_fec_controller()
                ? *controller_.fec_controller_
                : ::webrtc::audio_network_adaptor::config::FecController::default_instance();
        }
        ::webrtc::audio_network_adaptor::config::FecController* Controller::mutable_fec_controller()
        {
            if (!has_fec_controller()) {
                clear_controller();
                set_has_fec_controller();
                controller_.fec_controller_ = new ::webrtc::audio_network_adaptor::config::FecController;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.fec_controller)
            return controller_.fec_controller_;
        }
        ::webrtc::audio_network_adaptor::config::FecController* Controller::release_fec_controller()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.fec_controller)
            if (has_fec_controller()) {
                clear_has_controller();
                ::webrtc::audio_network_adaptor::config::FecController* temp = controller_.fec_controller_;
                controller_.fec_controller_ = NULL;
                return temp;
            } else {
                return NULL;
            }
        }
        void Controller::set_allocated_fec_controller(::webrtc::audio_network_adaptor::config::FecController* fec_controller)
        {
            clear_controller();
            if (fec_controller) {
                set_has_fec_controller();
                controller_.fec_controller_ = fec_controller;
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.fec_controller)
        }

        // optional .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
        bool Controller::has_frame_length_controller() const
        {
            return controller_case() == kFrameLengthController;
        }
        void Controller::set_has_frame_length_controller()
        {
            _oneof_case_[0] = kFrameLengthController;
        }
        void Controller::clear_frame_length_controller()
        {
            if (has_frame_length_controller()) {
                delete controller_.frame_length_controller_;
                clear_has_controller();
            }
        }
        const ::webrtc::audio_network_adaptor::config::FrameLengthController& Controller::frame_length_controller() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
            return has_frame_length_controller()
                ? *controller_.frame_length_controller_
                : ::webrtc::audio_network_adaptor::config::FrameLengthController::default_instance();
        }
        ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::mutable_frame_length_controller()
        {
            if (!has_frame_length_controller()) {
                clear_controller();
                set_has_frame_length_controller();
                controller_.frame_length_controller_ = new ::webrtc::audio_network_adaptor::config::FrameLengthController;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
            return controller_.frame_length_controller_;
        }
        ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::release_frame_length_controller()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
            if (has_frame_length_controller()) {
                clear_has_controller();
                ::webrtc::audio_network_adaptor::config::FrameLengthController* temp = controller_.frame_length_controller_;
                controller_.frame_length_controller_ = NULL;
                return temp;
            } else {
                return NULL;
            }
        }
        void Controller::set_allocated_frame_length_controller(::webrtc::audio_network_adaptor::config::FrameLengthController* frame_length_controller)
        {
            clear_controller();
            if (frame_length_controller) {
                set_has_frame_length_controller();
                controller_.frame_length_controller_ = frame_length_controller;
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
        }

        // optional .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
        bool Controller::has_channel_controller() const
        {
            return controller_case() == kChannelController;
        }
        void Controller::set_has_channel_controller()
        {
            _oneof_case_[0] = kChannelController;
        }
        void Controller::clear_channel_controller()
        {
            if (has_channel_controller()) {
                delete controller_.channel_controller_;
                clear_has_controller();
            }
        }
        const ::webrtc::audio_network_adaptor::config::ChannelController& Controller::channel_controller() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.channel_controller)
            return has_channel_controller()
                ? *controller_.channel_controller_
                : ::webrtc::audio_network_adaptor::config::ChannelController::default_instance();
        }
        ::webrtc::audio_network_adaptor::config::ChannelController* Controller::mutable_channel_controller()
        {
            if (!has_channel_controller()) {
                clear_controller();
                set_has_channel_controller();
                controller_.channel_controller_ = new ::webrtc::audio_network_adaptor::config::ChannelController;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.channel_controller)
            return controller_.channel_controller_;
        }
        ::webrtc::audio_network_adaptor::config::ChannelController* Controller::release_channel_controller()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.channel_controller)
            if (has_channel_controller()) {
                clear_has_controller();
                ::webrtc::audio_network_adaptor::config::ChannelController* temp = controller_.channel_controller_;
                controller_.channel_controller_ = NULL;
                return temp;
            } else {
                return NULL;
            }
        }
        void Controller::set_allocated_channel_controller(::webrtc::audio_network_adaptor::config::ChannelController* channel_controller)
        {
            clear_controller();
            if (channel_controller) {
                set_has_channel_controller();
                controller_.channel_controller_ = channel_controller;
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.channel_controller)
        }

        // optional .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
        bool Controller::has_dtx_controller() const
        {
            return controller_case() == kDtxController;
        }
        void Controller::set_has_dtx_controller()
        {
            _oneof_case_[0] = kDtxController;
        }
        void Controller::clear_dtx_controller()
        {
            if (has_dtx_controller()) {
                delete controller_.dtx_controller_;
                clear_has_controller();
            }
        }
        const ::webrtc::audio_network_adaptor::config::DtxController& Controller::dtx_controller() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
            return has_dtx_controller()
                ? *controller_.dtx_controller_
                : ::webrtc::audio_network_adaptor::config::DtxController::default_instance();
        }
        ::webrtc::audio_network_adaptor::config::DtxController* Controller::mutable_dtx_controller()
        {
            if (!has_dtx_controller()) {
                clear_controller();
                set_has_dtx_controller();
                controller_.dtx_controller_ = new ::webrtc::audio_network_adaptor::config::DtxController;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
            return controller_.dtx_controller_;
        }
        ::webrtc::audio_network_adaptor::config::DtxController* Controller::release_dtx_controller()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
            if (has_dtx_controller()) {
                clear_has_controller();
                ::webrtc::audio_network_adaptor::config::DtxController* temp = controller_.dtx_controller_;
                controller_.dtx_controller_ = NULL;
                return temp;
            } else {
                return NULL;
            }
        }
        void Controller::set_allocated_dtx_controller(::webrtc::audio_network_adaptor::config::DtxController* dtx_controller)
        {
            clear_controller();
            if (dtx_controller) {
                set_has_dtx_controller();
                controller_.dtx_controller_ = dtx_controller;
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
        }

        // optional .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
        bool Controller::has_bitrate_controller() const
        {
            return controller_case() == kBitrateController;
        }
        void Controller::set_has_bitrate_controller()
        {
            _oneof_case_[0] = kBitrateController;
        }
        void Controller::clear_bitrate_controller()
        {
            if (has_bitrate_controller()) {
                delete controller_.bitrate_controller_;
                clear_has_controller();
            }
        }
        const ::webrtc::audio_network_adaptor::config::BitrateController& Controller::bitrate_controller() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
            return has_bitrate_controller()
                ? *controller_.bitrate_controller_
                : ::webrtc::audio_network_adaptor::config::BitrateController::default_instance();
        }
        ::webrtc::audio_network_adaptor::config::BitrateController* Controller::mutable_bitrate_controller()
        {
            if (!has_bitrate_controller()) {
                clear_controller();
                set_has_bitrate_controller();
                controller_.bitrate_controller_ = new ::webrtc::audio_network_adaptor::config::BitrateController;
            }
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
            return controller_.bitrate_controller_;
        }
        ::webrtc::audio_network_adaptor::config::BitrateController* Controller::release_bitrate_controller()
        {
            // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
            if (has_bitrate_controller()) {
                clear_has_controller();
                ::webrtc::audio_network_adaptor::config::BitrateController* temp = controller_.bitrate_controller_;
                controller_.bitrate_controller_ = NULL;
                return temp;
            } else {
                return NULL;
            }
        }
        void Controller::set_allocated_bitrate_controller(::webrtc::audio_network_adaptor::config::BitrateController* bitrate_controller)
        {
            clear_controller();
            if (bitrate_controller) {
                set_has_bitrate_controller();
                controller_.bitrate_controller_ = bitrate_controller;
            }
            // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
        }

        bool Controller::has_controller() const
        {
            return controller_case() != CONTROLLER_NOT_SET;
        }
        void Controller::clear_has_controller()
        {
            _oneof_case_[0] = CONTROLLER_NOT_SET;
        }
        Controller::ControllerCase Controller::controller_case() const
        {
            return Controller::ControllerCase(_oneof_case_[0]);
        }
#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

        // ===================================================================

        static ::std::string* MutableUnknownFieldsForControllerManager(
            ControllerManager* ptr)
        {
            return ptr->mutable_unknown_fields();
        }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
        const int ControllerManager::kControllersFieldNumber;
        const int ControllerManager::kMinReorderingTimeMsFieldNumber;
        const int ControllerManager::kMinReorderingSquaredDistanceFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

        ControllerManager::ControllerManager()
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            // @@protoc_insertion_point(constructor:webrtc.audio_network_adaptor.config.ControllerManager)
        }

        void ControllerManager::InitAsDefaultInstance()
        {
        }

        ControllerManager::ControllerManager(const ControllerManager& from)
            : ::google::protobuf::MessageLite()
            , _arena_ptr_(NULL)
        {
            SharedCtor();
            MergeFrom(from);
            // @@protoc_insertion_point(copy_constructor:webrtc.audio_network_adaptor.config.ControllerManager)
        }

        void ControllerManager::SharedCtor()
        {
            ::google::protobuf::internal::GetEmptyString();
            _cached_size_ = 0;
            _unknown_fields_.UnsafeSetDefault(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
            min_reordering_time_ms_ = 0;
            min_reordering_squared_distance_ = 0;
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
        }

        ControllerManager::~ControllerManager()
        {
            // @@protoc_insertion_point(destructor:webrtc.audio_network_adaptor.config.ControllerManager)
            SharedDtor();
        }

        void ControllerManager::SharedDtor()
        {
            _unknown_fields_.DestroyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            if (this != &default_instance()) {
#else
            if (this != default_instance_) {
#endif
            }
        }

        void ControllerManager::SetCachedSize(int size) const
        {
            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
        }
        const ControllerManager& ControllerManager::default_instance()
        {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            protobuf_AddDesc_config_2eproto();
#else
            if (default_instance_ == NULL)
                protobuf_AddDesc_config_2eproto();
#endif
            return *default_instance_;
        }

        ControllerManager* ControllerManager::default_instance_ = NULL;

        ControllerManager* ControllerManager::New(::google::protobuf::Arena* arena) const
        {
            ControllerManager* n = new ControllerManager;
            if (arena != NULL) {
                arena->Own(n);
            }
            return n;
        }

        void ControllerManager::Clear()
        {
// @@protoc_insertion_point(message_clear_start:webrtc.audio_network_adaptor.config.ControllerManager)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                       \
    _Pragma("clang diagnostic push")                                                                        \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ControllerManager, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ControllerManager*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

            ZR_(min_reordering_time_ms_, min_reordering_squared_distance_);

#undef ZR_HELPER_
#undef ZR_

            controllers_.Clear();
            ::memset(_has_bits_, 0, sizeof(_has_bits_));
            _unknown_fields_.ClearToEmptyNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        bool ControllerManager::MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input)
        {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
            ::google::protobuf::uint32 tag;
            ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
                ::google::protobuf::internal::NewPermanentCallback(
                    &MutableUnknownFieldsForControllerManager, this));
            ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
                &unknown_fields_string, false);
            // @@protoc_insertion_point(parse_start:webrtc.audio_network_adaptor.config.ControllerManager)
            for (;;) {
                ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
                tag = p.first;
                if (!p.second)
                    goto handle_unusual;
                switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
                case 1: {
                    if (tag == 10) {
                        DO_(input->IncrementRecursionDepth());
                    parse_loop_controllers:
                        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                            input, add_controllers()));
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(10))
                        goto parse_loop_controllers;
                    input->UnsafeDecrementRecursionDepth();
                    if (input->ExpectTag(16))
                        goto parse_min_reordering_time_ms;
                    break;
                }

                // optional int32 min_reordering_time_ms = 2;
                case 2: {
                    if (tag == 16) {
                    parse_min_reordering_time_ms:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                            input, &min_reordering_time_ms_)));
                        set_has_min_reordering_time_ms();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectTag(29))
                        goto parse_min_reordering_squared_distance;
                    break;
                }

                // optional float min_reordering_squared_distance = 3;
                case 3: {
                    if (tag == 29) {
                    parse_min_reordering_squared_distance:
                        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                            float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                            input, &min_reordering_squared_distance_)));
                        set_has_min_reordering_squared_distance();
                    } else {
                        goto handle_unusual;
                    }
                    if (input->ExpectAtEnd())
                        goto success;
                    break;
                }

                default: {
                handle_unusual:
                    if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                        goto success;
                    }
                    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                        input, tag, &unknown_fields_stream));
                    break;
                }
                }
            }
        success:
            // @@protoc_insertion_point(parse_success:webrtc.audio_network_adaptor.config.ControllerManager)
            return true;
        failure:
            // @@protoc_insertion_point(parse_failure:webrtc.audio_network_adaptor.config.ControllerManager)
            return false;
#undef DO_
        }

        void ControllerManager::SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const
        {
            // @@protoc_insertion_point(serialize_start:webrtc.audio_network_adaptor.config.ControllerManager)
            // repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
            for (unsigned int i = 0, n = this->controllers_size(); i < n; i++) {
                ::google::protobuf::internal::WireFormatLite::WriteMessage(
                    1, this->controllers(i), output);
            }

            // optional int32 min_reordering_time_ms = 2;
            if (has_min_reordering_time_ms()) {
                ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->min_reordering_time_ms(), output);
            }

            // optional float min_reordering_squared_distance = 3;
            if (has_min_reordering_squared_distance()) {
                ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->min_reordering_squared_distance(), output);
            }

            output->WriteRaw(unknown_fields().data(),
                static_cast<int>(unknown_fields().size()));
            // @@protoc_insertion_point(serialize_end:webrtc.audio_network_adaptor.config.ControllerManager)
        }

        int ControllerManager::ByteSize() const
        {
            // @@protoc_insertion_point(message_byte_size_start:webrtc.audio_network_adaptor.config.ControllerManager)
            int total_size = 0;

            if (_has_bits_[1 / 32] & 6u) {
                // optional int32 min_reordering_time_ms = 2;
                if (has_min_reordering_time_ms()) {
                    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->min_reordering_time_ms());
                }

                // optional float min_reordering_squared_distance = 3;
                if (has_min_reordering_squared_distance()) {
                    total_size += 1 + 4;
                }
            }
            // repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
            total_size += 1 * this->controllers_size();
            for (int i = 0; i < this->controllers_size(); i++) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                    this->controllers(i));
            }

            total_size += unknown_fields().size();

            GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
            _cached_size_ = total_size;
            GOOGLE_SAFE_CONCURRENT_WRITES_END();
            return total_size;
        }

        void ControllerManager::CheckTypeAndMergeFrom(
            const ::google::protobuf::MessageLite& from)
        {
            MergeFrom(*::google::protobuf::down_cast<const ControllerManager*>(&from));
        }

        void ControllerManager::MergeFrom(const ControllerManager& from)
        {
            // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audio_network_adaptor.config.ControllerManager)
            if (GOOGLE_PREDICT_FALSE(&from == this))
                MergeFromFail(__LINE__);
            controllers_.MergeFrom(from.controllers_);
            if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
                if (from.has_min_reordering_time_ms()) {
                    set_min_reordering_time_ms(from.min_reordering_time_ms());
                }
                if (from.has_min_reordering_squared_distance()) {
                    set_min_reordering_squared_distance(from.min_reordering_squared_distance());
                }
            }
            if (!from.unknown_fields().empty()) {
                mutable_unknown_fields()->append(from.unknown_fields());
            }
        }

        void ControllerManager::CopyFrom(const ControllerManager& from)
        {
            // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audio_network_adaptor.config.ControllerManager)
            if (&from == this)
                return;
            Clear();
            MergeFrom(from);
        }

        bool ControllerManager::IsInitialized() const
        {

            return true;
        }

        void ControllerManager::Swap(ControllerManager* other)
        {
            if (other == this)
                return;
            InternalSwap(other);
        }
        void ControllerManager::InternalSwap(ControllerManager* other)
        {
            controllers_.UnsafeArenaSwap(&other->controllers_);
            std::swap(min_reordering_time_ms_, other->min_reordering_time_ms_);
            std::swap(min_reordering_squared_distance_, other->min_reordering_squared_distance_);
            std::swap(_has_bits_[0], other->_has_bits_[0]);
            _unknown_fields_.Swap(&other->_unknown_fields_);
            std::swap(_cached_size_, other->_cached_size_);
        }

        ::std::string ControllerManager::GetTypeName() const
        {
            return "webrtc.audio_network_adaptor.config.ControllerManager";
        }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
        // ControllerManager

        // repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
        int ControllerManager::controllers_size() const
        {
            return controllers_.size();
        }
        void ControllerManager::clear_controllers()
        {
            controllers_.Clear();
        }
        const ::webrtc::audio_network_adaptor::config::Controller& ControllerManager::controllers(int index) const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
            return controllers_.Get(index);
        }
        ::webrtc::audio_network_adaptor::config::Controller* ControllerManager::mutable_controllers(int index)
        {
            // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
            return controllers_.Mutable(index);
        }
        ::webrtc::audio_network_adaptor::config::Controller* ControllerManager::add_controllers()
        {
            // @@protoc_insertion_point(field_add:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
            return controllers_.Add();
        }
        ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>*
        ControllerManager::mutable_controllers()
        {
            // @@protoc_insertion_point(field_mutable_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
            return &controllers_;
        }
        const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>&
        ControllerManager::controllers() const
        {
            // @@protoc_insertion_point(field_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
            return controllers_;
        }

        // optional int32 min_reordering_time_ms = 2;
        bool ControllerManager::has_min_reordering_time_ms() const
        {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        void ControllerManager::set_has_min_reordering_time_ms()
        {
            _has_bits_[0] |= 0x00000002u;
        }
        void ControllerManager::clear_has_min_reordering_time_ms()
        {
            _has_bits_[0] &= ~0x00000002u;
        }
        void ControllerManager::clear_min_reordering_time_ms()
        {
            min_reordering_time_ms_ = 0;
            clear_has_min_reordering_time_ms();
        }
        ::google::protobuf::int32 ControllerManager::min_reordering_time_ms() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
            return min_reordering_time_ms_;
        }
        void ControllerManager::set_min_reordering_time_ms(::google::protobuf::int32 value)
        {
            set_has_min_reordering_time_ms();
            min_reordering_time_ms_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
        }

        // optional float min_reordering_squared_distance = 3;
        bool ControllerManager::has_min_reordering_squared_distance() const
        {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        void ControllerManager::set_has_min_reordering_squared_distance()
        {
            _has_bits_[0] |= 0x00000004u;
        }
        void ControllerManager::clear_has_min_reordering_squared_distance()
        {
            _has_bits_[0] &= ~0x00000004u;
        }
        void ControllerManager::clear_min_reordering_squared_distance()
        {
            min_reordering_squared_distance_ = 0;
            clear_has_min_reordering_squared_distance();
        }
        float ControllerManager::min_reordering_squared_distance() const
        {
            // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
            return min_reordering_squared_distance_;
        }
        void ControllerManager::set_min_reordering_squared_distance(float value)
        {
            set_has_min_reordering_squared_distance();
            min_reordering_squared_distance_ = value;
            // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
        }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

        // @@protoc_insertion_point(namespace_scope)

    } // namespace config
} // namespace audio_network_adaptor
} // namespace webrtc

// @@protoc_insertion_point(global_scope)
