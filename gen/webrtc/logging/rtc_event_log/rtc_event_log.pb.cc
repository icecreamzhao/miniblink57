// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtc_event_log.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "rtc_event_log.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace webrtc {
namespace rtclog {

    void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto()
    {
        delete EventStream::default_instance_;
        delete Event::default_instance_;
        delete RtpPacket::default_instance_;
        delete RtcpPacket::default_instance_;
        delete AudioPlayoutEvent::default_instance_;
        delete BwePacketLossEvent::default_instance_;
        delete VideoReceiveConfig::default_instance_;
        delete DecoderConfig::default_instance_;
        delete RtpHeaderExtension::default_instance_;
        delete RtxConfig::default_instance_;
        delete RtxMap::default_instance_;
        delete VideoSendConfig::default_instance_;
        delete EncoderConfig::default_instance_;
        delete AudioReceiveConfig::default_instance_;
        delete AudioSendConfig::default_instance_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl()
    {
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
    void protobuf_AddDesc_rtc_5fevent_5flog_2eproto()
    {
        static bool already_here = false;
        if (already_here)
            return;
        already_here = true;
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
        EventStream::default_instance_ = new EventStream();
        Event::default_instance_ = new Event();
        RtpPacket::default_instance_ = new RtpPacket();
        RtcpPacket::default_instance_ = new RtcpPacket();
        AudioPlayoutEvent::default_instance_ = new AudioPlayoutEvent();
        BwePacketLossEvent::default_instance_ = new BwePacketLossEvent();
        VideoReceiveConfig::default_instance_ = new VideoReceiveConfig();
        DecoderConfig::default_instance_ = new DecoderConfig();
        RtpHeaderExtension::default_instance_ = new RtpHeaderExtension();
        RtxConfig::default_instance_ = new RtxConfig();
        RtxMap::default_instance_ = new RtxMap();
        VideoSendConfig::default_instance_ = new VideoSendConfig();
        EncoderConfig::default_instance_ = new EncoderConfig();
        AudioReceiveConfig::default_instance_ = new AudioReceiveConfig();
        AudioSendConfig::default_instance_ = new AudioSendConfig();
        EventStream::default_instance_->InitAsDefaultInstance();
        Event::default_instance_->InitAsDefaultInstance();
        RtpPacket::default_instance_->InitAsDefaultInstance();
        RtcpPacket::default_instance_->InitAsDefaultInstance();
        AudioPlayoutEvent::default_instance_->InitAsDefaultInstance();
        BwePacketLossEvent::default_instance_->InitAsDefaultInstance();
        VideoReceiveConfig::default_instance_->InitAsDefaultInstance();
        DecoderConfig::default_instance_->InitAsDefaultInstance();
        RtpHeaderExtension::default_instance_->InitAsDefaultInstance();
        RtxConfig::default_instance_->InitAsDefaultInstance();
        RtxMap::default_instance_->InitAsDefaultInstance();
        VideoSendConfig::default_instance_->InitAsDefaultInstance();
        EncoderConfig::default_instance_->InitAsDefaultInstance();
        AudioReceiveConfig::default_instance_->InitAsDefaultInstance();
        AudioSendConfig::default_instance_->InitAsDefaultInstance();
        ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto);
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_rtc_5fevent_5flog_2eproto_once_);
    void protobuf_AddDesc_rtc_5fevent_5flog_2eproto()
    {
        ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_rtc_5fevent_5flog_2eproto_once_,
            &protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl);
    }
#else
    // Force AddDescriptors() to be called at static initialization time.
    struct StaticDescriptorInitializer_rtc_5fevent_5flog_2eproto {
        StaticDescriptorInitializer_rtc_5fevent_5flog_2eproto()
        {
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
        }
    } static_descriptor_initializer_rtc_5fevent_5flog_2eproto_;
#endif
    bool MediaType_IsValid(int value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
            return true;
        default:
            return false;
        }
    }

    namespace {

        static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
        GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line)
        {
            GOOGLE_CHECK(false) << __FILE__ << ":" << line;
        }

    } // namespace

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForEventStream(
        EventStream* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int EventStream::kStreamFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    EventStream::EventStream()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.EventStream)
    }

    void EventStream::InitAsDefaultInstance()
    {
    }

    EventStream::EventStream(const EventStream& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.EventStream)
    }

    void EventStream::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    EventStream::~EventStream()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.EventStream)
        SharedDtor();
    }

    void EventStream::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void EventStream::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const EventStream& EventStream::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    EventStream* EventStream::default_instance_ = NULL;

    EventStream* EventStream::New(::google::protobuf::Arena* arena) const
    {
        EventStream* n = new EventStream;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void EventStream::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.EventStream)
        stream_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool EventStream::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForEventStream, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.EventStream)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .webrtc.rtclog.Event stream = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_stream:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_stream()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_stream;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.EventStream)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.EventStream)
        return false;
#undef DO_
    }

    void EventStream::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.EventStream)
        // repeated .webrtc.rtclog.Event stream = 1;
        for (unsigned int i = 0, n = this->stream_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->stream(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.EventStream)
    }

    int EventStream::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.EventStream)
        int total_size = 0;

        // repeated .webrtc.rtclog.Event stream = 1;
        total_size += 1 * this->stream_size();
        for (int i = 0; i < this->stream_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->stream(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void EventStream::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const EventStream*>(&from));
    }

    void EventStream::MergeFrom(const EventStream& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.EventStream)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        stream_.MergeFrom(from.stream_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void EventStream::CopyFrom(const EventStream& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.EventStream)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool EventStream::IsInitialized() const
    {

        return true;
    }

    void EventStream::Swap(EventStream* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void EventStream::InternalSwap(EventStream* other)
    {
        stream_.UnsafeArenaSwap(&other->stream_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string EventStream::GetTypeName() const
    {
        return "webrtc.rtclog.EventStream";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // EventStream

    // repeated .webrtc.rtclog.Event stream = 1;
    int EventStream::stream_size() const
    {
        return stream_.size();
    }
    void EventStream::clear_stream()
    {
        stream_.Clear();
    }
    const ::webrtc::rtclog::Event& EventStream::stream(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.EventStream.stream)
        return stream_.Get(index);
    }
    ::webrtc::rtclog::Event* EventStream::mutable_stream(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.EventStream.stream)
        return stream_.Mutable(index);
    }
    ::webrtc::rtclog::Event* EventStream::add_stream()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.EventStream.stream)
        return stream_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::Event>*
    EventStream::mutable_stream()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.EventStream.stream)
        return &stream_;
    }
    const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::Event>&
    EventStream::stream() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.EventStream.stream)
        return stream_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForEvent(
        Event* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool Event_EventType_IsValid(int value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const Event_EventType Event::UNKNOWN_EVENT;
    const Event_EventType Event::LOG_START;
    const Event_EventType Event::LOG_END;
    const Event_EventType Event::RTP_EVENT;
    const Event_EventType Event::RTCP_EVENT;
    const Event_EventType Event::AUDIO_PLAYOUT_EVENT;
    const Event_EventType Event::BWE_PACKET_LOSS_EVENT;
    const Event_EventType Event::BWE_PACKET_DELAY_EVENT;
    const Event_EventType Event::VIDEO_RECEIVER_CONFIG_EVENT;
    const Event_EventType Event::VIDEO_SENDER_CONFIG_EVENT;
    const Event_EventType Event::AUDIO_RECEIVER_CONFIG_EVENT;
    const Event_EventType Event::AUDIO_SENDER_CONFIG_EVENT;
    const Event_EventType Event::EventType_MIN;
    const Event_EventType Event::EventType_MAX;
    const int Event::EventType_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int Event::kTimestampUsFieldNumber;
    const int Event::kTypeFieldNumber;
    const int Event::kRtpPacketFieldNumber;
    const int Event::kRtcpPacketFieldNumber;
    const int Event::kAudioPlayoutEventFieldNumber;
    const int Event::kBwePacketLossEventFieldNumber;
    const int Event::kVideoReceiverConfigFieldNumber;
    const int Event::kVideoSenderConfigFieldNumber;
    const int Event::kAudioReceiverConfigFieldNumber;
    const int Event::kAudioSenderConfigFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    Event::Event()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.Event)
    }

    void Event::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        rtp_packet_ = const_cast<::webrtc::rtclog::RtpPacket*>(
            ::webrtc::rtclog::RtpPacket::internal_default_instance());
#else
        rtp_packet_ = const_cast<::webrtc::rtclog::RtpPacket*>(&::webrtc::rtclog::RtpPacket::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        rtcp_packet_ = const_cast<::webrtc::rtclog::RtcpPacket*>(
            ::webrtc::rtclog::RtcpPacket::internal_default_instance());
#else
        rtcp_packet_ = const_cast<::webrtc::rtclog::RtcpPacket*>(&::webrtc::rtclog::RtcpPacket::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        audio_playout_event_ = const_cast<::webrtc::rtclog::AudioPlayoutEvent*>(
            ::webrtc::rtclog::AudioPlayoutEvent::internal_default_instance());
#else
        audio_playout_event_ = const_cast<::webrtc::rtclog::AudioPlayoutEvent*>(&::webrtc::rtclog::AudioPlayoutEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        bwe_packet_loss_event_ = const_cast<::webrtc::rtclog::BwePacketLossEvent*>(
            ::webrtc::rtclog::BwePacketLossEvent::internal_default_instance());
#else
        bwe_packet_loss_event_ = const_cast<::webrtc::rtclog::BwePacketLossEvent*>(&::webrtc::rtclog::BwePacketLossEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        video_receiver_config_ = const_cast<::webrtc::rtclog::VideoReceiveConfig*>(
            ::webrtc::rtclog::VideoReceiveConfig::internal_default_instance());
#else
        video_receiver_config_ = const_cast<::webrtc::rtclog::VideoReceiveConfig*>(&::webrtc::rtclog::VideoReceiveConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        video_sender_config_ = const_cast<::webrtc::rtclog::VideoSendConfig*>(
            ::webrtc::rtclog::VideoSendConfig::internal_default_instance());
#else
        video_sender_config_ = const_cast<::webrtc::rtclog::VideoSendConfig*>(&::webrtc::rtclog::VideoSendConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        audio_receiver_config_ = const_cast<::webrtc::rtclog::AudioReceiveConfig*>(
            ::webrtc::rtclog::AudioReceiveConfig::internal_default_instance());
#else
        audio_receiver_config_ = const_cast<::webrtc::rtclog::AudioReceiveConfig*>(&::webrtc::rtclog::AudioReceiveConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        audio_sender_config_ = const_cast<::webrtc::rtclog::AudioSendConfig*>(
            ::webrtc::rtclog::AudioSendConfig::internal_default_instance());
#else
        audio_sender_config_ = const_cast<::webrtc::rtclog::AudioSendConfig*>(&::webrtc::rtclog::AudioSendConfig::default_instance());
#endif
    }

    Event::Event(const Event& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.Event)
    }

    void Event::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        timestamp_us_ = GOOGLE_LONGLONG(0);
        type_ = 0;
        rtp_packet_ = NULL;
        rtcp_packet_ = NULL;
        audio_playout_event_ = NULL;
        bwe_packet_loss_event_ = NULL;
        video_receiver_config_ = NULL;
        video_sender_config_ = NULL;
        audio_receiver_config_ = NULL;
        audio_sender_config_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    Event::~Event()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.Event)
        SharedDtor();
    }

    void Event::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete rtp_packet_;
            delete rtcp_packet_;
            delete audio_playout_event_;
            delete bwe_packet_loss_event_;
            delete video_receiver_config_;
            delete video_sender_config_;
            delete audio_receiver_config_;
            delete audio_sender_config_;
        }
    }

    void Event::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const Event& Event::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    Event* Event::default_instance_ = NULL;

    Event* Event::New(::google::protobuf::Arena* arena) const
    {
        Event* n = new Event;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void Event::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.Event)
        if (_has_bits_[0 / 32] & 255u) {
            timestamp_us_ = GOOGLE_LONGLONG(0);
            type_ = 0;
            if (has_rtp_packet()) {
                if (rtp_packet_ != NULL)
                    rtp_packet_->::webrtc::rtclog::RtpPacket::Clear();
            }
            if (has_rtcp_packet()) {
                if (rtcp_packet_ != NULL)
                    rtcp_packet_->::webrtc::rtclog::RtcpPacket::Clear();
            }
            if (has_audio_playout_event()) {
                if (audio_playout_event_ != NULL)
                    audio_playout_event_->::webrtc::rtclog::AudioPlayoutEvent::Clear();
            }
            if (has_bwe_packet_loss_event()) {
                if (bwe_packet_loss_event_ != NULL)
                    bwe_packet_loss_event_->::webrtc::rtclog::BwePacketLossEvent::Clear();
            }
            if (has_video_receiver_config()) {
                if (video_receiver_config_ != NULL)
                    video_receiver_config_->::webrtc::rtclog::VideoReceiveConfig::Clear();
            }
            if (has_video_sender_config()) {
                if (video_sender_config_ != NULL)
                    video_sender_config_->::webrtc::rtclog::VideoSendConfig::Clear();
            }
        }
        if (_has_bits_[8 / 32] & 768u) {
            if (has_audio_receiver_config()) {
                if (audio_receiver_config_ != NULL)
                    audio_receiver_config_->::webrtc::rtclog::AudioReceiveConfig::Clear();
            }
            if (has_audio_sender_config()) {
                if (audio_sender_config_ != NULL)
                    audio_sender_config_->::webrtc::rtclog::AudioSendConfig::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool Event::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForEvent, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.Event)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int64 timestamp_us = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                        input, &timestamp_us_)));
                    set_has_timestamp_us();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_type;
                break;
            }

            // optional .webrtc.rtclog.Event.EventType type = 2;
            case 2: {
                if (tag == 16) {
                parse_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::webrtc::rtclog::Event_EventType_IsValid(value)) {
                        set_type(static_cast<::webrtc::rtclog::Event_EventType>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(16);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_rtp_packet;
                break;
            }

            // optional .webrtc.rtclog.RtpPacket rtp_packet = 3;
            case 3: {
                if (tag == 26) {
                parse_rtp_packet:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_rtp_packet()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_rtcp_packet;
                break;
            }

            // optional .webrtc.rtclog.RtcpPacket rtcp_packet = 4;
            case 4: {
                if (tag == 34) {
                parse_rtcp_packet:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_rtcp_packet()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_audio_playout_event;
                break;
            }

            // optional .webrtc.rtclog.AudioPlayoutEvent audio_playout_event = 5;
            case 5: {
                if (tag == 42) {
                parse_audio_playout_event:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_audio_playout_event()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(50))
                    goto parse_bwe_packet_loss_event;
                break;
            }

            // optional .webrtc.rtclog.BwePacketLossEvent bwe_packet_loss_event = 6;
            case 6: {
                if (tag == 50) {
                parse_bwe_packet_loss_event:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_bwe_packet_loss_event()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(66))
                    goto parse_video_receiver_config;
                break;
            }

            // optional .webrtc.rtclog.VideoReceiveConfig video_receiver_config = 8;
            case 8: {
                if (tag == 66) {
                parse_video_receiver_config:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_video_receiver_config()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(74))
                    goto parse_video_sender_config;
                break;
            }

            // optional .webrtc.rtclog.VideoSendConfig video_sender_config = 9;
            case 9: {
                if (tag == 74) {
                parse_video_sender_config:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_video_sender_config()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(82))
                    goto parse_audio_receiver_config;
                break;
            }

            // optional .webrtc.rtclog.AudioReceiveConfig audio_receiver_config = 10;
            case 10: {
                if (tag == 82) {
                parse_audio_receiver_config:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_audio_receiver_config()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(90))
                    goto parse_audio_sender_config;
                break;
            }

            // optional .webrtc.rtclog.AudioSendConfig audio_sender_config = 11;
            case 11: {
                if (tag == 90) {
                parse_audio_sender_config:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_audio_sender_config()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.Event)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.Event)
        return false;
#undef DO_
    }

    void Event::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.Event)
        // optional int64 timestamp_us = 1;
        if (has_timestamp_us()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->timestamp_us(), output);
        }

        // optional .webrtc.rtclog.Event.EventType type = 2;
        if (has_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                2, this->type(), output);
        }

        // optional .webrtc.rtclog.RtpPacket rtp_packet = 3;
        if (has_rtp_packet()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->rtp_packet_, output);
        }

        // optional .webrtc.rtclog.RtcpPacket rtcp_packet = 4;
        if (has_rtcp_packet()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                4, *this->rtcp_packet_, output);
        }

        // optional .webrtc.rtclog.AudioPlayoutEvent audio_playout_event = 5;
        if (has_audio_playout_event()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, *this->audio_playout_event_, output);
        }

        // optional .webrtc.rtclog.BwePacketLossEvent bwe_packet_loss_event = 6;
        if (has_bwe_packet_loss_event()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                6, *this->bwe_packet_loss_event_, output);
        }

        // optional .webrtc.rtclog.VideoReceiveConfig video_receiver_config = 8;
        if (has_video_receiver_config()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                8, *this->video_receiver_config_, output);
        }

        // optional .webrtc.rtclog.VideoSendConfig video_sender_config = 9;
        if (has_video_sender_config()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                9, *this->video_sender_config_, output);
        }

        // optional .webrtc.rtclog.AudioReceiveConfig audio_receiver_config = 10;
        if (has_audio_receiver_config()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                10, *this->audio_receiver_config_, output);
        }

        // optional .webrtc.rtclog.AudioSendConfig audio_sender_config = 11;
        if (has_audio_sender_config()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                11, *this->audio_sender_config_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.Event)
    }

    int Event::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.Event)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 255u) {
            // optional int64 timestamp_us = 1;
            if (has_timestamp_us()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->timestamp_us());
            }

            // optional .webrtc.rtclog.Event.EventType type = 2;
            if (has_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
            }

            // optional .webrtc.rtclog.RtpPacket rtp_packet = 3;
            if (has_rtp_packet()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->rtp_packet_);
            }

            // optional .webrtc.rtclog.RtcpPacket rtcp_packet = 4;
            if (has_rtcp_packet()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->rtcp_packet_);
            }

            // optional .webrtc.rtclog.AudioPlayoutEvent audio_playout_event = 5;
            if (has_audio_playout_event()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->audio_playout_event_);
            }

            // optional .webrtc.rtclog.BwePacketLossEvent bwe_packet_loss_event = 6;
            if (has_bwe_packet_loss_event()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->bwe_packet_loss_event_);
            }

            // optional .webrtc.rtclog.VideoReceiveConfig video_receiver_config = 8;
            if (has_video_receiver_config()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->video_receiver_config_);
            }

            // optional .webrtc.rtclog.VideoSendConfig video_sender_config = 9;
            if (has_video_sender_config()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->video_sender_config_);
            }
        }
        if (_has_bits_[8 / 32] & 768u) {
            // optional .webrtc.rtclog.AudioReceiveConfig audio_receiver_config = 10;
            if (has_audio_receiver_config()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->audio_receiver_config_);
            }

            // optional .webrtc.rtclog.AudioSendConfig audio_sender_config = 11;
            if (has_audio_sender_config()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->audio_sender_config_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void Event::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const Event*>(&from));
    }

    void Event::MergeFrom(const Event& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.Event)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_timestamp_us()) {
                set_timestamp_us(from.timestamp_us());
            }
            if (from.has_type()) {
                set_type(from.type());
            }
            if (from.has_rtp_packet()) {
                mutable_rtp_packet()->::webrtc::rtclog::RtpPacket::MergeFrom(from.rtp_packet());
            }
            if (from.has_rtcp_packet()) {
                mutable_rtcp_packet()->::webrtc::rtclog::RtcpPacket::MergeFrom(from.rtcp_packet());
            }
            if (from.has_audio_playout_event()) {
                mutable_audio_playout_event()->::webrtc::rtclog::AudioPlayoutEvent::MergeFrom(from.audio_playout_event());
            }
            if (from.has_bwe_packet_loss_event()) {
                mutable_bwe_packet_loss_event()->::webrtc::rtclog::BwePacketLossEvent::MergeFrom(from.bwe_packet_loss_event());
            }
            if (from.has_video_receiver_config()) {
                mutable_video_receiver_config()->::webrtc::rtclog::VideoReceiveConfig::MergeFrom(from.video_receiver_config());
            }
            if (from.has_video_sender_config()) {
                mutable_video_sender_config()->::webrtc::rtclog::VideoSendConfig::MergeFrom(from.video_sender_config());
            }
        }
        if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
            if (from.has_audio_receiver_config()) {
                mutable_audio_receiver_config()->::webrtc::rtclog::AudioReceiveConfig::MergeFrom(from.audio_receiver_config());
            }
            if (from.has_audio_sender_config()) {
                mutable_audio_sender_config()->::webrtc::rtclog::AudioSendConfig::MergeFrom(from.audio_sender_config());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void Event::CopyFrom(const Event& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.Event)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool Event::IsInitialized() const
    {

        return true;
    }

    void Event::Swap(Event* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void Event::InternalSwap(Event* other)
    {
        std::swap(timestamp_us_, other->timestamp_us_);
        std::swap(type_, other->type_);
        std::swap(rtp_packet_, other->rtp_packet_);
        std::swap(rtcp_packet_, other->rtcp_packet_);
        std::swap(audio_playout_event_, other->audio_playout_event_);
        std::swap(bwe_packet_loss_event_, other->bwe_packet_loss_event_);
        std::swap(video_receiver_config_, other->video_receiver_config_);
        std::swap(video_sender_config_, other->video_sender_config_);
        std::swap(audio_receiver_config_, other->audio_receiver_config_);
        std::swap(audio_sender_config_, other->audio_sender_config_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string Event::GetTypeName() const
    {
        return "webrtc.rtclog.Event";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // Event

    // optional int64 timestamp_us = 1;
    bool Event::has_timestamp_us() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void Event::set_has_timestamp_us()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void Event::clear_has_timestamp_us()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void Event::clear_timestamp_us()
    {
        timestamp_us_ = GOOGLE_LONGLONG(0);
        clear_has_timestamp_us();
    }
    ::google::protobuf::int64 Event::timestamp_us() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.timestamp_us)
        return timestamp_us_;
    }
    void Event::set_timestamp_us(::google::protobuf::int64 value)
    {
        set_has_timestamp_us();
        timestamp_us_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.Event.timestamp_us)
    }

    // optional .webrtc.rtclog.Event.EventType type = 2;
    bool Event::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void Event::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void Event::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void Event::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    ::webrtc::rtclog::Event_EventType Event::type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.type)
        return static_cast<::webrtc::rtclog::Event_EventType>(type_);
    }
    void Event::set_type(::webrtc::rtclog::Event_EventType value)
    {
        assert(::webrtc::rtclog::Event_EventType_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.Event.type)
    }

    // optional .webrtc.rtclog.RtpPacket rtp_packet = 3;
    bool Event::has_rtp_packet() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void Event::set_has_rtp_packet()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void Event::clear_has_rtp_packet()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void Event::clear_rtp_packet()
    {
        if (rtp_packet_ != NULL)
            rtp_packet_->::webrtc::rtclog::RtpPacket::Clear();
        clear_has_rtp_packet();
    }
    const ::webrtc::rtclog::RtpPacket& Event::rtp_packet() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.rtp_packet)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return rtp_packet_ != NULL ? *rtp_packet_ : *default_instance().rtp_packet_;
#else
        return rtp_packet_ != NULL ? *rtp_packet_ : *default_instance_->rtp_packet_;
#endif
    }
    ::webrtc::rtclog::RtpPacket* Event::mutable_rtp_packet()
    {
        set_has_rtp_packet();
        if (rtp_packet_ == NULL) {
            rtp_packet_ = new ::webrtc::rtclog::RtpPacket;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.rtp_packet)
        return rtp_packet_;
    }
    ::webrtc::rtclog::RtpPacket* Event::release_rtp_packet()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.rtp_packet)
        clear_has_rtp_packet();
        ::webrtc::rtclog::RtpPacket* temp = rtp_packet_;
        rtp_packet_ = NULL;
        return temp;
    }
    void Event::set_allocated_rtp_packet(::webrtc::rtclog::RtpPacket* rtp_packet)
    {
        delete rtp_packet_;
        rtp_packet_ = rtp_packet;
        if (rtp_packet) {
            set_has_rtp_packet();
        } else {
            clear_has_rtp_packet();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.rtp_packet)
    }

    // optional .webrtc.rtclog.RtcpPacket rtcp_packet = 4;
    bool Event::has_rtcp_packet() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void Event::set_has_rtcp_packet()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void Event::clear_has_rtcp_packet()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void Event::clear_rtcp_packet()
    {
        if (rtcp_packet_ != NULL)
            rtcp_packet_->::webrtc::rtclog::RtcpPacket::Clear();
        clear_has_rtcp_packet();
    }
    const ::webrtc::rtclog::RtcpPacket& Event::rtcp_packet() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.rtcp_packet)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return rtcp_packet_ != NULL ? *rtcp_packet_ : *default_instance().rtcp_packet_;
#else
        return rtcp_packet_ != NULL ? *rtcp_packet_ : *default_instance_->rtcp_packet_;
#endif
    }
    ::webrtc::rtclog::RtcpPacket* Event::mutable_rtcp_packet()
    {
        set_has_rtcp_packet();
        if (rtcp_packet_ == NULL) {
            rtcp_packet_ = new ::webrtc::rtclog::RtcpPacket;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.rtcp_packet)
        return rtcp_packet_;
    }
    ::webrtc::rtclog::RtcpPacket* Event::release_rtcp_packet()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.rtcp_packet)
        clear_has_rtcp_packet();
        ::webrtc::rtclog::RtcpPacket* temp = rtcp_packet_;
        rtcp_packet_ = NULL;
        return temp;
    }
    void Event::set_allocated_rtcp_packet(::webrtc::rtclog::RtcpPacket* rtcp_packet)
    {
        delete rtcp_packet_;
        rtcp_packet_ = rtcp_packet;
        if (rtcp_packet) {
            set_has_rtcp_packet();
        } else {
            clear_has_rtcp_packet();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.rtcp_packet)
    }

    // optional .webrtc.rtclog.AudioPlayoutEvent audio_playout_event = 5;
    bool Event::has_audio_playout_event() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void Event::set_has_audio_playout_event()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void Event::clear_has_audio_playout_event()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void Event::clear_audio_playout_event()
    {
        if (audio_playout_event_ != NULL)
            audio_playout_event_->::webrtc::rtclog::AudioPlayoutEvent::Clear();
        clear_has_audio_playout_event();
    }
    const ::webrtc::rtclog::AudioPlayoutEvent& Event::audio_playout_event() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.audio_playout_event)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return audio_playout_event_ != NULL ? *audio_playout_event_ : *default_instance().audio_playout_event_;
#else
        return audio_playout_event_ != NULL ? *audio_playout_event_ : *default_instance_->audio_playout_event_;
#endif
    }
    ::webrtc::rtclog::AudioPlayoutEvent* Event::mutable_audio_playout_event()
    {
        set_has_audio_playout_event();
        if (audio_playout_event_ == NULL) {
            audio_playout_event_ = new ::webrtc::rtclog::AudioPlayoutEvent;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.audio_playout_event)
        return audio_playout_event_;
    }
    ::webrtc::rtclog::AudioPlayoutEvent* Event::release_audio_playout_event()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.audio_playout_event)
        clear_has_audio_playout_event();
        ::webrtc::rtclog::AudioPlayoutEvent* temp = audio_playout_event_;
        audio_playout_event_ = NULL;
        return temp;
    }
    void Event::set_allocated_audio_playout_event(::webrtc::rtclog::AudioPlayoutEvent* audio_playout_event)
    {
        delete audio_playout_event_;
        audio_playout_event_ = audio_playout_event;
        if (audio_playout_event) {
            set_has_audio_playout_event();
        } else {
            clear_has_audio_playout_event();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.audio_playout_event)
    }

    // optional .webrtc.rtclog.BwePacketLossEvent bwe_packet_loss_event = 6;
    bool Event::has_bwe_packet_loss_event() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void Event::set_has_bwe_packet_loss_event()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void Event::clear_has_bwe_packet_loss_event()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void Event::clear_bwe_packet_loss_event()
    {
        if (bwe_packet_loss_event_ != NULL)
            bwe_packet_loss_event_->::webrtc::rtclog::BwePacketLossEvent::Clear();
        clear_has_bwe_packet_loss_event();
    }
    const ::webrtc::rtclog::BwePacketLossEvent& Event::bwe_packet_loss_event() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.bwe_packet_loss_event)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bwe_packet_loss_event_ != NULL ? *bwe_packet_loss_event_ : *default_instance().bwe_packet_loss_event_;
#else
        return bwe_packet_loss_event_ != NULL ? *bwe_packet_loss_event_ : *default_instance_->bwe_packet_loss_event_;
#endif
    }
    ::webrtc::rtclog::BwePacketLossEvent* Event::mutable_bwe_packet_loss_event()
    {
        set_has_bwe_packet_loss_event();
        if (bwe_packet_loss_event_ == NULL) {
            bwe_packet_loss_event_ = new ::webrtc::rtclog::BwePacketLossEvent;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.bwe_packet_loss_event)
        return bwe_packet_loss_event_;
    }
    ::webrtc::rtclog::BwePacketLossEvent* Event::release_bwe_packet_loss_event()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.bwe_packet_loss_event)
        clear_has_bwe_packet_loss_event();
        ::webrtc::rtclog::BwePacketLossEvent* temp = bwe_packet_loss_event_;
        bwe_packet_loss_event_ = NULL;
        return temp;
    }
    void Event::set_allocated_bwe_packet_loss_event(::webrtc::rtclog::BwePacketLossEvent* bwe_packet_loss_event)
    {
        delete bwe_packet_loss_event_;
        bwe_packet_loss_event_ = bwe_packet_loss_event;
        if (bwe_packet_loss_event) {
            set_has_bwe_packet_loss_event();
        } else {
            clear_has_bwe_packet_loss_event();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.bwe_packet_loss_event)
    }

    // optional .webrtc.rtclog.VideoReceiveConfig video_receiver_config = 8;
    bool Event::has_video_receiver_config() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    void Event::set_has_video_receiver_config()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    void Event::clear_has_video_receiver_config()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    void Event::clear_video_receiver_config()
    {
        if (video_receiver_config_ != NULL)
            video_receiver_config_->::webrtc::rtclog::VideoReceiveConfig::Clear();
        clear_has_video_receiver_config();
    }
    const ::webrtc::rtclog::VideoReceiveConfig& Event::video_receiver_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.video_receiver_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return video_receiver_config_ != NULL ? *video_receiver_config_ : *default_instance().video_receiver_config_;
#else
        return video_receiver_config_ != NULL ? *video_receiver_config_ : *default_instance_->video_receiver_config_;
#endif
    }
    ::webrtc::rtclog::VideoReceiveConfig* Event::mutable_video_receiver_config()
    {
        set_has_video_receiver_config();
        if (video_receiver_config_ == NULL) {
            video_receiver_config_ = new ::webrtc::rtclog::VideoReceiveConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.video_receiver_config)
        return video_receiver_config_;
    }
    ::webrtc::rtclog::VideoReceiveConfig* Event::release_video_receiver_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.video_receiver_config)
        clear_has_video_receiver_config();
        ::webrtc::rtclog::VideoReceiveConfig* temp = video_receiver_config_;
        video_receiver_config_ = NULL;
        return temp;
    }
    void Event::set_allocated_video_receiver_config(::webrtc::rtclog::VideoReceiveConfig* video_receiver_config)
    {
        delete video_receiver_config_;
        video_receiver_config_ = video_receiver_config;
        if (video_receiver_config) {
            set_has_video_receiver_config();
        } else {
            clear_has_video_receiver_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.video_receiver_config)
    }

    // optional .webrtc.rtclog.VideoSendConfig video_sender_config = 9;
    bool Event::has_video_sender_config() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    void Event::set_has_video_sender_config()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    void Event::clear_has_video_sender_config()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    void Event::clear_video_sender_config()
    {
        if (video_sender_config_ != NULL)
            video_sender_config_->::webrtc::rtclog::VideoSendConfig::Clear();
        clear_has_video_sender_config();
    }
    const ::webrtc::rtclog::VideoSendConfig& Event::video_sender_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.video_sender_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return video_sender_config_ != NULL ? *video_sender_config_ : *default_instance().video_sender_config_;
#else
        return video_sender_config_ != NULL ? *video_sender_config_ : *default_instance_->video_sender_config_;
#endif
    }
    ::webrtc::rtclog::VideoSendConfig* Event::mutable_video_sender_config()
    {
        set_has_video_sender_config();
        if (video_sender_config_ == NULL) {
            video_sender_config_ = new ::webrtc::rtclog::VideoSendConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.video_sender_config)
        return video_sender_config_;
    }
    ::webrtc::rtclog::VideoSendConfig* Event::release_video_sender_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.video_sender_config)
        clear_has_video_sender_config();
        ::webrtc::rtclog::VideoSendConfig* temp = video_sender_config_;
        video_sender_config_ = NULL;
        return temp;
    }
    void Event::set_allocated_video_sender_config(::webrtc::rtclog::VideoSendConfig* video_sender_config)
    {
        delete video_sender_config_;
        video_sender_config_ = video_sender_config;
        if (video_sender_config) {
            set_has_video_sender_config();
        } else {
            clear_has_video_sender_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.video_sender_config)
    }

    // optional .webrtc.rtclog.AudioReceiveConfig audio_receiver_config = 10;
    bool Event::has_audio_receiver_config() const
    {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    void Event::set_has_audio_receiver_config()
    {
        _has_bits_[0] |= 0x00000100u;
    }
    void Event::clear_has_audio_receiver_config()
    {
        _has_bits_[0] &= ~0x00000100u;
    }
    void Event::clear_audio_receiver_config()
    {
        if (audio_receiver_config_ != NULL)
            audio_receiver_config_->::webrtc::rtclog::AudioReceiveConfig::Clear();
        clear_has_audio_receiver_config();
    }
    const ::webrtc::rtclog::AudioReceiveConfig& Event::audio_receiver_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.audio_receiver_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return audio_receiver_config_ != NULL ? *audio_receiver_config_ : *default_instance().audio_receiver_config_;
#else
        return audio_receiver_config_ != NULL ? *audio_receiver_config_ : *default_instance_->audio_receiver_config_;
#endif
    }
    ::webrtc::rtclog::AudioReceiveConfig* Event::mutable_audio_receiver_config()
    {
        set_has_audio_receiver_config();
        if (audio_receiver_config_ == NULL) {
            audio_receiver_config_ = new ::webrtc::rtclog::AudioReceiveConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.audio_receiver_config)
        return audio_receiver_config_;
    }
    ::webrtc::rtclog::AudioReceiveConfig* Event::release_audio_receiver_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.audio_receiver_config)
        clear_has_audio_receiver_config();
        ::webrtc::rtclog::AudioReceiveConfig* temp = audio_receiver_config_;
        audio_receiver_config_ = NULL;
        return temp;
    }
    void Event::set_allocated_audio_receiver_config(::webrtc::rtclog::AudioReceiveConfig* audio_receiver_config)
    {
        delete audio_receiver_config_;
        audio_receiver_config_ = audio_receiver_config;
        if (audio_receiver_config) {
            set_has_audio_receiver_config();
        } else {
            clear_has_audio_receiver_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.audio_receiver_config)
    }

    // optional .webrtc.rtclog.AudioSendConfig audio_sender_config = 11;
    bool Event::has_audio_sender_config() const
    {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    void Event::set_has_audio_sender_config()
    {
        _has_bits_[0] |= 0x00000200u;
    }
    void Event::clear_has_audio_sender_config()
    {
        _has_bits_[0] &= ~0x00000200u;
    }
    void Event::clear_audio_sender_config()
    {
        if (audio_sender_config_ != NULL)
            audio_sender_config_->::webrtc::rtclog::AudioSendConfig::Clear();
        clear_has_audio_sender_config();
    }
    const ::webrtc::rtclog::AudioSendConfig& Event::audio_sender_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.audio_sender_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return audio_sender_config_ != NULL ? *audio_sender_config_ : *default_instance().audio_sender_config_;
#else
        return audio_sender_config_ != NULL ? *audio_sender_config_ : *default_instance_->audio_sender_config_;
#endif
    }
    ::webrtc::rtclog::AudioSendConfig* Event::mutable_audio_sender_config()
    {
        set_has_audio_sender_config();
        if (audio_sender_config_ == NULL) {
            audio_sender_config_ = new ::webrtc::rtclog::AudioSendConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.audio_sender_config)
        return audio_sender_config_;
    }
    ::webrtc::rtclog::AudioSendConfig* Event::release_audio_sender_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.audio_sender_config)
        clear_has_audio_sender_config();
        ::webrtc::rtclog::AudioSendConfig* temp = audio_sender_config_;
        audio_sender_config_ = NULL;
        return temp;
    }
    void Event::set_allocated_audio_sender_config(::webrtc::rtclog::AudioSendConfig* audio_sender_config)
    {
        delete audio_sender_config_;
        audio_sender_config_ = audio_sender_config;
        if (audio_sender_config) {
            set_has_audio_sender_config();
        } else {
            clear_has_audio_sender_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.audio_sender_config)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRtpPacket(
        RtpPacket* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RtpPacket::kIncomingFieldNumber;
    const int RtpPacket::kTypeFieldNumber;
    const int RtpPacket::kPacketLengthFieldNumber;
    const int RtpPacket::kHeaderFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RtpPacket::RtpPacket()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.RtpPacket)
    }

    void RtpPacket::InitAsDefaultInstance()
    {
    }

    RtpPacket::RtpPacket(const RtpPacket& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.RtpPacket)
    }

    void RtpPacket::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        incoming_ = false;
        type_ = 0;
        packet_length_ = 0u;
        header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RtpPacket::~RtpPacket()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.RtpPacket)
        SharedDtor();
    }

    void RtpPacket::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        header_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RtpPacket::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RtpPacket& RtpPacket::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    RtpPacket* RtpPacket::default_instance_ = NULL;

    RtpPacket* RtpPacket::New(::google::protobuf::Arena* arena) const
    {
        RtpPacket* n = new RtpPacket;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RtpPacket::Clear()
    {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog.RtpPacket)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                               \
    _Pragma("clang diagnostic push")                                                                \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(RtpPacket, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<RtpPacket*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 15u) {
            ZR_(incoming_, type_);
            packet_length_ = 0u;
            if (has_header()) {
                header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RtpPacket::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRtpPacket, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.RtpPacket)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional bool incoming = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &incoming_)));
                    set_has_incoming();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_type;
                break;
            }

            // optional .webrtc.rtclog.MediaType type = 2;
            case 2: {
                if (tag == 16) {
                parse_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::webrtc::rtclog::MediaType_IsValid(value)) {
                        set_type(static_cast<::webrtc::rtclog::MediaType>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(16);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_packet_length;
                break;
            }

            // optional uint32 packet_length = 3;
            case 3: {
                if (tag == 24) {
                parse_packet_length:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &packet_length_)));
                    set_has_packet_length();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_header;
                break;
            }

            // optional bytes header = 4;
            case 4: {
                if (tag == 34) {
                parse_header:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_header()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.RtpPacket)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.RtpPacket)
        return false;
#undef DO_
    }

    void RtpPacket::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.RtpPacket)
        // optional bool incoming = 1;
        if (has_incoming()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->incoming(), output);
        }

        // optional .webrtc.rtclog.MediaType type = 2;
        if (has_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                2, this->type(), output);
        }

        // optional uint32 packet_length = 3;
        if (has_packet_length()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->packet_length(), output);
        }

        // optional bytes header = 4;
        if (has_header()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                4, this->header(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.RtpPacket)
    }

    int RtpPacket::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.RtpPacket)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 15u) {
            // optional bool incoming = 1;
            if (has_incoming()) {
                total_size += 1 + 1;
            }

            // optional .webrtc.rtclog.MediaType type = 2;
            if (has_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
            }

            // optional uint32 packet_length = 3;
            if (has_packet_length()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->packet_length());
            }

            // optional bytes header = 4;
            if (has_header()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->header());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RtpPacket::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RtpPacket*>(&from));
    }

    void RtpPacket::MergeFrom(const RtpPacket& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.RtpPacket)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_incoming()) {
                set_incoming(from.incoming());
            }
            if (from.has_type()) {
                set_type(from.type());
            }
            if (from.has_packet_length()) {
                set_packet_length(from.packet_length());
            }
            if (from.has_header()) {
                set_has_header();
                header_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.header_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RtpPacket::CopyFrom(const RtpPacket& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.RtpPacket)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RtpPacket::IsInitialized() const
    {

        return true;
    }

    void RtpPacket::Swap(RtpPacket* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RtpPacket::InternalSwap(RtpPacket* other)
    {
        std::swap(incoming_, other->incoming_);
        std::swap(type_, other->type_);
        std::swap(packet_length_, other->packet_length_);
        header_.Swap(&other->header_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RtpPacket::GetTypeName() const
    {
        return "webrtc.rtclog.RtpPacket";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RtpPacket

    // optional bool incoming = 1;
    bool RtpPacket::has_incoming() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RtpPacket::set_has_incoming()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RtpPacket::clear_has_incoming()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RtpPacket::clear_incoming()
    {
        incoming_ = false;
        clear_has_incoming();
    }
    bool RtpPacket::incoming() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.incoming)
        return incoming_;
    }
    void RtpPacket::set_incoming(bool value)
    {
        set_has_incoming();
        incoming_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.incoming)
    }

    // optional .webrtc.rtclog.MediaType type = 2;
    bool RtpPacket::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RtpPacket::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RtpPacket::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RtpPacket::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    ::webrtc::rtclog::MediaType RtpPacket::type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.type)
        return static_cast<::webrtc::rtclog::MediaType>(type_);
    }
    void RtpPacket::set_type(::webrtc::rtclog::MediaType value)
    {
        assert(::webrtc::rtclog::MediaType_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.type)
    }

    // optional uint32 packet_length = 3;
    bool RtpPacket::has_packet_length() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void RtpPacket::set_has_packet_length()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void RtpPacket::clear_has_packet_length()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void RtpPacket::clear_packet_length()
    {
        packet_length_ = 0u;
        clear_has_packet_length();
    }
    ::google::protobuf::uint32 RtpPacket::packet_length() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.packet_length)
        return packet_length_;
    }
    void RtpPacket::set_packet_length(::google::protobuf::uint32 value)
    {
        set_has_packet_length();
        packet_length_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.packet_length)
    }

    // optional bytes header = 4;
    bool RtpPacket::has_header() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void RtpPacket::set_has_header()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void RtpPacket::clear_has_header()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void RtpPacket::clear_header()
    {
        header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_header();
    }
    const ::std::string& RtpPacket::header() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.header)
        return header_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RtpPacket::set_header(const ::std::string& value)
    {
        set_has_header();
        header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.header)
    }
    void RtpPacket::set_header(const char* value)
    {
        set_has_header();
        header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.RtpPacket.header)
    }
    void RtpPacket::set_header(const void* value, size_t size)
    {
        set_has_header();
        header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.RtpPacket.header)
    }
    ::std::string* RtpPacket::mutable_header()
    {
        set_has_header();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtpPacket.header)
        return header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* RtpPacket::release_header()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtpPacket.header)
        clear_has_header();
        return header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RtpPacket::set_allocated_header(::std::string* header)
    {
        if (header != NULL) {
            set_has_header();
        } else {
            clear_has_header();
        }
        header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtpPacket.header)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRtcpPacket(
        RtcpPacket* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RtcpPacket::kIncomingFieldNumber;
    const int RtcpPacket::kTypeFieldNumber;
    const int RtcpPacket::kPacketDataFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RtcpPacket::RtcpPacket()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.RtcpPacket)
    }

    void RtcpPacket::InitAsDefaultInstance()
    {
    }

    RtcpPacket::RtcpPacket(const RtcpPacket& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.RtcpPacket)
    }

    void RtcpPacket::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        incoming_ = false;
        type_ = 0;
        packet_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RtcpPacket::~RtcpPacket()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.RtcpPacket)
        SharedDtor();
    }

    void RtcpPacket::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        packet_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RtcpPacket::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RtcpPacket& RtcpPacket::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    RtcpPacket* RtcpPacket::default_instance_ = NULL;

    RtcpPacket* RtcpPacket::New(::google::protobuf::Arena* arena) const
    {
        RtcpPacket* n = new RtcpPacket;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RtcpPacket::Clear()
    {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog.RtcpPacket)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                \
    _Pragma("clang diagnostic push")                                                                 \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(RtcpPacket, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<RtcpPacket*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 7u) {
            ZR_(incoming_, type_);
            if (has_packet_data()) {
                packet_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RtcpPacket::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRtcpPacket, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.RtcpPacket)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional bool incoming = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &incoming_)));
                    set_has_incoming();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_type;
                break;
            }

            // optional .webrtc.rtclog.MediaType type = 2;
            case 2: {
                if (tag == 16) {
                parse_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::webrtc::rtclog::MediaType_IsValid(value)) {
                        set_type(static_cast<::webrtc::rtclog::MediaType>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(16);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_packet_data;
                break;
            }

            // optional bytes packet_data = 3;
            case 3: {
                if (tag == 26) {
                parse_packet_data:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_packet_data()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.RtcpPacket)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.RtcpPacket)
        return false;
#undef DO_
    }

    void RtcpPacket::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.RtcpPacket)
        // optional bool incoming = 1;
        if (has_incoming()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->incoming(), output);
        }

        // optional .webrtc.rtclog.MediaType type = 2;
        if (has_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                2, this->type(), output);
        }

        // optional bytes packet_data = 3;
        if (has_packet_data()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                3, this->packet_data(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.RtcpPacket)
    }

    int RtcpPacket::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.RtcpPacket)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 7u) {
            // optional bool incoming = 1;
            if (has_incoming()) {
                total_size += 1 + 1;
            }

            // optional .webrtc.rtclog.MediaType type = 2;
            if (has_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
            }

            // optional bytes packet_data = 3;
            if (has_packet_data()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->packet_data());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RtcpPacket::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RtcpPacket*>(&from));
    }

    void RtcpPacket::MergeFrom(const RtcpPacket& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.RtcpPacket)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_incoming()) {
                set_incoming(from.incoming());
            }
            if (from.has_type()) {
                set_type(from.type());
            }
            if (from.has_packet_data()) {
                set_has_packet_data();
                packet_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.packet_data_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RtcpPacket::CopyFrom(const RtcpPacket& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.RtcpPacket)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RtcpPacket::IsInitialized() const
    {

        return true;
    }

    void RtcpPacket::Swap(RtcpPacket* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RtcpPacket::InternalSwap(RtcpPacket* other)
    {
        std::swap(incoming_, other->incoming_);
        std::swap(type_, other->type_);
        packet_data_.Swap(&other->packet_data_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RtcpPacket::GetTypeName() const
    {
        return "webrtc.rtclog.RtcpPacket";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RtcpPacket

    // optional bool incoming = 1;
    bool RtcpPacket::has_incoming() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RtcpPacket::set_has_incoming()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RtcpPacket::clear_has_incoming()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RtcpPacket::clear_incoming()
    {
        incoming_ = false;
        clear_has_incoming();
    }
    bool RtcpPacket::incoming() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtcpPacket.incoming)
        return incoming_;
    }
    void RtcpPacket::set_incoming(bool value)
    {
        set_has_incoming();
        incoming_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtcpPacket.incoming)
    }

    // optional .webrtc.rtclog.MediaType type = 2;
    bool RtcpPacket::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RtcpPacket::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RtcpPacket::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RtcpPacket::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    ::webrtc::rtclog::MediaType RtcpPacket::type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtcpPacket.type)
        return static_cast<::webrtc::rtclog::MediaType>(type_);
    }
    void RtcpPacket::set_type(::webrtc::rtclog::MediaType value)
    {
        assert(::webrtc::rtclog::MediaType_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtcpPacket.type)
    }

    // optional bytes packet_data = 3;
    bool RtcpPacket::has_packet_data() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void RtcpPacket::set_has_packet_data()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void RtcpPacket::clear_has_packet_data()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void RtcpPacket::clear_packet_data()
    {
        packet_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_packet_data();
    }
    const ::std::string& RtcpPacket::packet_data() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtcpPacket.packet_data)
        return packet_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RtcpPacket::set_packet_data(const ::std::string& value)
    {
        set_has_packet_data();
        packet_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtcpPacket.packet_data)
    }
    void RtcpPacket::set_packet_data(const char* value)
    {
        set_has_packet_data();
        packet_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.RtcpPacket.packet_data)
    }
    void RtcpPacket::set_packet_data(const void* value, size_t size)
    {
        set_has_packet_data();
        packet_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.RtcpPacket.packet_data)
    }
    ::std::string* RtcpPacket::mutable_packet_data()
    {
        set_has_packet_data();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtcpPacket.packet_data)
        return packet_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* RtcpPacket::release_packet_data()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtcpPacket.packet_data)
        clear_has_packet_data();
        return packet_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RtcpPacket::set_allocated_packet_data(::std::string* packet_data)
    {
        if (packet_data != NULL) {
            set_has_packet_data();
        } else {
            clear_has_packet_data();
        }
        packet_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packet_data);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtcpPacket.packet_data)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForAudioPlayoutEvent(
        AudioPlayoutEvent* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int AudioPlayoutEvent::kLocalSsrcFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    AudioPlayoutEvent::AudioPlayoutEvent()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.AudioPlayoutEvent)
    }

    void AudioPlayoutEvent::InitAsDefaultInstance()
    {
    }

    AudioPlayoutEvent::AudioPlayoutEvent(const AudioPlayoutEvent& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.AudioPlayoutEvent)
    }

    void AudioPlayoutEvent::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        local_ssrc_ = 0u;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    AudioPlayoutEvent::~AudioPlayoutEvent()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.AudioPlayoutEvent)
        SharedDtor();
    }

    void AudioPlayoutEvent::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void AudioPlayoutEvent::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const AudioPlayoutEvent& AudioPlayoutEvent::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    AudioPlayoutEvent* AudioPlayoutEvent::default_instance_ = NULL;

    AudioPlayoutEvent* AudioPlayoutEvent::New(::google::protobuf::Arena* arena) const
    {
        AudioPlayoutEvent* n = new AudioPlayoutEvent;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void AudioPlayoutEvent::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.AudioPlayoutEvent)
        local_ssrc_ = 0u;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool AudioPlayoutEvent::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForAudioPlayoutEvent, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.AudioPlayoutEvent)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional uint32 local_ssrc = 2;
            case 2: {
                if (tag == 16) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &local_ssrc_)));
                    set_has_local_ssrc();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.AudioPlayoutEvent)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.AudioPlayoutEvent)
        return false;
#undef DO_
    }

    void AudioPlayoutEvent::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.AudioPlayoutEvent)
        // optional uint32 local_ssrc = 2;
        if (has_local_ssrc()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->local_ssrc(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.AudioPlayoutEvent)
    }

    int AudioPlayoutEvent::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.AudioPlayoutEvent)
        int total_size = 0;

        // optional uint32 local_ssrc = 2;
        if (has_local_ssrc()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->local_ssrc());
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void AudioPlayoutEvent::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const AudioPlayoutEvent*>(&from));
    }

    void AudioPlayoutEvent::MergeFrom(const AudioPlayoutEvent& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.AudioPlayoutEvent)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_local_ssrc()) {
                set_local_ssrc(from.local_ssrc());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void AudioPlayoutEvent::CopyFrom(const AudioPlayoutEvent& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.AudioPlayoutEvent)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool AudioPlayoutEvent::IsInitialized() const
    {

        return true;
    }

    void AudioPlayoutEvent::Swap(AudioPlayoutEvent* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void AudioPlayoutEvent::InternalSwap(AudioPlayoutEvent* other)
    {
        std::swap(local_ssrc_, other->local_ssrc_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string AudioPlayoutEvent::GetTypeName() const
    {
        return "webrtc.rtclog.AudioPlayoutEvent";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // AudioPlayoutEvent

    // optional uint32 local_ssrc = 2;
    bool AudioPlayoutEvent::has_local_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void AudioPlayoutEvent::set_has_local_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void AudioPlayoutEvent::clear_has_local_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void AudioPlayoutEvent::clear_local_ssrc()
    {
        local_ssrc_ = 0u;
        clear_has_local_ssrc();
    }
    ::google::protobuf::uint32 AudioPlayoutEvent::local_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioPlayoutEvent.local_ssrc)
        return local_ssrc_;
    }
    void AudioPlayoutEvent::set_local_ssrc(::google::protobuf::uint32 value)
    {
        set_has_local_ssrc();
        local_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioPlayoutEvent.local_ssrc)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForBwePacketLossEvent(
        BwePacketLossEvent* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int BwePacketLossEvent::kBitrateFieldNumber;
    const int BwePacketLossEvent::kFractionLossFieldNumber;
    const int BwePacketLossEvent::kTotalPacketsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    BwePacketLossEvent::BwePacketLossEvent()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.BwePacketLossEvent)
    }

    void BwePacketLossEvent::InitAsDefaultInstance()
    {
    }

    BwePacketLossEvent::BwePacketLossEvent(const BwePacketLossEvent& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.BwePacketLossEvent)
    }

    void BwePacketLossEvent::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        bitrate_ = 0;
        fraction_loss_ = 0u;
        total_packets_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    BwePacketLossEvent::~BwePacketLossEvent()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.BwePacketLossEvent)
        SharedDtor();
    }

    void BwePacketLossEvent::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void BwePacketLossEvent::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const BwePacketLossEvent& BwePacketLossEvent::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    BwePacketLossEvent* BwePacketLossEvent::default_instance_ = NULL;

    BwePacketLossEvent* BwePacketLossEvent::New(::google::protobuf::Arena* arena) const
    {
        BwePacketLossEvent* n = new BwePacketLossEvent;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void BwePacketLossEvent::Clear()
    {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog.BwePacketLossEvent)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                        \
    _Pragma("clang diagnostic push")                                                                         \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(BwePacketLossEvent, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<BwePacketLossEvent*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        ZR_(bitrate_, total_packets_);

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool BwePacketLossEvent::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForBwePacketLossEvent, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.BwePacketLossEvent)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 bitrate = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &bitrate_)));
                    set_has_bitrate();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_fraction_loss;
                break;
            }

            // optional uint32 fraction_loss = 2;
            case 2: {
                if (tag == 16) {
                parse_fraction_loss:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &fraction_loss_)));
                    set_has_fraction_loss();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_total_packets;
                break;
            }

            // optional int32 total_packets = 3;
            case 3: {
                if (tag == 24) {
                parse_total_packets:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &total_packets_)));
                    set_has_total_packets();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.BwePacketLossEvent)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.BwePacketLossEvent)
        return false;
#undef DO_
    }

    void BwePacketLossEvent::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.BwePacketLossEvent)
        // optional int32 bitrate = 1;
        if (has_bitrate()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bitrate(), output);
        }

        // optional uint32 fraction_loss = 2;
        if (has_fraction_loss()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->fraction_loss(), output);
        }

        // optional int32 total_packets = 3;
        if (has_total_packets()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->total_packets(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.BwePacketLossEvent)
    }

    int BwePacketLossEvent::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.BwePacketLossEvent)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 7u) {
            // optional int32 bitrate = 1;
            if (has_bitrate()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->bitrate());
            }

            // optional uint32 fraction_loss = 2;
            if (has_fraction_loss()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->fraction_loss());
            }

            // optional int32 total_packets = 3;
            if (has_total_packets()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->total_packets());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void BwePacketLossEvent::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const BwePacketLossEvent*>(&from));
    }

    void BwePacketLossEvent::MergeFrom(const BwePacketLossEvent& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.BwePacketLossEvent)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_bitrate()) {
                set_bitrate(from.bitrate());
            }
            if (from.has_fraction_loss()) {
                set_fraction_loss(from.fraction_loss());
            }
            if (from.has_total_packets()) {
                set_total_packets(from.total_packets());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void BwePacketLossEvent::CopyFrom(const BwePacketLossEvent& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.BwePacketLossEvent)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool BwePacketLossEvent::IsInitialized() const
    {

        return true;
    }

    void BwePacketLossEvent::Swap(BwePacketLossEvent* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void BwePacketLossEvent::InternalSwap(BwePacketLossEvent* other)
    {
        std::swap(bitrate_, other->bitrate_);
        std::swap(fraction_loss_, other->fraction_loss_);
        std::swap(total_packets_, other->total_packets_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string BwePacketLossEvent::GetTypeName() const
    {
        return "webrtc.rtclog.BwePacketLossEvent";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // BwePacketLossEvent

    // optional int32 bitrate = 1;
    bool BwePacketLossEvent::has_bitrate() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void BwePacketLossEvent::set_has_bitrate()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void BwePacketLossEvent::clear_has_bitrate()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void BwePacketLossEvent::clear_bitrate()
    {
        bitrate_ = 0;
        clear_has_bitrate();
    }
    ::google::protobuf::int32 BwePacketLossEvent::bitrate() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.BwePacketLossEvent.bitrate)
        return bitrate_;
    }
    void BwePacketLossEvent::set_bitrate(::google::protobuf::int32 value)
    {
        set_has_bitrate();
        bitrate_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.BwePacketLossEvent.bitrate)
    }

    // optional uint32 fraction_loss = 2;
    bool BwePacketLossEvent::has_fraction_loss() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void BwePacketLossEvent::set_has_fraction_loss()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void BwePacketLossEvent::clear_has_fraction_loss()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void BwePacketLossEvent::clear_fraction_loss()
    {
        fraction_loss_ = 0u;
        clear_has_fraction_loss();
    }
    ::google::protobuf::uint32 BwePacketLossEvent::fraction_loss() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.BwePacketLossEvent.fraction_loss)
        return fraction_loss_;
    }
    void BwePacketLossEvent::set_fraction_loss(::google::protobuf::uint32 value)
    {
        set_has_fraction_loss();
        fraction_loss_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.BwePacketLossEvent.fraction_loss)
    }

    // optional int32 total_packets = 3;
    bool BwePacketLossEvent::has_total_packets() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void BwePacketLossEvent::set_has_total_packets()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void BwePacketLossEvent::clear_has_total_packets()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void BwePacketLossEvent::clear_total_packets()
    {
        total_packets_ = 0;
        clear_has_total_packets();
    }
    ::google::protobuf::int32 BwePacketLossEvent::total_packets() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.BwePacketLossEvent.total_packets)
        return total_packets_;
    }
    void BwePacketLossEvent::set_total_packets(::google::protobuf::int32 value)
    {
        set_has_total_packets();
        total_packets_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.BwePacketLossEvent.total_packets)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForVideoReceiveConfig(
        VideoReceiveConfig* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool VideoReceiveConfig_RtcpMode_IsValid(int value)
    {
        switch (value) {
        case 1:
        case 2:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const VideoReceiveConfig_RtcpMode VideoReceiveConfig::RTCP_COMPOUND;
    const VideoReceiveConfig_RtcpMode VideoReceiveConfig::RTCP_REDUCEDSIZE;
    const VideoReceiveConfig_RtcpMode VideoReceiveConfig::RtcpMode_MIN;
    const VideoReceiveConfig_RtcpMode VideoReceiveConfig::RtcpMode_MAX;
    const int VideoReceiveConfig::RtcpMode_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int VideoReceiveConfig::kRemoteSsrcFieldNumber;
    const int VideoReceiveConfig::kLocalSsrcFieldNumber;
    const int VideoReceiveConfig::kRtcpModeFieldNumber;
    const int VideoReceiveConfig::kRembFieldNumber;
    const int VideoReceiveConfig::kRtxMapFieldNumber;
    const int VideoReceiveConfig::kHeaderExtensionsFieldNumber;
    const int VideoReceiveConfig::kDecodersFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    VideoReceiveConfig::VideoReceiveConfig()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.VideoReceiveConfig)
    }

    void VideoReceiveConfig::InitAsDefaultInstance()
    {
    }

    VideoReceiveConfig::VideoReceiveConfig(const VideoReceiveConfig& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.VideoReceiveConfig)
    }

    void VideoReceiveConfig::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        remote_ssrc_ = 0u;
        local_ssrc_ = 0u;
        rtcp_mode_ = 1;
        remb_ = false;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    VideoReceiveConfig::~VideoReceiveConfig()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.VideoReceiveConfig)
        SharedDtor();
    }

    void VideoReceiveConfig::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void VideoReceiveConfig::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const VideoReceiveConfig& VideoReceiveConfig::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    VideoReceiveConfig* VideoReceiveConfig::default_instance_ = NULL;

    VideoReceiveConfig* VideoReceiveConfig::New(::google::protobuf::Arena* arena) const
    {
        VideoReceiveConfig* n = new VideoReceiveConfig;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void VideoReceiveConfig::Clear()
    {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog.VideoReceiveConfig)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                        \
    _Pragma("clang diagnostic push")                                                                         \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(VideoReceiveConfig, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<VideoReceiveConfig*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 15u) {
            ZR_(remote_ssrc_, local_ssrc_);
            rtcp_mode_ = 1;
            remb_ = false;
        }

#undef ZR_HELPER_
#undef ZR_

        rtx_map_.Clear();
        header_extensions_.Clear();
        decoders_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool VideoReceiveConfig::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForVideoReceiveConfig, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.VideoReceiveConfig)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional uint32 remote_ssrc = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &remote_ssrc_)));
                    set_has_remote_ssrc();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_local_ssrc;
                break;
            }

            // optional uint32 local_ssrc = 2;
            case 2: {
                if (tag == 16) {
                parse_local_ssrc:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &local_ssrc_)));
                    set_has_local_ssrc();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_rtcp_mode;
                break;
            }

            // optional .webrtc.rtclog.VideoReceiveConfig.RtcpMode rtcp_mode = 3;
            case 3: {
                if (tag == 24) {
                parse_rtcp_mode:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::webrtc::rtclog::VideoReceiveConfig_RtcpMode_IsValid(value)) {
                        set_rtcp_mode(static_cast<::webrtc::rtclog::VideoReceiveConfig_RtcpMode>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(24);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(32))
                    goto parse_remb;
                break;
            }

            // optional bool remb = 4;
            case 4: {
                if (tag == 32) {
                parse_remb:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &remb_)));
                    set_has_remb();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_rtx_map;
                break;
            }

            // repeated .webrtc.rtclog.RtxMap rtx_map = 5;
            case 5: {
                if (tag == 42) {
                parse_rtx_map:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_rtx_map:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_rtx_map()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_loop_rtx_map;
                if (input->ExpectTag(50))
                    goto parse_loop_header_extensions;
                input->UnsafeDecrementRecursionDepth();
                break;
            }

            // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 6;
            case 6: {
                if (tag == 50) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_header_extensions:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_header_extensions()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(50))
                    goto parse_loop_header_extensions;
                if (input->ExpectTag(58))
                    goto parse_loop_decoders;
                input->UnsafeDecrementRecursionDepth();
                break;
            }

            // repeated .webrtc.rtclog.DecoderConfig decoders = 7;
            case 7: {
                if (tag == 58) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_decoders:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_decoders()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(58))
                    goto parse_loop_decoders;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.VideoReceiveConfig)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.VideoReceiveConfig)
        return false;
#undef DO_
    }

    void VideoReceiveConfig::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.VideoReceiveConfig)
        // optional uint32 remote_ssrc = 1;
        if (has_remote_ssrc()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->remote_ssrc(), output);
        }

        // optional uint32 local_ssrc = 2;
        if (has_local_ssrc()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->local_ssrc(), output);
        }

        // optional .webrtc.rtclog.VideoReceiveConfig.RtcpMode rtcp_mode = 3;
        if (has_rtcp_mode()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                3, this->rtcp_mode(), output);
        }

        // optional bool remb = 4;
        if (has_remb()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->remb(), output);
        }

        // repeated .webrtc.rtclog.RtxMap rtx_map = 5;
        for (unsigned int i = 0, n = this->rtx_map_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, this->rtx_map(i), output);
        }

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 6;
        for (unsigned int i = 0, n = this->header_extensions_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                6, this->header_extensions(i), output);
        }

        // repeated .webrtc.rtclog.DecoderConfig decoders = 7;
        for (unsigned int i = 0, n = this->decoders_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                7, this->decoders(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.VideoReceiveConfig)
    }

    int VideoReceiveConfig::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.VideoReceiveConfig)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 15u) {
            // optional uint32 remote_ssrc = 1;
            if (has_remote_ssrc()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->remote_ssrc());
            }

            // optional uint32 local_ssrc = 2;
            if (has_local_ssrc()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->local_ssrc());
            }

            // optional .webrtc.rtclog.VideoReceiveConfig.RtcpMode rtcp_mode = 3;
            if (has_rtcp_mode()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->rtcp_mode());
            }

            // optional bool remb = 4;
            if (has_remb()) {
                total_size += 1 + 1;
            }
        }
        // repeated .webrtc.rtclog.RtxMap rtx_map = 5;
        total_size += 1 * this->rtx_map_size();
        for (int i = 0; i < this->rtx_map_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->rtx_map(i));
        }

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 6;
        total_size += 1 * this->header_extensions_size();
        for (int i = 0; i < this->header_extensions_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->header_extensions(i));
        }

        // repeated .webrtc.rtclog.DecoderConfig decoders = 7;
        total_size += 1 * this->decoders_size();
        for (int i = 0; i < this->decoders_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->decoders(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void VideoReceiveConfig::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const VideoReceiveConfig*>(&from));
    }

    void VideoReceiveConfig::MergeFrom(const VideoReceiveConfig& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.VideoReceiveConfig)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        rtx_map_.MergeFrom(from.rtx_map_);
        header_extensions_.MergeFrom(from.header_extensions_);
        decoders_.MergeFrom(from.decoders_);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_remote_ssrc()) {
                set_remote_ssrc(from.remote_ssrc());
            }
            if (from.has_local_ssrc()) {
                set_local_ssrc(from.local_ssrc());
            }
            if (from.has_rtcp_mode()) {
                set_rtcp_mode(from.rtcp_mode());
            }
            if (from.has_remb()) {
                set_remb(from.remb());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void VideoReceiveConfig::CopyFrom(const VideoReceiveConfig& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.VideoReceiveConfig)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool VideoReceiveConfig::IsInitialized() const
    {

        return true;
    }

    void VideoReceiveConfig::Swap(VideoReceiveConfig* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void VideoReceiveConfig::InternalSwap(VideoReceiveConfig* other)
    {
        std::swap(remote_ssrc_, other->remote_ssrc_);
        std::swap(local_ssrc_, other->local_ssrc_);
        std::swap(rtcp_mode_, other->rtcp_mode_);
        std::swap(remb_, other->remb_);
        rtx_map_.UnsafeArenaSwap(&other->rtx_map_);
        header_extensions_.UnsafeArenaSwap(&other->header_extensions_);
        decoders_.UnsafeArenaSwap(&other->decoders_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string VideoReceiveConfig::GetTypeName() const
    {
        return "webrtc.rtclog.VideoReceiveConfig";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // VideoReceiveConfig

    // optional uint32 remote_ssrc = 1;
    bool VideoReceiveConfig::has_remote_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void VideoReceiveConfig::set_has_remote_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void VideoReceiveConfig::clear_has_remote_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void VideoReceiveConfig::clear_remote_ssrc()
    {
        remote_ssrc_ = 0u;
        clear_has_remote_ssrc();
    }
    ::google::protobuf::uint32 VideoReceiveConfig::remote_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.remote_ssrc)
        return remote_ssrc_;
    }
    void VideoReceiveConfig::set_remote_ssrc(::google::protobuf::uint32 value)
    {
        set_has_remote_ssrc();
        remote_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.remote_ssrc)
    }

    // optional uint32 local_ssrc = 2;
    bool VideoReceiveConfig::has_local_ssrc() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void VideoReceiveConfig::set_has_local_ssrc()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void VideoReceiveConfig::clear_has_local_ssrc()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void VideoReceiveConfig::clear_local_ssrc()
    {
        local_ssrc_ = 0u;
        clear_has_local_ssrc();
    }
    ::google::protobuf::uint32 VideoReceiveConfig::local_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.local_ssrc)
        return local_ssrc_;
    }
    void VideoReceiveConfig::set_local_ssrc(::google::protobuf::uint32 value)
    {
        set_has_local_ssrc();
        local_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.local_ssrc)
    }

    // optional .webrtc.rtclog.VideoReceiveConfig.RtcpMode rtcp_mode = 3;
    bool VideoReceiveConfig::has_rtcp_mode() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void VideoReceiveConfig::set_has_rtcp_mode()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void VideoReceiveConfig::clear_has_rtcp_mode()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void VideoReceiveConfig::clear_rtcp_mode()
    {
        rtcp_mode_ = 1;
        clear_has_rtcp_mode();
    }
    ::webrtc::rtclog::VideoReceiveConfig_RtcpMode VideoReceiveConfig::rtcp_mode() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.rtcp_mode)
        return static_cast<::webrtc::rtclog::VideoReceiveConfig_RtcpMode>(rtcp_mode_);
    }
    void VideoReceiveConfig::set_rtcp_mode(::webrtc::rtclog::VideoReceiveConfig_RtcpMode value)
    {
        assert(::webrtc::rtclog::VideoReceiveConfig_RtcpMode_IsValid(value));
        set_has_rtcp_mode();
        rtcp_mode_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.rtcp_mode)
    }

    // optional bool remb = 4;
    bool VideoReceiveConfig::has_remb() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void VideoReceiveConfig::set_has_remb()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void VideoReceiveConfig::clear_has_remb()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void VideoReceiveConfig::clear_remb()
    {
        remb_ = false;
        clear_has_remb();
    }
    bool VideoReceiveConfig::remb() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.remb)
        return remb_;
    }
    void VideoReceiveConfig::set_remb(bool value)
    {
        set_has_remb();
        remb_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.remb)
    }

    // repeated .webrtc.rtclog.RtxMap rtx_map = 5;
    int VideoReceiveConfig::rtx_map_size() const
    {
        return rtx_map_.size();
    }
    void VideoReceiveConfig::clear_rtx_map()
    {
        rtx_map_.Clear();
    }
    const ::webrtc::rtclog::RtxMap& VideoReceiveConfig::rtx_map(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_.Get(index);
    }
    ::webrtc::rtclog::RtxMap* VideoReceiveConfig::mutable_rtx_map(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_.Mutable(index);
    }
    ::webrtc::rtclog::RtxMap* VideoReceiveConfig::add_rtx_map()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtxMap>*
    VideoReceiveConfig::mutable_rtx_map()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return &rtx_map_;
    }
    const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtxMap>&
    VideoReceiveConfig::rtx_map() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_;
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 6;
    int VideoReceiveConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    void VideoReceiveConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    const ::webrtc::rtclog::RtpHeaderExtension& VideoReceiveConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* VideoReceiveConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* VideoReceiveConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    VideoReceiveConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return &header_extensions_;
    }
    const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    VideoReceiveConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_;
    }

    // repeated .webrtc.rtclog.DecoderConfig decoders = 7;
    int VideoReceiveConfig::decoders_size() const
    {
        return decoders_.size();
    }
    void VideoReceiveConfig::clear_decoders()
    {
        decoders_.Clear();
    }
    const ::webrtc::rtclog::DecoderConfig& VideoReceiveConfig::decoders(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_.Get(index);
    }
    ::webrtc::rtclog::DecoderConfig* VideoReceiveConfig::mutable_decoders(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_.Mutable(index);
    }
    ::webrtc::rtclog::DecoderConfig* VideoReceiveConfig::add_decoders()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::DecoderConfig>*
    VideoReceiveConfig::mutable_decoders()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoReceiveConfig.decoders)
        return &decoders_;
    }
    const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::DecoderConfig>&
    VideoReceiveConfig::decoders() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForDecoderConfig(
        DecoderConfig* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int DecoderConfig::kNameFieldNumber;
    const int DecoderConfig::kPayloadTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    DecoderConfig::DecoderConfig()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.DecoderConfig)
    }

    void DecoderConfig::InitAsDefaultInstance()
    {
    }

    DecoderConfig::DecoderConfig(const DecoderConfig& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.DecoderConfig)
    }

    void DecoderConfig::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        payload_type_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    DecoderConfig::~DecoderConfig()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.DecoderConfig)
        SharedDtor();
    }

    void DecoderConfig::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void DecoderConfig::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const DecoderConfig& DecoderConfig::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    DecoderConfig* DecoderConfig::default_instance_ = NULL;

    DecoderConfig* DecoderConfig::New(::google::protobuf::Arena* arena) const
    {
        DecoderConfig* n = new DecoderConfig;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void DecoderConfig::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.DecoderConfig)
        if (_has_bits_[0 / 32] & 3u) {
            if (has_name()) {
                name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            payload_type_ = 0;
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool DecoderConfig::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForDecoderConfig, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.DecoderConfig)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional string name = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_name()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_payload_type;
                break;
            }

            // optional int32 payload_type = 2;
            case 2: {
                if (tag == 16) {
                parse_payload_type:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &payload_type_)));
                    set_has_payload_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.DecoderConfig)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.DecoderConfig)
        return false;
#undef DO_
    }

    void DecoderConfig::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.DecoderConfig)
        // optional string name = 1;
        if (has_name()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                1, this->name(), output);
        }

        // optional int32 payload_type = 2;
        if (has_payload_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->payload_type(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.DecoderConfig)
    }

    int DecoderConfig::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.DecoderConfig)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional string name = 1;
            if (has_name()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->name());
            }

            // optional int32 payload_type = 2;
            if (has_payload_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->payload_type());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void DecoderConfig::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const DecoderConfig*>(&from));
    }

    void DecoderConfig::MergeFrom(const DecoderConfig& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.DecoderConfig)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_name()) {
                set_has_name();
                name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
            }
            if (from.has_payload_type()) {
                set_payload_type(from.payload_type());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void DecoderConfig::CopyFrom(const DecoderConfig& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.DecoderConfig)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool DecoderConfig::IsInitialized() const
    {

        return true;
    }

    void DecoderConfig::Swap(DecoderConfig* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void DecoderConfig::InternalSwap(DecoderConfig* other)
    {
        name_.Swap(&other->name_);
        std::swap(payload_type_, other->payload_type_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string DecoderConfig::GetTypeName() const
    {
        return "webrtc.rtclog.DecoderConfig";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // DecoderConfig

    // optional string name = 1;
    bool DecoderConfig::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void DecoderConfig::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void DecoderConfig::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void DecoderConfig::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    const ::std::string& DecoderConfig::name() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.DecoderConfig.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void DecoderConfig::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.DecoderConfig.name)
    }
    void DecoderConfig::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.DecoderConfig.name)
    }
    void DecoderConfig::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.DecoderConfig.name)
    }
    ::std::string* DecoderConfig::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.DecoderConfig.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* DecoderConfig::release_name()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.DecoderConfig.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void DecoderConfig::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.DecoderConfig.name)
    }

    // optional int32 payload_type = 2;
    bool DecoderConfig::has_payload_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void DecoderConfig::set_has_payload_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void DecoderConfig::clear_has_payload_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void DecoderConfig::clear_payload_type()
    {
        payload_type_ = 0;
        clear_has_payload_type();
    }
    ::google::protobuf::int32 DecoderConfig::payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.DecoderConfig.payload_type)
        return payload_type_;
    }
    void DecoderConfig::set_payload_type(::google::protobuf::int32 value)
    {
        set_has_payload_type();
        payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.DecoderConfig.payload_type)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRtpHeaderExtension(
        RtpHeaderExtension* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RtpHeaderExtension::kNameFieldNumber;
    const int RtpHeaderExtension::kIdFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RtpHeaderExtension::RtpHeaderExtension()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.RtpHeaderExtension)
    }

    void RtpHeaderExtension::InitAsDefaultInstance()
    {
    }

    RtpHeaderExtension::RtpHeaderExtension(const RtpHeaderExtension& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.RtpHeaderExtension)
    }

    void RtpHeaderExtension::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        id_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RtpHeaderExtension::~RtpHeaderExtension()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.RtpHeaderExtension)
        SharedDtor();
    }

    void RtpHeaderExtension::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RtpHeaderExtension::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RtpHeaderExtension& RtpHeaderExtension::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    RtpHeaderExtension* RtpHeaderExtension::default_instance_ = NULL;

    RtpHeaderExtension* RtpHeaderExtension::New(::google::protobuf::Arena* arena) const
    {
        RtpHeaderExtension* n = new RtpHeaderExtension;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RtpHeaderExtension::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.RtpHeaderExtension)
        if (_has_bits_[0 / 32] & 3u) {
            if (has_name()) {
                name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            id_ = 0;
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RtpHeaderExtension::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRtpHeaderExtension, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.RtpHeaderExtension)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional string name = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_name()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_id;
                break;
            }

            // optional int32 id = 2;
            case 2: {
                if (tag == 16) {
                parse_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &id_)));
                    set_has_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.RtpHeaderExtension)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.RtpHeaderExtension)
        return false;
#undef DO_
    }

    void RtpHeaderExtension::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.RtpHeaderExtension)
        // optional string name = 1;
        if (has_name()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                1, this->name(), output);
        }

        // optional int32 id = 2;
        if (has_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.RtpHeaderExtension)
    }

    int RtpHeaderExtension::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.RtpHeaderExtension)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional string name = 1;
            if (has_name()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->name());
            }

            // optional int32 id = 2;
            if (has_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->id());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RtpHeaderExtension::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RtpHeaderExtension*>(&from));
    }

    void RtpHeaderExtension::MergeFrom(const RtpHeaderExtension& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.RtpHeaderExtension)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_name()) {
                set_has_name();
                name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
            }
            if (from.has_id()) {
                set_id(from.id());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RtpHeaderExtension::CopyFrom(const RtpHeaderExtension& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.RtpHeaderExtension)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RtpHeaderExtension::IsInitialized() const
    {

        return true;
    }

    void RtpHeaderExtension::Swap(RtpHeaderExtension* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RtpHeaderExtension::InternalSwap(RtpHeaderExtension* other)
    {
        name_.Swap(&other->name_);
        std::swap(id_, other->id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RtpHeaderExtension::GetTypeName() const
    {
        return "webrtc.rtclog.RtpHeaderExtension";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RtpHeaderExtension

    // optional string name = 1;
    bool RtpHeaderExtension::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RtpHeaderExtension::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RtpHeaderExtension::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RtpHeaderExtension::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    const ::std::string& RtpHeaderExtension::name() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpHeaderExtension.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RtpHeaderExtension::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpHeaderExtension.name)
    }
    void RtpHeaderExtension::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.RtpHeaderExtension.name)
    }
    void RtpHeaderExtension::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.RtpHeaderExtension.name)
    }
    ::std::string* RtpHeaderExtension::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtpHeaderExtension.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* RtpHeaderExtension::release_name()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtpHeaderExtension.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RtpHeaderExtension::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtpHeaderExtension.name)
    }

    // optional int32 id = 2;
    bool RtpHeaderExtension::has_id() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RtpHeaderExtension::set_has_id()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RtpHeaderExtension::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RtpHeaderExtension::clear_id()
    {
        id_ = 0;
        clear_has_id();
    }
    ::google::protobuf::int32 RtpHeaderExtension::id() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpHeaderExtension.id)
        return id_;
    }
    void RtpHeaderExtension::set_id(::google::protobuf::int32 value)
    {
        set_has_id();
        id_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpHeaderExtension.id)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRtxConfig(
        RtxConfig* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RtxConfig::kRtxSsrcFieldNumber;
    const int RtxConfig::kRtxPayloadTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RtxConfig::RtxConfig()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.RtxConfig)
    }

    void RtxConfig::InitAsDefaultInstance()
    {
    }

    RtxConfig::RtxConfig(const RtxConfig& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.RtxConfig)
    }

    void RtxConfig::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        rtx_ssrc_ = 0u;
        rtx_payload_type_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RtxConfig::~RtxConfig()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.RtxConfig)
        SharedDtor();
    }

    void RtxConfig::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RtxConfig::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RtxConfig& RtxConfig::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    RtxConfig* RtxConfig::default_instance_ = NULL;

    RtxConfig* RtxConfig::New(::google::protobuf::Arena* arena) const
    {
        RtxConfig* n = new RtxConfig;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RtxConfig::Clear()
    {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog.RtxConfig)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                               \
    _Pragma("clang diagnostic push")                                                                \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(RtxConfig, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<RtxConfig*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        ZR_(rtx_ssrc_, rtx_payload_type_);

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RtxConfig::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRtxConfig, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.RtxConfig)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional uint32 rtx_ssrc = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &rtx_ssrc_)));
                    set_has_rtx_ssrc();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_rtx_payload_type;
                break;
            }

            // optional int32 rtx_payload_type = 2;
            case 2: {
                if (tag == 16) {
                parse_rtx_payload_type:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &rtx_payload_type_)));
                    set_has_rtx_payload_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.RtxConfig)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.RtxConfig)
        return false;
#undef DO_
    }

    void RtxConfig::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.RtxConfig)
        // optional uint32 rtx_ssrc = 1;
        if (has_rtx_ssrc()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rtx_ssrc(), output);
        }

        // optional int32 rtx_payload_type = 2;
        if (has_rtx_payload_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rtx_payload_type(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.RtxConfig)
    }

    int RtxConfig::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.RtxConfig)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional uint32 rtx_ssrc = 1;
            if (has_rtx_ssrc()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->rtx_ssrc());
            }

            // optional int32 rtx_payload_type = 2;
            if (has_rtx_payload_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->rtx_payload_type());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RtxConfig::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RtxConfig*>(&from));
    }

    void RtxConfig::MergeFrom(const RtxConfig& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.RtxConfig)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_rtx_ssrc()) {
                set_rtx_ssrc(from.rtx_ssrc());
            }
            if (from.has_rtx_payload_type()) {
                set_rtx_payload_type(from.rtx_payload_type());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RtxConfig::CopyFrom(const RtxConfig& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.RtxConfig)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RtxConfig::IsInitialized() const
    {

        return true;
    }

    void RtxConfig::Swap(RtxConfig* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RtxConfig::InternalSwap(RtxConfig* other)
    {
        std::swap(rtx_ssrc_, other->rtx_ssrc_);
        std::swap(rtx_payload_type_, other->rtx_payload_type_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RtxConfig::GetTypeName() const
    {
        return "webrtc.rtclog.RtxConfig";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RtxConfig

    // optional uint32 rtx_ssrc = 1;
    bool RtxConfig::has_rtx_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RtxConfig::set_has_rtx_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RtxConfig::clear_has_rtx_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RtxConfig::clear_rtx_ssrc()
    {
        rtx_ssrc_ = 0u;
        clear_has_rtx_ssrc();
    }
    ::google::protobuf::uint32 RtxConfig::rtx_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxConfig.rtx_ssrc)
        return rtx_ssrc_;
    }
    void RtxConfig::set_rtx_ssrc(::google::protobuf::uint32 value)
    {
        set_has_rtx_ssrc();
        rtx_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtxConfig.rtx_ssrc)
    }

    // optional int32 rtx_payload_type = 2;
    bool RtxConfig::has_rtx_payload_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RtxConfig::set_has_rtx_payload_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RtxConfig::clear_has_rtx_payload_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RtxConfig::clear_rtx_payload_type()
    {
        rtx_payload_type_ = 0;
        clear_has_rtx_payload_type();
    }
    ::google::protobuf::int32 RtxConfig::rtx_payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxConfig.rtx_payload_type)
        return rtx_payload_type_;
    }
    void RtxConfig::set_rtx_payload_type(::google::protobuf::int32 value)
    {
        set_has_rtx_payload_type();
        rtx_payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtxConfig.rtx_payload_type)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRtxMap(
        RtxMap* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RtxMap::kPayloadTypeFieldNumber;
    const int RtxMap::kConfigFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RtxMap::RtxMap()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.RtxMap)
    }

    void RtxMap::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        config_ = const_cast<::webrtc::rtclog::RtxConfig*>(
            ::webrtc::rtclog::RtxConfig::internal_default_instance());
#else
        config_ = const_cast<::webrtc::rtclog::RtxConfig*>(&::webrtc::rtclog::RtxConfig::default_instance());
#endif
    }

    RtxMap::RtxMap(const RtxMap& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.RtxMap)
    }

    void RtxMap::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        payload_type_ = 0;
        config_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RtxMap::~RtxMap()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.RtxMap)
        SharedDtor();
    }

    void RtxMap::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete config_;
        }
    }

    void RtxMap::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RtxMap& RtxMap::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    RtxMap* RtxMap::default_instance_ = NULL;

    RtxMap* RtxMap::New(::google::protobuf::Arena* arena) const
    {
        RtxMap* n = new RtxMap;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RtxMap::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.RtxMap)
        if (_has_bits_[0 / 32] & 3u) {
            payload_type_ = 0;
            if (has_config()) {
                if (config_ != NULL)
                    config_->::webrtc::rtclog::RtxConfig::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RtxMap::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRtxMap, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.RtxMap)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 payload_type = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &payload_type_)));
                    set_has_payload_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_config;
                break;
            }

            // optional .webrtc.rtclog.RtxConfig config = 2;
            case 2: {
                if (tag == 18) {
                parse_config:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_config()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.RtxMap)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.RtxMap)
        return false;
#undef DO_
    }

    void RtxMap::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.RtxMap)
        // optional int32 payload_type = 1;
        if (has_payload_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->payload_type(), output);
        }

        // optional .webrtc.rtclog.RtxConfig config = 2;
        if (has_config()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, *this->config_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.RtxMap)
    }

    int RtxMap::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.RtxMap)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional int32 payload_type = 1;
            if (has_payload_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->payload_type());
            }

            // optional .webrtc.rtclog.RtxConfig config = 2;
            if (has_config()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->config_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RtxMap::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RtxMap*>(&from));
    }

    void RtxMap::MergeFrom(const RtxMap& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.RtxMap)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_payload_type()) {
                set_payload_type(from.payload_type());
            }
            if (from.has_config()) {
                mutable_config()->::webrtc::rtclog::RtxConfig::MergeFrom(from.config());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RtxMap::CopyFrom(const RtxMap& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.RtxMap)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RtxMap::IsInitialized() const
    {

        return true;
    }

    void RtxMap::Swap(RtxMap* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RtxMap::InternalSwap(RtxMap* other)
    {
        std::swap(payload_type_, other->payload_type_);
        std::swap(config_, other->config_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RtxMap::GetTypeName() const
    {
        return "webrtc.rtclog.RtxMap";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RtxMap

    // optional int32 payload_type = 1;
    bool RtxMap::has_payload_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RtxMap::set_has_payload_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RtxMap::clear_has_payload_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RtxMap::clear_payload_type()
    {
        payload_type_ = 0;
        clear_has_payload_type();
    }
    ::google::protobuf::int32 RtxMap::payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxMap.payload_type)
        return payload_type_;
    }
    void RtxMap::set_payload_type(::google::protobuf::int32 value)
    {
        set_has_payload_type();
        payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtxMap.payload_type)
    }

    // optional .webrtc.rtclog.RtxConfig config = 2;
    bool RtxMap::has_config() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RtxMap::set_has_config()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RtxMap::clear_has_config()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RtxMap::clear_config()
    {
        if (config_ != NULL)
            config_->::webrtc::rtclog::RtxConfig::Clear();
        clear_has_config();
    }
    const ::webrtc::rtclog::RtxConfig& RtxMap::config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxMap.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return config_ != NULL ? *config_ : *default_instance().config_;
#else
        return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
    }
    ::webrtc::rtclog::RtxConfig* RtxMap::mutable_config()
    {
        set_has_config();
        if (config_ == NULL) {
            config_ = new ::webrtc::rtclog::RtxConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtxMap.config)
        return config_;
    }
    ::webrtc::rtclog::RtxConfig* RtxMap::release_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtxMap.config)
        clear_has_config();
        ::webrtc::rtclog::RtxConfig* temp = config_;
        config_ = NULL;
        return temp;
    }
    void RtxMap::set_allocated_config(::webrtc::rtclog::RtxConfig* config)
    {
        delete config_;
        config_ = config;
        if (config) {
            set_has_config();
        } else {
            clear_has_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtxMap.config)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForVideoSendConfig(
        VideoSendConfig* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int VideoSendConfig::kSsrcsFieldNumber;
    const int VideoSendConfig::kHeaderExtensionsFieldNumber;
    const int VideoSendConfig::kRtxSsrcsFieldNumber;
    const int VideoSendConfig::kRtxPayloadTypeFieldNumber;
    const int VideoSendConfig::kEncoderFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    VideoSendConfig::VideoSendConfig()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.VideoSendConfig)
    }

    void VideoSendConfig::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        encoder_ = const_cast<::webrtc::rtclog::EncoderConfig*>(
            ::webrtc::rtclog::EncoderConfig::internal_default_instance());
#else
        encoder_ = const_cast<::webrtc::rtclog::EncoderConfig*>(&::webrtc::rtclog::EncoderConfig::default_instance());
#endif
    }

    VideoSendConfig::VideoSendConfig(const VideoSendConfig& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.VideoSendConfig)
    }

    void VideoSendConfig::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        rtx_payload_type_ = 0;
        encoder_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    VideoSendConfig::~VideoSendConfig()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.VideoSendConfig)
        SharedDtor();
    }

    void VideoSendConfig::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete encoder_;
        }
    }

    void VideoSendConfig::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const VideoSendConfig& VideoSendConfig::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    VideoSendConfig* VideoSendConfig::default_instance_ = NULL;

    VideoSendConfig* VideoSendConfig::New(::google::protobuf::Arena* arena) const
    {
        VideoSendConfig* n = new VideoSendConfig;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void VideoSendConfig::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.VideoSendConfig)
        if (_has_bits_[0 / 32] & 24u) {
            rtx_payload_type_ = 0;
            if (has_encoder()) {
                if (encoder_ != NULL)
                    encoder_->::webrtc::rtclog::EncoderConfig::Clear();
            }
        }
        ssrcs_.Clear();
        header_extensions_.Clear();
        rtx_ssrcs_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool VideoSendConfig::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForVideoSendConfig, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.VideoSendConfig)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated uint32 ssrcs = 1;
            case 1: {
                if (tag == 8) {
                parse_ssrcs:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        1, 8, input, this->mutable_ssrcs())));
                } else if (tag == 10) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, this->mutable_ssrcs())));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8))
                    goto parse_ssrcs;
                if (input->ExpectTag(18))
                    goto parse_header_extensions;
                break;
            }

            // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
            case 2: {
                if (tag == 18) {
                parse_header_extensions:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_header_extensions:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_header_extensions()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_loop_header_extensions;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectTag(24))
                    goto parse_rtx_ssrcs;
                break;
            }

            // repeated uint32 rtx_ssrcs = 3;
            case 3: {
                if (tag == 24) {
                parse_rtx_ssrcs:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        1, 24, input, this->mutable_rtx_ssrcs())));
                } else if (tag == 26) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, this->mutable_rtx_ssrcs())));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_rtx_ssrcs;
                if (input->ExpectTag(32))
                    goto parse_rtx_payload_type;
                break;
            }

            // optional int32 rtx_payload_type = 4;
            case 4: {
                if (tag == 32) {
                parse_rtx_payload_type:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &rtx_payload_type_)));
                    set_has_rtx_payload_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_encoder;
                break;
            }

            // optional .webrtc.rtclog.EncoderConfig encoder = 5;
            case 5: {
                if (tag == 42) {
                parse_encoder:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_encoder()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.VideoSendConfig)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.VideoSendConfig)
        return false;
#undef DO_
    }

    void VideoSendConfig::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.VideoSendConfig)
        // repeated uint32 ssrcs = 1;
        for (int i = 0; i < this->ssrcs_size(); i++) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(
                1, this->ssrcs(i), output);
        }

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
        for (unsigned int i = 0, n = this->header_extensions_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, this->header_extensions(i), output);
        }

        // repeated uint32 rtx_ssrcs = 3;
        for (int i = 0; i < this->rtx_ssrcs_size(); i++) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(
                3, this->rtx_ssrcs(i), output);
        }

        // optional int32 rtx_payload_type = 4;
        if (has_rtx_payload_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->rtx_payload_type(), output);
        }

        // optional .webrtc.rtclog.EncoderConfig encoder = 5;
        if (has_encoder()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, *this->encoder_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.VideoSendConfig)
    }

    int VideoSendConfig::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.VideoSendConfig)
        int total_size = 0;

        if (_has_bits_[3 / 32] & 24u) {
            // optional int32 rtx_payload_type = 4;
            if (has_rtx_payload_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->rtx_payload_type());
            }

            // optional .webrtc.rtclog.EncoderConfig encoder = 5;
            if (has_encoder()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->encoder_);
            }
        }
        // repeated uint32 ssrcs = 1;
        {
            int data_size = 0;
            for (int i = 0; i < this->ssrcs_size(); i++) {
                data_size += ::google::protobuf::internal::WireFormatLite::
                    UInt32Size(this->ssrcs(i));
            }
            total_size += 1 * this->ssrcs_size() + data_size;
        }

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
        total_size += 1 * this->header_extensions_size();
        for (int i = 0; i < this->header_extensions_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->header_extensions(i));
        }

        // repeated uint32 rtx_ssrcs = 3;
        {
            int data_size = 0;
            for (int i = 0; i < this->rtx_ssrcs_size(); i++) {
                data_size += ::google::protobuf::internal::WireFormatLite::
                    UInt32Size(this->rtx_ssrcs(i));
            }
            total_size += 1 * this->rtx_ssrcs_size() + data_size;
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void VideoSendConfig::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const VideoSendConfig*>(&from));
    }

    void VideoSendConfig::MergeFrom(const VideoSendConfig& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.VideoSendConfig)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        ssrcs_.MergeFrom(from.ssrcs_);
        header_extensions_.MergeFrom(from.header_extensions_);
        rtx_ssrcs_.MergeFrom(from.rtx_ssrcs_);
        if (from._has_bits_[3 / 32] & (0xffu << (3 % 32))) {
            if (from.has_rtx_payload_type()) {
                set_rtx_payload_type(from.rtx_payload_type());
            }
            if (from.has_encoder()) {
                mutable_encoder()->::webrtc::rtclog::EncoderConfig::MergeFrom(from.encoder());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void VideoSendConfig::CopyFrom(const VideoSendConfig& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.VideoSendConfig)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool VideoSendConfig::IsInitialized() const
    {

        return true;
    }

    void VideoSendConfig::Swap(VideoSendConfig* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void VideoSendConfig::InternalSwap(VideoSendConfig* other)
    {
        ssrcs_.UnsafeArenaSwap(&other->ssrcs_);
        header_extensions_.UnsafeArenaSwap(&other->header_extensions_);
        rtx_ssrcs_.UnsafeArenaSwap(&other->rtx_ssrcs_);
        std::swap(rtx_payload_type_, other->rtx_payload_type_);
        std::swap(encoder_, other->encoder_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string VideoSendConfig::GetTypeName() const
    {
        return "webrtc.rtclog.VideoSendConfig";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // VideoSendConfig

    // repeated uint32 ssrcs = 1;
    int VideoSendConfig::ssrcs_size() const
    {
        return ssrcs_.size();
    }
    void VideoSendConfig::clear_ssrcs()
    {
        ssrcs_.Clear();
    }
    ::google::protobuf::uint32 VideoSendConfig::ssrcs(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.ssrcs)
        return ssrcs_.Get(index);
    }
    void VideoSendConfig::set_ssrcs(int index, ::google::protobuf::uint32 value)
    {
        ssrcs_.Set(index, value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoSendConfig.ssrcs)
    }
    void VideoSendConfig::add_ssrcs(::google::protobuf::uint32 value)
    {
        ssrcs_.Add(value);
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoSendConfig.ssrcs)
    }
    const ::google::protobuf::RepeatedField<::google::protobuf::uint32>&
    VideoSendConfig::ssrcs() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoSendConfig.ssrcs)
        return ssrcs_;
    }
    ::google::protobuf::RepeatedField<::google::protobuf::uint32>*
    VideoSendConfig::mutable_ssrcs()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoSendConfig.ssrcs)
        return &ssrcs_;
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
    int VideoSendConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    void VideoSendConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    const ::webrtc::rtclog::RtpHeaderExtension& VideoSendConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* VideoSendConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* VideoSendConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    VideoSendConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoSendConfig.header_extensions)
        return &header_extensions_;
    }
    const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    VideoSendConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_;
    }

    // repeated uint32 rtx_ssrcs = 3;
    int VideoSendConfig::rtx_ssrcs_size() const
    {
        return rtx_ssrcs_.size();
    }
    void VideoSendConfig::clear_rtx_ssrcs()
    {
        rtx_ssrcs_.Clear();
    }
    ::google::protobuf::uint32 VideoSendConfig::rtx_ssrcs(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
        return rtx_ssrcs_.Get(index);
    }
    void VideoSendConfig::set_rtx_ssrcs(int index, ::google::protobuf::uint32 value)
    {
        rtx_ssrcs_.Set(index, value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
    }
    void VideoSendConfig::add_rtx_ssrcs(::google::protobuf::uint32 value)
    {
        rtx_ssrcs_.Add(value);
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
    }
    const ::google::protobuf::RepeatedField<::google::protobuf::uint32>&
    VideoSendConfig::rtx_ssrcs() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
        return rtx_ssrcs_;
    }
    ::google::protobuf::RepeatedField<::google::protobuf::uint32>*
    VideoSendConfig::mutable_rtx_ssrcs()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
        return &rtx_ssrcs_;
    }

    // optional int32 rtx_payload_type = 4;
    bool VideoSendConfig::has_rtx_payload_type() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void VideoSendConfig::set_has_rtx_payload_type()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void VideoSendConfig::clear_has_rtx_payload_type()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void VideoSendConfig::clear_rtx_payload_type()
    {
        rtx_payload_type_ = 0;
        clear_has_rtx_payload_type();
    }
    ::google::protobuf::int32 VideoSendConfig::rtx_payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.rtx_payload_type)
        return rtx_payload_type_;
    }
    void VideoSendConfig::set_rtx_payload_type(::google::protobuf::int32 value)
    {
        set_has_rtx_payload_type();
        rtx_payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoSendConfig.rtx_payload_type)
    }

    // optional .webrtc.rtclog.EncoderConfig encoder = 5;
    bool VideoSendConfig::has_encoder() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void VideoSendConfig::set_has_encoder()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void VideoSendConfig::clear_has_encoder()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void VideoSendConfig::clear_encoder()
    {
        if (encoder_ != NULL)
            encoder_->::webrtc::rtclog::EncoderConfig::Clear();
        clear_has_encoder();
    }
    const ::webrtc::rtclog::EncoderConfig& VideoSendConfig::encoder() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.encoder)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return encoder_ != NULL ? *encoder_ : *default_instance().encoder_;
#else
        return encoder_ != NULL ? *encoder_ : *default_instance_->encoder_;
#endif
    }
    ::webrtc::rtclog::EncoderConfig* VideoSendConfig::mutable_encoder()
    {
        set_has_encoder();
        if (encoder_ == NULL) {
            encoder_ = new ::webrtc::rtclog::EncoderConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoSendConfig.encoder)
        return encoder_;
    }
    ::webrtc::rtclog::EncoderConfig* VideoSendConfig::release_encoder()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.VideoSendConfig.encoder)
        clear_has_encoder();
        ::webrtc::rtclog::EncoderConfig* temp = encoder_;
        encoder_ = NULL;
        return temp;
    }
    void VideoSendConfig::set_allocated_encoder(::webrtc::rtclog::EncoderConfig* encoder)
    {
        delete encoder_;
        encoder_ = encoder;
        if (encoder) {
            set_has_encoder();
        } else {
            clear_has_encoder();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.VideoSendConfig.encoder)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForEncoderConfig(
        EncoderConfig* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int EncoderConfig::kNameFieldNumber;
    const int EncoderConfig::kPayloadTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    EncoderConfig::EncoderConfig()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.EncoderConfig)
    }

    void EncoderConfig::InitAsDefaultInstance()
    {
    }

    EncoderConfig::EncoderConfig(const EncoderConfig& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.EncoderConfig)
    }

    void EncoderConfig::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        payload_type_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    EncoderConfig::~EncoderConfig()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.EncoderConfig)
        SharedDtor();
    }

    void EncoderConfig::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void EncoderConfig::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const EncoderConfig& EncoderConfig::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    EncoderConfig* EncoderConfig::default_instance_ = NULL;

    EncoderConfig* EncoderConfig::New(::google::protobuf::Arena* arena) const
    {
        EncoderConfig* n = new EncoderConfig;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void EncoderConfig::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.EncoderConfig)
        if (_has_bits_[0 / 32] & 3u) {
            if (has_name()) {
                name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            payload_type_ = 0;
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool EncoderConfig::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForEncoderConfig, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.EncoderConfig)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional string name = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_name()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_payload_type;
                break;
            }

            // optional int32 payload_type = 2;
            case 2: {
                if (tag == 16) {
                parse_payload_type:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &payload_type_)));
                    set_has_payload_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.EncoderConfig)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.EncoderConfig)
        return false;
#undef DO_
    }

    void EncoderConfig::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.EncoderConfig)
        // optional string name = 1;
        if (has_name()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                1, this->name(), output);
        }

        // optional int32 payload_type = 2;
        if (has_payload_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->payload_type(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.EncoderConfig)
    }

    int EncoderConfig::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.EncoderConfig)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional string name = 1;
            if (has_name()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->name());
            }

            // optional int32 payload_type = 2;
            if (has_payload_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->payload_type());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void EncoderConfig::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const EncoderConfig*>(&from));
    }

    void EncoderConfig::MergeFrom(const EncoderConfig& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.EncoderConfig)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_name()) {
                set_has_name();
                name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
            }
            if (from.has_payload_type()) {
                set_payload_type(from.payload_type());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void EncoderConfig::CopyFrom(const EncoderConfig& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.EncoderConfig)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool EncoderConfig::IsInitialized() const
    {

        return true;
    }

    void EncoderConfig::Swap(EncoderConfig* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void EncoderConfig::InternalSwap(EncoderConfig* other)
    {
        name_.Swap(&other->name_);
        std::swap(payload_type_, other->payload_type_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string EncoderConfig::GetTypeName() const
    {
        return "webrtc.rtclog.EncoderConfig";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // EncoderConfig

    // optional string name = 1;
    bool EncoderConfig::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void EncoderConfig::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void EncoderConfig::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void EncoderConfig::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    const ::std::string& EncoderConfig::name() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.EncoderConfig.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void EncoderConfig::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.EncoderConfig.name)
    }
    void EncoderConfig::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.EncoderConfig.name)
    }
    void EncoderConfig::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.EncoderConfig.name)
    }
    ::std::string* EncoderConfig::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.EncoderConfig.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* EncoderConfig::release_name()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.EncoderConfig.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void EncoderConfig::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.EncoderConfig.name)
    }

    // optional int32 payload_type = 2;
    bool EncoderConfig::has_payload_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void EncoderConfig::set_has_payload_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void EncoderConfig::clear_has_payload_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void EncoderConfig::clear_payload_type()
    {
        payload_type_ = 0;
        clear_has_payload_type();
    }
    ::google::protobuf::int32 EncoderConfig::payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.EncoderConfig.payload_type)
        return payload_type_;
    }
    void EncoderConfig::set_payload_type(::google::protobuf::int32 value)
    {
        set_has_payload_type();
        payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.EncoderConfig.payload_type)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForAudioReceiveConfig(
        AudioReceiveConfig* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int AudioReceiveConfig::kRemoteSsrcFieldNumber;
    const int AudioReceiveConfig::kLocalSsrcFieldNumber;
    const int AudioReceiveConfig::kHeaderExtensionsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    AudioReceiveConfig::AudioReceiveConfig()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.AudioReceiveConfig)
    }

    void AudioReceiveConfig::InitAsDefaultInstance()
    {
    }

    AudioReceiveConfig::AudioReceiveConfig(const AudioReceiveConfig& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.AudioReceiveConfig)
    }

    void AudioReceiveConfig::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        remote_ssrc_ = 0u;
        local_ssrc_ = 0u;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    AudioReceiveConfig::~AudioReceiveConfig()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.AudioReceiveConfig)
        SharedDtor();
    }

    void AudioReceiveConfig::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void AudioReceiveConfig::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const AudioReceiveConfig& AudioReceiveConfig::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    AudioReceiveConfig* AudioReceiveConfig::default_instance_ = NULL;

    AudioReceiveConfig* AudioReceiveConfig::New(::google::protobuf::Arena* arena) const
    {
        AudioReceiveConfig* n = new AudioReceiveConfig;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void AudioReceiveConfig::Clear()
    {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog.AudioReceiveConfig)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                        \
    _Pragma("clang diagnostic push")                                                                         \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(AudioReceiveConfig, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<AudioReceiveConfig*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        ZR_(remote_ssrc_, local_ssrc_);

#undef ZR_HELPER_
#undef ZR_

        header_extensions_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool AudioReceiveConfig::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForAudioReceiveConfig, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.AudioReceiveConfig)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional uint32 remote_ssrc = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &remote_ssrc_)));
                    set_has_remote_ssrc();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_local_ssrc;
                break;
            }

            // optional uint32 local_ssrc = 2;
            case 2: {
                if (tag == 16) {
                parse_local_ssrc:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &local_ssrc_)));
                    set_has_local_ssrc();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_header_extensions;
                break;
            }

            // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 3;
            case 3: {
                if (tag == 26) {
                parse_header_extensions:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_header_extensions:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_header_extensions()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_loop_header_extensions;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.AudioReceiveConfig)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.AudioReceiveConfig)
        return false;
#undef DO_
    }

    void AudioReceiveConfig::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.AudioReceiveConfig)
        // optional uint32 remote_ssrc = 1;
        if (has_remote_ssrc()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->remote_ssrc(), output);
        }

        // optional uint32 local_ssrc = 2;
        if (has_local_ssrc()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->local_ssrc(), output);
        }

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 3;
        for (unsigned int i = 0, n = this->header_extensions_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, this->header_extensions(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.AudioReceiveConfig)
    }

    int AudioReceiveConfig::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.AudioReceiveConfig)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional uint32 remote_ssrc = 1;
            if (has_remote_ssrc()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->remote_ssrc());
            }

            // optional uint32 local_ssrc = 2;
            if (has_local_ssrc()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->local_ssrc());
            }
        }
        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 3;
        total_size += 1 * this->header_extensions_size();
        for (int i = 0; i < this->header_extensions_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->header_extensions(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void AudioReceiveConfig::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const AudioReceiveConfig*>(&from));
    }

    void AudioReceiveConfig::MergeFrom(const AudioReceiveConfig& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.AudioReceiveConfig)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        header_extensions_.MergeFrom(from.header_extensions_);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_remote_ssrc()) {
                set_remote_ssrc(from.remote_ssrc());
            }
            if (from.has_local_ssrc()) {
                set_local_ssrc(from.local_ssrc());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void AudioReceiveConfig::CopyFrom(const AudioReceiveConfig& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.AudioReceiveConfig)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool AudioReceiveConfig::IsInitialized() const
    {

        return true;
    }

    void AudioReceiveConfig::Swap(AudioReceiveConfig* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void AudioReceiveConfig::InternalSwap(AudioReceiveConfig* other)
    {
        std::swap(remote_ssrc_, other->remote_ssrc_);
        std::swap(local_ssrc_, other->local_ssrc_);
        header_extensions_.UnsafeArenaSwap(&other->header_extensions_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string AudioReceiveConfig::GetTypeName() const
    {
        return "webrtc.rtclog.AudioReceiveConfig";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // AudioReceiveConfig

    // optional uint32 remote_ssrc = 1;
    bool AudioReceiveConfig::has_remote_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void AudioReceiveConfig::set_has_remote_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void AudioReceiveConfig::clear_has_remote_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void AudioReceiveConfig::clear_remote_ssrc()
    {
        remote_ssrc_ = 0u;
        clear_has_remote_ssrc();
    }
    ::google::protobuf::uint32 AudioReceiveConfig::remote_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioReceiveConfig.remote_ssrc)
        return remote_ssrc_;
    }
    void AudioReceiveConfig::set_remote_ssrc(::google::protobuf::uint32 value)
    {
        set_has_remote_ssrc();
        remote_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioReceiveConfig.remote_ssrc)
    }

    // optional uint32 local_ssrc = 2;
    bool AudioReceiveConfig::has_local_ssrc() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void AudioReceiveConfig::set_has_local_ssrc()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void AudioReceiveConfig::clear_has_local_ssrc()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void AudioReceiveConfig::clear_local_ssrc()
    {
        local_ssrc_ = 0u;
        clear_has_local_ssrc();
    }
    ::google::protobuf::uint32 AudioReceiveConfig::local_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioReceiveConfig.local_ssrc)
        return local_ssrc_;
    }
    void AudioReceiveConfig::set_local_ssrc(::google::protobuf::uint32 value)
    {
        set_has_local_ssrc();
        local_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioReceiveConfig.local_ssrc)
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 3;
    int AudioReceiveConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    void AudioReceiveConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    const ::webrtc::rtclog::RtpHeaderExtension& AudioReceiveConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* AudioReceiveConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* AudioReceiveConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    AudioReceiveConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return &header_extensions_;
    }
    const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    AudioReceiveConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForAudioSendConfig(
        AudioSendConfig* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int AudioSendConfig::kSsrcFieldNumber;
    const int AudioSendConfig::kHeaderExtensionsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    AudioSendConfig::AudioSendConfig()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:webrtc.rtclog.AudioSendConfig)
    }

    void AudioSendConfig::InitAsDefaultInstance()
    {
    }

    AudioSendConfig::AudioSendConfig(const AudioSendConfig& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:webrtc.rtclog.AudioSendConfig)
    }

    void AudioSendConfig::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ssrc_ = 0u;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    AudioSendConfig::~AudioSendConfig()
    {
        // @@protoc_insertion_point(destructor:webrtc.rtclog.AudioSendConfig)
        SharedDtor();
    }

    void AudioSendConfig::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void AudioSendConfig::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const AudioSendConfig& AudioSendConfig::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        return *default_instance_;
    }

    AudioSendConfig* AudioSendConfig::default_instance_ = NULL;

    AudioSendConfig* AudioSendConfig::New(::google::protobuf::Arena* arena) const
    {
        AudioSendConfig* n = new AudioSendConfig;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void AudioSendConfig::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:webrtc.rtclog.AudioSendConfig)
        ssrc_ = 0u;
        header_extensions_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool AudioSendConfig::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForAudioSendConfig, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:webrtc.rtclog.AudioSendConfig)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional uint32 ssrc = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &ssrc_)));
                    set_has_ssrc();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_header_extensions;
                break;
            }

            // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
            case 2: {
                if (tag == 18) {
                parse_header_extensions:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_header_extensions:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_header_extensions()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_loop_header_extensions;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:webrtc.rtclog.AudioSendConfig)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:webrtc.rtclog.AudioSendConfig)
        return false;
#undef DO_
    }

    void AudioSendConfig::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:webrtc.rtclog.AudioSendConfig)
        // optional uint32 ssrc = 1;
        if (has_ssrc()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ssrc(), output);
        }

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
        for (unsigned int i = 0, n = this->header_extensions_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, this->header_extensions(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:webrtc.rtclog.AudioSendConfig)
    }

    int AudioSendConfig::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog.AudioSendConfig)
        int total_size = 0;

        // optional uint32 ssrc = 1;
        if (has_ssrc()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->ssrc());
        }

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
        total_size += 1 * this->header_extensions_size();
        for (int i = 0; i < this->header_extensions_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->header_extensions(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void AudioSendConfig::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const AudioSendConfig*>(&from));
    }

    void AudioSendConfig::MergeFrom(const AudioSendConfig& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog.AudioSendConfig)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        header_extensions_.MergeFrom(from.header_extensions_);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_ssrc()) {
                set_ssrc(from.ssrc());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void AudioSendConfig::CopyFrom(const AudioSendConfig& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog.AudioSendConfig)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool AudioSendConfig::IsInitialized() const
    {

        return true;
    }

    void AudioSendConfig::Swap(AudioSendConfig* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void AudioSendConfig::InternalSwap(AudioSendConfig* other)
    {
        std::swap(ssrc_, other->ssrc_);
        header_extensions_.UnsafeArenaSwap(&other->header_extensions_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string AudioSendConfig::GetTypeName() const
    {
        return "webrtc.rtclog.AudioSendConfig";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // AudioSendConfig

    // optional uint32 ssrc = 1;
    bool AudioSendConfig::has_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void AudioSendConfig::set_has_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void AudioSendConfig::clear_has_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void AudioSendConfig::clear_ssrc()
    {
        ssrc_ = 0u;
        clear_has_ssrc();
    }
    ::google::protobuf::uint32 AudioSendConfig::ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioSendConfig.ssrc)
        return ssrc_;
    }
    void AudioSendConfig::set_ssrc(::google::protobuf::uint32 value)
    {
        set_has_ssrc();
        ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioSendConfig.ssrc)
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
    int AudioSendConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    void AudioSendConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    const ::webrtc::rtclog::RtpHeaderExtension& AudioSendConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* AudioSendConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    ::webrtc::rtclog::RtpHeaderExtension* AudioSendConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    AudioSendConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.AudioSendConfig.header_extensions)
        return &header_extensions_;
    }
    const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    AudioSendConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // @@protoc_insertion_point(namespace_scope)

} // namespace rtclog
} // namespace webrtc

// @@protoc_insertion_point(global_scope)
