// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtc_event_log.proto

#ifndef PROTOBUF_rtc_5fevent_5flog_2eproto__INCLUDED
#define PROTOBUF_rtc_5fevent_5flog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)

namespace webrtc {
namespace rtclog {

    // Internal implementation detail -- do not call these.
    void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
    void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
    void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

    class AudioPlayoutEvent;
    class AudioReceiveConfig;
    class AudioSendConfig;
    class BwePacketLossEvent;
    class DecoderConfig;
    class EncoderConfig;
    class Event;
    class EventStream;
    class RtcpPacket;
    class RtpHeaderExtension;
    class RtpPacket;
    class RtxConfig;
    class RtxMap;
    class VideoReceiveConfig;
    class VideoSendConfig;

    enum Event_EventType {
        Event_EventType_UNKNOWN_EVENT = 0,
        Event_EventType_LOG_START = 1,
        Event_EventType_LOG_END = 2,
        Event_EventType_RTP_EVENT = 3,
        Event_EventType_RTCP_EVENT = 4,
        Event_EventType_AUDIO_PLAYOUT_EVENT = 5,
        Event_EventType_BWE_PACKET_LOSS_EVENT = 6,
        Event_EventType_BWE_PACKET_DELAY_EVENT = 7,
        Event_EventType_VIDEO_RECEIVER_CONFIG_EVENT = 8,
        Event_EventType_VIDEO_SENDER_CONFIG_EVENT = 9,
        Event_EventType_AUDIO_RECEIVER_CONFIG_EVENT = 10,
        Event_EventType_AUDIO_SENDER_CONFIG_EVENT = 11
    };
    bool Event_EventType_IsValid(int value);
    const Event_EventType Event_EventType_EventType_MIN = Event_EventType_UNKNOWN_EVENT;
    const Event_EventType Event_EventType_EventType_MAX = Event_EventType_AUDIO_SENDER_CONFIG_EVENT;
    const int Event_EventType_EventType_ARRAYSIZE = Event_EventType_EventType_MAX + 1;

    enum VideoReceiveConfig_RtcpMode {
        VideoReceiveConfig_RtcpMode_RTCP_COMPOUND = 1,
        VideoReceiveConfig_RtcpMode_RTCP_REDUCEDSIZE = 2
    };
    bool VideoReceiveConfig_RtcpMode_IsValid(int value);
    const VideoReceiveConfig_RtcpMode VideoReceiveConfig_RtcpMode_RtcpMode_MIN = VideoReceiveConfig_RtcpMode_RTCP_COMPOUND;
    const VideoReceiveConfig_RtcpMode VideoReceiveConfig_RtcpMode_RtcpMode_MAX = VideoReceiveConfig_RtcpMode_RTCP_REDUCEDSIZE;
    const int VideoReceiveConfig_RtcpMode_RtcpMode_ARRAYSIZE = VideoReceiveConfig_RtcpMode_RtcpMode_MAX + 1;

    enum MediaType {
        ANY = 0,
        AUDIO = 1,
        VIDEO = 2,
        DATA = 3
    };
    bool MediaType_IsValid(int value);
    const MediaType MediaType_MIN = ANY;
    const MediaType MediaType_MAX = DATA;
    const int MediaType_ARRAYSIZE = MediaType_MAX + 1;

    // ===================================================================

    class EventStream : public ::google::protobuf::MessageLite {
    public:
        EventStream();
        virtual ~EventStream();

        EventStream(const EventStream& from);

        inline EventStream& operator=(const EventStream& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const EventStream& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const EventStream* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(EventStream* other);

        // implements Message ----------------------------------------------

        inline EventStream* New() const { return New(NULL); }

        EventStream* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const EventStream& from);
        void MergeFrom(const EventStream& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(EventStream* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .webrtc.rtclog.Event stream = 1;
        int stream_size() const;
        void clear_stream();
        static const int kStreamFieldNumber = 1;
        const ::webrtc::rtclog::Event& stream(int index) const;
        ::webrtc::rtclog::Event* mutable_stream(int index);
        ::webrtc::rtclog::Event* add_stream();
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::Event>*
        mutable_stream();
        const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::Event>&
        stream() const;

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.EventStream)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::Event> stream_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static EventStream* default_instance_;
    };
    // -------------------------------------------------------------------

    class Event : public ::google::protobuf::MessageLite {
    public:
        Event();
        virtual ~Event();

        Event(const Event& from);

        inline Event& operator=(const Event& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Event& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Event* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Event* other);

        // implements Message ----------------------------------------------

        inline Event* New() const { return New(NULL); }

        Event* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Event& from);
        void MergeFrom(const Event& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Event* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef Event_EventType EventType;
        static const EventType UNKNOWN_EVENT = Event_EventType_UNKNOWN_EVENT;
        static const EventType LOG_START = Event_EventType_LOG_START;
        static const EventType LOG_END = Event_EventType_LOG_END;
        static const EventType RTP_EVENT = Event_EventType_RTP_EVENT;
        static const EventType RTCP_EVENT = Event_EventType_RTCP_EVENT;
        static const EventType AUDIO_PLAYOUT_EVENT = Event_EventType_AUDIO_PLAYOUT_EVENT;
        static const EventType BWE_PACKET_LOSS_EVENT = Event_EventType_BWE_PACKET_LOSS_EVENT;
        static const EventType BWE_PACKET_DELAY_EVENT = Event_EventType_BWE_PACKET_DELAY_EVENT;
        static const EventType VIDEO_RECEIVER_CONFIG_EVENT = Event_EventType_VIDEO_RECEIVER_CONFIG_EVENT;
        static const EventType VIDEO_SENDER_CONFIG_EVENT = Event_EventType_VIDEO_SENDER_CONFIG_EVENT;
        static const EventType AUDIO_RECEIVER_CONFIG_EVENT = Event_EventType_AUDIO_RECEIVER_CONFIG_EVENT;
        static const EventType AUDIO_SENDER_CONFIG_EVENT = Event_EventType_AUDIO_SENDER_CONFIG_EVENT;
        static inline bool EventType_IsValid(int value)
        {
            return Event_EventType_IsValid(value);
        }
        static const EventType EventType_MIN = Event_EventType_EventType_MIN;
        static const EventType EventType_MAX = Event_EventType_EventType_MAX;
        static const int EventType_ARRAYSIZE = Event_EventType_EventType_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional int64 timestamp_us = 1;
        bool has_timestamp_us() const;
        void clear_timestamp_us();
        static const int kTimestampUsFieldNumber = 1;
        ::google::protobuf::int64 timestamp_us() const;
        void set_timestamp_us(::google::protobuf::int64 value);

        // optional .webrtc.rtclog.Event.EventType type = 2;
        bool has_type() const;
        void clear_type();
        static const int kTypeFieldNumber = 2;
        ::webrtc::rtclog::Event_EventType type() const;
        void set_type(::webrtc::rtclog::Event_EventType value);

        // optional .webrtc.rtclog.RtpPacket rtp_packet = 3;
        bool has_rtp_packet() const;
        void clear_rtp_packet();
        static const int kRtpPacketFieldNumber = 3;
        const ::webrtc::rtclog::RtpPacket& rtp_packet() const;
        ::webrtc::rtclog::RtpPacket* mutable_rtp_packet();
        ::webrtc::rtclog::RtpPacket* release_rtp_packet();
        void set_allocated_rtp_packet(::webrtc::rtclog::RtpPacket* rtp_packet);

        // optional .webrtc.rtclog.RtcpPacket rtcp_packet = 4;
        bool has_rtcp_packet() const;
        void clear_rtcp_packet();
        static const int kRtcpPacketFieldNumber = 4;
        const ::webrtc::rtclog::RtcpPacket& rtcp_packet() const;
        ::webrtc::rtclog::RtcpPacket* mutable_rtcp_packet();
        ::webrtc::rtclog::RtcpPacket* release_rtcp_packet();
        void set_allocated_rtcp_packet(::webrtc::rtclog::RtcpPacket* rtcp_packet);

        // optional .webrtc.rtclog.AudioPlayoutEvent audio_playout_event = 5;
        bool has_audio_playout_event() const;
        void clear_audio_playout_event();
        static const int kAudioPlayoutEventFieldNumber = 5;
        const ::webrtc::rtclog::AudioPlayoutEvent& audio_playout_event() const;
        ::webrtc::rtclog::AudioPlayoutEvent* mutable_audio_playout_event();
        ::webrtc::rtclog::AudioPlayoutEvent* release_audio_playout_event();
        void set_allocated_audio_playout_event(::webrtc::rtclog::AudioPlayoutEvent* audio_playout_event);

        // optional .webrtc.rtclog.BwePacketLossEvent bwe_packet_loss_event = 6;
        bool has_bwe_packet_loss_event() const;
        void clear_bwe_packet_loss_event();
        static const int kBwePacketLossEventFieldNumber = 6;
        const ::webrtc::rtclog::BwePacketLossEvent& bwe_packet_loss_event() const;
        ::webrtc::rtclog::BwePacketLossEvent* mutable_bwe_packet_loss_event();
        ::webrtc::rtclog::BwePacketLossEvent* release_bwe_packet_loss_event();
        void set_allocated_bwe_packet_loss_event(::webrtc::rtclog::BwePacketLossEvent* bwe_packet_loss_event);

        // optional .webrtc.rtclog.VideoReceiveConfig video_receiver_config = 8;
        bool has_video_receiver_config() const;
        void clear_video_receiver_config();
        static const int kVideoReceiverConfigFieldNumber = 8;
        const ::webrtc::rtclog::VideoReceiveConfig& video_receiver_config() const;
        ::webrtc::rtclog::VideoReceiveConfig* mutable_video_receiver_config();
        ::webrtc::rtclog::VideoReceiveConfig* release_video_receiver_config();
        void set_allocated_video_receiver_config(::webrtc::rtclog::VideoReceiveConfig* video_receiver_config);

        // optional .webrtc.rtclog.VideoSendConfig video_sender_config = 9;
        bool has_video_sender_config() const;
        void clear_video_sender_config();
        static const int kVideoSenderConfigFieldNumber = 9;
        const ::webrtc::rtclog::VideoSendConfig& video_sender_config() const;
        ::webrtc::rtclog::VideoSendConfig* mutable_video_sender_config();
        ::webrtc::rtclog::VideoSendConfig* release_video_sender_config();
        void set_allocated_video_sender_config(::webrtc::rtclog::VideoSendConfig* video_sender_config);

        // optional .webrtc.rtclog.AudioReceiveConfig audio_receiver_config = 10;
        bool has_audio_receiver_config() const;
        void clear_audio_receiver_config();
        static const int kAudioReceiverConfigFieldNumber = 10;
        const ::webrtc::rtclog::AudioReceiveConfig& audio_receiver_config() const;
        ::webrtc::rtclog::AudioReceiveConfig* mutable_audio_receiver_config();
        ::webrtc::rtclog::AudioReceiveConfig* release_audio_receiver_config();
        void set_allocated_audio_receiver_config(::webrtc::rtclog::AudioReceiveConfig* audio_receiver_config);

        // optional .webrtc.rtclog.AudioSendConfig audio_sender_config = 11;
        bool has_audio_sender_config() const;
        void clear_audio_sender_config();
        static const int kAudioSenderConfigFieldNumber = 11;
        const ::webrtc::rtclog::AudioSendConfig& audio_sender_config() const;
        ::webrtc::rtclog::AudioSendConfig* mutable_audio_sender_config();
        ::webrtc::rtclog::AudioSendConfig* release_audio_sender_config();
        void set_allocated_audio_sender_config(::webrtc::rtclog::AudioSendConfig* audio_sender_config);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.Event)
    private:
        inline void set_has_timestamp_us();
        inline void clear_has_timestamp_us();
        inline void set_has_type();
        inline void clear_has_type();
        inline void set_has_rtp_packet();
        inline void clear_has_rtp_packet();
        inline void set_has_rtcp_packet();
        inline void clear_has_rtcp_packet();
        inline void set_has_audio_playout_event();
        inline void clear_has_audio_playout_event();
        inline void set_has_bwe_packet_loss_event();
        inline void clear_has_bwe_packet_loss_event();
        inline void set_has_video_receiver_config();
        inline void clear_has_video_receiver_config();
        inline void set_has_video_sender_config();
        inline void clear_has_video_sender_config();
        inline void set_has_audio_receiver_config();
        inline void clear_has_audio_receiver_config();
        inline void set_has_audio_sender_config();
        inline void clear_has_audio_sender_config();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 timestamp_us_;
        ::webrtc::rtclog::RtpPacket* rtp_packet_;
        ::webrtc::rtclog::RtcpPacket* rtcp_packet_;
        ::webrtc::rtclog::AudioPlayoutEvent* audio_playout_event_;
        ::webrtc::rtclog::BwePacketLossEvent* bwe_packet_loss_event_;
        ::webrtc::rtclog::VideoReceiveConfig* video_receiver_config_;
        ::webrtc::rtclog::VideoSendConfig* video_sender_config_;
        ::webrtc::rtclog::AudioReceiveConfig* audio_receiver_config_;
        ::webrtc::rtclog::AudioSendConfig* audio_sender_config_;
        int type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static Event* default_instance_;
    };
    // -------------------------------------------------------------------

    class RtpPacket : public ::google::protobuf::MessageLite {
    public:
        RtpPacket();
        virtual ~RtpPacket();

        RtpPacket(const RtpPacket& from);

        inline RtpPacket& operator=(const RtpPacket& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RtpPacket& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RtpPacket* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RtpPacket* other);

        // implements Message ----------------------------------------------

        inline RtpPacket* New() const { return New(NULL); }

        RtpPacket* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RtpPacket& from);
        void MergeFrom(const RtpPacket& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RtpPacket* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional bool incoming = 1;
        bool has_incoming() const;
        void clear_incoming();
        static const int kIncomingFieldNumber = 1;
        bool incoming() const;
        void set_incoming(bool value);

        // optional .webrtc.rtclog.MediaType type = 2;
        bool has_type() const;
        void clear_type();
        static const int kTypeFieldNumber = 2;
        ::webrtc::rtclog::MediaType type() const;
        void set_type(::webrtc::rtclog::MediaType value);

        // optional uint32 packet_length = 3;
        bool has_packet_length() const;
        void clear_packet_length();
        static const int kPacketLengthFieldNumber = 3;
        ::google::protobuf::uint32 packet_length() const;
        void set_packet_length(::google::protobuf::uint32 value);

        // optional bytes header = 4;
        bool has_header() const;
        void clear_header();
        static const int kHeaderFieldNumber = 4;
        const ::std::string& header() const;
        void set_header(const ::std::string& value);
        void set_header(const char* value);
        void set_header(const void* value, size_t size);
        ::std::string* mutable_header();
        ::std::string* release_header();
        void set_allocated_header(::std::string* header);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.RtpPacket)
    private:
        inline void set_has_incoming();
        inline void clear_has_incoming();
        inline void set_has_type();
        inline void clear_has_type();
        inline void set_has_packet_length();
        inline void clear_has_packet_length();
        inline void set_has_header();
        inline void clear_has_header();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        bool incoming_;
        int type_;
        ::google::protobuf::internal::ArenaStringPtr header_;
        ::google::protobuf::uint32 packet_length_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static RtpPacket* default_instance_;
    };
    // -------------------------------------------------------------------

    class RtcpPacket : public ::google::protobuf::MessageLite {
    public:
        RtcpPacket();
        virtual ~RtcpPacket();

        RtcpPacket(const RtcpPacket& from);

        inline RtcpPacket& operator=(const RtcpPacket& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RtcpPacket& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RtcpPacket* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RtcpPacket* other);

        // implements Message ----------------------------------------------

        inline RtcpPacket* New() const { return New(NULL); }

        RtcpPacket* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RtcpPacket& from);
        void MergeFrom(const RtcpPacket& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RtcpPacket* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional bool incoming = 1;
        bool has_incoming() const;
        void clear_incoming();
        static const int kIncomingFieldNumber = 1;
        bool incoming() const;
        void set_incoming(bool value);

        // optional .webrtc.rtclog.MediaType type = 2;
        bool has_type() const;
        void clear_type();
        static const int kTypeFieldNumber = 2;
        ::webrtc::rtclog::MediaType type() const;
        void set_type(::webrtc::rtclog::MediaType value);

        // optional bytes packet_data = 3;
        bool has_packet_data() const;
        void clear_packet_data();
        static const int kPacketDataFieldNumber = 3;
        const ::std::string& packet_data() const;
        void set_packet_data(const ::std::string& value);
        void set_packet_data(const char* value);
        void set_packet_data(const void* value, size_t size);
        ::std::string* mutable_packet_data();
        ::std::string* release_packet_data();
        void set_allocated_packet_data(::std::string* packet_data);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.RtcpPacket)
    private:
        inline void set_has_incoming();
        inline void clear_has_incoming();
        inline void set_has_type();
        inline void clear_has_type();
        inline void set_has_packet_data();
        inline void clear_has_packet_data();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        bool incoming_;
        int type_;
        ::google::protobuf::internal::ArenaStringPtr packet_data_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static RtcpPacket* default_instance_;
    };
    // -------------------------------------------------------------------

    class AudioPlayoutEvent : public ::google::protobuf::MessageLite {
    public:
        AudioPlayoutEvent();
        virtual ~AudioPlayoutEvent();

        AudioPlayoutEvent(const AudioPlayoutEvent& from);

        inline AudioPlayoutEvent& operator=(const AudioPlayoutEvent& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const AudioPlayoutEvent& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const AudioPlayoutEvent* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(AudioPlayoutEvent* other);

        // implements Message ----------------------------------------------

        inline AudioPlayoutEvent* New() const { return New(NULL); }

        AudioPlayoutEvent* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const AudioPlayoutEvent& from);
        void MergeFrom(const AudioPlayoutEvent& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(AudioPlayoutEvent* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional uint32 local_ssrc = 2;
        bool has_local_ssrc() const;
        void clear_local_ssrc();
        static const int kLocalSsrcFieldNumber = 2;
        ::google::protobuf::uint32 local_ssrc() const;
        void set_local_ssrc(::google::protobuf::uint32 value);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.AudioPlayoutEvent)
    private:
        inline void set_has_local_ssrc();
        inline void clear_has_local_ssrc();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint32 local_ssrc_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static AudioPlayoutEvent* default_instance_;
    };
    // -------------------------------------------------------------------

    class BwePacketLossEvent : public ::google::protobuf::MessageLite {
    public:
        BwePacketLossEvent();
        virtual ~BwePacketLossEvent();

        BwePacketLossEvent(const BwePacketLossEvent& from);

        inline BwePacketLossEvent& operator=(const BwePacketLossEvent& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const BwePacketLossEvent& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const BwePacketLossEvent* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(BwePacketLossEvent* other);

        // implements Message ----------------------------------------------

        inline BwePacketLossEvent* New() const { return New(NULL); }

        BwePacketLossEvent* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const BwePacketLossEvent& from);
        void MergeFrom(const BwePacketLossEvent& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(BwePacketLossEvent* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 bitrate = 1;
        bool has_bitrate() const;
        void clear_bitrate();
        static const int kBitrateFieldNumber = 1;
        ::google::protobuf::int32 bitrate() const;
        void set_bitrate(::google::protobuf::int32 value);

        // optional uint32 fraction_loss = 2;
        bool has_fraction_loss() const;
        void clear_fraction_loss();
        static const int kFractionLossFieldNumber = 2;
        ::google::protobuf::uint32 fraction_loss() const;
        void set_fraction_loss(::google::protobuf::uint32 value);

        // optional int32 total_packets = 3;
        bool has_total_packets() const;
        void clear_total_packets();
        static const int kTotalPacketsFieldNumber = 3;
        ::google::protobuf::int32 total_packets() const;
        void set_total_packets(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.BwePacketLossEvent)
    private:
        inline void set_has_bitrate();
        inline void clear_has_bitrate();
        inline void set_has_fraction_loss();
        inline void clear_has_fraction_loss();
        inline void set_has_total_packets();
        inline void clear_has_total_packets();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int32 bitrate_;
        ::google::protobuf::uint32 fraction_loss_;
        ::google::protobuf::int32 total_packets_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static BwePacketLossEvent* default_instance_;
    };
    // -------------------------------------------------------------------

    class VideoReceiveConfig : public ::google::protobuf::MessageLite {
    public:
        VideoReceiveConfig();
        virtual ~VideoReceiveConfig();

        VideoReceiveConfig(const VideoReceiveConfig& from);

        inline VideoReceiveConfig& operator=(const VideoReceiveConfig& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const VideoReceiveConfig& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const VideoReceiveConfig* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(VideoReceiveConfig* other);

        // implements Message ----------------------------------------------

        inline VideoReceiveConfig* New() const { return New(NULL); }

        VideoReceiveConfig* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const VideoReceiveConfig& from);
        void MergeFrom(const VideoReceiveConfig& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(VideoReceiveConfig* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef VideoReceiveConfig_RtcpMode RtcpMode;
        static const RtcpMode RTCP_COMPOUND = VideoReceiveConfig_RtcpMode_RTCP_COMPOUND;
        static const RtcpMode RTCP_REDUCEDSIZE = VideoReceiveConfig_RtcpMode_RTCP_REDUCEDSIZE;
        static inline bool RtcpMode_IsValid(int value)
        {
            return VideoReceiveConfig_RtcpMode_IsValid(value);
        }
        static const RtcpMode RtcpMode_MIN = VideoReceiveConfig_RtcpMode_RtcpMode_MIN;
        static const RtcpMode RtcpMode_MAX = VideoReceiveConfig_RtcpMode_RtcpMode_MAX;
        static const int RtcpMode_ARRAYSIZE = VideoReceiveConfig_RtcpMode_RtcpMode_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional uint32 remote_ssrc = 1;
        bool has_remote_ssrc() const;
        void clear_remote_ssrc();
        static const int kRemoteSsrcFieldNumber = 1;
        ::google::protobuf::uint32 remote_ssrc() const;
        void set_remote_ssrc(::google::protobuf::uint32 value);

        // optional uint32 local_ssrc = 2;
        bool has_local_ssrc() const;
        void clear_local_ssrc();
        static const int kLocalSsrcFieldNumber = 2;
        ::google::protobuf::uint32 local_ssrc() const;
        void set_local_ssrc(::google::protobuf::uint32 value);

        // optional .webrtc.rtclog.VideoReceiveConfig.RtcpMode rtcp_mode = 3;
        bool has_rtcp_mode() const;
        void clear_rtcp_mode();
        static const int kRtcpModeFieldNumber = 3;
        ::webrtc::rtclog::VideoReceiveConfig_RtcpMode rtcp_mode() const;
        void set_rtcp_mode(::webrtc::rtclog::VideoReceiveConfig_RtcpMode value);

        // optional bool remb = 4;
        bool has_remb() const;
        void clear_remb();
        static const int kRembFieldNumber = 4;
        bool remb() const;
        void set_remb(bool value);

        // repeated .webrtc.rtclog.RtxMap rtx_map = 5;
        int rtx_map_size() const;
        void clear_rtx_map();
        static const int kRtxMapFieldNumber = 5;
        const ::webrtc::rtclog::RtxMap& rtx_map(int index) const;
        ::webrtc::rtclog::RtxMap* mutable_rtx_map(int index);
        ::webrtc::rtclog::RtxMap* add_rtx_map();
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtxMap>*
        mutable_rtx_map();
        const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtxMap>&
        rtx_map() const;

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 6;
        int header_extensions_size() const;
        void clear_header_extensions();
        static const int kHeaderExtensionsFieldNumber = 6;
        const ::webrtc::rtclog::RtpHeaderExtension& header_extensions(int index) const;
        ::webrtc::rtclog::RtpHeaderExtension* mutable_header_extensions(int index);
        ::webrtc::rtclog::RtpHeaderExtension* add_header_extensions();
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
        mutable_header_extensions();
        const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
        header_extensions() const;

        // repeated .webrtc.rtclog.DecoderConfig decoders = 7;
        int decoders_size() const;
        void clear_decoders();
        static const int kDecodersFieldNumber = 7;
        const ::webrtc::rtclog::DecoderConfig& decoders(int index) const;
        ::webrtc::rtclog::DecoderConfig* mutable_decoders(int index);
        ::webrtc::rtclog::DecoderConfig* add_decoders();
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::DecoderConfig>*
        mutable_decoders();
        const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::DecoderConfig>&
        decoders() const;

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.VideoReceiveConfig)
    private:
        inline void set_has_remote_ssrc();
        inline void clear_has_remote_ssrc();
        inline void set_has_local_ssrc();
        inline void clear_has_local_ssrc();
        inline void set_has_rtcp_mode();
        inline void clear_has_rtcp_mode();
        inline void set_has_remb();
        inline void clear_has_remb();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint32 remote_ssrc_;
        ::google::protobuf::uint32 local_ssrc_;
        int rtcp_mode_;
        bool remb_;
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtxMap> rtx_map_;
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension> header_extensions_;
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::DecoderConfig> decoders_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static VideoReceiveConfig* default_instance_;
    };
    // -------------------------------------------------------------------

    class DecoderConfig : public ::google::protobuf::MessageLite {
    public:
        DecoderConfig();
        virtual ~DecoderConfig();

        DecoderConfig(const DecoderConfig& from);

        inline DecoderConfig& operator=(const DecoderConfig& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const DecoderConfig& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const DecoderConfig* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(DecoderConfig* other);

        // implements Message ----------------------------------------------

        inline DecoderConfig* New() const { return New(NULL); }

        DecoderConfig* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const DecoderConfig& from);
        void MergeFrom(const DecoderConfig& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(DecoderConfig* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional string name = 1;
        bool has_name() const;
        void clear_name();
        static const int kNameFieldNumber = 1;
        const ::std::string& name() const;
        void set_name(const ::std::string& value);
        void set_name(const char* value);
        void set_name(const char* value, size_t size);
        ::std::string* mutable_name();
        ::std::string* release_name();
        void set_allocated_name(::std::string* name);

        // optional int32 payload_type = 2;
        bool has_payload_type() const;
        void clear_payload_type();
        static const int kPayloadTypeFieldNumber = 2;
        ::google::protobuf::int32 payload_type() const;
        void set_payload_type(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.DecoderConfig)
    private:
        inline void set_has_name();
        inline void clear_has_name();
        inline void set_has_payload_type();
        inline void clear_has_payload_type();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr name_;
        ::google::protobuf::int32 payload_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static DecoderConfig* default_instance_;
    };
    // -------------------------------------------------------------------

    class RtpHeaderExtension : public ::google::protobuf::MessageLite {
    public:
        RtpHeaderExtension();
        virtual ~RtpHeaderExtension();

        RtpHeaderExtension(const RtpHeaderExtension& from);

        inline RtpHeaderExtension& operator=(const RtpHeaderExtension& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RtpHeaderExtension& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RtpHeaderExtension* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RtpHeaderExtension* other);

        // implements Message ----------------------------------------------

        inline RtpHeaderExtension* New() const { return New(NULL); }

        RtpHeaderExtension* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RtpHeaderExtension& from);
        void MergeFrom(const RtpHeaderExtension& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RtpHeaderExtension* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional string name = 1;
        bool has_name() const;
        void clear_name();
        static const int kNameFieldNumber = 1;
        const ::std::string& name() const;
        void set_name(const ::std::string& value);
        void set_name(const char* value);
        void set_name(const char* value, size_t size);
        ::std::string* mutable_name();
        ::std::string* release_name();
        void set_allocated_name(::std::string* name);

        // optional int32 id = 2;
        bool has_id() const;
        void clear_id();
        static const int kIdFieldNumber = 2;
        ::google::protobuf::int32 id() const;
        void set_id(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.RtpHeaderExtension)
    private:
        inline void set_has_name();
        inline void clear_has_name();
        inline void set_has_id();
        inline void clear_has_id();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr name_;
        ::google::protobuf::int32 id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static RtpHeaderExtension* default_instance_;
    };
    // -------------------------------------------------------------------

    class RtxConfig : public ::google::protobuf::MessageLite {
    public:
        RtxConfig();
        virtual ~RtxConfig();

        RtxConfig(const RtxConfig& from);

        inline RtxConfig& operator=(const RtxConfig& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RtxConfig& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RtxConfig* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RtxConfig* other);

        // implements Message ----------------------------------------------

        inline RtxConfig* New() const { return New(NULL); }

        RtxConfig* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RtxConfig& from);
        void MergeFrom(const RtxConfig& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RtxConfig* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional uint32 rtx_ssrc = 1;
        bool has_rtx_ssrc() const;
        void clear_rtx_ssrc();
        static const int kRtxSsrcFieldNumber = 1;
        ::google::protobuf::uint32 rtx_ssrc() const;
        void set_rtx_ssrc(::google::protobuf::uint32 value);

        // optional int32 rtx_payload_type = 2;
        bool has_rtx_payload_type() const;
        void clear_rtx_payload_type();
        static const int kRtxPayloadTypeFieldNumber = 2;
        ::google::protobuf::int32 rtx_payload_type() const;
        void set_rtx_payload_type(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.RtxConfig)
    private:
        inline void set_has_rtx_ssrc();
        inline void clear_has_rtx_ssrc();
        inline void set_has_rtx_payload_type();
        inline void clear_has_rtx_payload_type();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint32 rtx_ssrc_;
        ::google::protobuf::int32 rtx_payload_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static RtxConfig* default_instance_;
    };
    // -------------------------------------------------------------------

    class RtxMap : public ::google::protobuf::MessageLite {
    public:
        RtxMap();
        virtual ~RtxMap();

        RtxMap(const RtxMap& from);

        inline RtxMap& operator=(const RtxMap& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RtxMap& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RtxMap* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RtxMap* other);

        // implements Message ----------------------------------------------

        inline RtxMap* New() const { return New(NULL); }

        RtxMap* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RtxMap& from);
        void MergeFrom(const RtxMap& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RtxMap* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 payload_type = 1;
        bool has_payload_type() const;
        void clear_payload_type();
        static const int kPayloadTypeFieldNumber = 1;
        ::google::protobuf::int32 payload_type() const;
        void set_payload_type(::google::protobuf::int32 value);

        // optional .webrtc.rtclog.RtxConfig config = 2;
        bool has_config() const;
        void clear_config();
        static const int kConfigFieldNumber = 2;
        const ::webrtc::rtclog::RtxConfig& config() const;
        ::webrtc::rtclog::RtxConfig* mutable_config();
        ::webrtc::rtclog::RtxConfig* release_config();
        void set_allocated_config(::webrtc::rtclog::RtxConfig* config);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.RtxMap)
    private:
        inline void set_has_payload_type();
        inline void clear_has_payload_type();
        inline void set_has_config();
        inline void clear_has_config();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::webrtc::rtclog::RtxConfig* config_;
        ::google::protobuf::int32 payload_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static RtxMap* default_instance_;
    };
    // -------------------------------------------------------------------

    class VideoSendConfig : public ::google::protobuf::MessageLite {
    public:
        VideoSendConfig();
        virtual ~VideoSendConfig();

        VideoSendConfig(const VideoSendConfig& from);

        inline VideoSendConfig& operator=(const VideoSendConfig& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const VideoSendConfig& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const VideoSendConfig* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(VideoSendConfig* other);

        // implements Message ----------------------------------------------

        inline VideoSendConfig* New() const { return New(NULL); }

        VideoSendConfig* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const VideoSendConfig& from);
        void MergeFrom(const VideoSendConfig& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(VideoSendConfig* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated uint32 ssrcs = 1;
        int ssrcs_size() const;
        void clear_ssrcs();
        static const int kSsrcsFieldNumber = 1;
        ::google::protobuf::uint32 ssrcs(int index) const;
        void set_ssrcs(int index, ::google::protobuf::uint32 value);
        void add_ssrcs(::google::protobuf::uint32 value);
        const ::google::protobuf::RepeatedField<::google::protobuf::uint32>&
        ssrcs() const;
        ::google::protobuf::RepeatedField<::google::protobuf::uint32>*
        mutable_ssrcs();

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
        int header_extensions_size() const;
        void clear_header_extensions();
        static const int kHeaderExtensionsFieldNumber = 2;
        const ::webrtc::rtclog::RtpHeaderExtension& header_extensions(int index) const;
        ::webrtc::rtclog::RtpHeaderExtension* mutable_header_extensions(int index);
        ::webrtc::rtclog::RtpHeaderExtension* add_header_extensions();
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
        mutable_header_extensions();
        const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
        header_extensions() const;

        // repeated uint32 rtx_ssrcs = 3;
        int rtx_ssrcs_size() const;
        void clear_rtx_ssrcs();
        static const int kRtxSsrcsFieldNumber = 3;
        ::google::protobuf::uint32 rtx_ssrcs(int index) const;
        void set_rtx_ssrcs(int index, ::google::protobuf::uint32 value);
        void add_rtx_ssrcs(::google::protobuf::uint32 value);
        const ::google::protobuf::RepeatedField<::google::protobuf::uint32>&
        rtx_ssrcs() const;
        ::google::protobuf::RepeatedField<::google::protobuf::uint32>*
        mutable_rtx_ssrcs();

        // optional int32 rtx_payload_type = 4;
        bool has_rtx_payload_type() const;
        void clear_rtx_payload_type();
        static const int kRtxPayloadTypeFieldNumber = 4;
        ::google::protobuf::int32 rtx_payload_type() const;
        void set_rtx_payload_type(::google::protobuf::int32 value);

        // optional .webrtc.rtclog.EncoderConfig encoder = 5;
        bool has_encoder() const;
        void clear_encoder();
        static const int kEncoderFieldNumber = 5;
        const ::webrtc::rtclog::EncoderConfig& encoder() const;
        ::webrtc::rtclog::EncoderConfig* mutable_encoder();
        ::webrtc::rtclog::EncoderConfig* release_encoder();
        void set_allocated_encoder(::webrtc::rtclog::EncoderConfig* encoder);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.VideoSendConfig)
    private:
        inline void set_has_rtx_payload_type();
        inline void clear_has_rtx_payload_type();
        inline void set_has_encoder();
        inline void clear_has_encoder();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedField<::google::protobuf::uint32> ssrcs_;
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension> header_extensions_;
        ::google::protobuf::RepeatedField<::google::protobuf::uint32> rtx_ssrcs_;
        ::webrtc::rtclog::EncoderConfig* encoder_;
        ::google::protobuf::int32 rtx_payload_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static VideoSendConfig* default_instance_;
    };
    // -------------------------------------------------------------------

    class EncoderConfig : public ::google::protobuf::MessageLite {
    public:
        EncoderConfig();
        virtual ~EncoderConfig();

        EncoderConfig(const EncoderConfig& from);

        inline EncoderConfig& operator=(const EncoderConfig& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const EncoderConfig& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const EncoderConfig* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(EncoderConfig* other);

        // implements Message ----------------------------------------------

        inline EncoderConfig* New() const { return New(NULL); }

        EncoderConfig* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const EncoderConfig& from);
        void MergeFrom(const EncoderConfig& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(EncoderConfig* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional string name = 1;
        bool has_name() const;
        void clear_name();
        static const int kNameFieldNumber = 1;
        const ::std::string& name() const;
        void set_name(const ::std::string& value);
        void set_name(const char* value);
        void set_name(const char* value, size_t size);
        ::std::string* mutable_name();
        ::std::string* release_name();
        void set_allocated_name(::std::string* name);

        // optional int32 payload_type = 2;
        bool has_payload_type() const;
        void clear_payload_type();
        static const int kPayloadTypeFieldNumber = 2;
        ::google::protobuf::int32 payload_type() const;
        void set_payload_type(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.EncoderConfig)
    private:
        inline void set_has_name();
        inline void clear_has_name();
        inline void set_has_payload_type();
        inline void clear_has_payload_type();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr name_;
        ::google::protobuf::int32 payload_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static EncoderConfig* default_instance_;
    };
    // -------------------------------------------------------------------

    class AudioReceiveConfig : public ::google::protobuf::MessageLite {
    public:
        AudioReceiveConfig();
        virtual ~AudioReceiveConfig();

        AudioReceiveConfig(const AudioReceiveConfig& from);

        inline AudioReceiveConfig& operator=(const AudioReceiveConfig& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const AudioReceiveConfig& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const AudioReceiveConfig* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(AudioReceiveConfig* other);

        // implements Message ----------------------------------------------

        inline AudioReceiveConfig* New() const { return New(NULL); }

        AudioReceiveConfig* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const AudioReceiveConfig& from);
        void MergeFrom(const AudioReceiveConfig& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(AudioReceiveConfig* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional uint32 remote_ssrc = 1;
        bool has_remote_ssrc() const;
        void clear_remote_ssrc();
        static const int kRemoteSsrcFieldNumber = 1;
        ::google::protobuf::uint32 remote_ssrc() const;
        void set_remote_ssrc(::google::protobuf::uint32 value);

        // optional uint32 local_ssrc = 2;
        bool has_local_ssrc() const;
        void clear_local_ssrc();
        static const int kLocalSsrcFieldNumber = 2;
        ::google::protobuf::uint32 local_ssrc() const;
        void set_local_ssrc(::google::protobuf::uint32 value);

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 3;
        int header_extensions_size() const;
        void clear_header_extensions();
        static const int kHeaderExtensionsFieldNumber = 3;
        const ::webrtc::rtclog::RtpHeaderExtension& header_extensions(int index) const;
        ::webrtc::rtclog::RtpHeaderExtension* mutable_header_extensions(int index);
        ::webrtc::rtclog::RtpHeaderExtension* add_header_extensions();
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
        mutable_header_extensions();
        const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
        header_extensions() const;

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.AudioReceiveConfig)
    private:
        inline void set_has_remote_ssrc();
        inline void clear_has_remote_ssrc();
        inline void set_has_local_ssrc();
        inline void clear_has_local_ssrc();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint32 remote_ssrc_;
        ::google::protobuf::uint32 local_ssrc_;
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension> header_extensions_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static AudioReceiveConfig* default_instance_;
    };
    // -------------------------------------------------------------------

    class AudioSendConfig : public ::google::protobuf::MessageLite {
    public:
        AudioSendConfig();
        virtual ~AudioSendConfig();

        AudioSendConfig(const AudioSendConfig& from);

        inline AudioSendConfig& operator=(const AudioSendConfig& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const AudioSendConfig& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const AudioSendConfig* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(AudioSendConfig* other);

        // implements Message ----------------------------------------------

        inline AudioSendConfig* New() const { return New(NULL); }

        AudioSendConfig* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const AudioSendConfig& from);
        void MergeFrom(const AudioSendConfig& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(AudioSendConfig* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional uint32 ssrc = 1;
        bool has_ssrc() const;
        void clear_ssrc();
        static const int kSsrcFieldNumber = 1;
        ::google::protobuf::uint32 ssrc() const;
        void set_ssrc(::google::protobuf::uint32 value);

        // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
        int header_extensions_size() const;
        void clear_header_extensions();
        static const int kHeaderExtensionsFieldNumber = 2;
        const ::webrtc::rtclog::RtpHeaderExtension& header_extensions(int index) const;
        ::webrtc::rtclog::RtpHeaderExtension* mutable_header_extensions(int index);
        ::webrtc::rtclog::RtpHeaderExtension* add_header_extensions();
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
        mutable_header_extensions();
        const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
        header_extensions() const;

        // @@protoc_insertion_point(class_scope:webrtc.rtclog.AudioSendConfig)
    private:
        inline void set_has_ssrc();
        inline void clear_has_ssrc();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension> header_extensions_;
        ::google::protobuf::uint32 ssrc_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto_impl();
#else
        friend void protobuf_AddDesc_rtc_5fevent_5flog_2eproto();
#endif
        friend void protobuf_AssignDesc_rtc_5fevent_5flog_2eproto();
        friend void protobuf_ShutdownFile_rtc_5fevent_5flog_2eproto();

        void InitAsDefaultInstance();
        static AudioSendConfig* default_instance_;
    };
    // ===================================================================

    // ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
    // EventStream

    // repeated .webrtc.rtclog.Event stream = 1;
    inline int EventStream::stream_size() const
    {
        return stream_.size();
    }
    inline void EventStream::clear_stream()
    {
        stream_.Clear();
    }
    inline const ::webrtc::rtclog::Event& EventStream::stream(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.EventStream.stream)
        return stream_.Get(index);
    }
    inline ::webrtc::rtclog::Event* EventStream::mutable_stream(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.EventStream.stream)
        return stream_.Mutable(index);
    }
    inline ::webrtc::rtclog::Event* EventStream::add_stream()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.EventStream.stream)
        return stream_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::Event>*
    EventStream::mutable_stream()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.EventStream.stream)
        return &stream_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::Event>&
    EventStream::stream() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.EventStream.stream)
        return stream_;
    }

    // -------------------------------------------------------------------

    // Event

    // optional int64 timestamp_us = 1;
    inline bool Event::has_timestamp_us() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Event::set_has_timestamp_us()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Event::clear_has_timestamp_us()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Event::clear_timestamp_us()
    {
        timestamp_us_ = GOOGLE_LONGLONG(0);
        clear_has_timestamp_us();
    }
    inline ::google::protobuf::int64 Event::timestamp_us() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.timestamp_us)
        return timestamp_us_;
    }
    inline void Event::set_timestamp_us(::google::protobuf::int64 value)
    {
        set_has_timestamp_us();
        timestamp_us_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.Event.timestamp_us)
    }

    // optional .webrtc.rtclog.Event.EventType type = 2;
    inline bool Event::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Event::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Event::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Event::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    inline ::webrtc::rtclog::Event_EventType Event::type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.type)
        return static_cast<::webrtc::rtclog::Event_EventType>(type_);
    }
    inline void Event::set_type(::webrtc::rtclog::Event_EventType value)
    {
        assert(::webrtc::rtclog::Event_EventType_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.Event.type)
    }

    // optional .webrtc.rtclog.RtpPacket rtp_packet = 3;
    inline bool Event::has_rtp_packet() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Event::set_has_rtp_packet()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Event::clear_has_rtp_packet()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Event::clear_rtp_packet()
    {
        if (rtp_packet_ != NULL)
            rtp_packet_->::webrtc::rtclog::RtpPacket::Clear();
        clear_has_rtp_packet();
    }
    inline const ::webrtc::rtclog::RtpPacket& Event::rtp_packet() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.rtp_packet)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return rtp_packet_ != NULL ? *rtp_packet_ : *default_instance().rtp_packet_;
#else
        return rtp_packet_ != NULL ? *rtp_packet_ : *default_instance_->rtp_packet_;
#endif
    }
    inline ::webrtc::rtclog::RtpPacket* Event::mutable_rtp_packet()
    {
        set_has_rtp_packet();
        if (rtp_packet_ == NULL) {
            rtp_packet_ = new ::webrtc::rtclog::RtpPacket;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.rtp_packet)
        return rtp_packet_;
    }
    inline ::webrtc::rtclog::RtpPacket* Event::release_rtp_packet()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.rtp_packet)
        clear_has_rtp_packet();
        ::webrtc::rtclog::RtpPacket* temp = rtp_packet_;
        rtp_packet_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_rtp_packet(::webrtc::rtclog::RtpPacket* rtp_packet)
    {
        delete rtp_packet_;
        rtp_packet_ = rtp_packet;
        if (rtp_packet) {
            set_has_rtp_packet();
        } else {
            clear_has_rtp_packet();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.rtp_packet)
    }

    // optional .webrtc.rtclog.RtcpPacket rtcp_packet = 4;
    inline bool Event::has_rtcp_packet() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void Event::set_has_rtcp_packet()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void Event::clear_has_rtcp_packet()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void Event::clear_rtcp_packet()
    {
        if (rtcp_packet_ != NULL)
            rtcp_packet_->::webrtc::rtclog::RtcpPacket::Clear();
        clear_has_rtcp_packet();
    }
    inline const ::webrtc::rtclog::RtcpPacket& Event::rtcp_packet() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.rtcp_packet)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return rtcp_packet_ != NULL ? *rtcp_packet_ : *default_instance().rtcp_packet_;
#else
        return rtcp_packet_ != NULL ? *rtcp_packet_ : *default_instance_->rtcp_packet_;
#endif
    }
    inline ::webrtc::rtclog::RtcpPacket* Event::mutable_rtcp_packet()
    {
        set_has_rtcp_packet();
        if (rtcp_packet_ == NULL) {
            rtcp_packet_ = new ::webrtc::rtclog::RtcpPacket;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.rtcp_packet)
        return rtcp_packet_;
    }
    inline ::webrtc::rtclog::RtcpPacket* Event::release_rtcp_packet()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.rtcp_packet)
        clear_has_rtcp_packet();
        ::webrtc::rtclog::RtcpPacket* temp = rtcp_packet_;
        rtcp_packet_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_rtcp_packet(::webrtc::rtclog::RtcpPacket* rtcp_packet)
    {
        delete rtcp_packet_;
        rtcp_packet_ = rtcp_packet;
        if (rtcp_packet) {
            set_has_rtcp_packet();
        } else {
            clear_has_rtcp_packet();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.rtcp_packet)
    }

    // optional .webrtc.rtclog.AudioPlayoutEvent audio_playout_event = 5;
    inline bool Event::has_audio_playout_event() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void Event::set_has_audio_playout_event()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void Event::clear_has_audio_playout_event()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void Event::clear_audio_playout_event()
    {
        if (audio_playout_event_ != NULL)
            audio_playout_event_->::webrtc::rtclog::AudioPlayoutEvent::Clear();
        clear_has_audio_playout_event();
    }
    inline const ::webrtc::rtclog::AudioPlayoutEvent& Event::audio_playout_event() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.audio_playout_event)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return audio_playout_event_ != NULL ? *audio_playout_event_ : *default_instance().audio_playout_event_;
#else
        return audio_playout_event_ != NULL ? *audio_playout_event_ : *default_instance_->audio_playout_event_;
#endif
    }
    inline ::webrtc::rtclog::AudioPlayoutEvent* Event::mutable_audio_playout_event()
    {
        set_has_audio_playout_event();
        if (audio_playout_event_ == NULL) {
            audio_playout_event_ = new ::webrtc::rtclog::AudioPlayoutEvent;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.audio_playout_event)
        return audio_playout_event_;
    }
    inline ::webrtc::rtclog::AudioPlayoutEvent* Event::release_audio_playout_event()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.audio_playout_event)
        clear_has_audio_playout_event();
        ::webrtc::rtclog::AudioPlayoutEvent* temp = audio_playout_event_;
        audio_playout_event_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_audio_playout_event(::webrtc::rtclog::AudioPlayoutEvent* audio_playout_event)
    {
        delete audio_playout_event_;
        audio_playout_event_ = audio_playout_event;
        if (audio_playout_event) {
            set_has_audio_playout_event();
        } else {
            clear_has_audio_playout_event();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.audio_playout_event)
    }

    // optional .webrtc.rtclog.BwePacketLossEvent bwe_packet_loss_event = 6;
    inline bool Event::has_bwe_packet_loss_event() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void Event::set_has_bwe_packet_loss_event()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void Event::clear_has_bwe_packet_loss_event()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void Event::clear_bwe_packet_loss_event()
    {
        if (bwe_packet_loss_event_ != NULL)
            bwe_packet_loss_event_->::webrtc::rtclog::BwePacketLossEvent::Clear();
        clear_has_bwe_packet_loss_event();
    }
    inline const ::webrtc::rtclog::BwePacketLossEvent& Event::bwe_packet_loss_event() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.bwe_packet_loss_event)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bwe_packet_loss_event_ != NULL ? *bwe_packet_loss_event_ : *default_instance().bwe_packet_loss_event_;
#else
        return bwe_packet_loss_event_ != NULL ? *bwe_packet_loss_event_ : *default_instance_->bwe_packet_loss_event_;
#endif
    }
    inline ::webrtc::rtclog::BwePacketLossEvent* Event::mutable_bwe_packet_loss_event()
    {
        set_has_bwe_packet_loss_event();
        if (bwe_packet_loss_event_ == NULL) {
            bwe_packet_loss_event_ = new ::webrtc::rtclog::BwePacketLossEvent;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.bwe_packet_loss_event)
        return bwe_packet_loss_event_;
    }
    inline ::webrtc::rtclog::BwePacketLossEvent* Event::release_bwe_packet_loss_event()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.bwe_packet_loss_event)
        clear_has_bwe_packet_loss_event();
        ::webrtc::rtclog::BwePacketLossEvent* temp = bwe_packet_loss_event_;
        bwe_packet_loss_event_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_bwe_packet_loss_event(::webrtc::rtclog::BwePacketLossEvent* bwe_packet_loss_event)
    {
        delete bwe_packet_loss_event_;
        bwe_packet_loss_event_ = bwe_packet_loss_event;
        if (bwe_packet_loss_event) {
            set_has_bwe_packet_loss_event();
        } else {
            clear_has_bwe_packet_loss_event();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.bwe_packet_loss_event)
    }

    // optional .webrtc.rtclog.VideoReceiveConfig video_receiver_config = 8;
    inline bool Event::has_video_receiver_config() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void Event::set_has_video_receiver_config()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void Event::clear_has_video_receiver_config()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void Event::clear_video_receiver_config()
    {
        if (video_receiver_config_ != NULL)
            video_receiver_config_->::webrtc::rtclog::VideoReceiveConfig::Clear();
        clear_has_video_receiver_config();
    }
    inline const ::webrtc::rtclog::VideoReceiveConfig& Event::video_receiver_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.video_receiver_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return video_receiver_config_ != NULL ? *video_receiver_config_ : *default_instance().video_receiver_config_;
#else
        return video_receiver_config_ != NULL ? *video_receiver_config_ : *default_instance_->video_receiver_config_;
#endif
    }
    inline ::webrtc::rtclog::VideoReceiveConfig* Event::mutable_video_receiver_config()
    {
        set_has_video_receiver_config();
        if (video_receiver_config_ == NULL) {
            video_receiver_config_ = new ::webrtc::rtclog::VideoReceiveConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.video_receiver_config)
        return video_receiver_config_;
    }
    inline ::webrtc::rtclog::VideoReceiveConfig* Event::release_video_receiver_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.video_receiver_config)
        clear_has_video_receiver_config();
        ::webrtc::rtclog::VideoReceiveConfig* temp = video_receiver_config_;
        video_receiver_config_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_video_receiver_config(::webrtc::rtclog::VideoReceiveConfig* video_receiver_config)
    {
        delete video_receiver_config_;
        video_receiver_config_ = video_receiver_config;
        if (video_receiver_config) {
            set_has_video_receiver_config();
        } else {
            clear_has_video_receiver_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.video_receiver_config)
    }

    // optional .webrtc.rtclog.VideoSendConfig video_sender_config = 9;
    inline bool Event::has_video_sender_config() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void Event::set_has_video_sender_config()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void Event::clear_has_video_sender_config()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void Event::clear_video_sender_config()
    {
        if (video_sender_config_ != NULL)
            video_sender_config_->::webrtc::rtclog::VideoSendConfig::Clear();
        clear_has_video_sender_config();
    }
    inline const ::webrtc::rtclog::VideoSendConfig& Event::video_sender_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.video_sender_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return video_sender_config_ != NULL ? *video_sender_config_ : *default_instance().video_sender_config_;
#else
        return video_sender_config_ != NULL ? *video_sender_config_ : *default_instance_->video_sender_config_;
#endif
    }
    inline ::webrtc::rtclog::VideoSendConfig* Event::mutable_video_sender_config()
    {
        set_has_video_sender_config();
        if (video_sender_config_ == NULL) {
            video_sender_config_ = new ::webrtc::rtclog::VideoSendConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.video_sender_config)
        return video_sender_config_;
    }
    inline ::webrtc::rtclog::VideoSendConfig* Event::release_video_sender_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.video_sender_config)
        clear_has_video_sender_config();
        ::webrtc::rtclog::VideoSendConfig* temp = video_sender_config_;
        video_sender_config_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_video_sender_config(::webrtc::rtclog::VideoSendConfig* video_sender_config)
    {
        delete video_sender_config_;
        video_sender_config_ = video_sender_config;
        if (video_sender_config) {
            set_has_video_sender_config();
        } else {
            clear_has_video_sender_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.video_sender_config)
    }

    // optional .webrtc.rtclog.AudioReceiveConfig audio_receiver_config = 10;
    inline bool Event::has_audio_receiver_config() const
    {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void Event::set_has_audio_receiver_config()
    {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void Event::clear_has_audio_receiver_config()
    {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void Event::clear_audio_receiver_config()
    {
        if (audio_receiver_config_ != NULL)
            audio_receiver_config_->::webrtc::rtclog::AudioReceiveConfig::Clear();
        clear_has_audio_receiver_config();
    }
    inline const ::webrtc::rtclog::AudioReceiveConfig& Event::audio_receiver_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.audio_receiver_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return audio_receiver_config_ != NULL ? *audio_receiver_config_ : *default_instance().audio_receiver_config_;
#else
        return audio_receiver_config_ != NULL ? *audio_receiver_config_ : *default_instance_->audio_receiver_config_;
#endif
    }
    inline ::webrtc::rtclog::AudioReceiveConfig* Event::mutable_audio_receiver_config()
    {
        set_has_audio_receiver_config();
        if (audio_receiver_config_ == NULL) {
            audio_receiver_config_ = new ::webrtc::rtclog::AudioReceiveConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.audio_receiver_config)
        return audio_receiver_config_;
    }
    inline ::webrtc::rtclog::AudioReceiveConfig* Event::release_audio_receiver_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.audio_receiver_config)
        clear_has_audio_receiver_config();
        ::webrtc::rtclog::AudioReceiveConfig* temp = audio_receiver_config_;
        audio_receiver_config_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_audio_receiver_config(::webrtc::rtclog::AudioReceiveConfig* audio_receiver_config)
    {
        delete audio_receiver_config_;
        audio_receiver_config_ = audio_receiver_config;
        if (audio_receiver_config) {
            set_has_audio_receiver_config();
        } else {
            clear_has_audio_receiver_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.audio_receiver_config)
    }

    // optional .webrtc.rtclog.AudioSendConfig audio_sender_config = 11;
    inline bool Event::has_audio_sender_config() const
    {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void Event::set_has_audio_sender_config()
    {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void Event::clear_has_audio_sender_config()
    {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void Event::clear_audio_sender_config()
    {
        if (audio_sender_config_ != NULL)
            audio_sender_config_->::webrtc::rtclog::AudioSendConfig::Clear();
        clear_has_audio_sender_config();
    }
    inline const ::webrtc::rtclog::AudioSendConfig& Event::audio_sender_config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.Event.audio_sender_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return audio_sender_config_ != NULL ? *audio_sender_config_ : *default_instance().audio_sender_config_;
#else
        return audio_sender_config_ != NULL ? *audio_sender_config_ : *default_instance_->audio_sender_config_;
#endif
    }
    inline ::webrtc::rtclog::AudioSendConfig* Event::mutable_audio_sender_config()
    {
        set_has_audio_sender_config();
        if (audio_sender_config_ == NULL) {
            audio_sender_config_ = new ::webrtc::rtclog::AudioSendConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.Event.audio_sender_config)
        return audio_sender_config_;
    }
    inline ::webrtc::rtclog::AudioSendConfig* Event::release_audio_sender_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.Event.audio_sender_config)
        clear_has_audio_sender_config();
        ::webrtc::rtclog::AudioSendConfig* temp = audio_sender_config_;
        audio_sender_config_ = NULL;
        return temp;
    }
    inline void Event::set_allocated_audio_sender_config(::webrtc::rtclog::AudioSendConfig* audio_sender_config)
    {
        delete audio_sender_config_;
        audio_sender_config_ = audio_sender_config;
        if (audio_sender_config) {
            set_has_audio_sender_config();
        } else {
            clear_has_audio_sender_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.Event.audio_sender_config)
    }

    // -------------------------------------------------------------------

    // RtpPacket

    // optional bool incoming = 1;
    inline bool RtpPacket::has_incoming() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RtpPacket::set_has_incoming()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RtpPacket::clear_has_incoming()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RtpPacket::clear_incoming()
    {
        incoming_ = false;
        clear_has_incoming();
    }
    inline bool RtpPacket::incoming() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.incoming)
        return incoming_;
    }
    inline void RtpPacket::set_incoming(bool value)
    {
        set_has_incoming();
        incoming_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.incoming)
    }

    // optional .webrtc.rtclog.MediaType type = 2;
    inline bool RtpPacket::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RtpPacket::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RtpPacket::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RtpPacket::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    inline ::webrtc::rtclog::MediaType RtpPacket::type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.type)
        return static_cast<::webrtc::rtclog::MediaType>(type_);
    }
    inline void RtpPacket::set_type(::webrtc::rtclog::MediaType value)
    {
        assert(::webrtc::rtclog::MediaType_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.type)
    }

    // optional uint32 packet_length = 3;
    inline bool RtpPacket::has_packet_length() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void RtpPacket::set_has_packet_length()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void RtpPacket::clear_has_packet_length()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void RtpPacket::clear_packet_length()
    {
        packet_length_ = 0u;
        clear_has_packet_length();
    }
    inline ::google::protobuf::uint32 RtpPacket::packet_length() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.packet_length)
        return packet_length_;
    }
    inline void RtpPacket::set_packet_length(::google::protobuf::uint32 value)
    {
        set_has_packet_length();
        packet_length_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.packet_length)
    }

    // optional bytes header = 4;
    inline bool RtpPacket::has_header() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void RtpPacket::set_has_header()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void RtpPacket::clear_has_header()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void RtpPacket::clear_header()
    {
        header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_header();
    }
    inline const ::std::string& RtpPacket::header() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpPacket.header)
        return header_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RtpPacket::set_header(const ::std::string& value)
    {
        set_has_header();
        header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpPacket.header)
    }
    inline void RtpPacket::set_header(const char* value)
    {
        set_has_header();
        header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.RtpPacket.header)
    }
    inline void RtpPacket::set_header(const void* value, size_t size)
    {
        set_has_header();
        header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.RtpPacket.header)
    }
    inline ::std::string* RtpPacket::mutable_header()
    {
        set_has_header();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtpPacket.header)
        return header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* RtpPacket::release_header()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtpPacket.header)
        clear_has_header();
        return header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RtpPacket::set_allocated_header(::std::string* header)
    {
        if (header != NULL) {
            set_has_header();
        } else {
            clear_has_header();
        }
        header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtpPacket.header)
    }

    // -------------------------------------------------------------------

    // RtcpPacket

    // optional bool incoming = 1;
    inline bool RtcpPacket::has_incoming() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RtcpPacket::set_has_incoming()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RtcpPacket::clear_has_incoming()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RtcpPacket::clear_incoming()
    {
        incoming_ = false;
        clear_has_incoming();
    }
    inline bool RtcpPacket::incoming() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtcpPacket.incoming)
        return incoming_;
    }
    inline void RtcpPacket::set_incoming(bool value)
    {
        set_has_incoming();
        incoming_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtcpPacket.incoming)
    }

    // optional .webrtc.rtclog.MediaType type = 2;
    inline bool RtcpPacket::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RtcpPacket::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RtcpPacket::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RtcpPacket::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    inline ::webrtc::rtclog::MediaType RtcpPacket::type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtcpPacket.type)
        return static_cast<::webrtc::rtclog::MediaType>(type_);
    }
    inline void RtcpPacket::set_type(::webrtc::rtclog::MediaType value)
    {
        assert(::webrtc::rtclog::MediaType_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtcpPacket.type)
    }

    // optional bytes packet_data = 3;
    inline bool RtcpPacket::has_packet_data() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void RtcpPacket::set_has_packet_data()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void RtcpPacket::clear_has_packet_data()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void RtcpPacket::clear_packet_data()
    {
        packet_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_packet_data();
    }
    inline const ::std::string& RtcpPacket::packet_data() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtcpPacket.packet_data)
        return packet_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RtcpPacket::set_packet_data(const ::std::string& value)
    {
        set_has_packet_data();
        packet_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtcpPacket.packet_data)
    }
    inline void RtcpPacket::set_packet_data(const char* value)
    {
        set_has_packet_data();
        packet_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.RtcpPacket.packet_data)
    }
    inline void RtcpPacket::set_packet_data(const void* value, size_t size)
    {
        set_has_packet_data();
        packet_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.RtcpPacket.packet_data)
    }
    inline ::std::string* RtcpPacket::mutable_packet_data()
    {
        set_has_packet_data();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtcpPacket.packet_data)
        return packet_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* RtcpPacket::release_packet_data()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtcpPacket.packet_data)
        clear_has_packet_data();
        return packet_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RtcpPacket::set_allocated_packet_data(::std::string* packet_data)
    {
        if (packet_data != NULL) {
            set_has_packet_data();
        } else {
            clear_has_packet_data();
        }
        packet_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packet_data);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtcpPacket.packet_data)
    }

    // -------------------------------------------------------------------

    // AudioPlayoutEvent

    // optional uint32 local_ssrc = 2;
    inline bool AudioPlayoutEvent::has_local_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AudioPlayoutEvent::set_has_local_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AudioPlayoutEvent::clear_has_local_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AudioPlayoutEvent::clear_local_ssrc()
    {
        local_ssrc_ = 0u;
        clear_has_local_ssrc();
    }
    inline ::google::protobuf::uint32 AudioPlayoutEvent::local_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioPlayoutEvent.local_ssrc)
        return local_ssrc_;
    }
    inline void AudioPlayoutEvent::set_local_ssrc(::google::protobuf::uint32 value)
    {
        set_has_local_ssrc();
        local_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioPlayoutEvent.local_ssrc)
    }

    // -------------------------------------------------------------------

    // BwePacketLossEvent

    // optional int32 bitrate = 1;
    inline bool BwePacketLossEvent::has_bitrate() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void BwePacketLossEvent::set_has_bitrate()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void BwePacketLossEvent::clear_has_bitrate()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void BwePacketLossEvent::clear_bitrate()
    {
        bitrate_ = 0;
        clear_has_bitrate();
    }
    inline ::google::protobuf::int32 BwePacketLossEvent::bitrate() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.BwePacketLossEvent.bitrate)
        return bitrate_;
    }
    inline void BwePacketLossEvent::set_bitrate(::google::protobuf::int32 value)
    {
        set_has_bitrate();
        bitrate_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.BwePacketLossEvent.bitrate)
    }

    // optional uint32 fraction_loss = 2;
    inline bool BwePacketLossEvent::has_fraction_loss() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void BwePacketLossEvent::set_has_fraction_loss()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void BwePacketLossEvent::clear_has_fraction_loss()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void BwePacketLossEvent::clear_fraction_loss()
    {
        fraction_loss_ = 0u;
        clear_has_fraction_loss();
    }
    inline ::google::protobuf::uint32 BwePacketLossEvent::fraction_loss() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.BwePacketLossEvent.fraction_loss)
        return fraction_loss_;
    }
    inline void BwePacketLossEvent::set_fraction_loss(::google::protobuf::uint32 value)
    {
        set_has_fraction_loss();
        fraction_loss_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.BwePacketLossEvent.fraction_loss)
    }

    // optional int32 total_packets = 3;
    inline bool BwePacketLossEvent::has_total_packets() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void BwePacketLossEvent::set_has_total_packets()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void BwePacketLossEvent::clear_has_total_packets()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void BwePacketLossEvent::clear_total_packets()
    {
        total_packets_ = 0;
        clear_has_total_packets();
    }
    inline ::google::protobuf::int32 BwePacketLossEvent::total_packets() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.BwePacketLossEvent.total_packets)
        return total_packets_;
    }
    inline void BwePacketLossEvent::set_total_packets(::google::protobuf::int32 value)
    {
        set_has_total_packets();
        total_packets_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.BwePacketLossEvent.total_packets)
    }

    // -------------------------------------------------------------------

    // VideoReceiveConfig

    // optional uint32 remote_ssrc = 1;
    inline bool VideoReceiveConfig::has_remote_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void VideoReceiveConfig::set_has_remote_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void VideoReceiveConfig::clear_has_remote_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void VideoReceiveConfig::clear_remote_ssrc()
    {
        remote_ssrc_ = 0u;
        clear_has_remote_ssrc();
    }
    inline ::google::protobuf::uint32 VideoReceiveConfig::remote_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.remote_ssrc)
        return remote_ssrc_;
    }
    inline void VideoReceiveConfig::set_remote_ssrc(::google::protobuf::uint32 value)
    {
        set_has_remote_ssrc();
        remote_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.remote_ssrc)
    }

    // optional uint32 local_ssrc = 2;
    inline bool VideoReceiveConfig::has_local_ssrc() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void VideoReceiveConfig::set_has_local_ssrc()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void VideoReceiveConfig::clear_has_local_ssrc()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void VideoReceiveConfig::clear_local_ssrc()
    {
        local_ssrc_ = 0u;
        clear_has_local_ssrc();
    }
    inline ::google::protobuf::uint32 VideoReceiveConfig::local_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.local_ssrc)
        return local_ssrc_;
    }
    inline void VideoReceiveConfig::set_local_ssrc(::google::protobuf::uint32 value)
    {
        set_has_local_ssrc();
        local_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.local_ssrc)
    }

    // optional .webrtc.rtclog.VideoReceiveConfig.RtcpMode rtcp_mode = 3;
    inline bool VideoReceiveConfig::has_rtcp_mode() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void VideoReceiveConfig::set_has_rtcp_mode()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void VideoReceiveConfig::clear_has_rtcp_mode()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void VideoReceiveConfig::clear_rtcp_mode()
    {
        rtcp_mode_ = 1;
        clear_has_rtcp_mode();
    }
    inline ::webrtc::rtclog::VideoReceiveConfig_RtcpMode VideoReceiveConfig::rtcp_mode() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.rtcp_mode)
        return static_cast<::webrtc::rtclog::VideoReceiveConfig_RtcpMode>(rtcp_mode_);
    }
    inline void VideoReceiveConfig::set_rtcp_mode(::webrtc::rtclog::VideoReceiveConfig_RtcpMode value)
    {
        assert(::webrtc::rtclog::VideoReceiveConfig_RtcpMode_IsValid(value));
        set_has_rtcp_mode();
        rtcp_mode_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.rtcp_mode)
    }

    // optional bool remb = 4;
    inline bool VideoReceiveConfig::has_remb() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void VideoReceiveConfig::set_has_remb()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void VideoReceiveConfig::clear_has_remb()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void VideoReceiveConfig::clear_remb()
    {
        remb_ = false;
        clear_has_remb();
    }
    inline bool VideoReceiveConfig::remb() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.remb)
        return remb_;
    }
    inline void VideoReceiveConfig::set_remb(bool value)
    {
        set_has_remb();
        remb_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoReceiveConfig.remb)
    }

    // repeated .webrtc.rtclog.RtxMap rtx_map = 5;
    inline int VideoReceiveConfig::rtx_map_size() const
    {
        return rtx_map_.size();
    }
    inline void VideoReceiveConfig::clear_rtx_map()
    {
        rtx_map_.Clear();
    }
    inline const ::webrtc::rtclog::RtxMap& VideoReceiveConfig::rtx_map(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_.Get(index);
    }
    inline ::webrtc::rtclog::RtxMap* VideoReceiveConfig::mutable_rtx_map(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_.Mutable(index);
    }
    inline ::webrtc::rtclog::RtxMap* VideoReceiveConfig::add_rtx_map()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtxMap>*
    VideoReceiveConfig::mutable_rtx_map()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return &rtx_map_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtxMap>&
    VideoReceiveConfig::rtx_map() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoReceiveConfig.rtx_map)
        return rtx_map_;
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 6;
    inline int VideoReceiveConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    inline void VideoReceiveConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    inline const ::webrtc::rtclog::RtpHeaderExtension& VideoReceiveConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* VideoReceiveConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* VideoReceiveConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    VideoReceiveConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return &header_extensions_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    VideoReceiveConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoReceiveConfig.header_extensions)
        return header_extensions_;
    }

    // repeated .webrtc.rtclog.DecoderConfig decoders = 7;
    inline int VideoReceiveConfig::decoders_size() const
    {
        return decoders_.size();
    }
    inline void VideoReceiveConfig::clear_decoders()
    {
        decoders_.Clear();
    }
    inline const ::webrtc::rtclog::DecoderConfig& VideoReceiveConfig::decoders(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_.Get(index);
    }
    inline ::webrtc::rtclog::DecoderConfig* VideoReceiveConfig::mutable_decoders(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_.Mutable(index);
    }
    inline ::webrtc::rtclog::DecoderConfig* VideoReceiveConfig::add_decoders()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::DecoderConfig>*
    VideoReceiveConfig::mutable_decoders()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoReceiveConfig.decoders)
        return &decoders_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::DecoderConfig>&
    VideoReceiveConfig::decoders() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoReceiveConfig.decoders)
        return decoders_;
    }

    // -------------------------------------------------------------------

    // DecoderConfig

    // optional string name = 1;
    inline bool DecoderConfig::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void DecoderConfig::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void DecoderConfig::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void DecoderConfig::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    inline const ::std::string& DecoderConfig::name() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.DecoderConfig.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void DecoderConfig::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.DecoderConfig.name)
    }
    inline void DecoderConfig::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.DecoderConfig.name)
    }
    inline void DecoderConfig::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.DecoderConfig.name)
    }
    inline ::std::string* DecoderConfig::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.DecoderConfig.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* DecoderConfig::release_name()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.DecoderConfig.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void DecoderConfig::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.DecoderConfig.name)
    }

    // optional int32 payload_type = 2;
    inline bool DecoderConfig::has_payload_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void DecoderConfig::set_has_payload_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void DecoderConfig::clear_has_payload_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void DecoderConfig::clear_payload_type()
    {
        payload_type_ = 0;
        clear_has_payload_type();
    }
    inline ::google::protobuf::int32 DecoderConfig::payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.DecoderConfig.payload_type)
        return payload_type_;
    }
    inline void DecoderConfig::set_payload_type(::google::protobuf::int32 value)
    {
        set_has_payload_type();
        payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.DecoderConfig.payload_type)
    }

    // -------------------------------------------------------------------

    // RtpHeaderExtension

    // optional string name = 1;
    inline bool RtpHeaderExtension::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RtpHeaderExtension::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RtpHeaderExtension::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RtpHeaderExtension::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    inline const ::std::string& RtpHeaderExtension::name() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpHeaderExtension.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RtpHeaderExtension::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpHeaderExtension.name)
    }
    inline void RtpHeaderExtension::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.RtpHeaderExtension.name)
    }
    inline void RtpHeaderExtension::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.RtpHeaderExtension.name)
    }
    inline ::std::string* RtpHeaderExtension::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtpHeaderExtension.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* RtpHeaderExtension::release_name()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtpHeaderExtension.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RtpHeaderExtension::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtpHeaderExtension.name)
    }

    // optional int32 id = 2;
    inline bool RtpHeaderExtension::has_id() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RtpHeaderExtension::set_has_id()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RtpHeaderExtension::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RtpHeaderExtension::clear_id()
    {
        id_ = 0;
        clear_has_id();
    }
    inline ::google::protobuf::int32 RtpHeaderExtension::id() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtpHeaderExtension.id)
        return id_;
    }
    inline void RtpHeaderExtension::set_id(::google::protobuf::int32 value)
    {
        set_has_id();
        id_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtpHeaderExtension.id)
    }

    // -------------------------------------------------------------------

    // RtxConfig

    // optional uint32 rtx_ssrc = 1;
    inline bool RtxConfig::has_rtx_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RtxConfig::set_has_rtx_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RtxConfig::clear_has_rtx_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RtxConfig::clear_rtx_ssrc()
    {
        rtx_ssrc_ = 0u;
        clear_has_rtx_ssrc();
    }
    inline ::google::protobuf::uint32 RtxConfig::rtx_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxConfig.rtx_ssrc)
        return rtx_ssrc_;
    }
    inline void RtxConfig::set_rtx_ssrc(::google::protobuf::uint32 value)
    {
        set_has_rtx_ssrc();
        rtx_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtxConfig.rtx_ssrc)
    }

    // optional int32 rtx_payload_type = 2;
    inline bool RtxConfig::has_rtx_payload_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RtxConfig::set_has_rtx_payload_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RtxConfig::clear_has_rtx_payload_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RtxConfig::clear_rtx_payload_type()
    {
        rtx_payload_type_ = 0;
        clear_has_rtx_payload_type();
    }
    inline ::google::protobuf::int32 RtxConfig::rtx_payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxConfig.rtx_payload_type)
        return rtx_payload_type_;
    }
    inline void RtxConfig::set_rtx_payload_type(::google::protobuf::int32 value)
    {
        set_has_rtx_payload_type();
        rtx_payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtxConfig.rtx_payload_type)
    }

    // -------------------------------------------------------------------

    // RtxMap

    // optional int32 payload_type = 1;
    inline bool RtxMap::has_payload_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RtxMap::set_has_payload_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RtxMap::clear_has_payload_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RtxMap::clear_payload_type()
    {
        payload_type_ = 0;
        clear_has_payload_type();
    }
    inline ::google::protobuf::int32 RtxMap::payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxMap.payload_type)
        return payload_type_;
    }
    inline void RtxMap::set_payload_type(::google::protobuf::int32 value)
    {
        set_has_payload_type();
        payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.RtxMap.payload_type)
    }

    // optional .webrtc.rtclog.RtxConfig config = 2;
    inline bool RtxMap::has_config() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RtxMap::set_has_config()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RtxMap::clear_has_config()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RtxMap::clear_config()
    {
        if (config_ != NULL)
            config_->::webrtc::rtclog::RtxConfig::Clear();
        clear_has_config();
    }
    inline const ::webrtc::rtclog::RtxConfig& RtxMap::config() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.RtxMap.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return config_ != NULL ? *config_ : *default_instance().config_;
#else
        return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
    }
    inline ::webrtc::rtclog::RtxConfig* RtxMap::mutable_config()
    {
        set_has_config();
        if (config_ == NULL) {
            config_ = new ::webrtc::rtclog::RtxConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.RtxMap.config)
        return config_;
    }
    inline ::webrtc::rtclog::RtxConfig* RtxMap::release_config()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.RtxMap.config)
        clear_has_config();
        ::webrtc::rtclog::RtxConfig* temp = config_;
        config_ = NULL;
        return temp;
    }
    inline void RtxMap::set_allocated_config(::webrtc::rtclog::RtxConfig* config)
    {
        delete config_;
        config_ = config;
        if (config) {
            set_has_config();
        } else {
            clear_has_config();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.RtxMap.config)
    }

    // -------------------------------------------------------------------

    // VideoSendConfig

    // repeated uint32 ssrcs = 1;
    inline int VideoSendConfig::ssrcs_size() const
    {
        return ssrcs_.size();
    }
    inline void VideoSendConfig::clear_ssrcs()
    {
        ssrcs_.Clear();
    }
    inline ::google::protobuf::uint32 VideoSendConfig::ssrcs(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.ssrcs)
        return ssrcs_.Get(index);
    }
    inline void VideoSendConfig::set_ssrcs(int index, ::google::protobuf::uint32 value)
    {
        ssrcs_.Set(index, value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoSendConfig.ssrcs)
    }
    inline void VideoSendConfig::add_ssrcs(::google::protobuf::uint32 value)
    {
        ssrcs_.Add(value);
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoSendConfig.ssrcs)
    }
    inline const ::google::protobuf::RepeatedField<::google::protobuf::uint32>&
    VideoSendConfig::ssrcs() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoSendConfig.ssrcs)
        return ssrcs_;
    }
    inline ::google::protobuf::RepeatedField<::google::protobuf::uint32>*
    VideoSendConfig::mutable_ssrcs()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoSendConfig.ssrcs)
        return &ssrcs_;
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
    inline int VideoSendConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    inline void VideoSendConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    inline const ::webrtc::rtclog::RtpHeaderExtension& VideoSendConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* VideoSendConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* VideoSendConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    VideoSendConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoSendConfig.header_extensions)
        return &header_extensions_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    VideoSendConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoSendConfig.header_extensions)
        return header_extensions_;
    }

    // repeated uint32 rtx_ssrcs = 3;
    inline int VideoSendConfig::rtx_ssrcs_size() const
    {
        return rtx_ssrcs_.size();
    }
    inline void VideoSendConfig::clear_rtx_ssrcs()
    {
        rtx_ssrcs_.Clear();
    }
    inline ::google::protobuf::uint32 VideoSendConfig::rtx_ssrcs(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
        return rtx_ssrcs_.Get(index);
    }
    inline void VideoSendConfig::set_rtx_ssrcs(int index, ::google::protobuf::uint32 value)
    {
        rtx_ssrcs_.Set(index, value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
    }
    inline void VideoSendConfig::add_rtx_ssrcs(::google::protobuf::uint32 value)
    {
        rtx_ssrcs_.Add(value);
        // @@protoc_insertion_point(field_add:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
    }
    inline const ::google::protobuf::RepeatedField<::google::protobuf::uint32>&
    VideoSendConfig::rtx_ssrcs() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
        return rtx_ssrcs_;
    }
    inline ::google::protobuf::RepeatedField<::google::protobuf::uint32>*
    VideoSendConfig::mutable_rtx_ssrcs()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.VideoSendConfig.rtx_ssrcs)
        return &rtx_ssrcs_;
    }

    // optional int32 rtx_payload_type = 4;
    inline bool VideoSendConfig::has_rtx_payload_type() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void VideoSendConfig::set_has_rtx_payload_type()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void VideoSendConfig::clear_has_rtx_payload_type()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void VideoSendConfig::clear_rtx_payload_type()
    {
        rtx_payload_type_ = 0;
        clear_has_rtx_payload_type();
    }
    inline ::google::protobuf::int32 VideoSendConfig::rtx_payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.rtx_payload_type)
        return rtx_payload_type_;
    }
    inline void VideoSendConfig::set_rtx_payload_type(::google::protobuf::int32 value)
    {
        set_has_rtx_payload_type();
        rtx_payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.VideoSendConfig.rtx_payload_type)
    }

    // optional .webrtc.rtclog.EncoderConfig encoder = 5;
    inline bool VideoSendConfig::has_encoder() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void VideoSendConfig::set_has_encoder()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void VideoSendConfig::clear_has_encoder()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void VideoSendConfig::clear_encoder()
    {
        if (encoder_ != NULL)
            encoder_->::webrtc::rtclog::EncoderConfig::Clear();
        clear_has_encoder();
    }
    inline const ::webrtc::rtclog::EncoderConfig& VideoSendConfig::encoder() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.VideoSendConfig.encoder)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return encoder_ != NULL ? *encoder_ : *default_instance().encoder_;
#else
        return encoder_ != NULL ? *encoder_ : *default_instance_->encoder_;
#endif
    }
    inline ::webrtc::rtclog::EncoderConfig* VideoSendConfig::mutable_encoder()
    {
        set_has_encoder();
        if (encoder_ == NULL) {
            encoder_ = new ::webrtc::rtclog::EncoderConfig;
        }
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.VideoSendConfig.encoder)
        return encoder_;
    }
    inline ::webrtc::rtclog::EncoderConfig* VideoSendConfig::release_encoder()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.VideoSendConfig.encoder)
        clear_has_encoder();
        ::webrtc::rtclog::EncoderConfig* temp = encoder_;
        encoder_ = NULL;
        return temp;
    }
    inline void VideoSendConfig::set_allocated_encoder(::webrtc::rtclog::EncoderConfig* encoder)
    {
        delete encoder_;
        encoder_ = encoder;
        if (encoder) {
            set_has_encoder();
        } else {
            clear_has_encoder();
        }
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.VideoSendConfig.encoder)
    }

    // -------------------------------------------------------------------

    // EncoderConfig

    // optional string name = 1;
    inline bool EncoderConfig::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void EncoderConfig::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void EncoderConfig::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void EncoderConfig::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    inline const ::std::string& EncoderConfig::name() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.EncoderConfig.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void EncoderConfig::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:webrtc.rtclog.EncoderConfig.name)
    }
    inline void EncoderConfig::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:webrtc.rtclog.EncoderConfig.name)
    }
    inline void EncoderConfig::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:webrtc.rtclog.EncoderConfig.name)
    }
    inline ::std::string* EncoderConfig::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.EncoderConfig.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* EncoderConfig::release_name()
    {
        // @@protoc_insertion_point(field_release:webrtc.rtclog.EncoderConfig.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void EncoderConfig::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog.EncoderConfig.name)
    }

    // optional int32 payload_type = 2;
    inline bool EncoderConfig::has_payload_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void EncoderConfig::set_has_payload_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void EncoderConfig::clear_has_payload_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void EncoderConfig::clear_payload_type()
    {
        payload_type_ = 0;
        clear_has_payload_type();
    }
    inline ::google::protobuf::int32 EncoderConfig::payload_type() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.EncoderConfig.payload_type)
        return payload_type_;
    }
    inline void EncoderConfig::set_payload_type(::google::protobuf::int32 value)
    {
        set_has_payload_type();
        payload_type_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.EncoderConfig.payload_type)
    }

    // -------------------------------------------------------------------

    // AudioReceiveConfig

    // optional uint32 remote_ssrc = 1;
    inline bool AudioReceiveConfig::has_remote_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AudioReceiveConfig::set_has_remote_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AudioReceiveConfig::clear_has_remote_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AudioReceiveConfig::clear_remote_ssrc()
    {
        remote_ssrc_ = 0u;
        clear_has_remote_ssrc();
    }
    inline ::google::protobuf::uint32 AudioReceiveConfig::remote_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioReceiveConfig.remote_ssrc)
        return remote_ssrc_;
    }
    inline void AudioReceiveConfig::set_remote_ssrc(::google::protobuf::uint32 value)
    {
        set_has_remote_ssrc();
        remote_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioReceiveConfig.remote_ssrc)
    }

    // optional uint32 local_ssrc = 2;
    inline bool AudioReceiveConfig::has_local_ssrc() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void AudioReceiveConfig::set_has_local_ssrc()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void AudioReceiveConfig::clear_has_local_ssrc()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void AudioReceiveConfig::clear_local_ssrc()
    {
        local_ssrc_ = 0u;
        clear_has_local_ssrc();
    }
    inline ::google::protobuf::uint32 AudioReceiveConfig::local_ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioReceiveConfig.local_ssrc)
        return local_ssrc_;
    }
    inline void AudioReceiveConfig::set_local_ssrc(::google::protobuf::uint32 value)
    {
        set_has_local_ssrc();
        local_ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioReceiveConfig.local_ssrc)
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 3;
    inline int AudioReceiveConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    inline void AudioReceiveConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    inline const ::webrtc::rtclog::RtpHeaderExtension& AudioReceiveConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* AudioReceiveConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* AudioReceiveConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    AudioReceiveConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return &header_extensions_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    AudioReceiveConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.AudioReceiveConfig.header_extensions)
        return header_extensions_;
    }

    // -------------------------------------------------------------------

    // AudioSendConfig

    // optional uint32 ssrc = 1;
    inline bool AudioSendConfig::has_ssrc() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void AudioSendConfig::set_has_ssrc()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void AudioSendConfig::clear_has_ssrc()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void AudioSendConfig::clear_ssrc()
    {
        ssrc_ = 0u;
        clear_has_ssrc();
    }
    inline ::google::protobuf::uint32 AudioSendConfig::ssrc() const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioSendConfig.ssrc)
        return ssrc_;
    }
    inline void AudioSendConfig::set_ssrc(::google::protobuf::uint32 value)
    {
        set_has_ssrc();
        ssrc_ = value;
        // @@protoc_insertion_point(field_set:webrtc.rtclog.AudioSendConfig.ssrc)
    }

    // repeated .webrtc.rtclog.RtpHeaderExtension header_extensions = 2;
    inline int AudioSendConfig::header_extensions_size() const
    {
        return header_extensions_.size();
    }
    inline void AudioSendConfig::clear_header_extensions()
    {
        header_extensions_.Clear();
    }
    inline const ::webrtc::rtclog::RtpHeaderExtension& AudioSendConfig::header_extensions(int index) const
    {
        // @@protoc_insertion_point(field_get:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_.Get(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* AudioSendConfig::mutable_header_extensions(int index)
    {
        // @@protoc_insertion_point(field_mutable:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_.Mutable(index);
    }
    inline ::webrtc::rtclog::RtpHeaderExtension* AudioSendConfig::add_header_extensions()
    {
        // @@protoc_insertion_point(field_add:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>*
    AudioSendConfig::mutable_header_extensions()
    {
        // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog.AudioSendConfig.header_extensions)
        return &header_extensions_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog::RtpHeaderExtension>&
    AudioSendConfig::header_extensions() const
    {
        // @@protoc_insertion_point(field_list:webrtc.rtclog.AudioSendConfig.header_extensions)
        return header_extensions_;
    }

#endif // !PROTOBUF_INLINE_NOT_IN_HEADERS
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

} // namespace rtclog
} // namespace webrtc

#ifndef SWIG
namespace google {
namespace protobuf {

    template <>
    struct is_proto_enum<::webrtc::rtclog::Event_EventType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::webrtc::rtclog::VideoReceiveConfig_RtcpMode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::webrtc::rtclog::MediaType> : ::google::protobuf::internal::true_type {
    };

} // namespace protobuf
} // namespace google
#endif // SWIG

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_rtc_5fevent_5flog_2eproto__INCLUDED
