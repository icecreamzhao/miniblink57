// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: display_item.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "display_item.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace cc {
namespace proto {

    void protobuf_ShutdownFile_display_5fitem_2eproto()
    {
        delete DisplayItemListSettings::default_instance_;
        delete DisplayItemList::default_instance_;
        delete DisplayItem::default_instance_;
        delete ClipDisplayItem::default_instance_;
        delete ClipPathDisplayItem::default_instance_;
        delete CompositingDisplayItem::default_instance_;
        delete SkPictureID::default_instance_;
        delete DrawingDisplayItem::default_instance_;
        delete FilterDisplayItem::default_instance_;
        delete FloatClipDisplayItem::default_instance_;
        delete TransformDisplayItem::default_instance_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    void protobuf_AddDesc_display_5fitem_2eproto_impl()
    {
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
    void protobuf_AddDesc_display_5fitem_2eproto()
    {
        static bool already_here = false;
        if (already_here)
            return;
        already_here = true;
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
        ::cc::proto::protobuf_AddDesc_skclipop_2eproto();
        ::cc::proto::protobuf_AddDesc_skrrect_2eproto();
        ::cc::proto::protobuf_AddDesc_skxfermode_2eproto();
        ::cc::proto::protobuf_AddDesc_rect_2eproto();
        ::cc::proto::protobuf_AddDesc_rectf_2eproto();
        ::cc::proto::protobuf_AddDesc_transform_2eproto();
        DisplayItemListSettings::default_instance_ = new DisplayItemListSettings();
        DisplayItemList::default_instance_ = new DisplayItemList();
        DisplayItem::default_instance_ = new DisplayItem();
        ClipDisplayItem::default_instance_ = new ClipDisplayItem();
        ClipPathDisplayItem::default_instance_ = new ClipPathDisplayItem();
        CompositingDisplayItem::default_instance_ = new CompositingDisplayItem();
        SkPictureID::default_instance_ = new SkPictureID();
        DrawingDisplayItem::default_instance_ = new DrawingDisplayItem();
        FilterDisplayItem::default_instance_ = new FilterDisplayItem();
        FloatClipDisplayItem::default_instance_ = new FloatClipDisplayItem();
        TransformDisplayItem::default_instance_ = new TransformDisplayItem();
        DisplayItemListSettings::default_instance_->InitAsDefaultInstance();
        DisplayItemList::default_instance_->InitAsDefaultInstance();
        DisplayItem::default_instance_->InitAsDefaultInstance();
        ClipDisplayItem::default_instance_->InitAsDefaultInstance();
        ClipPathDisplayItem::default_instance_->InitAsDefaultInstance();
        CompositingDisplayItem::default_instance_->InitAsDefaultInstance();
        SkPictureID::default_instance_->InitAsDefaultInstance();
        DrawingDisplayItem::default_instance_->InitAsDefaultInstance();
        FilterDisplayItem::default_instance_->InitAsDefaultInstance();
        FloatClipDisplayItem::default_instance_->InitAsDefaultInstance();
        TransformDisplayItem::default_instance_->InitAsDefaultInstance();
        ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_display_5fitem_2eproto);
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_display_5fitem_2eproto_once_);
    void protobuf_AddDesc_display_5fitem_2eproto()
    {
        ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_display_5fitem_2eproto_once_,
            &protobuf_AddDesc_display_5fitem_2eproto_impl);
    }
#else
    // Force AddDescriptors() to be called at static initialization time.
    struct StaticDescriptorInitializer_display_5fitem_2eproto {
        StaticDescriptorInitializer_display_5fitem_2eproto()
        {
            protobuf_AddDesc_display_5fitem_2eproto();
        }
    } static_descriptor_initializer_display_5fitem_2eproto_;
#endif

    namespace {

        static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
        GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line)
        {
            GOOGLE_CHECK(false) << __FILE__ << ":" << line;
        }

    } // namespace

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForDisplayItemListSettings(
        DisplayItemListSettings* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int DisplayItemListSettings::kUseCachedPictureFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    DisplayItemListSettings::DisplayItemListSettings()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.DisplayItemListSettings)
    }

    void DisplayItemListSettings::InitAsDefaultInstance()
    {
    }

    DisplayItemListSettings::DisplayItemListSettings(const DisplayItemListSettings& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.DisplayItemListSettings)
    }

    void DisplayItemListSettings::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        use_cached_picture_ = false;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    DisplayItemListSettings::~DisplayItemListSettings()
    {
        // @@protoc_insertion_point(destructor:cc.proto.DisplayItemListSettings)
        SharedDtor();
    }

    void DisplayItemListSettings::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void DisplayItemListSettings::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const DisplayItemListSettings& DisplayItemListSettings::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    DisplayItemListSettings* DisplayItemListSettings::default_instance_ = NULL;

    DisplayItemListSettings* DisplayItemListSettings::New(::google::protobuf::Arena* arena) const
    {
        DisplayItemListSettings* n = new DisplayItemListSettings;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void DisplayItemListSettings::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.DisplayItemListSettings)
        use_cached_picture_ = false;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool DisplayItemListSettings::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForDisplayItemListSettings, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.DisplayItemListSettings)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional bool use_cached_picture = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &use_cached_picture_)));
                    set_has_use_cached_picture();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.DisplayItemListSettings)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.DisplayItemListSettings)
        return false;
#undef DO_
    }

    void DisplayItemListSettings::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.DisplayItemListSettings)
        // optional bool use_cached_picture = 1;
        if (has_use_cached_picture()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->use_cached_picture(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.DisplayItemListSettings)
    }

    int DisplayItemListSettings::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.DisplayItemListSettings)
        int total_size = 0;

        // optional bool use_cached_picture = 1;
        if (has_use_cached_picture()) {
            total_size += 1 + 1;
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void DisplayItemListSettings::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const DisplayItemListSettings*>(&from));
    }

    void DisplayItemListSettings::MergeFrom(const DisplayItemListSettings& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.DisplayItemListSettings)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_use_cached_picture()) {
                set_use_cached_picture(from.use_cached_picture());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void DisplayItemListSettings::CopyFrom(const DisplayItemListSettings& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.DisplayItemListSettings)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool DisplayItemListSettings::IsInitialized() const
    {

        return true;
    }

    void DisplayItemListSettings::Swap(DisplayItemListSettings* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void DisplayItemListSettings::InternalSwap(DisplayItemListSettings* other)
    {
        std::swap(use_cached_picture_, other->use_cached_picture_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string DisplayItemListSettings::GetTypeName() const
    {
        return "cc.proto.DisplayItemListSettings";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // DisplayItemListSettings

    // optional bool use_cached_picture = 1;
    bool DisplayItemListSettings::has_use_cached_picture() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void DisplayItemListSettings::set_has_use_cached_picture()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void DisplayItemListSettings::clear_has_use_cached_picture()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void DisplayItemListSettings::clear_use_cached_picture()
    {
        use_cached_picture_ = false;
        clear_has_use_cached_picture();
    }
    bool DisplayItemListSettings::use_cached_picture() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItemListSettings.use_cached_picture)
        return use_cached_picture_;
    }
    void DisplayItemListSettings::set_use_cached_picture(bool value)
    {
        set_has_use_cached_picture();
        use_cached_picture_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.DisplayItemListSettings.use_cached_picture)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForDisplayItemList(
        DisplayItemList* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int DisplayItemList::kItemsFieldNumber;
    const int DisplayItemList::kSettingsFieldNumber;
    const int DisplayItemList::kVisualRectsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    DisplayItemList::DisplayItemList()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.DisplayItemList)
    }

    void DisplayItemList::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        settings_ = const_cast<::cc::proto::DisplayItemListSettings*>(
            ::cc::proto::DisplayItemListSettings::internal_default_instance());
#else
        settings_ = const_cast<::cc::proto::DisplayItemListSettings*>(&::cc::proto::DisplayItemListSettings::default_instance());
#endif
    }

    DisplayItemList::DisplayItemList(const DisplayItemList& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.DisplayItemList)
    }

    void DisplayItemList::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        settings_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    DisplayItemList::~DisplayItemList()
    {
        // @@protoc_insertion_point(destructor:cc.proto.DisplayItemList)
        SharedDtor();
    }

    void DisplayItemList::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete settings_;
        }
    }

    void DisplayItemList::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const DisplayItemList& DisplayItemList::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    DisplayItemList* DisplayItemList::default_instance_ = NULL;

    DisplayItemList* DisplayItemList::New(::google::protobuf::Arena* arena) const
    {
        DisplayItemList* n = new DisplayItemList;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void DisplayItemList::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.DisplayItemList)
        if (has_settings()) {
            if (settings_ != NULL)
                settings_->::cc::proto::DisplayItemListSettings::Clear();
        }
        items_.Clear();
        visual_rects_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool DisplayItemList::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForDisplayItemList, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.DisplayItemList)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .cc.proto.DisplayItem items = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_items:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_items()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_items;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectTag(26))
                    goto parse_settings;
                break;
            }

            // optional .cc.proto.DisplayItemListSettings settings = 3;
            case 3: {
                if (tag == 26) {
                parse_settings:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_settings()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_visual_rects;
                break;
            }

            // repeated .cc.proto.Rect visual_rects = 4;
            case 4: {
                if (tag == 34) {
                parse_visual_rects:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_visual_rects:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_visual_rects()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_loop_visual_rects;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.DisplayItemList)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.DisplayItemList)
        return false;
#undef DO_
    }

    void DisplayItemList::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.DisplayItemList)
        // repeated .cc.proto.DisplayItem items = 1;
        for (unsigned int i = 0, n = this->items_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->items(i), output);
        }

        // optional .cc.proto.DisplayItemListSettings settings = 3;
        if (has_settings()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->settings_, output);
        }

        // repeated .cc.proto.Rect visual_rects = 4;
        for (unsigned int i = 0, n = this->visual_rects_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                4, this->visual_rects(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.DisplayItemList)
    }

    int DisplayItemList::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.DisplayItemList)
        int total_size = 0;

        // optional .cc.proto.DisplayItemListSettings settings = 3;
        if (has_settings()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->settings_);
        }

        // repeated .cc.proto.DisplayItem items = 1;
        total_size += 1 * this->items_size();
        for (int i = 0; i < this->items_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->items(i));
        }

        // repeated .cc.proto.Rect visual_rects = 4;
        total_size += 1 * this->visual_rects_size();
        for (int i = 0; i < this->visual_rects_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->visual_rects(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void DisplayItemList::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const DisplayItemList*>(&from));
    }

    void DisplayItemList::MergeFrom(const DisplayItemList& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.DisplayItemList)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        items_.MergeFrom(from.items_);
        visual_rects_.MergeFrom(from.visual_rects_);
        if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
            if (from.has_settings()) {
                mutable_settings()->::cc::proto::DisplayItemListSettings::MergeFrom(from.settings());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void DisplayItemList::CopyFrom(const DisplayItemList& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.DisplayItemList)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool DisplayItemList::IsInitialized() const
    {

        return true;
    }

    void DisplayItemList::Swap(DisplayItemList* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void DisplayItemList::InternalSwap(DisplayItemList* other)
    {
        items_.UnsafeArenaSwap(&other->items_);
        std::swap(settings_, other->settings_);
        visual_rects_.UnsafeArenaSwap(&other->visual_rects_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string DisplayItemList::GetTypeName() const
    {
        return "cc.proto.DisplayItemList";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // DisplayItemList

    // repeated .cc.proto.DisplayItem items = 1;
    int DisplayItemList::items_size() const
    {
        return items_.size();
    }
    void DisplayItemList::clear_items()
    {
        items_.Clear();
    }
    const ::cc::proto::DisplayItem& DisplayItemList::items(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItemList.items)
        return items_.Get(index);
    }
    ::cc::proto::DisplayItem* DisplayItemList::mutable_items(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItemList.items)
        return items_.Mutable(index);
    }
    ::cc::proto::DisplayItem* DisplayItemList::add_items()
    {
        // @@protoc_insertion_point(field_add:cc.proto.DisplayItemList.items)
        return items_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::cc::proto::DisplayItem>*
    DisplayItemList::mutable_items()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.DisplayItemList.items)
        return &items_;
    }
    const ::google::protobuf::RepeatedPtrField<::cc::proto::DisplayItem>&
    DisplayItemList::items() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.DisplayItemList.items)
        return items_;
    }

    // optional .cc.proto.DisplayItemListSettings settings = 3;
    bool DisplayItemList::has_settings() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void DisplayItemList::set_has_settings()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void DisplayItemList::clear_has_settings()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void DisplayItemList::clear_settings()
    {
        if (settings_ != NULL)
            settings_->::cc::proto::DisplayItemListSettings::Clear();
        clear_has_settings();
    }
    const ::cc::proto::DisplayItemListSettings& DisplayItemList::settings() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItemList.settings)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return settings_ != NULL ? *settings_ : *default_instance().settings_;
#else
        return settings_ != NULL ? *settings_ : *default_instance_->settings_;
#endif
    }
    ::cc::proto::DisplayItemListSettings* DisplayItemList::mutable_settings()
    {
        set_has_settings();
        if (settings_ == NULL) {
            settings_ = new ::cc::proto::DisplayItemListSettings;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItemList.settings)
        return settings_;
    }
    ::cc::proto::DisplayItemListSettings* DisplayItemList::release_settings()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItemList.settings)
        clear_has_settings();
        ::cc::proto::DisplayItemListSettings* temp = settings_;
        settings_ = NULL;
        return temp;
    }
    void DisplayItemList::set_allocated_settings(::cc::proto::DisplayItemListSettings* settings)
    {
        delete settings_;
        settings_ = settings;
        if (settings) {
            set_has_settings();
        } else {
            clear_has_settings();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItemList.settings)
    }

    // repeated .cc.proto.Rect visual_rects = 4;
    int DisplayItemList::visual_rects_size() const
    {
        return visual_rects_.size();
    }
    void DisplayItemList::clear_visual_rects()
    {
        visual_rects_.Clear();
    }
    const ::cc::proto::Rect& DisplayItemList::visual_rects(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_.Get(index);
    }
    ::cc::proto::Rect* DisplayItemList::mutable_visual_rects(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_.Mutable(index);
    }
    ::cc::proto::Rect* DisplayItemList::add_visual_rects()
    {
        // @@protoc_insertion_point(field_add:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::cc::proto::Rect>*
    DisplayItemList::mutable_visual_rects()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.DisplayItemList.visual_rects)
        return &visual_rects_;
    }
    const ::google::protobuf::RepeatedPtrField<::cc::proto::Rect>&
    DisplayItemList::visual_rects() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForDisplayItem(
        DisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool DisplayItem_Type_IsValid(int value)
    {
        switch (value) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const DisplayItem_Type DisplayItem::Type_Clip;
    const DisplayItem_Type DisplayItem::Type_EndClip;
    const DisplayItem_Type DisplayItem::Type_ClipPath;
    const DisplayItem_Type DisplayItem::Type_EndClipPath;
    const DisplayItem_Type DisplayItem::Type_Compositing;
    const DisplayItem_Type DisplayItem::Type_EndCompositing;
    const DisplayItem_Type DisplayItem::Type_Drawing;
    const DisplayItem_Type DisplayItem::Type_Filter;
    const DisplayItem_Type DisplayItem::Type_EndFilter;
    const DisplayItem_Type DisplayItem::Type_FloatClip;
    const DisplayItem_Type DisplayItem::Type_EndFloatClip;
    const DisplayItem_Type DisplayItem::Type_Transform;
    const DisplayItem_Type DisplayItem::Type_EndTransform;
    const DisplayItem_Type DisplayItem::Type_MIN;
    const DisplayItem_Type DisplayItem::Type_MAX;
    const int DisplayItem::Type_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int DisplayItem::kTypeFieldNumber;
    const int DisplayItem::kClipItemFieldNumber;
    const int DisplayItem::kClipPathItemFieldNumber;
    const int DisplayItem::kCompositingItemFieldNumber;
    const int DisplayItem::kDrawingItemFieldNumber;
    const int DisplayItem::kFilterItemFieldNumber;
    const int DisplayItem::kFloatClipItemFieldNumber;
    const int DisplayItem::kTransformItemFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    DisplayItem::DisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.DisplayItem)
    }

    void DisplayItem::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        clip_item_ = const_cast<::cc::proto::ClipDisplayItem*>(
            ::cc::proto::ClipDisplayItem::internal_default_instance());
#else
        clip_item_ = const_cast<::cc::proto::ClipDisplayItem*>(&::cc::proto::ClipDisplayItem::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        clip_path_item_ = const_cast<::cc::proto::ClipPathDisplayItem*>(
            ::cc::proto::ClipPathDisplayItem::internal_default_instance());
#else
        clip_path_item_ = const_cast<::cc::proto::ClipPathDisplayItem*>(&::cc::proto::ClipPathDisplayItem::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        compositing_item_ = const_cast<::cc::proto::CompositingDisplayItem*>(
            ::cc::proto::CompositingDisplayItem::internal_default_instance());
#else
        compositing_item_ = const_cast<::cc::proto::CompositingDisplayItem*>(&::cc::proto::CompositingDisplayItem::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        drawing_item_ = const_cast<::cc::proto::DrawingDisplayItem*>(
            ::cc::proto::DrawingDisplayItem::internal_default_instance());
#else
        drawing_item_ = const_cast<::cc::proto::DrawingDisplayItem*>(&::cc::proto::DrawingDisplayItem::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        filter_item_ = const_cast<::cc::proto::FilterDisplayItem*>(
            ::cc::proto::FilterDisplayItem::internal_default_instance());
#else
        filter_item_ = const_cast<::cc::proto::FilterDisplayItem*>(&::cc::proto::FilterDisplayItem::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        float_clip_item_ = const_cast<::cc::proto::FloatClipDisplayItem*>(
            ::cc::proto::FloatClipDisplayItem::internal_default_instance());
#else
        float_clip_item_ = const_cast<::cc::proto::FloatClipDisplayItem*>(&::cc::proto::FloatClipDisplayItem::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        transform_item_ = const_cast<::cc::proto::TransformDisplayItem*>(
            ::cc::proto::TransformDisplayItem::internal_default_instance());
#else
        transform_item_ = const_cast<::cc::proto::TransformDisplayItem*>(&::cc::proto::TransformDisplayItem::default_instance());
#endif
    }

    DisplayItem::DisplayItem(const DisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.DisplayItem)
    }

    void DisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        type_ = 1;
        clip_item_ = NULL;
        clip_path_item_ = NULL;
        compositing_item_ = NULL;
        drawing_item_ = NULL;
        filter_item_ = NULL;
        float_clip_item_ = NULL;
        transform_item_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    DisplayItem::~DisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.DisplayItem)
        SharedDtor();
    }

    void DisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete clip_item_;
            delete clip_path_item_;
            delete compositing_item_;
            delete drawing_item_;
            delete filter_item_;
            delete float_clip_item_;
            delete transform_item_;
        }
    }

    void DisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const DisplayItem& DisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    DisplayItem* DisplayItem::default_instance_ = NULL;

    DisplayItem* DisplayItem::New(::google::protobuf::Arena* arena) const
    {
        DisplayItem* n = new DisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void DisplayItem::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.DisplayItem)
        if (_has_bits_[0 / 32] & 255u) {
            type_ = 1;
            if (has_clip_item()) {
                if (clip_item_ != NULL)
                    clip_item_->::cc::proto::ClipDisplayItem::Clear();
            }
            if (has_clip_path_item()) {
                if (clip_path_item_ != NULL)
                    clip_path_item_->::cc::proto::ClipPathDisplayItem::Clear();
            }
            if (has_compositing_item()) {
                if (compositing_item_ != NULL)
                    compositing_item_->::cc::proto::CompositingDisplayItem::Clear();
            }
            if (has_drawing_item()) {
                if (drawing_item_ != NULL)
                    drawing_item_->::cc::proto::DrawingDisplayItem::Clear();
            }
            if (has_filter_item()) {
                if (filter_item_ != NULL)
                    filter_item_->::cc::proto::FilterDisplayItem::Clear();
            }
            if (has_float_clip_item()) {
                if (float_clip_item_ != NULL)
                    float_clip_item_->::cc::proto::FloatClipDisplayItem::Clear();
            }
            if (has_transform_item()) {
                if (transform_item_ != NULL)
                    transform_item_->::cc::proto::TransformDisplayItem::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool DisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.DisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.DisplayItem.Type type = 1;
            case 1: {
                if (tag == 8) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::cc::proto::DisplayItem_Type_IsValid(value)) {
                        set_type(static_cast<::cc::proto::DisplayItem_Type>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(8);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8002))
                    goto parse_clip_item;
                break;
            }

            // optional .cc.proto.ClipDisplayItem clip_item = 1000;
            case 1000: {
                if (tag == 8002) {
                parse_clip_item:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_clip_item()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8010))
                    goto parse_clip_path_item;
                break;
            }

            // optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
            case 1001: {
                if (tag == 8010) {
                parse_clip_path_item:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_clip_path_item()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8018))
                    goto parse_compositing_item;
                break;
            }

            // optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
            case 1002: {
                if (tag == 8018) {
                parse_compositing_item:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_compositing_item()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8026))
                    goto parse_drawing_item;
                break;
            }

            // optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
            case 1003: {
                if (tag == 8026) {
                parse_drawing_item:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_drawing_item()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8034))
                    goto parse_filter_item;
                break;
            }

            // optional .cc.proto.FilterDisplayItem filter_item = 1004;
            case 1004: {
                if (tag == 8034) {
                parse_filter_item:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_filter_item()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8042))
                    goto parse_float_clip_item;
                break;
            }

            // optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
            case 1005: {
                if (tag == 8042) {
                parse_float_clip_item:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_float_clip_item()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8050))
                    goto parse_transform_item;
                break;
            }

            // optional .cc.proto.TransformDisplayItem transform_item = 1006;
            case 1006: {
                if (tag == 8050) {
                parse_transform_item:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_transform_item()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.DisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.DisplayItem)
        return false;
#undef DO_
    }

    void DisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.DisplayItem)
        // optional .cc.proto.DisplayItem.Type type = 1;
        if (has_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                1, this->type(), output);
        }

        // optional .cc.proto.ClipDisplayItem clip_item = 1000;
        if (has_clip_item()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1000, *this->clip_item_, output);
        }

        // optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
        if (has_clip_path_item()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1001, *this->clip_path_item_, output);
        }

        // optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
        if (has_compositing_item()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1002, *this->compositing_item_, output);
        }

        // optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
        if (has_drawing_item()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1003, *this->drawing_item_, output);
        }

        // optional .cc.proto.FilterDisplayItem filter_item = 1004;
        if (has_filter_item()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1004, *this->filter_item_, output);
        }

        // optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
        if (has_float_clip_item()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1005, *this->float_clip_item_, output);
        }

        // optional .cc.proto.TransformDisplayItem transform_item = 1006;
        if (has_transform_item()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1006, *this->transform_item_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.DisplayItem)
    }

    int DisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.DisplayItem)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 255u) {
            // optional .cc.proto.DisplayItem.Type type = 1;
            if (has_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
            }

            // optional .cc.proto.ClipDisplayItem clip_item = 1000;
            if (has_clip_item()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->clip_item_);
            }

            // optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
            if (has_clip_path_item()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->clip_path_item_);
            }

            // optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
            if (has_compositing_item()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->compositing_item_);
            }

            // optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
            if (has_drawing_item()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->drawing_item_);
            }

            // optional .cc.proto.FilterDisplayItem filter_item = 1004;
            if (has_filter_item()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->filter_item_);
            }

            // optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
            if (has_float_clip_item()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->float_clip_item_);
            }

            // optional .cc.proto.TransformDisplayItem transform_item = 1006;
            if (has_transform_item()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->transform_item_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void DisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const DisplayItem*>(&from));
    }

    void DisplayItem::MergeFrom(const DisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.DisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_type()) {
                set_type(from.type());
            }
            if (from.has_clip_item()) {
                mutable_clip_item()->::cc::proto::ClipDisplayItem::MergeFrom(from.clip_item());
            }
            if (from.has_clip_path_item()) {
                mutable_clip_path_item()->::cc::proto::ClipPathDisplayItem::MergeFrom(from.clip_path_item());
            }
            if (from.has_compositing_item()) {
                mutable_compositing_item()->::cc::proto::CompositingDisplayItem::MergeFrom(from.compositing_item());
            }
            if (from.has_drawing_item()) {
                mutable_drawing_item()->::cc::proto::DrawingDisplayItem::MergeFrom(from.drawing_item());
            }
            if (from.has_filter_item()) {
                mutable_filter_item()->::cc::proto::FilterDisplayItem::MergeFrom(from.filter_item());
            }
            if (from.has_float_clip_item()) {
                mutable_float_clip_item()->::cc::proto::FloatClipDisplayItem::MergeFrom(from.float_clip_item());
            }
            if (from.has_transform_item()) {
                mutable_transform_item()->::cc::proto::TransformDisplayItem::MergeFrom(from.transform_item());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void DisplayItem::CopyFrom(const DisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.DisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool DisplayItem::IsInitialized() const
    {

        return true;
    }

    void DisplayItem::Swap(DisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void DisplayItem::InternalSwap(DisplayItem* other)
    {
        std::swap(type_, other->type_);
        std::swap(clip_item_, other->clip_item_);
        std::swap(clip_path_item_, other->clip_path_item_);
        std::swap(compositing_item_, other->compositing_item_);
        std::swap(drawing_item_, other->drawing_item_);
        std::swap(filter_item_, other->filter_item_);
        std::swap(float_clip_item_, other->float_clip_item_);
        std::swap(transform_item_, other->transform_item_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string DisplayItem::GetTypeName() const
    {
        return "cc.proto.DisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // DisplayItem

    // optional .cc.proto.DisplayItem.Type type = 1;
    bool DisplayItem::has_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void DisplayItem::set_has_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void DisplayItem::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void DisplayItem::clear_type()
    {
        type_ = 1;
        clear_has_type();
    }
    ::cc::proto::DisplayItem_Type DisplayItem::type() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.type)
        return static_cast<::cc::proto::DisplayItem_Type>(type_);
    }
    void DisplayItem::set_type(::cc::proto::DisplayItem_Type value)
    {
        assert(::cc::proto::DisplayItem_Type_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.DisplayItem.type)
    }

    // optional .cc.proto.ClipDisplayItem clip_item = 1000;
    bool DisplayItem::has_clip_item() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void DisplayItem::set_has_clip_item()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void DisplayItem::clear_has_clip_item()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void DisplayItem::clear_clip_item()
    {
        if (clip_item_ != NULL)
            clip_item_->::cc::proto::ClipDisplayItem::Clear();
        clear_has_clip_item();
    }
    const ::cc::proto::ClipDisplayItem& DisplayItem::clip_item() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.clip_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_item_ != NULL ? *clip_item_ : *default_instance().clip_item_;
#else
        return clip_item_ != NULL ? *clip_item_ : *default_instance_->clip_item_;
#endif
    }
    ::cc::proto::ClipDisplayItem* DisplayItem::mutable_clip_item()
    {
        set_has_clip_item();
        if (clip_item_ == NULL) {
            clip_item_ = new ::cc::proto::ClipDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.clip_item)
        return clip_item_;
    }
    ::cc::proto::ClipDisplayItem* DisplayItem::release_clip_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.clip_item)
        clear_has_clip_item();
        ::cc::proto::ClipDisplayItem* temp = clip_item_;
        clip_item_ = NULL;
        return temp;
    }
    void DisplayItem::set_allocated_clip_item(::cc::proto::ClipDisplayItem* clip_item)
    {
        delete clip_item_;
        clip_item_ = clip_item;
        if (clip_item) {
            set_has_clip_item();
        } else {
            clear_has_clip_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.clip_item)
    }

    // optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
    bool DisplayItem::has_clip_path_item() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void DisplayItem::set_has_clip_path_item()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void DisplayItem::clear_has_clip_path_item()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void DisplayItem::clear_clip_path_item()
    {
        if (clip_path_item_ != NULL)
            clip_path_item_->::cc::proto::ClipPathDisplayItem::Clear();
        clear_has_clip_path_item();
    }
    const ::cc::proto::ClipPathDisplayItem& DisplayItem::clip_path_item() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.clip_path_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_path_item_ != NULL ? *clip_path_item_ : *default_instance().clip_path_item_;
#else
        return clip_path_item_ != NULL ? *clip_path_item_ : *default_instance_->clip_path_item_;
#endif
    }
    ::cc::proto::ClipPathDisplayItem* DisplayItem::mutable_clip_path_item()
    {
        set_has_clip_path_item();
        if (clip_path_item_ == NULL) {
            clip_path_item_ = new ::cc::proto::ClipPathDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.clip_path_item)
        return clip_path_item_;
    }
    ::cc::proto::ClipPathDisplayItem* DisplayItem::release_clip_path_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.clip_path_item)
        clear_has_clip_path_item();
        ::cc::proto::ClipPathDisplayItem* temp = clip_path_item_;
        clip_path_item_ = NULL;
        return temp;
    }
    void DisplayItem::set_allocated_clip_path_item(::cc::proto::ClipPathDisplayItem* clip_path_item)
    {
        delete clip_path_item_;
        clip_path_item_ = clip_path_item;
        if (clip_path_item) {
            set_has_clip_path_item();
        } else {
            clear_has_clip_path_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.clip_path_item)
    }

    // optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
    bool DisplayItem::has_compositing_item() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void DisplayItem::set_has_compositing_item()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void DisplayItem::clear_has_compositing_item()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void DisplayItem::clear_compositing_item()
    {
        if (compositing_item_ != NULL)
            compositing_item_->::cc::proto::CompositingDisplayItem::Clear();
        clear_has_compositing_item();
    }
    const ::cc::proto::CompositingDisplayItem& DisplayItem::compositing_item() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.compositing_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return compositing_item_ != NULL ? *compositing_item_ : *default_instance().compositing_item_;
#else
        return compositing_item_ != NULL ? *compositing_item_ : *default_instance_->compositing_item_;
#endif
    }
    ::cc::proto::CompositingDisplayItem* DisplayItem::mutable_compositing_item()
    {
        set_has_compositing_item();
        if (compositing_item_ == NULL) {
            compositing_item_ = new ::cc::proto::CompositingDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.compositing_item)
        return compositing_item_;
    }
    ::cc::proto::CompositingDisplayItem* DisplayItem::release_compositing_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.compositing_item)
        clear_has_compositing_item();
        ::cc::proto::CompositingDisplayItem* temp = compositing_item_;
        compositing_item_ = NULL;
        return temp;
    }
    void DisplayItem::set_allocated_compositing_item(::cc::proto::CompositingDisplayItem* compositing_item)
    {
        delete compositing_item_;
        compositing_item_ = compositing_item;
        if (compositing_item) {
            set_has_compositing_item();
        } else {
            clear_has_compositing_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.compositing_item)
    }

    // optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
    bool DisplayItem::has_drawing_item() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void DisplayItem::set_has_drawing_item()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void DisplayItem::clear_has_drawing_item()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void DisplayItem::clear_drawing_item()
    {
        if (drawing_item_ != NULL)
            drawing_item_->::cc::proto::DrawingDisplayItem::Clear();
        clear_has_drawing_item();
    }
    const ::cc::proto::DrawingDisplayItem& DisplayItem::drawing_item() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.drawing_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return drawing_item_ != NULL ? *drawing_item_ : *default_instance().drawing_item_;
#else
        return drawing_item_ != NULL ? *drawing_item_ : *default_instance_->drawing_item_;
#endif
    }
    ::cc::proto::DrawingDisplayItem* DisplayItem::mutable_drawing_item()
    {
        set_has_drawing_item();
        if (drawing_item_ == NULL) {
            drawing_item_ = new ::cc::proto::DrawingDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.drawing_item)
        return drawing_item_;
    }
    ::cc::proto::DrawingDisplayItem* DisplayItem::release_drawing_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.drawing_item)
        clear_has_drawing_item();
        ::cc::proto::DrawingDisplayItem* temp = drawing_item_;
        drawing_item_ = NULL;
        return temp;
    }
    void DisplayItem::set_allocated_drawing_item(::cc::proto::DrawingDisplayItem* drawing_item)
    {
        delete drawing_item_;
        drawing_item_ = drawing_item;
        if (drawing_item) {
            set_has_drawing_item();
        } else {
            clear_has_drawing_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.drawing_item)
    }

    // optional .cc.proto.FilterDisplayItem filter_item = 1004;
    bool DisplayItem::has_filter_item() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void DisplayItem::set_has_filter_item()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void DisplayItem::clear_has_filter_item()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void DisplayItem::clear_filter_item()
    {
        if (filter_item_ != NULL)
            filter_item_->::cc::proto::FilterDisplayItem::Clear();
        clear_has_filter_item();
    }
    const ::cc::proto::FilterDisplayItem& DisplayItem::filter_item() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.filter_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return filter_item_ != NULL ? *filter_item_ : *default_instance().filter_item_;
#else
        return filter_item_ != NULL ? *filter_item_ : *default_instance_->filter_item_;
#endif
    }
    ::cc::proto::FilterDisplayItem* DisplayItem::mutable_filter_item()
    {
        set_has_filter_item();
        if (filter_item_ == NULL) {
            filter_item_ = new ::cc::proto::FilterDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.filter_item)
        return filter_item_;
    }
    ::cc::proto::FilterDisplayItem* DisplayItem::release_filter_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.filter_item)
        clear_has_filter_item();
        ::cc::proto::FilterDisplayItem* temp = filter_item_;
        filter_item_ = NULL;
        return temp;
    }
    void DisplayItem::set_allocated_filter_item(::cc::proto::FilterDisplayItem* filter_item)
    {
        delete filter_item_;
        filter_item_ = filter_item;
        if (filter_item) {
            set_has_filter_item();
        } else {
            clear_has_filter_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.filter_item)
    }

    // optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
    bool DisplayItem::has_float_clip_item() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    void DisplayItem::set_has_float_clip_item()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    void DisplayItem::clear_has_float_clip_item()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    void DisplayItem::clear_float_clip_item()
    {
        if (float_clip_item_ != NULL)
            float_clip_item_->::cc::proto::FloatClipDisplayItem::Clear();
        clear_has_float_clip_item();
    }
    const ::cc::proto::FloatClipDisplayItem& DisplayItem::float_clip_item() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.float_clip_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return float_clip_item_ != NULL ? *float_clip_item_ : *default_instance().float_clip_item_;
#else
        return float_clip_item_ != NULL ? *float_clip_item_ : *default_instance_->float_clip_item_;
#endif
    }
    ::cc::proto::FloatClipDisplayItem* DisplayItem::mutable_float_clip_item()
    {
        set_has_float_clip_item();
        if (float_clip_item_ == NULL) {
            float_clip_item_ = new ::cc::proto::FloatClipDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.float_clip_item)
        return float_clip_item_;
    }
    ::cc::proto::FloatClipDisplayItem* DisplayItem::release_float_clip_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.float_clip_item)
        clear_has_float_clip_item();
        ::cc::proto::FloatClipDisplayItem* temp = float_clip_item_;
        float_clip_item_ = NULL;
        return temp;
    }
    void DisplayItem::set_allocated_float_clip_item(::cc::proto::FloatClipDisplayItem* float_clip_item)
    {
        delete float_clip_item_;
        float_clip_item_ = float_clip_item;
        if (float_clip_item) {
            set_has_float_clip_item();
        } else {
            clear_has_float_clip_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.float_clip_item)
    }

    // optional .cc.proto.TransformDisplayItem transform_item = 1006;
    bool DisplayItem::has_transform_item() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    void DisplayItem::set_has_transform_item()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    void DisplayItem::clear_has_transform_item()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    void DisplayItem::clear_transform_item()
    {
        if (transform_item_ != NULL)
            transform_item_->::cc::proto::TransformDisplayItem::Clear();
        clear_has_transform_item();
    }
    const ::cc::proto::TransformDisplayItem& DisplayItem::transform_item() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.transform_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_item_ != NULL ? *transform_item_ : *default_instance().transform_item_;
#else
        return transform_item_ != NULL ? *transform_item_ : *default_instance_->transform_item_;
#endif
    }
    ::cc::proto::TransformDisplayItem* DisplayItem::mutable_transform_item()
    {
        set_has_transform_item();
        if (transform_item_ == NULL) {
            transform_item_ = new ::cc::proto::TransformDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.transform_item)
        return transform_item_;
    }
    ::cc::proto::TransformDisplayItem* DisplayItem::release_transform_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.transform_item)
        clear_has_transform_item();
        ::cc::proto::TransformDisplayItem* temp = transform_item_;
        transform_item_ = NULL;
        return temp;
    }
    void DisplayItem::set_allocated_transform_item(::cc::proto::TransformDisplayItem* transform_item)
    {
        delete transform_item_;
        transform_item_ = transform_item;
        if (transform_item) {
            set_has_transform_item();
        } else {
            clear_has_transform_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.transform_item)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForClipDisplayItem(
        ClipDisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ClipDisplayItem::kClipRectFieldNumber;
    const int ClipDisplayItem::kRoundedRectsFieldNumber;
    const int ClipDisplayItem::kAntialiasFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ClipDisplayItem::ClipDisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.ClipDisplayItem)
    }

    void ClipDisplayItem::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        clip_rect_ = const_cast<::cc::proto::Rect*>(
            ::cc::proto::Rect::internal_default_instance());
#else
        clip_rect_ = const_cast<::cc::proto::Rect*>(&::cc::proto::Rect::default_instance());
#endif
    }

    ClipDisplayItem::ClipDisplayItem(const ClipDisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.ClipDisplayItem)
    }

    void ClipDisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clip_rect_ = NULL;
        antialias_ = false;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ClipDisplayItem::~ClipDisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.ClipDisplayItem)
        SharedDtor();
    }

    void ClipDisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete clip_rect_;
        }
    }

    void ClipDisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ClipDisplayItem& ClipDisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    ClipDisplayItem* ClipDisplayItem::default_instance_ = NULL;

    ClipDisplayItem* ClipDisplayItem::New(::google::protobuf::Arena* arena) const
    {
        ClipDisplayItem* n = new ClipDisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ClipDisplayItem::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.ClipDisplayItem)
        if (_has_bits_[0 / 32] & 5u) {
            if (has_clip_rect()) {
                if (clip_rect_ != NULL)
                    clip_rect_->::cc::proto::Rect::Clear();
            }
            antialias_ = false;
        }
        rounded_rects_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ClipDisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForClipDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.ClipDisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.Rect clip_rect = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_clip_rect()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_rounded_rects;
                break;
            }

            // repeated .cc.proto.SkRRect rounded_rects = 2;
            case 2: {
                if (tag == 18) {
                parse_rounded_rects:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_rounded_rects:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_rounded_rects()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_loop_rounded_rects;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectTag(24))
                    goto parse_antialias;
                break;
            }

            // optional bool antialias = 3;
            case 3: {
                if (tag == 24) {
                parse_antialias:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &antialias_)));
                    set_has_antialias();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.ClipDisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.ClipDisplayItem)
        return false;
#undef DO_
    }

    void ClipDisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.ClipDisplayItem)
        // optional .cc.proto.Rect clip_rect = 1;
        if (has_clip_rect()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->clip_rect_, output);
        }

        // repeated .cc.proto.SkRRect rounded_rects = 2;
        for (unsigned int i = 0, n = this->rounded_rects_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, this->rounded_rects(i), output);
        }

        // optional bool antialias = 3;
        if (has_antialias()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->antialias(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.ClipDisplayItem)
    }

    int ClipDisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.ClipDisplayItem)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 5u) {
            // optional .cc.proto.Rect clip_rect = 1;
            if (has_clip_rect()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->clip_rect_);
            }

            // optional bool antialias = 3;
            if (has_antialias()) {
                total_size += 1 + 1;
            }
        }
        // repeated .cc.proto.SkRRect rounded_rects = 2;
        total_size += 1 * this->rounded_rects_size();
        for (int i = 0; i < this->rounded_rects_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->rounded_rects(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ClipDisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ClipDisplayItem*>(&from));
    }

    void ClipDisplayItem::MergeFrom(const ClipDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.ClipDisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        rounded_rects_.MergeFrom(from.rounded_rects_);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_clip_rect()) {
                mutable_clip_rect()->::cc::proto::Rect::MergeFrom(from.clip_rect());
            }
            if (from.has_antialias()) {
                set_antialias(from.antialias());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ClipDisplayItem::CopyFrom(const ClipDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.ClipDisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ClipDisplayItem::IsInitialized() const
    {

        return true;
    }

    void ClipDisplayItem::Swap(ClipDisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ClipDisplayItem::InternalSwap(ClipDisplayItem* other)
    {
        std::swap(clip_rect_, other->clip_rect_);
        rounded_rects_.UnsafeArenaSwap(&other->rounded_rects_);
        std::swap(antialias_, other->antialias_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ClipDisplayItem::GetTypeName() const
    {
        return "cc.proto.ClipDisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ClipDisplayItem

    // optional .cc.proto.Rect clip_rect = 1;
    bool ClipDisplayItem::has_clip_rect() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ClipDisplayItem::set_has_clip_rect()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ClipDisplayItem::clear_has_clip_rect()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ClipDisplayItem::clear_clip_rect()
    {
        if (clip_rect_ != NULL)
            clip_rect_->::cc::proto::Rect::Clear();
        clear_has_clip_rect();
    }
    const ::cc::proto::Rect& ClipDisplayItem::clip_rect() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipDisplayItem.clip_rect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance().clip_rect_;
#else
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance_->clip_rect_;
#endif
    }
    ::cc::proto::Rect* ClipDisplayItem::mutable_clip_rect()
    {
        set_has_clip_rect();
        if (clip_rect_ == NULL) {
            clip_rect_ = new ::cc::proto::Rect;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.ClipDisplayItem.clip_rect)
        return clip_rect_;
    }
    ::cc::proto::Rect* ClipDisplayItem::release_clip_rect()
    {
        // @@protoc_insertion_point(field_release:cc.proto.ClipDisplayItem.clip_rect)
        clear_has_clip_rect();
        ::cc::proto::Rect* temp = clip_rect_;
        clip_rect_ = NULL;
        return temp;
    }
    void ClipDisplayItem::set_allocated_clip_rect(::cc::proto::Rect* clip_rect)
    {
        delete clip_rect_;
        clip_rect_ = clip_rect;
        if (clip_rect) {
            set_has_clip_rect();
        } else {
            clear_has_clip_rect();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.ClipDisplayItem.clip_rect)
    }

    // repeated .cc.proto.SkRRect rounded_rects = 2;
    int ClipDisplayItem::rounded_rects_size() const
    {
        return rounded_rects_.size();
    }
    void ClipDisplayItem::clear_rounded_rects()
    {
        rounded_rects_.Clear();
    }
    const ::cc::proto::SkRRect& ClipDisplayItem::rounded_rects(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_.Get(index);
    }
    ::cc::proto::SkRRect* ClipDisplayItem::mutable_rounded_rects(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_.Mutable(index);
    }
    ::cc::proto::SkRRect* ClipDisplayItem::add_rounded_rects()
    {
        // @@protoc_insertion_point(field_add:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::cc::proto::SkRRect>*
    ClipDisplayItem::mutable_rounded_rects()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.ClipDisplayItem.rounded_rects)
        return &rounded_rects_;
    }
    const ::google::protobuf::RepeatedPtrField<::cc::proto::SkRRect>&
    ClipDisplayItem::rounded_rects() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_;
    }

    // optional bool antialias = 3;
    bool ClipDisplayItem::has_antialias() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ClipDisplayItem::set_has_antialias()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ClipDisplayItem::clear_has_antialias()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ClipDisplayItem::clear_antialias()
    {
        antialias_ = false;
        clear_has_antialias();
    }
    bool ClipDisplayItem::antialias() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipDisplayItem.antialias)
        return antialias_;
    }
    void ClipDisplayItem::set_antialias(bool value)
    {
        set_has_antialias();
        antialias_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.ClipDisplayItem.antialias)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForClipPathDisplayItem(
        ClipPathDisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ClipPathDisplayItem::kClipOpFieldNumber;
    const int ClipPathDisplayItem::kAntialiasFieldNumber;
    const int ClipPathDisplayItem::kClipPathFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ClipPathDisplayItem::ClipPathDisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.ClipPathDisplayItem)
    }

    void ClipPathDisplayItem::InitAsDefaultInstance()
    {
    }

    ClipPathDisplayItem::ClipPathDisplayItem(const ClipPathDisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.ClipPathDisplayItem)
    }

    void ClipPathDisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clip_op_ = 0;
        antialias_ = false;
        clip_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ClipPathDisplayItem::~ClipPathDisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.ClipPathDisplayItem)
        SharedDtor();
    }

    void ClipPathDisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clip_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void ClipPathDisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ClipPathDisplayItem& ClipPathDisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    ClipPathDisplayItem* ClipPathDisplayItem::default_instance_ = NULL;

    ClipPathDisplayItem* ClipPathDisplayItem::New(::google::protobuf::Arena* arena) const
    {
        ClipPathDisplayItem* n = new ClipPathDisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ClipPathDisplayItem::Clear()
    {
// @@protoc_insertion_point(message_clear_start:cc.proto.ClipPathDisplayItem)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                         \
    _Pragma("clang diagnostic push")                                                                          \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ClipPathDisplayItem, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ClipPathDisplayItem*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 7u) {
            ZR_(clip_op_, antialias_);
            if (has_clip_path()) {
                clip_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ClipPathDisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForClipPathDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.ClipPathDisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.SkClipOp.Op clip_op = 1;
            case 1: {
                if (tag == 8) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::cc::proto::SkClipOp_Op_IsValid(value)) {
                        set_clip_op(static_cast<::cc::proto::SkClipOp_Op>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(8);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_antialias;
                break;
            }

            // optional bool antialias = 2;
            case 2: {
                if (tag == 16) {
                parse_antialias:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &antialias_)));
                    set_has_antialias();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_clip_path;
                break;
            }

            // optional bytes clip_path = 3;
            case 3: {
                if (tag == 26) {
                parse_clip_path:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_clip_path()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.ClipPathDisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.ClipPathDisplayItem)
        return false;
#undef DO_
    }

    void ClipPathDisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.ClipPathDisplayItem)
        // optional .cc.proto.SkClipOp.Op clip_op = 1;
        if (has_clip_op()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                1, this->clip_op(), output);
        }

        // optional bool antialias = 2;
        if (has_antialias()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->antialias(), output);
        }

        // optional bytes clip_path = 3;
        if (has_clip_path()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                3, this->clip_path(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.ClipPathDisplayItem)
    }

    int ClipPathDisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.ClipPathDisplayItem)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 7u) {
            // optional .cc.proto.SkClipOp.Op clip_op = 1;
            if (has_clip_op()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->clip_op());
            }

            // optional bool antialias = 2;
            if (has_antialias()) {
                total_size += 1 + 1;
            }

            // optional bytes clip_path = 3;
            if (has_clip_path()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->clip_path());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ClipPathDisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ClipPathDisplayItem*>(&from));
    }

    void ClipPathDisplayItem::MergeFrom(const ClipPathDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.ClipPathDisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_clip_op()) {
                set_clip_op(from.clip_op());
            }
            if (from.has_antialias()) {
                set_antialias(from.antialias());
            }
            if (from.has_clip_path()) {
                set_has_clip_path();
                clip_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clip_path_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ClipPathDisplayItem::CopyFrom(const ClipPathDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.ClipPathDisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ClipPathDisplayItem::IsInitialized() const
    {

        return true;
    }

    void ClipPathDisplayItem::Swap(ClipPathDisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ClipPathDisplayItem::InternalSwap(ClipPathDisplayItem* other)
    {
        std::swap(clip_op_, other->clip_op_);
        std::swap(antialias_, other->antialias_);
        clip_path_.Swap(&other->clip_path_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ClipPathDisplayItem::GetTypeName() const
    {
        return "cc.proto.ClipPathDisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ClipPathDisplayItem

    // optional .cc.proto.SkClipOp.Op clip_op = 1;
    bool ClipPathDisplayItem::has_clip_op() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ClipPathDisplayItem::set_has_clip_op()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ClipPathDisplayItem::clear_has_clip_op()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ClipPathDisplayItem::clear_clip_op()
    {
        clip_op_ = 0;
        clear_has_clip_op();
    }
    ::cc::proto::SkClipOp_Op ClipPathDisplayItem::clip_op() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipPathDisplayItem.clip_op)
        return static_cast<::cc::proto::SkClipOp_Op>(clip_op_);
    }
    void ClipPathDisplayItem::set_clip_op(::cc::proto::SkClipOp_Op value)
    {
        assert(::cc::proto::SkClipOp_Op_IsValid(value));
        set_has_clip_op();
        clip_op_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.ClipPathDisplayItem.clip_op)
    }

    // optional bool antialias = 2;
    bool ClipPathDisplayItem::has_antialias() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ClipPathDisplayItem::set_has_antialias()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ClipPathDisplayItem::clear_has_antialias()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ClipPathDisplayItem::clear_antialias()
    {
        antialias_ = false;
        clear_has_antialias();
    }
    bool ClipPathDisplayItem::antialias() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipPathDisplayItem.antialias)
        return antialias_;
    }
    void ClipPathDisplayItem::set_antialias(bool value)
    {
        set_has_antialias();
        antialias_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.ClipPathDisplayItem.antialias)
    }

    // optional bytes clip_path = 3;
    bool ClipPathDisplayItem::has_clip_path() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ClipPathDisplayItem::set_has_clip_path()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ClipPathDisplayItem::clear_has_clip_path()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ClipPathDisplayItem::clear_clip_path()
    {
        clip_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_clip_path();
    }
    const ::std::string& ClipPathDisplayItem::clip_path() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipPathDisplayItem.clip_path)
        return clip_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClipPathDisplayItem::set_clip_path(const ::std::string& value)
    {
        set_has_clip_path();
        clip_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:cc.proto.ClipPathDisplayItem.clip_path)
    }
    void ClipPathDisplayItem::set_clip_path(const char* value)
    {
        set_has_clip_path();
        clip_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:cc.proto.ClipPathDisplayItem.clip_path)
    }
    void ClipPathDisplayItem::set_clip_path(const void* value, size_t size)
    {
        set_has_clip_path();
        clip_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:cc.proto.ClipPathDisplayItem.clip_path)
    }
    ::std::string* ClipPathDisplayItem::mutable_clip_path()
    {
        set_has_clip_path();
        // @@protoc_insertion_point(field_mutable:cc.proto.ClipPathDisplayItem.clip_path)
        return clip_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ClipPathDisplayItem::release_clip_path()
    {
        // @@protoc_insertion_point(field_release:cc.proto.ClipPathDisplayItem.clip_path)
        clear_has_clip_path();
        return clip_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClipPathDisplayItem::set_allocated_clip_path(::std::string* clip_path)
    {
        if (clip_path != NULL) {
            set_has_clip_path();
        } else {
            clear_has_clip_path();
        }
        clip_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clip_path);
        // @@protoc_insertion_point(field_set_allocated:cc.proto.ClipPathDisplayItem.clip_path)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForCompositingDisplayItem(
        CompositingDisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int CompositingDisplayItem::kAlphaFieldNumber;
    const int CompositingDisplayItem::kModeFieldNumber;
    const int CompositingDisplayItem::kBoundsFieldNumber;
    const int CompositingDisplayItem::kColorFilterFieldNumber;
    const int CompositingDisplayItem::kLcdTextRequiresOpaqueLayerFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    CompositingDisplayItem::CompositingDisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.CompositingDisplayItem)
    }

    void CompositingDisplayItem::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        bounds_ = const_cast<::cc::proto::RectF*>(
            ::cc::proto::RectF::internal_default_instance());
#else
        bounds_ = const_cast<::cc::proto::RectF*>(&::cc::proto::RectF::default_instance());
#endif
    }

    CompositingDisplayItem::CompositingDisplayItem(const CompositingDisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.CompositingDisplayItem)
    }

    void CompositingDisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        alpha_ = 0u;
        mode_ = 0;
        bounds_ = NULL;
        color_filter_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        lcd_text_requires_opaque_layer_ = false;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    CompositingDisplayItem::~CompositingDisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.CompositingDisplayItem)
        SharedDtor();
    }

    void CompositingDisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        color_filter_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete bounds_;
        }
    }

    void CompositingDisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const CompositingDisplayItem& CompositingDisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    CompositingDisplayItem* CompositingDisplayItem::default_instance_ = NULL;

    CompositingDisplayItem* CompositingDisplayItem::New(::google::protobuf::Arena* arena) const
    {
        CompositingDisplayItem* n = new CompositingDisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void CompositingDisplayItem::Clear()
    {
// @@protoc_insertion_point(message_clear_start:cc.proto.CompositingDisplayItem)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                            \
    _Pragma("clang diagnostic push")                                                                             \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(CompositingDisplayItem, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<CompositingDisplayItem*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 31u) {
            ZR_(alpha_, mode_);
            if (has_bounds()) {
                if (bounds_ != NULL)
                    bounds_->::cc::proto::RectF::Clear();
            }
            if (has_color_filter()) {
                color_filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            lcd_text_requires_opaque_layer_ = false;
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool CompositingDisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForCompositingDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.CompositingDisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional uint32 alpha = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &alpha_)));
                    set_has_alpha();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_mode;
                break;
            }

            // optional .cc.proto.SkXfermode.Mode mode = 2;
            case 2: {
                if (tag == 16) {
                parse_mode:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::cc::proto::SkXfermode_Mode_IsValid(value)) {
                        set_mode(static_cast<::cc::proto::SkXfermode_Mode>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(16);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_bounds;
                break;
            }

            // optional .cc.proto.RectF bounds = 3;
            case 3: {
                if (tag == 26) {
                parse_bounds:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_bounds()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_color_filter;
                break;
            }

            // optional bytes color_filter = 4;
            case 4: {
                if (tag == 34) {
                parse_color_filter:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_color_filter()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(40))
                    goto parse_lcd_text_requires_opaque_layer;
                break;
            }

            // optional bool lcd_text_requires_opaque_layer = 5;
            case 5: {
                if (tag == 40) {
                parse_lcd_text_requires_opaque_layer:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &lcd_text_requires_opaque_layer_)));
                    set_has_lcd_text_requires_opaque_layer();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.CompositingDisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.CompositingDisplayItem)
        return false;
#undef DO_
    }

    void CompositingDisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.CompositingDisplayItem)
        // optional uint32 alpha = 1;
        if (has_alpha()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->alpha(), output);
        }

        // optional .cc.proto.SkXfermode.Mode mode = 2;
        if (has_mode()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                2, this->mode(), output);
        }

        // optional .cc.proto.RectF bounds = 3;
        if (has_bounds()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->bounds_, output);
        }

        // optional bytes color_filter = 4;
        if (has_color_filter()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                4, this->color_filter(), output);
        }

        // optional bool lcd_text_requires_opaque_layer = 5;
        if (has_lcd_text_requires_opaque_layer()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->lcd_text_requires_opaque_layer(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.CompositingDisplayItem)
    }

    int CompositingDisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.CompositingDisplayItem)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 31u) {
            // optional uint32 alpha = 1;
            if (has_alpha()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->alpha());
            }

            // optional .cc.proto.SkXfermode.Mode mode = 2;
            if (has_mode()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
            }

            // optional .cc.proto.RectF bounds = 3;
            if (has_bounds()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->bounds_);
            }

            // optional bytes color_filter = 4;
            if (has_color_filter()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->color_filter());
            }

            // optional bool lcd_text_requires_opaque_layer = 5;
            if (has_lcd_text_requires_opaque_layer()) {
                total_size += 1 + 1;
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void CompositingDisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const CompositingDisplayItem*>(&from));
    }

    void CompositingDisplayItem::MergeFrom(const CompositingDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.CompositingDisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_alpha()) {
                set_alpha(from.alpha());
            }
            if (from.has_mode()) {
                set_mode(from.mode());
            }
            if (from.has_bounds()) {
                mutable_bounds()->::cc::proto::RectF::MergeFrom(from.bounds());
            }
            if (from.has_color_filter()) {
                set_has_color_filter();
                color_filter_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.color_filter_);
            }
            if (from.has_lcd_text_requires_opaque_layer()) {
                set_lcd_text_requires_opaque_layer(from.lcd_text_requires_opaque_layer());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void CompositingDisplayItem::CopyFrom(const CompositingDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.CompositingDisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool CompositingDisplayItem::IsInitialized() const
    {

        return true;
    }

    void CompositingDisplayItem::Swap(CompositingDisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void CompositingDisplayItem::InternalSwap(CompositingDisplayItem* other)
    {
        std::swap(alpha_, other->alpha_);
        std::swap(mode_, other->mode_);
        std::swap(bounds_, other->bounds_);
        color_filter_.Swap(&other->color_filter_);
        std::swap(lcd_text_requires_opaque_layer_, other->lcd_text_requires_opaque_layer_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string CompositingDisplayItem::GetTypeName() const
    {
        return "cc.proto.CompositingDisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // CompositingDisplayItem

    // optional uint32 alpha = 1;
    bool CompositingDisplayItem::has_alpha() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void CompositingDisplayItem::set_has_alpha()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void CompositingDisplayItem::clear_has_alpha()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void CompositingDisplayItem::clear_alpha()
    {
        alpha_ = 0u;
        clear_has_alpha();
    }
    ::google::protobuf::uint32 CompositingDisplayItem::alpha() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.alpha)
        return alpha_;
    }
    void CompositingDisplayItem::set_alpha(::google::protobuf::uint32 value)
    {
        set_has_alpha();
        alpha_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.alpha)
    }

    // optional .cc.proto.SkXfermode.Mode mode = 2;
    bool CompositingDisplayItem::has_mode() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void CompositingDisplayItem::set_has_mode()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void CompositingDisplayItem::clear_has_mode()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void CompositingDisplayItem::clear_mode()
    {
        mode_ = 0;
        clear_has_mode();
    }
    ::cc::proto::SkXfermode_Mode CompositingDisplayItem::mode() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.mode)
        return static_cast<::cc::proto::SkXfermode_Mode>(mode_);
    }
    void CompositingDisplayItem::set_mode(::cc::proto::SkXfermode_Mode value)
    {
        assert(::cc::proto::SkXfermode_Mode_IsValid(value));
        set_has_mode();
        mode_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.mode)
    }

    // optional .cc.proto.RectF bounds = 3;
    bool CompositingDisplayItem::has_bounds() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void CompositingDisplayItem::set_has_bounds()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void CompositingDisplayItem::clear_has_bounds()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void CompositingDisplayItem::clear_bounds()
    {
        if (bounds_ != NULL)
            bounds_->::cc::proto::RectF::Clear();
        clear_has_bounds();
    }
    const ::cc::proto::RectF& CompositingDisplayItem::bounds() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
        return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
    }
    ::cc::proto::RectF* CompositingDisplayItem::mutable_bounds()
    {
        set_has_bounds();
        if (bounds_ == NULL) {
            bounds_ = new ::cc::proto::RectF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.CompositingDisplayItem.bounds)
        return bounds_;
    }
    ::cc::proto::RectF* CompositingDisplayItem::release_bounds()
    {
        // @@protoc_insertion_point(field_release:cc.proto.CompositingDisplayItem.bounds)
        clear_has_bounds();
        ::cc::proto::RectF* temp = bounds_;
        bounds_ = NULL;
        return temp;
    }
    void CompositingDisplayItem::set_allocated_bounds(::cc::proto::RectF* bounds)
    {
        delete bounds_;
        bounds_ = bounds;
        if (bounds) {
            set_has_bounds();
        } else {
            clear_has_bounds();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.CompositingDisplayItem.bounds)
    }

    // optional bytes color_filter = 4;
    bool CompositingDisplayItem::has_color_filter() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void CompositingDisplayItem::set_has_color_filter()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void CompositingDisplayItem::clear_has_color_filter()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void CompositingDisplayItem::clear_color_filter()
    {
        color_filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_color_filter();
    }
    const ::std::string& CompositingDisplayItem::color_filter() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.color_filter)
        return color_filter_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void CompositingDisplayItem::set_color_filter(const ::std::string& value)
    {
        set_has_color_filter();
        color_filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.color_filter)
    }
    void CompositingDisplayItem::set_color_filter(const char* value)
    {
        set_has_color_filter();
        color_filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:cc.proto.CompositingDisplayItem.color_filter)
    }
    void CompositingDisplayItem::set_color_filter(const void* value, size_t size)
    {
        set_has_color_filter();
        color_filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:cc.proto.CompositingDisplayItem.color_filter)
    }
    ::std::string* CompositingDisplayItem::mutable_color_filter()
    {
        set_has_color_filter();
        // @@protoc_insertion_point(field_mutable:cc.proto.CompositingDisplayItem.color_filter)
        return color_filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* CompositingDisplayItem::release_color_filter()
    {
        // @@protoc_insertion_point(field_release:cc.proto.CompositingDisplayItem.color_filter)
        clear_has_color_filter();
        return color_filter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void CompositingDisplayItem::set_allocated_color_filter(::std::string* color_filter)
    {
        if (color_filter != NULL) {
            set_has_color_filter();
        } else {
            clear_has_color_filter();
        }
        color_filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color_filter);
        // @@protoc_insertion_point(field_set_allocated:cc.proto.CompositingDisplayItem.color_filter)
    }

    // optional bool lcd_text_requires_opaque_layer = 5;
    bool CompositingDisplayItem::has_lcd_text_requires_opaque_layer() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void CompositingDisplayItem::set_has_lcd_text_requires_opaque_layer()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void CompositingDisplayItem::clear_has_lcd_text_requires_opaque_layer()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void CompositingDisplayItem::clear_lcd_text_requires_opaque_layer()
    {
        lcd_text_requires_opaque_layer_ = false;
        clear_has_lcd_text_requires_opaque_layer();
    }
    bool CompositingDisplayItem::lcd_text_requires_opaque_layer() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.lcd_text_requires_opaque_layer)
        return lcd_text_requires_opaque_layer_;
    }
    void CompositingDisplayItem::set_lcd_text_requires_opaque_layer(bool value)
    {
        set_has_lcd_text_requires_opaque_layer();
        lcd_text_requires_opaque_layer_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.lcd_text_requires_opaque_layer)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForSkPictureID(
        SkPictureID* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int SkPictureID::kUniqueIdFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    SkPictureID::SkPictureID()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.SkPictureID)
    }

    void SkPictureID::InitAsDefaultInstance()
    {
    }

    SkPictureID::SkPictureID(const SkPictureID& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.SkPictureID)
    }

    void SkPictureID::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        unique_id_ = 0u;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    SkPictureID::~SkPictureID()
    {
        // @@protoc_insertion_point(destructor:cc.proto.SkPictureID)
        SharedDtor();
    }

    void SkPictureID::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void SkPictureID::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const SkPictureID& SkPictureID::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    SkPictureID* SkPictureID::default_instance_ = NULL;

    SkPictureID* SkPictureID::New(::google::protobuf::Arena* arena) const
    {
        SkPictureID* n = new SkPictureID;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void SkPictureID::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.SkPictureID)
        unique_id_ = 0u;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool SkPictureID::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForSkPictureID, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.SkPictureID)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional uint32 unique_id = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &unique_id_)));
                    set_has_unique_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.SkPictureID)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.SkPictureID)
        return false;
#undef DO_
    }

    void SkPictureID::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.SkPictureID)
        // optional uint32 unique_id = 1;
        if (has_unique_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unique_id(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.SkPictureID)
    }

    int SkPictureID::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.SkPictureID)
        int total_size = 0;

        // optional uint32 unique_id = 1;
        if (has_unique_id()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->unique_id());
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void SkPictureID::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const SkPictureID*>(&from));
    }

    void SkPictureID::MergeFrom(const SkPictureID& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.SkPictureID)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_unique_id()) {
                set_unique_id(from.unique_id());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void SkPictureID::CopyFrom(const SkPictureID& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.SkPictureID)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool SkPictureID::IsInitialized() const
    {

        return true;
    }

    void SkPictureID::Swap(SkPictureID* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void SkPictureID::InternalSwap(SkPictureID* other)
    {
        std::swap(unique_id_, other->unique_id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string SkPictureID::GetTypeName() const
    {
        return "cc.proto.SkPictureID";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // SkPictureID

    // optional uint32 unique_id = 1;
    bool SkPictureID::has_unique_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void SkPictureID::set_has_unique_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void SkPictureID::clear_has_unique_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void SkPictureID::clear_unique_id()
    {
        unique_id_ = 0u;
        clear_has_unique_id();
    }
    ::google::protobuf::uint32 SkPictureID::unique_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SkPictureID.unique_id)
        return unique_id_;
    }
    void SkPictureID::set_unique_id(::google::protobuf::uint32 value)
    {
        set_has_unique_id();
        unique_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SkPictureID.unique_id)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForDrawingDisplayItem(
        DrawingDisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int DrawingDisplayItem::kIdFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    DrawingDisplayItem::DrawingDisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.DrawingDisplayItem)
    }

    void DrawingDisplayItem::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        id_ = const_cast<::cc::proto::SkPictureID*>(
            ::cc::proto::SkPictureID::internal_default_instance());
#else
        id_ = const_cast<::cc::proto::SkPictureID*>(&::cc::proto::SkPictureID::default_instance());
#endif
    }

    DrawingDisplayItem::DrawingDisplayItem(const DrawingDisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.DrawingDisplayItem)
    }

    void DrawingDisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        id_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    DrawingDisplayItem::~DrawingDisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.DrawingDisplayItem)
        SharedDtor();
    }

    void DrawingDisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete id_;
        }
    }

    void DrawingDisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const DrawingDisplayItem& DrawingDisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    DrawingDisplayItem* DrawingDisplayItem::default_instance_ = NULL;

    DrawingDisplayItem* DrawingDisplayItem::New(::google::protobuf::Arena* arena) const
    {
        DrawingDisplayItem* n = new DrawingDisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void DrawingDisplayItem::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.DrawingDisplayItem)
        if (has_id()) {
            if (id_ != NULL)
                id_->::cc::proto::SkPictureID::Clear();
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool DrawingDisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForDrawingDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.DrawingDisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.SkPictureID id = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_id()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.DrawingDisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.DrawingDisplayItem)
        return false;
#undef DO_
    }

    void DrawingDisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.DrawingDisplayItem)
        // optional .cc.proto.SkPictureID id = 1;
        if (has_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->id_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.DrawingDisplayItem)
    }

    int DrawingDisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.DrawingDisplayItem)
        int total_size = 0;

        // optional .cc.proto.SkPictureID id = 1;
        if (has_id()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->id_);
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void DrawingDisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const DrawingDisplayItem*>(&from));
    }

    void DrawingDisplayItem::MergeFrom(const DrawingDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.DrawingDisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_id()) {
                mutable_id()->::cc::proto::SkPictureID::MergeFrom(from.id());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void DrawingDisplayItem::CopyFrom(const DrawingDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.DrawingDisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool DrawingDisplayItem::IsInitialized() const
    {

        return true;
    }

    void DrawingDisplayItem::Swap(DrawingDisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void DrawingDisplayItem::InternalSwap(DrawingDisplayItem* other)
    {
        std::swap(id_, other->id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string DrawingDisplayItem::GetTypeName() const
    {
        return "cc.proto.DrawingDisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // DrawingDisplayItem

    // optional .cc.proto.SkPictureID id = 1;
    bool DrawingDisplayItem::has_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void DrawingDisplayItem::set_has_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void DrawingDisplayItem::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void DrawingDisplayItem::clear_id()
    {
        if (id_ != NULL)
            id_->::cc::proto::SkPictureID::Clear();
        clear_has_id();
    }
    const ::cc::proto::SkPictureID& DrawingDisplayItem::id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DrawingDisplayItem.id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return id_ != NULL ? *id_ : *default_instance().id_;
#else
        return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
    }
    ::cc::proto::SkPictureID* DrawingDisplayItem::mutable_id()
    {
        set_has_id();
        if (id_ == NULL) {
            id_ = new ::cc::proto::SkPictureID;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DrawingDisplayItem.id)
        return id_;
    }
    ::cc::proto::SkPictureID* DrawingDisplayItem::release_id()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DrawingDisplayItem.id)
        clear_has_id();
        ::cc::proto::SkPictureID* temp = id_;
        id_ = NULL;
        return temp;
    }
    void DrawingDisplayItem::set_allocated_id(::cc::proto::SkPictureID* id)
    {
        delete id_;
        id_ = id;
        if (id) {
            set_has_id();
        } else {
            clear_has_id();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DrawingDisplayItem.id)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForFilterDisplayItem(
        FilterDisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int FilterDisplayItem::kBoundsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    FilterDisplayItem::FilterDisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.FilterDisplayItem)
    }

    void FilterDisplayItem::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        bounds_ = const_cast<::cc::proto::RectF*>(
            ::cc::proto::RectF::internal_default_instance());
#else
        bounds_ = const_cast<::cc::proto::RectF*>(&::cc::proto::RectF::default_instance());
#endif
    }

    FilterDisplayItem::FilterDisplayItem(const FilterDisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.FilterDisplayItem)
    }

    void FilterDisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        bounds_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    FilterDisplayItem::~FilterDisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.FilterDisplayItem)
        SharedDtor();
    }

    void FilterDisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete bounds_;
        }
    }

    void FilterDisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const FilterDisplayItem& FilterDisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    FilterDisplayItem* FilterDisplayItem::default_instance_ = NULL;

    FilterDisplayItem* FilterDisplayItem::New(::google::protobuf::Arena* arena) const
    {
        FilterDisplayItem* n = new FilterDisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void FilterDisplayItem::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.FilterDisplayItem)
        if (has_bounds()) {
            if (bounds_ != NULL)
                bounds_->::cc::proto::RectF::Clear();
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool FilterDisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForFilterDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.FilterDisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.RectF bounds = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_bounds()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.FilterDisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.FilterDisplayItem)
        return false;
#undef DO_
    }

    void FilterDisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.FilterDisplayItem)
        // optional .cc.proto.RectF bounds = 1;
        if (has_bounds()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->bounds_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.FilterDisplayItem)
    }

    int FilterDisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.FilterDisplayItem)
        int total_size = 0;

        // optional .cc.proto.RectF bounds = 1;
        if (has_bounds()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->bounds_);
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void FilterDisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const FilterDisplayItem*>(&from));
    }

    void FilterDisplayItem::MergeFrom(const FilterDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.FilterDisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_bounds()) {
                mutable_bounds()->::cc::proto::RectF::MergeFrom(from.bounds());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void FilterDisplayItem::CopyFrom(const FilterDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.FilterDisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool FilterDisplayItem::IsInitialized() const
    {

        return true;
    }

    void FilterDisplayItem::Swap(FilterDisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void FilterDisplayItem::InternalSwap(FilterDisplayItem* other)
    {
        std::swap(bounds_, other->bounds_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string FilterDisplayItem::GetTypeName() const
    {
        return "cc.proto.FilterDisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // FilterDisplayItem

    // optional .cc.proto.RectF bounds = 1;
    bool FilterDisplayItem::has_bounds() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void FilterDisplayItem::set_has_bounds()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void FilterDisplayItem::clear_has_bounds()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void FilterDisplayItem::clear_bounds()
    {
        if (bounds_ != NULL)
            bounds_->::cc::proto::RectF::Clear();
        clear_has_bounds();
    }
    const ::cc::proto::RectF& FilterDisplayItem::bounds() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.FilterDisplayItem.bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
        return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
    }
    ::cc::proto::RectF* FilterDisplayItem::mutable_bounds()
    {
        set_has_bounds();
        if (bounds_ == NULL) {
            bounds_ = new ::cc::proto::RectF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.FilterDisplayItem.bounds)
        return bounds_;
    }
    ::cc::proto::RectF* FilterDisplayItem::release_bounds()
    {
        // @@protoc_insertion_point(field_release:cc.proto.FilterDisplayItem.bounds)
        clear_has_bounds();
        ::cc::proto::RectF* temp = bounds_;
        bounds_ = NULL;
        return temp;
    }
    void FilterDisplayItem::set_allocated_bounds(::cc::proto::RectF* bounds)
    {
        delete bounds_;
        bounds_ = bounds;
        if (bounds) {
            set_has_bounds();
        } else {
            clear_has_bounds();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.FilterDisplayItem.bounds)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForFloatClipDisplayItem(
        FloatClipDisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int FloatClipDisplayItem::kClipRectFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    FloatClipDisplayItem::FloatClipDisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.FloatClipDisplayItem)
    }

    void FloatClipDisplayItem::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        clip_rect_ = const_cast<::cc::proto::RectF*>(
            ::cc::proto::RectF::internal_default_instance());
#else
        clip_rect_ = const_cast<::cc::proto::RectF*>(&::cc::proto::RectF::default_instance());
#endif
    }

    FloatClipDisplayItem::FloatClipDisplayItem(const FloatClipDisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.FloatClipDisplayItem)
    }

    void FloatClipDisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clip_rect_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    FloatClipDisplayItem::~FloatClipDisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.FloatClipDisplayItem)
        SharedDtor();
    }

    void FloatClipDisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete clip_rect_;
        }
    }

    void FloatClipDisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const FloatClipDisplayItem& FloatClipDisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    FloatClipDisplayItem* FloatClipDisplayItem::default_instance_ = NULL;

    FloatClipDisplayItem* FloatClipDisplayItem::New(::google::protobuf::Arena* arena) const
    {
        FloatClipDisplayItem* n = new FloatClipDisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void FloatClipDisplayItem::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.FloatClipDisplayItem)
        if (has_clip_rect()) {
            if (clip_rect_ != NULL)
                clip_rect_->::cc::proto::RectF::Clear();
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool FloatClipDisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForFloatClipDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.FloatClipDisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.RectF clip_rect = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_clip_rect()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.FloatClipDisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.FloatClipDisplayItem)
        return false;
#undef DO_
    }

    void FloatClipDisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.FloatClipDisplayItem)
        // optional .cc.proto.RectF clip_rect = 1;
        if (has_clip_rect()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->clip_rect_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.FloatClipDisplayItem)
    }

    int FloatClipDisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.FloatClipDisplayItem)
        int total_size = 0;

        // optional .cc.proto.RectF clip_rect = 1;
        if (has_clip_rect()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->clip_rect_);
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void FloatClipDisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const FloatClipDisplayItem*>(&from));
    }

    void FloatClipDisplayItem::MergeFrom(const FloatClipDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.FloatClipDisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_clip_rect()) {
                mutable_clip_rect()->::cc::proto::RectF::MergeFrom(from.clip_rect());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void FloatClipDisplayItem::CopyFrom(const FloatClipDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.FloatClipDisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool FloatClipDisplayItem::IsInitialized() const
    {

        return true;
    }

    void FloatClipDisplayItem::Swap(FloatClipDisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void FloatClipDisplayItem::InternalSwap(FloatClipDisplayItem* other)
    {
        std::swap(clip_rect_, other->clip_rect_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string FloatClipDisplayItem::GetTypeName() const
    {
        return "cc.proto.FloatClipDisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // FloatClipDisplayItem

    // optional .cc.proto.RectF clip_rect = 1;
    bool FloatClipDisplayItem::has_clip_rect() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void FloatClipDisplayItem::set_has_clip_rect()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void FloatClipDisplayItem::clear_has_clip_rect()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void FloatClipDisplayItem::clear_clip_rect()
    {
        if (clip_rect_ != NULL)
            clip_rect_->::cc::proto::RectF::Clear();
        clear_has_clip_rect();
    }
    const ::cc::proto::RectF& FloatClipDisplayItem::clip_rect() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.FloatClipDisplayItem.clip_rect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance().clip_rect_;
#else
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance_->clip_rect_;
#endif
    }
    ::cc::proto::RectF* FloatClipDisplayItem::mutable_clip_rect()
    {
        set_has_clip_rect();
        if (clip_rect_ == NULL) {
            clip_rect_ = new ::cc::proto::RectF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.FloatClipDisplayItem.clip_rect)
        return clip_rect_;
    }
    ::cc::proto::RectF* FloatClipDisplayItem::release_clip_rect()
    {
        // @@protoc_insertion_point(field_release:cc.proto.FloatClipDisplayItem.clip_rect)
        clear_has_clip_rect();
        ::cc::proto::RectF* temp = clip_rect_;
        clip_rect_ = NULL;
        return temp;
    }
    void FloatClipDisplayItem::set_allocated_clip_rect(::cc::proto::RectF* clip_rect)
    {
        delete clip_rect_;
        clip_rect_ = clip_rect;
        if (clip_rect) {
            set_has_clip_rect();
        } else {
            clear_has_clip_rect();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.FloatClipDisplayItem.clip_rect)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForTransformDisplayItem(
        TransformDisplayItem* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int TransformDisplayItem::kTransformFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    TransformDisplayItem::TransformDisplayItem()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.TransformDisplayItem)
    }

    void TransformDisplayItem::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        transform_ = const_cast<::cc::proto::Transform*>(
            ::cc::proto::Transform::internal_default_instance());
#else
        transform_ = const_cast<::cc::proto::Transform*>(&::cc::proto::Transform::default_instance());
#endif
    }

    TransformDisplayItem::TransformDisplayItem(const TransformDisplayItem& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.TransformDisplayItem)
    }

    void TransformDisplayItem::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        transform_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    TransformDisplayItem::~TransformDisplayItem()
    {
        // @@protoc_insertion_point(destructor:cc.proto.TransformDisplayItem)
        SharedDtor();
    }

    void TransformDisplayItem::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete transform_;
        }
    }

    void TransformDisplayItem::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const TransformDisplayItem& TransformDisplayItem::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_display_5fitem_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_display_5fitem_2eproto();
#endif
        return *default_instance_;
    }

    TransformDisplayItem* TransformDisplayItem::default_instance_ = NULL;

    TransformDisplayItem* TransformDisplayItem::New(::google::protobuf::Arena* arena) const
    {
        TransformDisplayItem* n = new TransformDisplayItem;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void TransformDisplayItem::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.TransformDisplayItem)
        if (has_transform()) {
            if (transform_ != NULL)
                transform_->::cc::proto::Transform::Clear();
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool TransformDisplayItem::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForTransformDisplayItem, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.TransformDisplayItem)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.Transform transform = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_transform()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.TransformDisplayItem)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.TransformDisplayItem)
        return false;
#undef DO_
    }

    void TransformDisplayItem::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.TransformDisplayItem)
        // optional .cc.proto.Transform transform = 1;
        if (has_transform()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->transform_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.TransformDisplayItem)
    }

    int TransformDisplayItem::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.TransformDisplayItem)
        int total_size = 0;

        // optional .cc.proto.Transform transform = 1;
        if (has_transform()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->transform_);
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void TransformDisplayItem::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const TransformDisplayItem*>(&from));
    }

    void TransformDisplayItem::MergeFrom(const TransformDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.TransformDisplayItem)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_transform()) {
                mutable_transform()->::cc::proto::Transform::MergeFrom(from.transform());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void TransformDisplayItem::CopyFrom(const TransformDisplayItem& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.TransformDisplayItem)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool TransformDisplayItem::IsInitialized() const
    {

        return true;
    }

    void TransformDisplayItem::Swap(TransformDisplayItem* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void TransformDisplayItem::InternalSwap(TransformDisplayItem* other)
    {
        std::swap(transform_, other->transform_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string TransformDisplayItem::GetTypeName() const
    {
        return "cc.proto.TransformDisplayItem";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // TransformDisplayItem

    // optional .cc.proto.Transform transform = 1;
    bool TransformDisplayItem::has_transform() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void TransformDisplayItem::set_has_transform()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void TransformDisplayItem::clear_has_transform()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void TransformDisplayItem::clear_transform()
    {
        if (transform_ != NULL)
            transform_->::cc::proto::Transform::Clear();
        clear_has_transform();
    }
    const ::cc::proto::Transform& TransformDisplayItem::transform() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.TransformDisplayItem.transform)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_ != NULL ? *transform_ : *default_instance().transform_;
#else
        return transform_ != NULL ? *transform_ : *default_instance_->transform_;
#endif
    }
    ::cc::proto::Transform* TransformDisplayItem::mutable_transform()
    {
        set_has_transform();
        if (transform_ == NULL) {
            transform_ = new ::cc::proto::Transform;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.TransformDisplayItem.transform)
        return transform_;
    }
    ::cc::proto::Transform* TransformDisplayItem::release_transform()
    {
        // @@protoc_insertion_point(field_release:cc.proto.TransformDisplayItem.transform)
        clear_has_transform();
        ::cc::proto::Transform* temp = transform_;
        transform_ = NULL;
        return temp;
    }
    void TransformDisplayItem::set_allocated_transform(::cc::proto::Transform* transform)
    {
        delete transform_;
        transform_ = transform;
        if (transform) {
            set_has_transform();
        } else {
            clear_has_transform();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.TransformDisplayItem.transform)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace cc

// @@protoc_insertion_point(global_scope)
