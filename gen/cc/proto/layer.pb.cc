// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "layer.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace cc {
namespace proto {

    void protobuf_ShutdownFile_layer_2eproto()
    {
        delete LayerNode::default_instance_;
        delete LayerUpdate::default_instance_;
        delete LayerProperties::default_instance_;
        delete BaseLayerProperties::default_instance_;
        delete PictureLayerProperties::default_instance_;
        delete SolidColorScrollbarLayerProperties::default_instance_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    void protobuf_AddDesc_layer_2eproto_impl()
    {
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
    void protobuf_AddDesc_layer_2eproto()
    {
        static bool already_here = false;
        if (already_here)
            return;
        already_here = true;
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
        ::cc::proto::protobuf_AddDesc_display_5fitem_2eproto();
        ::cc::proto::protobuf_AddDesc_layer_5fposition_5fconstraint_2eproto();
        ::cc::proto::protobuf_AddDesc_layer_5fsticky_5fposition_5fconstraint_2eproto();
        ::cc::proto::protobuf_AddDesc_point3f_2eproto();
        ::cc::proto::protobuf_AddDesc_pointf_2eproto();
        ::cc::proto::protobuf_AddDesc_rect_2eproto();
        ::cc::proto::protobuf_AddDesc_region_2eproto();
        ::cc::proto::protobuf_AddDesc_scroll_5foffset_2eproto();
        ::cc::proto::protobuf_AddDesc_size_2eproto();
        ::cc::proto::protobuf_AddDesc_skxfermode_2eproto();
        ::cc::proto::protobuf_AddDesc_transform_2eproto();
        ::cc::proto::protobuf_AddDesc_vector2df_2eproto();
        LayerNode::default_instance_ = new LayerNode();
        LayerUpdate::default_instance_ = new LayerUpdate();
        LayerProperties::default_instance_ = new LayerProperties();
        BaseLayerProperties::default_instance_ = new BaseLayerProperties();
        PictureLayerProperties::default_instance_ = new PictureLayerProperties();
        SolidColorScrollbarLayerProperties::default_instance_ = new SolidColorScrollbarLayerProperties();
        LayerNode::default_instance_->InitAsDefaultInstance();
        LayerUpdate::default_instance_->InitAsDefaultInstance();
        LayerProperties::default_instance_->InitAsDefaultInstance();
        BaseLayerProperties::default_instance_->InitAsDefaultInstance();
        PictureLayerProperties::default_instance_->InitAsDefaultInstance();
        SolidColorScrollbarLayerProperties::default_instance_->InitAsDefaultInstance();
        ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_layer_2eproto);
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_layer_2eproto_once_);
    void protobuf_AddDesc_layer_2eproto()
    {
        ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_layer_2eproto_once_,
            &protobuf_AddDesc_layer_2eproto_impl);
    }
#else
    // Force AddDescriptors() to be called at static initialization time.
    struct StaticDescriptorInitializer_layer_2eproto {
        StaticDescriptorInitializer_layer_2eproto()
        {
            protobuf_AddDesc_layer_2eproto();
        }
    } static_descriptor_initializer_layer_2eproto_;
#endif

    namespace {

        static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
        GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line)
        {
            GOOGLE_CHECK(false) << __FILE__ << ":" << line;
        }

    } // namespace

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForLayerNode(
        LayerNode* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool LayerNode_Type_IsValid(int value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 4:
        case 5:
        case 6:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const LayerNode_Type LayerNode::UNKNOWN;
    const LayerNode_Type LayerNode::LAYER;
    const LayerNode_Type LayerNode::PICTURE_LAYER;
    const LayerNode_Type LayerNode::SOLID_COLOR_SCROLLBAR_LAYER;
    const LayerNode_Type LayerNode::FAKE_PICTURE_LAYER;
    const LayerNode_Type LayerNode::PUSH_PROPERTIES_COUNTING_LAYER;
    const LayerNode_Type LayerNode::Type_MIN;
    const LayerNode_Type LayerNode::Type_MAX;
    const int LayerNode::Type_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int LayerNode::kIdFieldNumber;
    const int LayerNode::kTypeFieldNumber;
    const int LayerNode::kParentIdFieldNumber;
    const int LayerNode::kChildrenFieldNumber;
    const int LayerNode::kMaskLayerFieldNumber;
    const int LayerNode::kSolidScrollbarFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    LayerNode::LayerNode()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.LayerNode)
    }

    void LayerNode::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        mask_layer_ = const_cast<::cc::proto::LayerNode*>(
            ::cc::proto::LayerNode::internal_default_instance());
#else
        mask_layer_ = const_cast<::cc::proto::LayerNode*>(&::cc::proto::LayerNode::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        solid_scrollbar_ = const_cast<::cc::proto::SolidColorScrollbarLayerProperties*>(
            ::cc::proto::SolidColorScrollbarLayerProperties::internal_default_instance());
#else
        solid_scrollbar_ = const_cast<::cc::proto::SolidColorScrollbarLayerProperties*>(&::cc::proto::SolidColorScrollbarLayerProperties::default_instance());
#endif
    }

    LayerNode::LayerNode(const LayerNode& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.LayerNode)
    }

    void LayerNode::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        id_ = 0;
        type_ = 0;
        parent_id_ = 0;
        mask_layer_ = NULL;
        solid_scrollbar_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    LayerNode::~LayerNode()
    {
        // @@protoc_insertion_point(destructor:cc.proto.LayerNode)
        SharedDtor();
    }

    void LayerNode::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete mask_layer_;
            delete solid_scrollbar_;
        }
    }

    void LayerNode::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const LayerNode& LayerNode::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_layer_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_layer_2eproto();
#endif
        return *default_instance_;
    }

    LayerNode* LayerNode::default_instance_ = NULL;

    LayerNode* LayerNode::New(::google::protobuf::Arena* arena) const
    {
        LayerNode* n = new LayerNode;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void LayerNode::Clear()
    {
// @@protoc_insertion_point(message_clear_start:cc.proto.LayerNode)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                               \
    _Pragma("clang diagnostic push")                                                                \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(LayerNode, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<LayerNode*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 55u) {
            ZR_(id_, type_);
            parent_id_ = 0;
            if (has_mask_layer()) {
                if (mask_layer_ != NULL)
                    mask_layer_->::cc::proto::LayerNode::Clear();
            }
            if (has_solid_scrollbar()) {
                if (solid_scrollbar_ != NULL)
                    solid_scrollbar_->::cc::proto::SolidColorScrollbarLayerProperties::Clear();
            }
        }

#undef ZR_HELPER_
#undef ZR_

        children_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool LayerNode::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForLayerNode, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.LayerNode)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 id = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &id_)));
                    set_has_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_type;
                break;
            }

            // optional .cc.proto.LayerNode.Type type = 2;
            case 2: {
                if (tag == 16) {
                parse_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::cc::proto::LayerNode_Type_IsValid(value)) {
                        set_type(static_cast<::cc::proto::LayerNode_Type>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(16);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_parent_id;
                break;
            }

            // optional int32 parent_id = 3;
            case 3: {
                if (tag == 24) {
                parse_parent_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &parent_id_)));
                    set_has_parent_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_children;
                break;
            }

            // repeated .cc.proto.LayerNode children = 4;
            case 4: {
                if (tag == 34) {
                parse_children:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_children:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_children()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_loop_children;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectTag(42))
                    goto parse_mask_layer;
                break;
            }

            // optional .cc.proto.LayerNode mask_layer = 5;
            case 5: {
                if (tag == 42) {
                parse_mask_layer:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_mask_layer()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(50))
                    goto parse_solid_scrollbar;
                break;
            }

            // optional .cc.proto.SolidColorScrollbarLayerProperties solid_scrollbar = 6;
            case 6: {
                if (tag == 50) {
                parse_solid_scrollbar:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_solid_scrollbar()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.LayerNode)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.LayerNode)
        return false;
#undef DO_
    }

    void LayerNode::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.LayerNode)
        // optional int32 id = 1;
        if (has_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
        }

        // optional .cc.proto.LayerNode.Type type = 2;
        if (has_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                2, this->type(), output);
        }

        // optional int32 parent_id = 3;
        if (has_parent_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->parent_id(), output);
        }

        // repeated .cc.proto.LayerNode children = 4;
        for (unsigned int i = 0, n = this->children_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                4, this->children(i), output);
        }

        // optional .cc.proto.LayerNode mask_layer = 5;
        if (has_mask_layer()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, *this->mask_layer_, output);
        }

        // optional .cc.proto.SolidColorScrollbarLayerProperties solid_scrollbar = 6;
        if (has_solid_scrollbar()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                6, *this->solid_scrollbar_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.LayerNode)
    }

    int LayerNode::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.LayerNode)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 55u) {
            // optional int32 id = 1;
            if (has_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->id());
            }

            // optional .cc.proto.LayerNode.Type type = 2;
            if (has_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
            }

            // optional int32 parent_id = 3;
            if (has_parent_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->parent_id());
            }

            // optional .cc.proto.LayerNode mask_layer = 5;
            if (has_mask_layer()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->mask_layer_);
            }

            // optional .cc.proto.SolidColorScrollbarLayerProperties solid_scrollbar = 6;
            if (has_solid_scrollbar()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->solid_scrollbar_);
            }
        }
        // repeated .cc.proto.LayerNode children = 4;
        total_size += 1 * this->children_size();
        for (int i = 0; i < this->children_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->children(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void LayerNode::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const LayerNode*>(&from));
    }

    void LayerNode::MergeFrom(const LayerNode& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.LayerNode)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        children_.MergeFrom(from.children_);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_id()) {
                set_id(from.id());
            }
            if (from.has_type()) {
                set_type(from.type());
            }
            if (from.has_parent_id()) {
                set_parent_id(from.parent_id());
            }
            if (from.has_mask_layer()) {
                mutable_mask_layer()->::cc::proto::LayerNode::MergeFrom(from.mask_layer());
            }
            if (from.has_solid_scrollbar()) {
                mutable_solid_scrollbar()->::cc::proto::SolidColorScrollbarLayerProperties::MergeFrom(from.solid_scrollbar());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void LayerNode::CopyFrom(const LayerNode& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.LayerNode)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool LayerNode::IsInitialized() const
    {

        return true;
    }

    void LayerNode::Swap(LayerNode* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void LayerNode::InternalSwap(LayerNode* other)
    {
        std::swap(id_, other->id_);
        std::swap(type_, other->type_);
        std::swap(parent_id_, other->parent_id_);
        children_.UnsafeArenaSwap(&other->children_);
        std::swap(mask_layer_, other->mask_layer_);
        std::swap(solid_scrollbar_, other->solid_scrollbar_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string LayerNode::GetTypeName() const
    {
        return "cc.proto.LayerNode";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // LayerNode

    // optional int32 id = 1;
    bool LayerNode::has_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void LayerNode::set_has_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void LayerNode::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void LayerNode::clear_id()
    {
        id_ = 0;
        clear_has_id();
    }
    ::google::protobuf::int32 LayerNode::id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.id)
        return id_;
    }
    void LayerNode::set_id(::google::protobuf::int32 value)
    {
        set_has_id();
        id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerNode.id)
    }

    // optional .cc.proto.LayerNode.Type type = 2;
    bool LayerNode::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void LayerNode::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void LayerNode::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void LayerNode::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    ::cc::proto::LayerNode_Type LayerNode::type() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.type)
        return static_cast<::cc::proto::LayerNode_Type>(type_);
    }
    void LayerNode::set_type(::cc::proto::LayerNode_Type value)
    {
        assert(::cc::proto::LayerNode_Type_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerNode.type)
    }

    // optional int32 parent_id = 3;
    bool LayerNode::has_parent_id() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void LayerNode::set_has_parent_id()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void LayerNode::clear_has_parent_id()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void LayerNode::clear_parent_id()
    {
        parent_id_ = 0;
        clear_has_parent_id();
    }
    ::google::protobuf::int32 LayerNode::parent_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.parent_id)
        return parent_id_;
    }
    void LayerNode::set_parent_id(::google::protobuf::int32 value)
    {
        set_has_parent_id();
        parent_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerNode.parent_id)
    }

    // repeated .cc.proto.LayerNode children = 4;
    int LayerNode::children_size() const
    {
        return children_.size();
    }
    void LayerNode::clear_children()
    {
        children_.Clear();
    }
    const ::cc::proto::LayerNode& LayerNode::children(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.children)
        return children_.Get(index);
    }
    ::cc::proto::LayerNode* LayerNode::mutable_children(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerNode.children)
        return children_.Mutable(index);
    }
    ::cc::proto::LayerNode* LayerNode::add_children()
    {
        // @@protoc_insertion_point(field_add:cc.proto.LayerNode.children)
        return children_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::cc::proto::LayerNode>*
    LayerNode::mutable_children()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.LayerNode.children)
        return &children_;
    }
    const ::google::protobuf::RepeatedPtrField<::cc::proto::LayerNode>&
    LayerNode::children() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.LayerNode.children)
        return children_;
    }

    // optional .cc.proto.LayerNode mask_layer = 5;
    bool LayerNode::has_mask_layer() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void LayerNode::set_has_mask_layer()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void LayerNode::clear_has_mask_layer()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void LayerNode::clear_mask_layer()
    {
        if (mask_layer_ != NULL)
            mask_layer_->::cc::proto::LayerNode::Clear();
        clear_has_mask_layer();
    }
    const ::cc::proto::LayerNode& LayerNode::mask_layer() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.mask_layer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return mask_layer_ != NULL ? *mask_layer_ : *default_instance().mask_layer_;
#else
        return mask_layer_ != NULL ? *mask_layer_ : *default_instance_->mask_layer_;
#endif
    }
    ::cc::proto::LayerNode* LayerNode::mutable_mask_layer()
    {
        set_has_mask_layer();
        if (mask_layer_ == NULL) {
            mask_layer_ = new ::cc::proto::LayerNode;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerNode.mask_layer)
        return mask_layer_;
    }
    ::cc::proto::LayerNode* LayerNode::release_mask_layer()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerNode.mask_layer)
        clear_has_mask_layer();
        ::cc::proto::LayerNode* temp = mask_layer_;
        mask_layer_ = NULL;
        return temp;
    }
    void LayerNode::set_allocated_mask_layer(::cc::proto::LayerNode* mask_layer)
    {
        delete mask_layer_;
        mask_layer_ = mask_layer;
        if (mask_layer) {
            set_has_mask_layer();
        } else {
            clear_has_mask_layer();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerNode.mask_layer)
    }

    // optional .cc.proto.SolidColorScrollbarLayerProperties solid_scrollbar = 6;
    bool LayerNode::has_solid_scrollbar() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void LayerNode::set_has_solid_scrollbar()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void LayerNode::clear_has_solid_scrollbar()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void LayerNode::clear_solid_scrollbar()
    {
        if (solid_scrollbar_ != NULL)
            solid_scrollbar_->::cc::proto::SolidColorScrollbarLayerProperties::Clear();
        clear_has_solid_scrollbar();
    }
    const ::cc::proto::SolidColorScrollbarLayerProperties& LayerNode::solid_scrollbar() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.solid_scrollbar)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return solid_scrollbar_ != NULL ? *solid_scrollbar_ : *default_instance().solid_scrollbar_;
#else
        return solid_scrollbar_ != NULL ? *solid_scrollbar_ : *default_instance_->solid_scrollbar_;
#endif
    }
    ::cc::proto::SolidColorScrollbarLayerProperties* LayerNode::mutable_solid_scrollbar()
    {
        set_has_solid_scrollbar();
        if (solid_scrollbar_ == NULL) {
            solid_scrollbar_ = new ::cc::proto::SolidColorScrollbarLayerProperties;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerNode.solid_scrollbar)
        return solid_scrollbar_;
    }
    ::cc::proto::SolidColorScrollbarLayerProperties* LayerNode::release_solid_scrollbar()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerNode.solid_scrollbar)
        clear_has_solid_scrollbar();
        ::cc::proto::SolidColorScrollbarLayerProperties* temp = solid_scrollbar_;
        solid_scrollbar_ = NULL;
        return temp;
    }
    void LayerNode::set_allocated_solid_scrollbar(::cc::proto::SolidColorScrollbarLayerProperties* solid_scrollbar)
    {
        delete solid_scrollbar_;
        solid_scrollbar_ = solid_scrollbar;
        if (solid_scrollbar) {
            set_has_solid_scrollbar();
        } else {
            clear_has_solid_scrollbar();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerNode.solid_scrollbar)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForLayerUpdate(
        LayerUpdate* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int LayerUpdate::kLayersFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    LayerUpdate::LayerUpdate()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.LayerUpdate)
    }

    void LayerUpdate::InitAsDefaultInstance()
    {
    }

    LayerUpdate::LayerUpdate(const LayerUpdate& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.LayerUpdate)
    }

    void LayerUpdate::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    LayerUpdate::~LayerUpdate()
    {
        // @@protoc_insertion_point(destructor:cc.proto.LayerUpdate)
        SharedDtor();
    }

    void LayerUpdate::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void LayerUpdate::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const LayerUpdate& LayerUpdate::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_layer_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_layer_2eproto();
#endif
        return *default_instance_;
    }

    LayerUpdate* LayerUpdate::default_instance_ = NULL;

    LayerUpdate* LayerUpdate::New(::google::protobuf::Arena* arena) const
    {
        LayerUpdate* n = new LayerUpdate;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void LayerUpdate::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.LayerUpdate)
        layers_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool LayerUpdate::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForLayerUpdate, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.LayerUpdate)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .cc.proto.LayerProperties layers = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_layers:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_layers()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_layers;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.LayerUpdate)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.LayerUpdate)
        return false;
#undef DO_
    }

    void LayerUpdate::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.LayerUpdate)
        // repeated .cc.proto.LayerProperties layers = 1;
        for (unsigned int i = 0, n = this->layers_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->layers(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.LayerUpdate)
    }

    int LayerUpdate::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.LayerUpdate)
        int total_size = 0;

        // repeated .cc.proto.LayerProperties layers = 1;
        total_size += 1 * this->layers_size();
        for (int i = 0; i < this->layers_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->layers(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void LayerUpdate::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const LayerUpdate*>(&from));
    }

    void LayerUpdate::MergeFrom(const LayerUpdate& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.LayerUpdate)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        layers_.MergeFrom(from.layers_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void LayerUpdate::CopyFrom(const LayerUpdate& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.LayerUpdate)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool LayerUpdate::IsInitialized() const
    {

        return true;
    }

    void LayerUpdate::Swap(LayerUpdate* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void LayerUpdate::InternalSwap(LayerUpdate* other)
    {
        layers_.UnsafeArenaSwap(&other->layers_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string LayerUpdate::GetTypeName() const
    {
        return "cc.proto.LayerUpdate";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // LayerUpdate

    // repeated .cc.proto.LayerProperties layers = 1;
    int LayerUpdate::layers_size() const
    {
        return layers_.size();
    }
    void LayerUpdate::clear_layers()
    {
        layers_.Clear();
    }
    const ::cc::proto::LayerProperties& LayerUpdate::layers(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerUpdate.layers)
        return layers_.Get(index);
    }
    ::cc::proto::LayerProperties* LayerUpdate::mutable_layers(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerUpdate.layers)
        return layers_.Mutable(index);
    }
    ::cc::proto::LayerProperties* LayerUpdate::add_layers()
    {
        // @@protoc_insertion_point(field_add:cc.proto.LayerUpdate.layers)
        return layers_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::cc::proto::LayerProperties>*
    LayerUpdate::mutable_layers()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.LayerUpdate.layers)
        return &layers_;
    }
    const ::google::protobuf::RepeatedPtrField<::cc::proto::LayerProperties>&
    LayerUpdate::layers() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.LayerUpdate.layers)
        return layers_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForLayerProperties(
        LayerProperties* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int LayerProperties::kIdFieldNumber;
    const int LayerProperties::kBaseFieldNumber;
    const int LayerProperties::kPictureFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    LayerProperties::LayerProperties()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.LayerProperties)
    }

    void LayerProperties::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        base_ = const_cast<::cc::proto::BaseLayerProperties*>(
            ::cc::proto::BaseLayerProperties::internal_default_instance());
#else
        base_ = const_cast<::cc::proto::BaseLayerProperties*>(&::cc::proto::BaseLayerProperties::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        picture_ = const_cast<::cc::proto::PictureLayerProperties*>(
            ::cc::proto::PictureLayerProperties::internal_default_instance());
#else
        picture_ = const_cast<::cc::proto::PictureLayerProperties*>(&::cc::proto::PictureLayerProperties::default_instance());
#endif
    }

    LayerProperties::LayerProperties(const LayerProperties& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.LayerProperties)
    }

    void LayerProperties::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        id_ = 0;
        base_ = NULL;
        picture_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    LayerProperties::~LayerProperties()
    {
        // @@protoc_insertion_point(destructor:cc.proto.LayerProperties)
        SharedDtor();
    }

    void LayerProperties::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete base_;
            delete picture_;
        }
    }

    void LayerProperties::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const LayerProperties& LayerProperties::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_layer_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_layer_2eproto();
#endif
        return *default_instance_;
    }

    LayerProperties* LayerProperties::default_instance_ = NULL;

    LayerProperties* LayerProperties::New(::google::protobuf::Arena* arena) const
    {
        LayerProperties* n = new LayerProperties;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void LayerProperties::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.LayerProperties)
        if (_has_bits_[0 / 32] & 7u) {
            id_ = 0;
            if (has_base()) {
                if (base_ != NULL)
                    base_->::cc::proto::BaseLayerProperties::Clear();
            }
            if (has_picture()) {
                if (picture_ != NULL)
                    picture_->::cc::proto::PictureLayerProperties::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool LayerProperties::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForLayerProperties, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.LayerProperties)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 id = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &id_)));
                    set_has_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_base;
                break;
            }

            // optional .cc.proto.BaseLayerProperties base = 5;
            case 5: {
                if (tag == 42) {
                parse_base:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_base()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(50))
                    goto parse_picture;
                break;
            }

            // optional .cc.proto.PictureLayerProperties picture = 6;
            case 6: {
                if (tag == 50) {
                parse_picture:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_picture()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.LayerProperties)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.LayerProperties)
        return false;
#undef DO_
    }

    void LayerProperties::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.LayerProperties)
        // optional int32 id = 1;
        if (has_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
        }

        // optional .cc.proto.BaseLayerProperties base = 5;
        if (has_base()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, *this->base_, output);
        }

        // optional .cc.proto.PictureLayerProperties picture = 6;
        if (has_picture()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                6, *this->picture_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.LayerProperties)
    }

    int LayerProperties::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.LayerProperties)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 7u) {
            // optional int32 id = 1;
            if (has_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->id());
            }

            // optional .cc.proto.BaseLayerProperties base = 5;
            if (has_base()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->base_);
            }

            // optional .cc.proto.PictureLayerProperties picture = 6;
            if (has_picture()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->picture_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void LayerProperties::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const LayerProperties*>(&from));
    }

    void LayerProperties::MergeFrom(const LayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.LayerProperties)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_id()) {
                set_id(from.id());
            }
            if (from.has_base()) {
                mutable_base()->::cc::proto::BaseLayerProperties::MergeFrom(from.base());
            }
            if (from.has_picture()) {
                mutable_picture()->::cc::proto::PictureLayerProperties::MergeFrom(from.picture());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void LayerProperties::CopyFrom(const LayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.LayerProperties)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool LayerProperties::IsInitialized() const
    {

        return true;
    }

    void LayerProperties::Swap(LayerProperties* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void LayerProperties::InternalSwap(LayerProperties* other)
    {
        std::swap(id_, other->id_);
        std::swap(base_, other->base_);
        std::swap(picture_, other->picture_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string LayerProperties::GetTypeName() const
    {
        return "cc.proto.LayerProperties";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // LayerProperties

    // optional int32 id = 1;
    bool LayerProperties::has_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void LayerProperties::set_has_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void LayerProperties::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void LayerProperties::clear_id()
    {
        id_ = 0;
        clear_has_id();
    }
    ::google::protobuf::int32 LayerProperties::id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerProperties.id)
        return id_;
    }
    void LayerProperties::set_id(::google::protobuf::int32 value)
    {
        set_has_id();
        id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerProperties.id)
    }

    // optional .cc.proto.BaseLayerProperties base = 5;
    bool LayerProperties::has_base() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void LayerProperties::set_has_base()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void LayerProperties::clear_has_base()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void LayerProperties::clear_base()
    {
        if (base_ != NULL)
            base_->::cc::proto::BaseLayerProperties::Clear();
        clear_has_base();
    }
    const ::cc::proto::BaseLayerProperties& LayerProperties::base() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerProperties.base)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return base_ != NULL ? *base_ : *default_instance().base_;
#else
        return base_ != NULL ? *base_ : *default_instance_->base_;
#endif
    }
    ::cc::proto::BaseLayerProperties* LayerProperties::mutable_base()
    {
        set_has_base();
        if (base_ == NULL) {
            base_ = new ::cc::proto::BaseLayerProperties;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerProperties.base)
        return base_;
    }
    ::cc::proto::BaseLayerProperties* LayerProperties::release_base()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerProperties.base)
        clear_has_base();
        ::cc::proto::BaseLayerProperties* temp = base_;
        base_ = NULL;
        return temp;
    }
    void LayerProperties::set_allocated_base(::cc::proto::BaseLayerProperties* base)
    {
        delete base_;
        base_ = base;
        if (base) {
            set_has_base();
        } else {
            clear_has_base();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerProperties.base)
    }

    // optional .cc.proto.PictureLayerProperties picture = 6;
    bool LayerProperties::has_picture() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void LayerProperties::set_has_picture()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void LayerProperties::clear_has_picture()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void LayerProperties::clear_picture()
    {
        if (picture_ != NULL)
            picture_->::cc::proto::PictureLayerProperties::Clear();
        clear_has_picture();
    }
    const ::cc::proto::PictureLayerProperties& LayerProperties::picture() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerProperties.picture)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return picture_ != NULL ? *picture_ : *default_instance().picture_;
#else
        return picture_ != NULL ? *picture_ : *default_instance_->picture_;
#endif
    }
    ::cc::proto::PictureLayerProperties* LayerProperties::mutable_picture()
    {
        set_has_picture();
        if (picture_ == NULL) {
            picture_ = new ::cc::proto::PictureLayerProperties;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerProperties.picture)
        return picture_;
    }
    ::cc::proto::PictureLayerProperties* LayerProperties::release_picture()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerProperties.picture)
        clear_has_picture();
        ::cc::proto::PictureLayerProperties* temp = picture_;
        picture_ = NULL;
        return temp;
    }
    void LayerProperties::set_allocated_picture(::cc::proto::PictureLayerProperties* picture)
    {
        delete picture_;
        picture_ = picture;
        if (picture) {
            set_has_picture();
        } else {
            clear_has_picture();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerProperties.picture)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForBaseLayerProperties(
        BaseLayerProperties* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int BaseLayerProperties::kUpdateRectFieldNumber;
    const int BaseLayerProperties::kBoundsFieldNumber;
    const int BaseLayerProperties::kMasksToBoundsFieldNumber;
    const int BaseLayerProperties::kOpacityFieldNumber;
    const int BaseLayerProperties::kBlendModeFieldNumber;
    const int BaseLayerProperties::kIsRootForIsolatedGroupFieldNumber;
    const int BaseLayerProperties::kContentsOpaqueFieldNumber;
    const int BaseLayerProperties::kPositionFieldNumber;
    const int BaseLayerProperties::kTransformFieldNumber;
    const int BaseLayerProperties::kTransformOriginFieldNumber;
    const int BaseLayerProperties::kIsDrawableFieldNumber;
    const int BaseLayerProperties::kDoubleSidedFieldNumber;
    const int BaseLayerProperties::kShouldFlattenTransformFieldNumber;
    const int BaseLayerProperties::kSortingContextIdFieldNumber;
    const int BaseLayerProperties::kUseParentBackfaceVisibilityFieldNumber;
    const int BaseLayerProperties::kBackgroundColorFieldNumber;
    const int BaseLayerProperties::kScrollOffsetFieldNumber;
    const int BaseLayerProperties::kScrollClipLayerIdFieldNumber;
    const int BaseLayerProperties::kUserScrollableHorizontalFieldNumber;
    const int BaseLayerProperties::kUserScrollableVerticalFieldNumber;
    const int BaseLayerProperties::kMainThreadScrollingReasonsFieldNumber;
    const int BaseLayerProperties::kNonFastScrollableRegionFieldNumber;
    const int BaseLayerProperties::kTouchEventHandlerRegionFieldNumber;
    const int BaseLayerProperties::kIsContainerForFixedPositionLayersFieldNumber;
    const int BaseLayerProperties::kPositionConstraintFieldNumber;
    const int BaseLayerProperties::kStickyPositionConstraintFieldNumber;
    const int BaseLayerProperties::kScrollParentIdFieldNumber;
    const int BaseLayerProperties::kClipParentIdFieldNumber;
    const int BaseLayerProperties::kHasWillChangeTransformHintFieldNumber;
    const int BaseLayerProperties::kHideLayerAndSubtreeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    BaseLayerProperties::BaseLayerProperties()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.BaseLayerProperties)
    }

    void BaseLayerProperties::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        update_rect_ = const_cast<::cc::proto::Rect*>(
            ::cc::proto::Rect::internal_default_instance());
#else
        update_rect_ = const_cast<::cc::proto::Rect*>(&::cc::proto::Rect::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        bounds_ = const_cast<::cc::proto::Size*>(
            ::cc::proto::Size::internal_default_instance());
#else
        bounds_ = const_cast<::cc::proto::Size*>(&::cc::proto::Size::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        position_ = const_cast<::cc::proto::PointF*>(
            ::cc::proto::PointF::internal_default_instance());
#else
        position_ = const_cast<::cc::proto::PointF*>(&::cc::proto::PointF::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        transform_ = const_cast<::cc::proto::Transform*>(
            ::cc::proto::Transform::internal_default_instance());
#else
        transform_ = const_cast<::cc::proto::Transform*>(&::cc::proto::Transform::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        transform_origin_ = const_cast<::cc::proto::Point3F*>(
            ::cc::proto::Point3F::internal_default_instance());
#else
        transform_origin_ = const_cast<::cc::proto::Point3F*>(&::cc::proto::Point3F::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        scroll_offset_ = const_cast<::cc::proto::ScrollOffset*>(
            ::cc::proto::ScrollOffset::internal_default_instance());
#else
        scroll_offset_ = const_cast<::cc::proto::ScrollOffset*>(&::cc::proto::ScrollOffset::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        non_fast_scrollable_region_ = const_cast<::cc::proto::Region*>(
            ::cc::proto::Region::internal_default_instance());
#else
        non_fast_scrollable_region_ = const_cast<::cc::proto::Region*>(&::cc::proto::Region::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        touch_event_handler_region_ = const_cast<::cc::proto::Region*>(
            ::cc::proto::Region::internal_default_instance());
#else
        touch_event_handler_region_ = const_cast<::cc::proto::Region*>(&::cc::proto::Region::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        position_constraint_ = const_cast<::cc::proto::LayerPositionConstraint*>(
            ::cc::proto::LayerPositionConstraint::internal_default_instance());
#else
        position_constraint_ = const_cast<::cc::proto::LayerPositionConstraint*>(&::cc::proto::LayerPositionConstraint::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        sticky_position_constraint_ = const_cast<::cc::proto::LayerStickyPositionConstraint*>(
            ::cc::proto::LayerStickyPositionConstraint::internal_default_instance());
#else
        sticky_position_constraint_ = const_cast<::cc::proto::LayerStickyPositionConstraint*>(&::cc::proto::LayerStickyPositionConstraint::default_instance());
#endif
    }

    BaseLayerProperties::BaseLayerProperties(const BaseLayerProperties& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.BaseLayerProperties)
    }

    void BaseLayerProperties::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        update_rect_ = NULL;
        bounds_ = NULL;
        masks_to_bounds_ = false;
        opacity_ = 0;
        blend_mode_ = 0;
        is_root_for_isolated_group_ = false;
        contents_opaque_ = false;
        position_ = NULL;
        transform_ = NULL;
        transform_origin_ = NULL;
        is_drawable_ = false;
        double_sided_ = false;
        should_flatten_transform_ = false;
        sorting_context_id_ = 0;
        use_parent_backface_visibility_ = false;
        background_color_ = 0u;
        scroll_offset_ = NULL;
        scroll_clip_layer_id_ = 0;
        user_scrollable_horizontal_ = false;
        user_scrollable_vertical_ = false;
        main_thread_scrolling_reasons_ = 0u;
        non_fast_scrollable_region_ = NULL;
        touch_event_handler_region_ = NULL;
        is_container_for_fixed_position_layers_ = false;
        position_constraint_ = NULL;
        sticky_position_constraint_ = NULL;
        scroll_parent_id_ = 0;
        clip_parent_id_ = 0;
        has_will_change_transform_hint_ = false;
        hide_layer_and_subtree_ = false;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    BaseLayerProperties::~BaseLayerProperties()
    {
        // @@protoc_insertion_point(destructor:cc.proto.BaseLayerProperties)
        SharedDtor();
    }

    void BaseLayerProperties::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete update_rect_;
            delete bounds_;
            delete position_;
            delete transform_;
            delete transform_origin_;
            delete scroll_offset_;
            delete non_fast_scrollable_region_;
            delete touch_event_handler_region_;
            delete position_constraint_;
            delete sticky_position_constraint_;
        }
    }

    void BaseLayerProperties::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const BaseLayerProperties& BaseLayerProperties::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_layer_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_layer_2eproto();
#endif
        return *default_instance_;
    }

    BaseLayerProperties* BaseLayerProperties::default_instance_ = NULL;

    BaseLayerProperties* BaseLayerProperties::New(::google::protobuf::Arena* arena) const
    {
        BaseLayerProperties* n = new BaseLayerProperties;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void BaseLayerProperties::Clear()
    {
// @@protoc_insertion_point(message_clear_start:cc.proto.BaseLayerProperties)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                         \
    _Pragma("clang diagnostic push")                                                                          \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(BaseLayerProperties, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<BaseLayerProperties*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 255u) {
            ZR_(opacity_, blend_mode_);
            ZR_(masks_to_bounds_, contents_opaque_);
            if (has_update_rect()) {
                if (update_rect_ != NULL)
                    update_rect_->::cc::proto::Rect::Clear();
            }
            if (has_bounds()) {
                if (bounds_ != NULL)
                    bounds_->::cc::proto::Size::Clear();
            }
            if (has_position()) {
                if (position_ != NULL)
                    position_->::cc::proto::PointF::Clear();
            }
        }
        if (_has_bits_[8 / 32] & 65280u) {
            ZR_(is_drawable_, sorting_context_id_);
            ZR_(double_sided_, use_parent_backface_visibility_);
            if (has_transform()) {
                if (transform_ != NULL)
                    transform_->::cc::proto::Transform::Clear();
            }
            if (has_transform_origin()) {
                if (transform_origin_ != NULL)
                    transform_origin_->::cc::proto::Point3F::Clear();
            }
            background_color_ = 0u;
        }
        if (_has_bits_[16 / 32] & 16711680u) {
            ZR_(scroll_clip_layer_id_, main_thread_scrolling_reasons_);
            ZR_(user_scrollable_vertical_, is_container_for_fixed_position_layers_);
            if (has_scroll_offset()) {
                if (scroll_offset_ != NULL)
                    scroll_offset_->::cc::proto::ScrollOffset::Clear();
            }
            user_scrollable_horizontal_ = false;
            if (has_non_fast_scrollable_region()) {
                if (non_fast_scrollable_region_ != NULL)
                    non_fast_scrollable_region_->::cc::proto::Region::Clear();
            }
            if (has_touch_event_handler_region()) {
                if (touch_event_handler_region_ != NULL)
                    touch_event_handler_region_->::cc::proto::Region::Clear();
            }
        }
        if (_has_bits_[24 / 32] & 1056964608u) {
            ZR_(has_will_change_transform_hint_, clip_parent_id_);
            if (has_position_constraint()) {
                if (position_constraint_ != NULL)
                    position_constraint_->::cc::proto::LayerPositionConstraint::Clear();
            }
            if (has_sticky_position_constraint()) {
                if (sticky_position_constraint_ != NULL)
                    sticky_position_constraint_->::cc::proto::LayerStickyPositionConstraint::Clear();
            }
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool BaseLayerProperties::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForBaseLayerProperties, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.BaseLayerProperties)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .cc.proto.Point3F transform_origin = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_transform_origin()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_background_color;
                break;
            }

            // optional uint32 background_color = 2;
            case 2: {
                if (tag == 16) {
                parse_background_color:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &background_color_)));
                    set_has_background_color();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_bounds;
                break;
            }

            // optional .cc.proto.Size bounds = 3;
            case 3: {
                if (tag == 26) {
                parse_bounds:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_bounds()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(64))
                    goto parse_double_sided;
                break;
            }

            // optional bool double_sided = 8;
            case 8: {
                if (tag == 64) {
                parse_double_sided:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &double_sided_)));
                    set_has_double_sided();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(80))
                    goto parse_hide_layer_and_subtree;
                break;
            }

            // optional bool hide_layer_and_subtree = 10;
            case 10: {
                if (tag == 80) {
                parse_hide_layer_and_subtree:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &hide_layer_and_subtree_)));
                    set_has_hide_layer_and_subtree();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(112))
                    goto parse_masks_to_bounds;
                break;
            }

            // optional bool masks_to_bounds = 14;
            case 14: {
                if (tag == 112) {
                parse_masks_to_bounds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &masks_to_bounds_)));
                    set_has_masks_to_bounds();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(120))
                    goto parse_main_thread_scrolling_reasons;
                break;
            }

            // optional uint32 main_thread_scrolling_reasons = 15;
            case 15: {
                if (tag == 120) {
                parse_main_thread_scrolling_reasons:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                        input, &main_thread_scrolling_reasons_)));
                    set_has_main_thread_scrolling_reasons();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(146))
                    goto parse_non_fast_scrollable_region;
                break;
            }

            // optional .cc.proto.Region non_fast_scrollable_region = 18;
            case 18: {
                if (tag == 146) {
                parse_non_fast_scrollable_region:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_non_fast_scrollable_region()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(154))
                    goto parse_touch_event_handler_region;
                break;
            }

            // optional .cc.proto.Region touch_event_handler_region = 19;
            case 19: {
                if (tag == 154) {
                parse_touch_event_handler_region:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_touch_event_handler_region()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(168))
                    goto parse_contents_opaque;
                break;
            }

            // optional bool contents_opaque = 21;
            case 21: {
                if (tag == 168) {
                parse_contents_opaque:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &contents_opaque_)));
                    set_has_contents_opaque();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(181))
                    goto parse_opacity;
                break;
            }

            // optional float opacity = 22;
            case 22: {
                if (tag == 181) {
                parse_opacity:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                        input, &opacity_)));
                    set_has_opacity();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(184))
                    goto parse_blend_mode;
                break;
            }

            // optional .cc.proto.SkXfermode.Mode blend_mode = 23;
            case 23: {
                if (tag == 184) {
                parse_blend_mode:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::cc::proto::SkXfermode_Mode_IsValid(value)) {
                        set_blend_mode(static_cast<::cc::proto::SkXfermode_Mode>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(184);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(192))
                    goto parse_is_root_for_isolated_group;
                break;
            }

            // optional bool is_root_for_isolated_group = 24;
            case 24: {
                if (tag == 192) {
                parse_is_root_for_isolated_group:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &is_root_for_isolated_group_)));
                    set_has_is_root_for_isolated_group();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(202))
                    goto parse_position;
                break;
            }

            // optional .cc.proto.PointF position = 25;
            case 25: {
                if (tag == 202) {
                parse_position:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_position()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(208))
                    goto parse_is_container_for_fixed_position_layers;
                break;
            }

            // optional bool is_container_for_fixed_position_layers = 26;
            case 26: {
                if (tag == 208) {
                parse_is_container_for_fixed_position_layers:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &is_container_for_fixed_position_layers_)));
                    set_has_is_container_for_fixed_position_layers();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(218))
                    goto parse_position_constraint;
                break;
            }

            // optional .cc.proto.LayerPositionConstraint position_constraint = 27;
            case 27: {
                if (tag == 218) {
                parse_position_constraint:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_position_constraint()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(224))
                    goto parse_should_flatten_transform;
                break;
            }

            // optional bool should_flatten_transform = 28;
            case 28: {
                if (tag == 224) {
                parse_should_flatten_transform:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &should_flatten_transform_)));
                    set_has_should_flatten_transform();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(256))
                    goto parse_use_parent_backface_visibility;
                break;
            }

            // optional bool use_parent_backface_visibility = 32;
            case 32: {
                if (tag == 256) {
                parse_use_parent_backface_visibility:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &use_parent_backface_visibility_)));
                    set_has_use_parent_backface_visibility();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(266))
                    goto parse_transform;
                break;
            }

            // optional .cc.proto.Transform transform = 33;
            case 33: {
                if (tag == 266) {
                parse_transform:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_transform()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(280))
                    goto parse_sorting_context_id;
                break;
            }

            // optional int32 sorting_context_id = 35;
            case 35: {
                if (tag == 280) {
                parse_sorting_context_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &sorting_context_id_)));
                    set_has_sorting_context_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(296))
                    goto parse_scroll_clip_layer_id;
                break;
            }

            // optional int32 scroll_clip_layer_id = 37;
            case 37: {
                if (tag == 296) {
                parse_scroll_clip_layer_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &scroll_clip_layer_id_)));
                    set_has_scroll_clip_layer_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(304))
                    goto parse_user_scrollable_horizontal;
                break;
            }

            // optional bool user_scrollable_horizontal = 38;
            case 38: {
                if (tag == 304) {
                parse_user_scrollable_horizontal:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &user_scrollable_horizontal_)));
                    set_has_user_scrollable_horizontal();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(312))
                    goto parse_user_scrollable_vertical;
                break;
            }

            // optional bool user_scrollable_vertical = 39;
            case 39: {
                if (tag == 312) {
                parse_user_scrollable_vertical:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &user_scrollable_vertical_)));
                    set_has_user_scrollable_vertical();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(320))
                    goto parse_scroll_parent_id;
                break;
            }

            // optional int32 scroll_parent_id = 40;
            case 40: {
                if (tag == 320) {
                parse_scroll_parent_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &scroll_parent_id_)));
                    set_has_scroll_parent_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(336))
                    goto parse_clip_parent_id;
                break;
            }

            // optional int32 clip_parent_id = 42;
            case 42: {
                if (tag == 336) {
                parse_clip_parent_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &clip_parent_id_)));
                    set_has_clip_parent_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(354))
                    goto parse_scroll_offset;
                break;
            }

            // optional .cc.proto.ScrollOffset scroll_offset = 44;
            case 44: {
                if (tag == 354) {
                parse_scroll_offset:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_scroll_offset()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(370))
                    goto parse_update_rect;
                break;
            }

            // optional .cc.proto.Rect update_rect = 46;
            case 46: {
                if (tag == 370) {
                parse_update_rect:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_update_rect()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(384))
                    goto parse_has_will_change_transform_hint;
                break;
            }

            // optional bool has_will_change_transform_hint = 48;
            case 48: {
                if (tag == 384) {
                parse_has_will_change_transform_hint:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &has_will_change_transform_hint_)));
                    set_has_has_will_change_transform_hint();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(448))
                    goto parse_is_drawable;
                break;
            }

            // optional bool is_drawable = 56;
            case 56: {
                if (tag == 448) {
                parse_is_drawable:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &is_drawable_)));
                    set_has_is_drawable();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(466))
                    goto parse_sticky_position_constraint;
                break;
            }

            // optional .cc.proto.LayerStickyPositionConstraint sticky_position_constraint = 58;
            case 58: {
                if (tag == 466) {
                parse_sticky_position_constraint:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_sticky_position_constraint()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.BaseLayerProperties)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.BaseLayerProperties)
        return false;
#undef DO_
    }

    void BaseLayerProperties::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.BaseLayerProperties)
        // optional .cc.proto.Point3F transform_origin = 1;
        if (has_transform_origin()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->transform_origin_, output);
        }

        // optional uint32 background_color = 2;
        if (has_background_color()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->background_color(), output);
        }

        // optional .cc.proto.Size bounds = 3;
        if (has_bounds()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->bounds_, output);
        }

        // optional bool double_sided = 8;
        if (has_double_sided()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->double_sided(), output);
        }

        // optional bool hide_layer_and_subtree = 10;
        if (has_hide_layer_and_subtree()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->hide_layer_and_subtree(), output);
        }

        // optional bool masks_to_bounds = 14;
        if (has_masks_to_bounds()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->masks_to_bounds(), output);
        }

        // optional uint32 main_thread_scrolling_reasons = 15;
        if (has_main_thread_scrolling_reasons()) {
            ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->main_thread_scrolling_reasons(), output);
        }

        // optional .cc.proto.Region non_fast_scrollable_region = 18;
        if (has_non_fast_scrollable_region()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                18, *this->non_fast_scrollable_region_, output);
        }

        // optional .cc.proto.Region touch_event_handler_region = 19;
        if (has_touch_event_handler_region()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                19, *this->touch_event_handler_region_, output);
        }

        // optional bool contents_opaque = 21;
        if (has_contents_opaque()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->contents_opaque(), output);
        }

        // optional float opacity = 22;
        if (has_opacity()) {
            ::google::protobuf::internal::WireFormatLite::WriteFloat(22, this->opacity(), output);
        }

        // optional .cc.proto.SkXfermode.Mode blend_mode = 23;
        if (has_blend_mode()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                23, this->blend_mode(), output);
        }

        // optional bool is_root_for_isolated_group = 24;
        if (has_is_root_for_isolated_group()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(24, this->is_root_for_isolated_group(), output);
        }

        // optional .cc.proto.PointF position = 25;
        if (has_position()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                25, *this->position_, output);
        }

        // optional bool is_container_for_fixed_position_layers = 26;
        if (has_is_container_for_fixed_position_layers()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(26, this->is_container_for_fixed_position_layers(), output);
        }

        // optional .cc.proto.LayerPositionConstraint position_constraint = 27;
        if (has_position_constraint()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                27, *this->position_constraint_, output);
        }

        // optional bool should_flatten_transform = 28;
        if (has_should_flatten_transform()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(28, this->should_flatten_transform(), output);
        }

        // optional bool use_parent_backface_visibility = 32;
        if (has_use_parent_backface_visibility()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(32, this->use_parent_backface_visibility(), output);
        }

        // optional .cc.proto.Transform transform = 33;
        if (has_transform()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                33, *this->transform_, output);
        }

        // optional int32 sorting_context_id = 35;
        if (has_sorting_context_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(35, this->sorting_context_id(), output);
        }

        // optional int32 scroll_clip_layer_id = 37;
        if (has_scroll_clip_layer_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(37, this->scroll_clip_layer_id(), output);
        }

        // optional bool user_scrollable_horizontal = 38;
        if (has_user_scrollable_horizontal()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(38, this->user_scrollable_horizontal(), output);
        }

        // optional bool user_scrollable_vertical = 39;
        if (has_user_scrollable_vertical()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(39, this->user_scrollable_vertical(), output);
        }

        // optional int32 scroll_parent_id = 40;
        if (has_scroll_parent_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(40, this->scroll_parent_id(), output);
        }

        // optional int32 clip_parent_id = 42;
        if (has_clip_parent_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(42, this->clip_parent_id(), output);
        }

        // optional .cc.proto.ScrollOffset scroll_offset = 44;
        if (has_scroll_offset()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                44, *this->scroll_offset_, output);
        }

        // optional .cc.proto.Rect update_rect = 46;
        if (has_update_rect()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                46, *this->update_rect_, output);
        }

        // optional bool has_will_change_transform_hint = 48;
        if (has_has_will_change_transform_hint()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(48, this->has_will_change_transform_hint(), output);
        }

        // optional bool is_drawable = 56;
        if (has_is_drawable()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(56, this->is_drawable(), output);
        }

        // optional .cc.proto.LayerStickyPositionConstraint sticky_position_constraint = 58;
        if (has_sticky_position_constraint()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                58, *this->sticky_position_constraint_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.BaseLayerProperties)
    }

    int BaseLayerProperties::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.BaseLayerProperties)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 255u) {
            // optional .cc.proto.Rect update_rect = 46;
            if (has_update_rect()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->update_rect_);
            }

            // optional .cc.proto.Size bounds = 3;
            if (has_bounds()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->bounds_);
            }

            // optional bool masks_to_bounds = 14;
            if (has_masks_to_bounds()) {
                total_size += 1 + 1;
            }

            // optional float opacity = 22;
            if (has_opacity()) {
                total_size += 2 + 4;
            }

            // optional .cc.proto.SkXfermode.Mode blend_mode = 23;
            if (has_blend_mode()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->blend_mode());
            }

            // optional bool is_root_for_isolated_group = 24;
            if (has_is_root_for_isolated_group()) {
                total_size += 2 + 1;
            }

            // optional bool contents_opaque = 21;
            if (has_contents_opaque()) {
                total_size += 2 + 1;
            }

            // optional .cc.proto.PointF position = 25;
            if (has_position()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->position_);
            }
        }
        if (_has_bits_[8 / 32] & 65280u) {
            // optional .cc.proto.Transform transform = 33;
            if (has_transform()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->transform_);
            }

            // optional .cc.proto.Point3F transform_origin = 1;
            if (has_transform_origin()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->transform_origin_);
            }

            // optional bool is_drawable = 56;
            if (has_is_drawable()) {
                total_size += 2 + 1;
            }

            // optional bool double_sided = 8;
            if (has_double_sided()) {
                total_size += 1 + 1;
            }

            // optional bool should_flatten_transform = 28;
            if (has_should_flatten_transform()) {
                total_size += 2 + 1;
            }

            // optional int32 sorting_context_id = 35;
            if (has_sorting_context_id()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->sorting_context_id());
            }

            // optional bool use_parent_backface_visibility = 32;
            if (has_use_parent_backface_visibility()) {
                total_size += 2 + 1;
            }

            // optional uint32 background_color = 2;
            if (has_background_color()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->background_color());
            }
        }
        if (_has_bits_[16 / 32] & 16711680u) {
            // optional .cc.proto.ScrollOffset scroll_offset = 44;
            if (has_scroll_offset()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->scroll_offset_);
            }

            // optional int32 scroll_clip_layer_id = 37;
            if (has_scroll_clip_layer_id()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->scroll_clip_layer_id());
            }

            // optional bool user_scrollable_horizontal = 38;
            if (has_user_scrollable_horizontal()) {
                total_size += 2 + 1;
            }

            // optional bool user_scrollable_vertical = 39;
            if (has_user_scrollable_vertical()) {
                total_size += 2 + 1;
            }

            // optional uint32 main_thread_scrolling_reasons = 15;
            if (has_main_thread_scrolling_reasons()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->main_thread_scrolling_reasons());
            }

            // optional .cc.proto.Region non_fast_scrollable_region = 18;
            if (has_non_fast_scrollable_region()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->non_fast_scrollable_region_);
            }

            // optional .cc.proto.Region touch_event_handler_region = 19;
            if (has_touch_event_handler_region()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->touch_event_handler_region_);
            }

            // optional bool is_container_for_fixed_position_layers = 26;
            if (has_is_container_for_fixed_position_layers()) {
                total_size += 2 + 1;
            }
        }
        if (_has_bits_[24 / 32] & 1056964608u) {
            // optional .cc.proto.LayerPositionConstraint position_constraint = 27;
            if (has_position_constraint()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->position_constraint_);
            }

            // optional .cc.proto.LayerStickyPositionConstraint sticky_position_constraint = 58;
            if (has_sticky_position_constraint()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->sticky_position_constraint_);
            }

            // optional int32 scroll_parent_id = 40;
            if (has_scroll_parent_id()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->scroll_parent_id());
            }

            // optional int32 clip_parent_id = 42;
            if (has_clip_parent_id()) {
                total_size += 2 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->clip_parent_id());
            }

            // optional bool has_will_change_transform_hint = 48;
            if (has_has_will_change_transform_hint()) {
                total_size += 2 + 1;
            }

            // optional bool hide_layer_and_subtree = 10;
            if (has_hide_layer_and_subtree()) {
                total_size += 1 + 1;
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void BaseLayerProperties::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const BaseLayerProperties*>(&from));
    }

    void BaseLayerProperties::MergeFrom(const BaseLayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.BaseLayerProperties)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_update_rect()) {
                mutable_update_rect()->::cc::proto::Rect::MergeFrom(from.update_rect());
            }
            if (from.has_bounds()) {
                mutable_bounds()->::cc::proto::Size::MergeFrom(from.bounds());
            }
            if (from.has_masks_to_bounds()) {
                set_masks_to_bounds(from.masks_to_bounds());
            }
            if (from.has_opacity()) {
                set_opacity(from.opacity());
            }
            if (from.has_blend_mode()) {
                set_blend_mode(from.blend_mode());
            }
            if (from.has_is_root_for_isolated_group()) {
                set_is_root_for_isolated_group(from.is_root_for_isolated_group());
            }
            if (from.has_contents_opaque()) {
                set_contents_opaque(from.contents_opaque());
            }
            if (from.has_position()) {
                mutable_position()->::cc::proto::PointF::MergeFrom(from.position());
            }
        }
        if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
            if (from.has_transform()) {
                mutable_transform()->::cc::proto::Transform::MergeFrom(from.transform());
            }
            if (from.has_transform_origin()) {
                mutable_transform_origin()->::cc::proto::Point3F::MergeFrom(from.transform_origin());
            }
            if (from.has_is_drawable()) {
                set_is_drawable(from.is_drawable());
            }
            if (from.has_double_sided()) {
                set_double_sided(from.double_sided());
            }
            if (from.has_should_flatten_transform()) {
                set_should_flatten_transform(from.should_flatten_transform());
            }
            if (from.has_sorting_context_id()) {
                set_sorting_context_id(from.sorting_context_id());
            }
            if (from.has_use_parent_backface_visibility()) {
                set_use_parent_backface_visibility(from.use_parent_backface_visibility());
            }
            if (from.has_background_color()) {
                set_background_color(from.background_color());
            }
        }
        if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
            if (from.has_scroll_offset()) {
                mutable_scroll_offset()->::cc::proto::ScrollOffset::MergeFrom(from.scroll_offset());
            }
            if (from.has_scroll_clip_layer_id()) {
                set_scroll_clip_layer_id(from.scroll_clip_layer_id());
            }
            if (from.has_user_scrollable_horizontal()) {
                set_user_scrollable_horizontal(from.user_scrollable_horizontal());
            }
            if (from.has_user_scrollable_vertical()) {
                set_user_scrollable_vertical(from.user_scrollable_vertical());
            }
            if (from.has_main_thread_scrolling_reasons()) {
                set_main_thread_scrolling_reasons(from.main_thread_scrolling_reasons());
            }
            if (from.has_non_fast_scrollable_region()) {
                mutable_non_fast_scrollable_region()->::cc::proto::Region::MergeFrom(from.non_fast_scrollable_region());
            }
            if (from.has_touch_event_handler_region()) {
                mutable_touch_event_handler_region()->::cc::proto::Region::MergeFrom(from.touch_event_handler_region());
            }
            if (from.has_is_container_for_fixed_position_layers()) {
                set_is_container_for_fixed_position_layers(from.is_container_for_fixed_position_layers());
            }
        }
        if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
            if (from.has_position_constraint()) {
                mutable_position_constraint()->::cc::proto::LayerPositionConstraint::MergeFrom(from.position_constraint());
            }
            if (from.has_sticky_position_constraint()) {
                mutable_sticky_position_constraint()->::cc::proto::LayerStickyPositionConstraint::MergeFrom(from.sticky_position_constraint());
            }
            if (from.has_scroll_parent_id()) {
                set_scroll_parent_id(from.scroll_parent_id());
            }
            if (from.has_clip_parent_id()) {
                set_clip_parent_id(from.clip_parent_id());
            }
            if (from.has_has_will_change_transform_hint()) {
                set_has_will_change_transform_hint(from.has_will_change_transform_hint());
            }
            if (from.has_hide_layer_and_subtree()) {
                set_hide_layer_and_subtree(from.hide_layer_and_subtree());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void BaseLayerProperties::CopyFrom(const BaseLayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.BaseLayerProperties)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool BaseLayerProperties::IsInitialized() const
    {

        return true;
    }

    void BaseLayerProperties::Swap(BaseLayerProperties* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void BaseLayerProperties::InternalSwap(BaseLayerProperties* other)
    {
        std::swap(update_rect_, other->update_rect_);
        std::swap(bounds_, other->bounds_);
        std::swap(masks_to_bounds_, other->masks_to_bounds_);
        std::swap(opacity_, other->opacity_);
        std::swap(blend_mode_, other->blend_mode_);
        std::swap(is_root_for_isolated_group_, other->is_root_for_isolated_group_);
        std::swap(contents_opaque_, other->contents_opaque_);
        std::swap(position_, other->position_);
        std::swap(transform_, other->transform_);
        std::swap(transform_origin_, other->transform_origin_);
        std::swap(is_drawable_, other->is_drawable_);
        std::swap(double_sided_, other->double_sided_);
        std::swap(should_flatten_transform_, other->should_flatten_transform_);
        std::swap(sorting_context_id_, other->sorting_context_id_);
        std::swap(use_parent_backface_visibility_, other->use_parent_backface_visibility_);
        std::swap(background_color_, other->background_color_);
        std::swap(scroll_offset_, other->scroll_offset_);
        std::swap(scroll_clip_layer_id_, other->scroll_clip_layer_id_);
        std::swap(user_scrollable_horizontal_, other->user_scrollable_horizontal_);
        std::swap(user_scrollable_vertical_, other->user_scrollable_vertical_);
        std::swap(main_thread_scrolling_reasons_, other->main_thread_scrolling_reasons_);
        std::swap(non_fast_scrollable_region_, other->non_fast_scrollable_region_);
        std::swap(touch_event_handler_region_, other->touch_event_handler_region_);
        std::swap(is_container_for_fixed_position_layers_, other->is_container_for_fixed_position_layers_);
        std::swap(position_constraint_, other->position_constraint_);
        std::swap(sticky_position_constraint_, other->sticky_position_constraint_);
        std::swap(scroll_parent_id_, other->scroll_parent_id_);
        std::swap(clip_parent_id_, other->clip_parent_id_);
        std::swap(has_will_change_transform_hint_, other->has_will_change_transform_hint_);
        std::swap(hide_layer_and_subtree_, other->hide_layer_and_subtree_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string BaseLayerProperties::GetTypeName() const
    {
        return "cc.proto.BaseLayerProperties";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // BaseLayerProperties

    // optional .cc.proto.Rect update_rect = 46;
    bool BaseLayerProperties::has_update_rect() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void BaseLayerProperties::set_has_update_rect()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void BaseLayerProperties::clear_has_update_rect()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void BaseLayerProperties::clear_update_rect()
    {
        if (update_rect_ != NULL)
            update_rect_->::cc::proto::Rect::Clear();
        clear_has_update_rect();
    }
    const ::cc::proto::Rect& BaseLayerProperties::update_rect() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.update_rect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return update_rect_ != NULL ? *update_rect_ : *default_instance().update_rect_;
#else
        return update_rect_ != NULL ? *update_rect_ : *default_instance_->update_rect_;
#endif
    }
    ::cc::proto::Rect* BaseLayerProperties::mutable_update_rect()
    {
        set_has_update_rect();
        if (update_rect_ == NULL) {
            update_rect_ = new ::cc::proto::Rect;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.update_rect)
        return update_rect_;
    }
    ::cc::proto::Rect* BaseLayerProperties::release_update_rect()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.update_rect)
        clear_has_update_rect();
        ::cc::proto::Rect* temp = update_rect_;
        update_rect_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_update_rect(::cc::proto::Rect* update_rect)
    {
        delete update_rect_;
        update_rect_ = update_rect;
        if (update_rect) {
            set_has_update_rect();
        } else {
            clear_has_update_rect();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.update_rect)
    }

    // optional .cc.proto.Size bounds = 3;
    bool BaseLayerProperties::has_bounds() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void BaseLayerProperties::set_has_bounds()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void BaseLayerProperties::clear_has_bounds()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void BaseLayerProperties::clear_bounds()
    {
        if (bounds_ != NULL)
            bounds_->::cc::proto::Size::Clear();
        clear_has_bounds();
    }
    const ::cc::proto::Size& BaseLayerProperties::bounds() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
        return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
    }
    ::cc::proto::Size* BaseLayerProperties::mutable_bounds()
    {
        set_has_bounds();
        if (bounds_ == NULL) {
            bounds_ = new ::cc::proto::Size;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.bounds)
        return bounds_;
    }
    ::cc::proto::Size* BaseLayerProperties::release_bounds()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.bounds)
        clear_has_bounds();
        ::cc::proto::Size* temp = bounds_;
        bounds_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_bounds(::cc::proto::Size* bounds)
    {
        delete bounds_;
        bounds_ = bounds;
        if (bounds) {
            set_has_bounds();
        } else {
            clear_has_bounds();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.bounds)
    }

    // optional bool masks_to_bounds = 14;
    bool BaseLayerProperties::has_masks_to_bounds() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void BaseLayerProperties::set_has_masks_to_bounds()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void BaseLayerProperties::clear_has_masks_to_bounds()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void BaseLayerProperties::clear_masks_to_bounds()
    {
        masks_to_bounds_ = false;
        clear_has_masks_to_bounds();
    }
    bool BaseLayerProperties::masks_to_bounds() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.masks_to_bounds)
        return masks_to_bounds_;
    }
    void BaseLayerProperties::set_masks_to_bounds(bool value)
    {
        set_has_masks_to_bounds();
        masks_to_bounds_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.masks_to_bounds)
    }

    // optional float opacity = 22;
    bool BaseLayerProperties::has_opacity() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void BaseLayerProperties::set_has_opacity()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void BaseLayerProperties::clear_has_opacity()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void BaseLayerProperties::clear_opacity()
    {
        opacity_ = 0;
        clear_has_opacity();
    }
    float BaseLayerProperties::opacity() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.opacity)
        return opacity_;
    }
    void BaseLayerProperties::set_opacity(float value)
    {
        set_has_opacity();
        opacity_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.opacity)
    }

    // optional .cc.proto.SkXfermode.Mode blend_mode = 23;
    bool BaseLayerProperties::has_blend_mode() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void BaseLayerProperties::set_has_blend_mode()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void BaseLayerProperties::clear_has_blend_mode()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void BaseLayerProperties::clear_blend_mode()
    {
        blend_mode_ = 0;
        clear_has_blend_mode();
    }
    ::cc::proto::SkXfermode_Mode BaseLayerProperties::blend_mode() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.blend_mode)
        return static_cast<::cc::proto::SkXfermode_Mode>(blend_mode_);
    }
    void BaseLayerProperties::set_blend_mode(::cc::proto::SkXfermode_Mode value)
    {
        assert(::cc::proto::SkXfermode_Mode_IsValid(value));
        set_has_blend_mode();
        blend_mode_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.blend_mode)
    }

    // optional bool is_root_for_isolated_group = 24;
    bool BaseLayerProperties::has_is_root_for_isolated_group() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void BaseLayerProperties::set_has_is_root_for_isolated_group()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void BaseLayerProperties::clear_has_is_root_for_isolated_group()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void BaseLayerProperties::clear_is_root_for_isolated_group()
    {
        is_root_for_isolated_group_ = false;
        clear_has_is_root_for_isolated_group();
    }
    bool BaseLayerProperties::is_root_for_isolated_group() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.is_root_for_isolated_group)
        return is_root_for_isolated_group_;
    }
    void BaseLayerProperties::set_is_root_for_isolated_group(bool value)
    {
        set_has_is_root_for_isolated_group();
        is_root_for_isolated_group_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.is_root_for_isolated_group)
    }

    // optional bool contents_opaque = 21;
    bool BaseLayerProperties::has_contents_opaque() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    void BaseLayerProperties::set_has_contents_opaque()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    void BaseLayerProperties::clear_has_contents_opaque()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    void BaseLayerProperties::clear_contents_opaque()
    {
        contents_opaque_ = false;
        clear_has_contents_opaque();
    }
    bool BaseLayerProperties::contents_opaque() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.contents_opaque)
        return contents_opaque_;
    }
    void BaseLayerProperties::set_contents_opaque(bool value)
    {
        set_has_contents_opaque();
        contents_opaque_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.contents_opaque)
    }

    // optional .cc.proto.PointF position = 25;
    bool BaseLayerProperties::has_position() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    void BaseLayerProperties::set_has_position()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    void BaseLayerProperties::clear_has_position()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    void BaseLayerProperties::clear_position()
    {
        if (position_ != NULL)
            position_->::cc::proto::PointF::Clear();
        clear_has_position();
    }
    const ::cc::proto::PointF& BaseLayerProperties::position() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.position)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return position_ != NULL ? *position_ : *default_instance().position_;
#else
        return position_ != NULL ? *position_ : *default_instance_->position_;
#endif
    }
    ::cc::proto::PointF* BaseLayerProperties::mutable_position()
    {
        set_has_position();
        if (position_ == NULL) {
            position_ = new ::cc::proto::PointF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.position)
        return position_;
    }
    ::cc::proto::PointF* BaseLayerProperties::release_position()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.position)
        clear_has_position();
        ::cc::proto::PointF* temp = position_;
        position_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_position(::cc::proto::PointF* position)
    {
        delete position_;
        position_ = position;
        if (position) {
            set_has_position();
        } else {
            clear_has_position();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.position)
    }

    // optional .cc.proto.Transform transform = 33;
    bool BaseLayerProperties::has_transform() const
    {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    void BaseLayerProperties::set_has_transform()
    {
        _has_bits_[0] |= 0x00000100u;
    }
    void BaseLayerProperties::clear_has_transform()
    {
        _has_bits_[0] &= ~0x00000100u;
    }
    void BaseLayerProperties::clear_transform()
    {
        if (transform_ != NULL)
            transform_->::cc::proto::Transform::Clear();
        clear_has_transform();
    }
    const ::cc::proto::Transform& BaseLayerProperties::transform() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.transform)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_ != NULL ? *transform_ : *default_instance().transform_;
#else
        return transform_ != NULL ? *transform_ : *default_instance_->transform_;
#endif
    }
    ::cc::proto::Transform* BaseLayerProperties::mutable_transform()
    {
        set_has_transform();
        if (transform_ == NULL) {
            transform_ = new ::cc::proto::Transform;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.transform)
        return transform_;
    }
    ::cc::proto::Transform* BaseLayerProperties::release_transform()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.transform)
        clear_has_transform();
        ::cc::proto::Transform* temp = transform_;
        transform_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_transform(::cc::proto::Transform* transform)
    {
        delete transform_;
        transform_ = transform;
        if (transform) {
            set_has_transform();
        } else {
            clear_has_transform();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.transform)
    }

    // optional .cc.proto.Point3F transform_origin = 1;
    bool BaseLayerProperties::has_transform_origin() const
    {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    void BaseLayerProperties::set_has_transform_origin()
    {
        _has_bits_[0] |= 0x00000200u;
    }
    void BaseLayerProperties::clear_has_transform_origin()
    {
        _has_bits_[0] &= ~0x00000200u;
    }
    void BaseLayerProperties::clear_transform_origin()
    {
        if (transform_origin_ != NULL)
            transform_origin_->::cc::proto::Point3F::Clear();
        clear_has_transform_origin();
    }
    const ::cc::proto::Point3F& BaseLayerProperties::transform_origin() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.transform_origin)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_origin_ != NULL ? *transform_origin_ : *default_instance().transform_origin_;
#else
        return transform_origin_ != NULL ? *transform_origin_ : *default_instance_->transform_origin_;
#endif
    }
    ::cc::proto::Point3F* BaseLayerProperties::mutable_transform_origin()
    {
        set_has_transform_origin();
        if (transform_origin_ == NULL) {
            transform_origin_ = new ::cc::proto::Point3F;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.transform_origin)
        return transform_origin_;
    }
    ::cc::proto::Point3F* BaseLayerProperties::release_transform_origin()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.transform_origin)
        clear_has_transform_origin();
        ::cc::proto::Point3F* temp = transform_origin_;
        transform_origin_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_transform_origin(::cc::proto::Point3F* transform_origin)
    {
        delete transform_origin_;
        transform_origin_ = transform_origin;
        if (transform_origin) {
            set_has_transform_origin();
        } else {
            clear_has_transform_origin();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.transform_origin)
    }

    // optional bool is_drawable = 56;
    bool BaseLayerProperties::has_is_drawable() const
    {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    void BaseLayerProperties::set_has_is_drawable()
    {
        _has_bits_[0] |= 0x00000400u;
    }
    void BaseLayerProperties::clear_has_is_drawable()
    {
        _has_bits_[0] &= ~0x00000400u;
    }
    void BaseLayerProperties::clear_is_drawable()
    {
        is_drawable_ = false;
        clear_has_is_drawable();
    }
    bool BaseLayerProperties::is_drawable() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.is_drawable)
        return is_drawable_;
    }
    void BaseLayerProperties::set_is_drawable(bool value)
    {
        set_has_is_drawable();
        is_drawable_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.is_drawable)
    }

    // optional bool double_sided = 8;
    bool BaseLayerProperties::has_double_sided() const
    {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    void BaseLayerProperties::set_has_double_sided()
    {
        _has_bits_[0] |= 0x00000800u;
    }
    void BaseLayerProperties::clear_has_double_sided()
    {
        _has_bits_[0] &= ~0x00000800u;
    }
    void BaseLayerProperties::clear_double_sided()
    {
        double_sided_ = false;
        clear_has_double_sided();
    }
    bool BaseLayerProperties::double_sided() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.double_sided)
        return double_sided_;
    }
    void BaseLayerProperties::set_double_sided(bool value)
    {
        set_has_double_sided();
        double_sided_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.double_sided)
    }

    // optional bool should_flatten_transform = 28;
    bool BaseLayerProperties::has_should_flatten_transform() const
    {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    void BaseLayerProperties::set_has_should_flatten_transform()
    {
        _has_bits_[0] |= 0x00001000u;
    }
    void BaseLayerProperties::clear_has_should_flatten_transform()
    {
        _has_bits_[0] &= ~0x00001000u;
    }
    void BaseLayerProperties::clear_should_flatten_transform()
    {
        should_flatten_transform_ = false;
        clear_has_should_flatten_transform();
    }
    bool BaseLayerProperties::should_flatten_transform() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.should_flatten_transform)
        return should_flatten_transform_;
    }
    void BaseLayerProperties::set_should_flatten_transform(bool value)
    {
        set_has_should_flatten_transform();
        should_flatten_transform_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.should_flatten_transform)
    }

    // optional int32 sorting_context_id = 35;
    bool BaseLayerProperties::has_sorting_context_id() const
    {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    void BaseLayerProperties::set_has_sorting_context_id()
    {
        _has_bits_[0] |= 0x00002000u;
    }
    void BaseLayerProperties::clear_has_sorting_context_id()
    {
        _has_bits_[0] &= ~0x00002000u;
    }
    void BaseLayerProperties::clear_sorting_context_id()
    {
        sorting_context_id_ = 0;
        clear_has_sorting_context_id();
    }
    ::google::protobuf::int32 BaseLayerProperties::sorting_context_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.sorting_context_id)
        return sorting_context_id_;
    }
    void BaseLayerProperties::set_sorting_context_id(::google::protobuf::int32 value)
    {
        set_has_sorting_context_id();
        sorting_context_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.sorting_context_id)
    }

    // optional bool use_parent_backface_visibility = 32;
    bool BaseLayerProperties::has_use_parent_backface_visibility() const
    {
        return (_has_bits_[0] & 0x00004000u) != 0;
    }
    void BaseLayerProperties::set_has_use_parent_backface_visibility()
    {
        _has_bits_[0] |= 0x00004000u;
    }
    void BaseLayerProperties::clear_has_use_parent_backface_visibility()
    {
        _has_bits_[0] &= ~0x00004000u;
    }
    void BaseLayerProperties::clear_use_parent_backface_visibility()
    {
        use_parent_backface_visibility_ = false;
        clear_has_use_parent_backface_visibility();
    }
    bool BaseLayerProperties::use_parent_backface_visibility() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.use_parent_backface_visibility)
        return use_parent_backface_visibility_;
    }
    void BaseLayerProperties::set_use_parent_backface_visibility(bool value)
    {
        set_has_use_parent_backface_visibility();
        use_parent_backface_visibility_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.use_parent_backface_visibility)
    }

    // optional uint32 background_color = 2;
    bool BaseLayerProperties::has_background_color() const
    {
        return (_has_bits_[0] & 0x00008000u) != 0;
    }
    void BaseLayerProperties::set_has_background_color()
    {
        _has_bits_[0] |= 0x00008000u;
    }
    void BaseLayerProperties::clear_has_background_color()
    {
        _has_bits_[0] &= ~0x00008000u;
    }
    void BaseLayerProperties::clear_background_color()
    {
        background_color_ = 0u;
        clear_has_background_color();
    }
    ::google::protobuf::uint32 BaseLayerProperties::background_color() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.background_color)
        return background_color_;
    }
    void BaseLayerProperties::set_background_color(::google::protobuf::uint32 value)
    {
        set_has_background_color();
        background_color_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.background_color)
    }

    // optional .cc.proto.ScrollOffset scroll_offset = 44;
    bool BaseLayerProperties::has_scroll_offset() const
    {
        return (_has_bits_[0] & 0x00010000u) != 0;
    }
    void BaseLayerProperties::set_has_scroll_offset()
    {
        _has_bits_[0] |= 0x00010000u;
    }
    void BaseLayerProperties::clear_has_scroll_offset()
    {
        _has_bits_[0] &= ~0x00010000u;
    }
    void BaseLayerProperties::clear_scroll_offset()
    {
        if (scroll_offset_ != NULL)
            scroll_offset_->::cc::proto::ScrollOffset::Clear();
        clear_has_scroll_offset();
    }
    const ::cc::proto::ScrollOffset& BaseLayerProperties::scroll_offset() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.scroll_offset)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance().scroll_offset_;
#else
        return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance_->scroll_offset_;
#endif
    }
    ::cc::proto::ScrollOffset* BaseLayerProperties::mutable_scroll_offset()
    {
        set_has_scroll_offset();
        if (scroll_offset_ == NULL) {
            scroll_offset_ = new ::cc::proto::ScrollOffset;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.scroll_offset)
        return scroll_offset_;
    }
    ::cc::proto::ScrollOffset* BaseLayerProperties::release_scroll_offset()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.scroll_offset)
        clear_has_scroll_offset();
        ::cc::proto::ScrollOffset* temp = scroll_offset_;
        scroll_offset_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset)
    {
        delete scroll_offset_;
        scroll_offset_ = scroll_offset;
        if (scroll_offset) {
            set_has_scroll_offset();
        } else {
            clear_has_scroll_offset();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.scroll_offset)
    }

    // optional int32 scroll_clip_layer_id = 37;
    bool BaseLayerProperties::has_scroll_clip_layer_id() const
    {
        return (_has_bits_[0] & 0x00020000u) != 0;
    }
    void BaseLayerProperties::set_has_scroll_clip_layer_id()
    {
        _has_bits_[0] |= 0x00020000u;
    }
    void BaseLayerProperties::clear_has_scroll_clip_layer_id()
    {
        _has_bits_[0] &= ~0x00020000u;
    }
    void BaseLayerProperties::clear_scroll_clip_layer_id()
    {
        scroll_clip_layer_id_ = 0;
        clear_has_scroll_clip_layer_id();
    }
    ::google::protobuf::int32 BaseLayerProperties::scroll_clip_layer_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.scroll_clip_layer_id)
        return scroll_clip_layer_id_;
    }
    void BaseLayerProperties::set_scroll_clip_layer_id(::google::protobuf::int32 value)
    {
        set_has_scroll_clip_layer_id();
        scroll_clip_layer_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.scroll_clip_layer_id)
    }

    // optional bool user_scrollable_horizontal = 38;
    bool BaseLayerProperties::has_user_scrollable_horizontal() const
    {
        return (_has_bits_[0] & 0x00040000u) != 0;
    }
    void BaseLayerProperties::set_has_user_scrollable_horizontal()
    {
        _has_bits_[0] |= 0x00040000u;
    }
    void BaseLayerProperties::clear_has_user_scrollable_horizontal()
    {
        _has_bits_[0] &= ~0x00040000u;
    }
    void BaseLayerProperties::clear_user_scrollable_horizontal()
    {
        user_scrollable_horizontal_ = false;
        clear_has_user_scrollable_horizontal();
    }
    bool BaseLayerProperties::user_scrollable_horizontal() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.user_scrollable_horizontal)
        return user_scrollable_horizontal_;
    }
    void BaseLayerProperties::set_user_scrollable_horizontal(bool value)
    {
        set_has_user_scrollable_horizontal();
        user_scrollable_horizontal_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.user_scrollable_horizontal)
    }

    // optional bool user_scrollable_vertical = 39;
    bool BaseLayerProperties::has_user_scrollable_vertical() const
    {
        return (_has_bits_[0] & 0x00080000u) != 0;
    }
    void BaseLayerProperties::set_has_user_scrollable_vertical()
    {
        _has_bits_[0] |= 0x00080000u;
    }
    void BaseLayerProperties::clear_has_user_scrollable_vertical()
    {
        _has_bits_[0] &= ~0x00080000u;
    }
    void BaseLayerProperties::clear_user_scrollable_vertical()
    {
        user_scrollable_vertical_ = false;
        clear_has_user_scrollable_vertical();
    }
    bool BaseLayerProperties::user_scrollable_vertical() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.user_scrollable_vertical)
        return user_scrollable_vertical_;
    }
    void BaseLayerProperties::set_user_scrollable_vertical(bool value)
    {
        set_has_user_scrollable_vertical();
        user_scrollable_vertical_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.user_scrollable_vertical)
    }

    // optional uint32 main_thread_scrolling_reasons = 15;
    bool BaseLayerProperties::has_main_thread_scrolling_reasons() const
    {
        return (_has_bits_[0] & 0x00100000u) != 0;
    }
    void BaseLayerProperties::set_has_main_thread_scrolling_reasons()
    {
        _has_bits_[0] |= 0x00100000u;
    }
    void BaseLayerProperties::clear_has_main_thread_scrolling_reasons()
    {
        _has_bits_[0] &= ~0x00100000u;
    }
    void BaseLayerProperties::clear_main_thread_scrolling_reasons()
    {
        main_thread_scrolling_reasons_ = 0u;
        clear_has_main_thread_scrolling_reasons();
    }
    ::google::protobuf::uint32 BaseLayerProperties::main_thread_scrolling_reasons() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.main_thread_scrolling_reasons)
        return main_thread_scrolling_reasons_;
    }
    void BaseLayerProperties::set_main_thread_scrolling_reasons(::google::protobuf::uint32 value)
    {
        set_has_main_thread_scrolling_reasons();
        main_thread_scrolling_reasons_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.main_thread_scrolling_reasons)
    }

    // optional .cc.proto.Region non_fast_scrollable_region = 18;
    bool BaseLayerProperties::has_non_fast_scrollable_region() const
    {
        return (_has_bits_[0] & 0x00200000u) != 0;
    }
    void BaseLayerProperties::set_has_non_fast_scrollable_region()
    {
        _has_bits_[0] |= 0x00200000u;
    }
    void BaseLayerProperties::clear_has_non_fast_scrollable_region()
    {
        _has_bits_[0] &= ~0x00200000u;
    }
    void BaseLayerProperties::clear_non_fast_scrollable_region()
    {
        if (non_fast_scrollable_region_ != NULL)
            non_fast_scrollable_region_->::cc::proto::Region::Clear();
        clear_has_non_fast_scrollable_region();
    }
    const ::cc::proto::Region& BaseLayerProperties::non_fast_scrollable_region() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return non_fast_scrollable_region_ != NULL ? *non_fast_scrollable_region_ : *default_instance().non_fast_scrollable_region_;
#else
        return non_fast_scrollable_region_ != NULL ? *non_fast_scrollable_region_ : *default_instance_->non_fast_scrollable_region_;
#endif
    }
    ::cc::proto::Region* BaseLayerProperties::mutable_non_fast_scrollable_region()
    {
        set_has_non_fast_scrollable_region();
        if (non_fast_scrollable_region_ == NULL) {
            non_fast_scrollable_region_ = new ::cc::proto::Region;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
        return non_fast_scrollable_region_;
    }
    ::cc::proto::Region* BaseLayerProperties::release_non_fast_scrollable_region()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
        clear_has_non_fast_scrollable_region();
        ::cc::proto::Region* temp = non_fast_scrollable_region_;
        non_fast_scrollable_region_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_non_fast_scrollable_region(::cc::proto::Region* non_fast_scrollable_region)
    {
        delete non_fast_scrollable_region_;
        non_fast_scrollable_region_ = non_fast_scrollable_region;
        if (non_fast_scrollable_region) {
            set_has_non_fast_scrollable_region();
        } else {
            clear_has_non_fast_scrollable_region();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
    }

    // optional .cc.proto.Region touch_event_handler_region = 19;
    bool BaseLayerProperties::has_touch_event_handler_region() const
    {
        return (_has_bits_[0] & 0x00400000u) != 0;
    }
    void BaseLayerProperties::set_has_touch_event_handler_region()
    {
        _has_bits_[0] |= 0x00400000u;
    }
    void BaseLayerProperties::clear_has_touch_event_handler_region()
    {
        _has_bits_[0] &= ~0x00400000u;
    }
    void BaseLayerProperties::clear_touch_event_handler_region()
    {
        if (touch_event_handler_region_ != NULL)
            touch_event_handler_region_->::cc::proto::Region::Clear();
        clear_has_touch_event_handler_region();
    }
    const ::cc::proto::Region& BaseLayerProperties::touch_event_handler_region() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.touch_event_handler_region)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return touch_event_handler_region_ != NULL ? *touch_event_handler_region_ : *default_instance().touch_event_handler_region_;
#else
        return touch_event_handler_region_ != NULL ? *touch_event_handler_region_ : *default_instance_->touch_event_handler_region_;
#endif
    }
    ::cc::proto::Region* BaseLayerProperties::mutable_touch_event_handler_region()
    {
        set_has_touch_event_handler_region();
        if (touch_event_handler_region_ == NULL) {
            touch_event_handler_region_ = new ::cc::proto::Region;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.touch_event_handler_region)
        return touch_event_handler_region_;
    }
    ::cc::proto::Region* BaseLayerProperties::release_touch_event_handler_region()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.touch_event_handler_region)
        clear_has_touch_event_handler_region();
        ::cc::proto::Region* temp = touch_event_handler_region_;
        touch_event_handler_region_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_touch_event_handler_region(::cc::proto::Region* touch_event_handler_region)
    {
        delete touch_event_handler_region_;
        touch_event_handler_region_ = touch_event_handler_region;
        if (touch_event_handler_region) {
            set_has_touch_event_handler_region();
        } else {
            clear_has_touch_event_handler_region();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.touch_event_handler_region)
    }

    // optional bool is_container_for_fixed_position_layers = 26;
    bool BaseLayerProperties::has_is_container_for_fixed_position_layers() const
    {
        return (_has_bits_[0] & 0x00800000u) != 0;
    }
    void BaseLayerProperties::set_has_is_container_for_fixed_position_layers()
    {
        _has_bits_[0] |= 0x00800000u;
    }
    void BaseLayerProperties::clear_has_is_container_for_fixed_position_layers()
    {
        _has_bits_[0] &= ~0x00800000u;
    }
    void BaseLayerProperties::clear_is_container_for_fixed_position_layers()
    {
        is_container_for_fixed_position_layers_ = false;
        clear_has_is_container_for_fixed_position_layers();
    }
    bool BaseLayerProperties::is_container_for_fixed_position_layers() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.is_container_for_fixed_position_layers)
        return is_container_for_fixed_position_layers_;
    }
    void BaseLayerProperties::set_is_container_for_fixed_position_layers(bool value)
    {
        set_has_is_container_for_fixed_position_layers();
        is_container_for_fixed_position_layers_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.is_container_for_fixed_position_layers)
    }

    // optional .cc.proto.LayerPositionConstraint position_constraint = 27;
    bool BaseLayerProperties::has_position_constraint() const
    {
        return (_has_bits_[0] & 0x01000000u) != 0;
    }
    void BaseLayerProperties::set_has_position_constraint()
    {
        _has_bits_[0] |= 0x01000000u;
    }
    void BaseLayerProperties::clear_has_position_constraint()
    {
        _has_bits_[0] &= ~0x01000000u;
    }
    void BaseLayerProperties::clear_position_constraint()
    {
        if (position_constraint_ != NULL)
            position_constraint_->::cc::proto::LayerPositionConstraint::Clear();
        clear_has_position_constraint();
    }
    const ::cc::proto::LayerPositionConstraint& BaseLayerProperties::position_constraint() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.position_constraint)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return position_constraint_ != NULL ? *position_constraint_ : *default_instance().position_constraint_;
#else
        return position_constraint_ != NULL ? *position_constraint_ : *default_instance_->position_constraint_;
#endif
    }
    ::cc::proto::LayerPositionConstraint* BaseLayerProperties::mutable_position_constraint()
    {
        set_has_position_constraint();
        if (position_constraint_ == NULL) {
            position_constraint_ = new ::cc::proto::LayerPositionConstraint;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.position_constraint)
        return position_constraint_;
    }
    ::cc::proto::LayerPositionConstraint* BaseLayerProperties::release_position_constraint()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.position_constraint)
        clear_has_position_constraint();
        ::cc::proto::LayerPositionConstraint* temp = position_constraint_;
        position_constraint_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_position_constraint(::cc::proto::LayerPositionConstraint* position_constraint)
    {
        delete position_constraint_;
        position_constraint_ = position_constraint;
        if (position_constraint) {
            set_has_position_constraint();
        } else {
            clear_has_position_constraint();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.position_constraint)
    }

    // optional .cc.proto.LayerStickyPositionConstraint sticky_position_constraint = 58;
    bool BaseLayerProperties::has_sticky_position_constraint() const
    {
        return (_has_bits_[0] & 0x02000000u) != 0;
    }
    void BaseLayerProperties::set_has_sticky_position_constraint()
    {
        _has_bits_[0] |= 0x02000000u;
    }
    void BaseLayerProperties::clear_has_sticky_position_constraint()
    {
        _has_bits_[0] &= ~0x02000000u;
    }
    void BaseLayerProperties::clear_sticky_position_constraint()
    {
        if (sticky_position_constraint_ != NULL)
            sticky_position_constraint_->::cc::proto::LayerStickyPositionConstraint::Clear();
        clear_has_sticky_position_constraint();
    }
    const ::cc::proto::LayerStickyPositionConstraint& BaseLayerProperties::sticky_position_constraint() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.sticky_position_constraint)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return sticky_position_constraint_ != NULL ? *sticky_position_constraint_ : *default_instance().sticky_position_constraint_;
#else
        return sticky_position_constraint_ != NULL ? *sticky_position_constraint_ : *default_instance_->sticky_position_constraint_;
#endif
    }
    ::cc::proto::LayerStickyPositionConstraint* BaseLayerProperties::mutable_sticky_position_constraint()
    {
        set_has_sticky_position_constraint();
        if (sticky_position_constraint_ == NULL) {
            sticky_position_constraint_ = new ::cc::proto::LayerStickyPositionConstraint;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.sticky_position_constraint)
        return sticky_position_constraint_;
    }
    ::cc::proto::LayerStickyPositionConstraint* BaseLayerProperties::release_sticky_position_constraint()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.sticky_position_constraint)
        clear_has_sticky_position_constraint();
        ::cc::proto::LayerStickyPositionConstraint* temp = sticky_position_constraint_;
        sticky_position_constraint_ = NULL;
        return temp;
    }
    void BaseLayerProperties::set_allocated_sticky_position_constraint(::cc::proto::LayerStickyPositionConstraint* sticky_position_constraint)
    {
        delete sticky_position_constraint_;
        sticky_position_constraint_ = sticky_position_constraint;
        if (sticky_position_constraint) {
            set_has_sticky_position_constraint();
        } else {
            clear_has_sticky_position_constraint();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.sticky_position_constraint)
    }

    // optional int32 scroll_parent_id = 40;
    bool BaseLayerProperties::has_scroll_parent_id() const
    {
        return (_has_bits_[0] & 0x04000000u) != 0;
    }
    void BaseLayerProperties::set_has_scroll_parent_id()
    {
        _has_bits_[0] |= 0x04000000u;
    }
    void BaseLayerProperties::clear_has_scroll_parent_id()
    {
        _has_bits_[0] &= ~0x04000000u;
    }
    void BaseLayerProperties::clear_scroll_parent_id()
    {
        scroll_parent_id_ = 0;
        clear_has_scroll_parent_id();
    }
    ::google::protobuf::int32 BaseLayerProperties::scroll_parent_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.scroll_parent_id)
        return scroll_parent_id_;
    }
    void BaseLayerProperties::set_scroll_parent_id(::google::protobuf::int32 value)
    {
        set_has_scroll_parent_id();
        scroll_parent_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.scroll_parent_id)
    }

    // optional int32 clip_parent_id = 42;
    bool BaseLayerProperties::has_clip_parent_id() const
    {
        return (_has_bits_[0] & 0x08000000u) != 0;
    }
    void BaseLayerProperties::set_has_clip_parent_id()
    {
        _has_bits_[0] |= 0x08000000u;
    }
    void BaseLayerProperties::clear_has_clip_parent_id()
    {
        _has_bits_[0] &= ~0x08000000u;
    }
    void BaseLayerProperties::clear_clip_parent_id()
    {
        clip_parent_id_ = 0;
        clear_has_clip_parent_id();
    }
    ::google::protobuf::int32 BaseLayerProperties::clip_parent_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.clip_parent_id)
        return clip_parent_id_;
    }
    void BaseLayerProperties::set_clip_parent_id(::google::protobuf::int32 value)
    {
        set_has_clip_parent_id();
        clip_parent_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.clip_parent_id)
    }

    // optional bool has_will_change_transform_hint = 48;
    bool BaseLayerProperties::has_has_will_change_transform_hint() const
    {
        return (_has_bits_[0] & 0x10000000u) != 0;
    }
    void BaseLayerProperties::set_has_has_will_change_transform_hint()
    {
        _has_bits_[0] |= 0x10000000u;
    }
    void BaseLayerProperties::clear_has_has_will_change_transform_hint()
    {
        _has_bits_[0] &= ~0x10000000u;
    }
    void BaseLayerProperties::clear_has_will_change_transform_hint()
    {
        has_will_change_transform_hint_ = false;
        clear_has_has_will_change_transform_hint();
    }
    bool BaseLayerProperties::has_will_change_transform_hint() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.has_will_change_transform_hint)
        return has_will_change_transform_hint_;
    }
    void BaseLayerProperties::set_has_will_change_transform_hint(bool value)
    {
        set_has_has_will_change_transform_hint();
        has_will_change_transform_hint_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.has_will_change_transform_hint)
    }

    // optional bool hide_layer_and_subtree = 10;
    bool BaseLayerProperties::has_hide_layer_and_subtree() const
    {
        return (_has_bits_[0] & 0x20000000u) != 0;
    }
    void BaseLayerProperties::set_has_hide_layer_and_subtree()
    {
        _has_bits_[0] |= 0x20000000u;
    }
    void BaseLayerProperties::clear_has_hide_layer_and_subtree()
    {
        _has_bits_[0] &= ~0x20000000u;
    }
    void BaseLayerProperties::clear_hide_layer_and_subtree()
    {
        hide_layer_and_subtree_ = false;
        clear_has_hide_layer_and_subtree();
    }
    bool BaseLayerProperties::hide_layer_and_subtree() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.hide_layer_and_subtree)
        return hide_layer_and_subtree_;
    }
    void BaseLayerProperties::set_hide_layer_and_subtree(bool value)
    {
        set_has_hide_layer_and_subtree();
        hide_layer_and_subtree_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.hide_layer_and_subtree)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForPictureLayerProperties(
        PictureLayerProperties* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int PictureLayerProperties::kNearestNeighborFieldNumber;
    const int PictureLayerProperties::kRecordedViewportFieldNumber;
    const int PictureLayerProperties::kDisplayListFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    PictureLayerProperties::PictureLayerProperties()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.PictureLayerProperties)
    }

    void PictureLayerProperties::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        recorded_viewport_ = const_cast<::cc::proto::Rect*>(
            ::cc::proto::Rect::internal_default_instance());
#else
        recorded_viewport_ = const_cast<::cc::proto::Rect*>(&::cc::proto::Rect::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        display_list_ = const_cast<::cc::proto::DisplayItemList*>(
            ::cc::proto::DisplayItemList::internal_default_instance());
#else
        display_list_ = const_cast<::cc::proto::DisplayItemList*>(&::cc::proto::DisplayItemList::default_instance());
#endif
    }

    PictureLayerProperties::PictureLayerProperties(const PictureLayerProperties& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.PictureLayerProperties)
    }

    void PictureLayerProperties::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        nearest_neighbor_ = false;
        recorded_viewport_ = NULL;
        display_list_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    PictureLayerProperties::~PictureLayerProperties()
    {
        // @@protoc_insertion_point(destructor:cc.proto.PictureLayerProperties)
        SharedDtor();
    }

    void PictureLayerProperties::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete recorded_viewport_;
            delete display_list_;
        }
    }

    void PictureLayerProperties::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const PictureLayerProperties& PictureLayerProperties::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_layer_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_layer_2eproto();
#endif
        return *default_instance_;
    }

    PictureLayerProperties* PictureLayerProperties::default_instance_ = NULL;

    PictureLayerProperties* PictureLayerProperties::New(::google::protobuf::Arena* arena) const
    {
        PictureLayerProperties* n = new PictureLayerProperties;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void PictureLayerProperties::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:cc.proto.PictureLayerProperties)
        if (_has_bits_[0 / 32] & 7u) {
            nearest_neighbor_ = false;
            if (has_recorded_viewport()) {
                if (recorded_viewport_ != NULL)
                    recorded_viewport_->::cc::proto::Rect::Clear();
            }
            if (has_display_list()) {
                if (display_list_ != NULL)
                    display_list_->::cc::proto::DisplayItemList::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool PictureLayerProperties::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForPictureLayerProperties, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.PictureLayerProperties)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional bool nearest_neighbor = 5;
            case 5: {
                if (tag == 40) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &nearest_neighbor_)));
                    set_has_nearest_neighbor();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(58))
                    goto parse_recorded_viewport;
                break;
            }

            // optional .cc.proto.Rect recorded_viewport = 7;
            case 7: {
                if (tag == 58) {
                parse_recorded_viewport:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_recorded_viewport()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(66))
                    goto parse_display_list;
                break;
            }

            // optional .cc.proto.DisplayItemList display_list = 8;
            case 8: {
                if (tag == 66) {
                parse_display_list:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_display_list()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.PictureLayerProperties)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.PictureLayerProperties)
        return false;
#undef DO_
    }

    void PictureLayerProperties::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.PictureLayerProperties)
        // optional bool nearest_neighbor = 5;
        if (has_nearest_neighbor()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->nearest_neighbor(), output);
        }

        // optional .cc.proto.Rect recorded_viewport = 7;
        if (has_recorded_viewport()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                7, *this->recorded_viewport_, output);
        }

        // optional .cc.proto.DisplayItemList display_list = 8;
        if (has_display_list()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                8, *this->display_list_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.PictureLayerProperties)
    }

    int PictureLayerProperties::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.PictureLayerProperties)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 7u) {
            // optional bool nearest_neighbor = 5;
            if (has_nearest_neighbor()) {
                total_size += 1 + 1;
            }

            // optional .cc.proto.Rect recorded_viewport = 7;
            if (has_recorded_viewport()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->recorded_viewport_);
            }

            // optional .cc.proto.DisplayItemList display_list = 8;
            if (has_display_list()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->display_list_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void PictureLayerProperties::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const PictureLayerProperties*>(&from));
    }

    void PictureLayerProperties::MergeFrom(const PictureLayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.PictureLayerProperties)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_nearest_neighbor()) {
                set_nearest_neighbor(from.nearest_neighbor());
            }
            if (from.has_recorded_viewport()) {
                mutable_recorded_viewport()->::cc::proto::Rect::MergeFrom(from.recorded_viewport());
            }
            if (from.has_display_list()) {
                mutable_display_list()->::cc::proto::DisplayItemList::MergeFrom(from.display_list());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void PictureLayerProperties::CopyFrom(const PictureLayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.PictureLayerProperties)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool PictureLayerProperties::IsInitialized() const
    {

        return true;
    }

    void PictureLayerProperties::Swap(PictureLayerProperties* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void PictureLayerProperties::InternalSwap(PictureLayerProperties* other)
    {
        std::swap(nearest_neighbor_, other->nearest_neighbor_);
        std::swap(recorded_viewport_, other->recorded_viewport_);
        std::swap(display_list_, other->display_list_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string PictureLayerProperties::GetTypeName() const
    {
        return "cc.proto.PictureLayerProperties";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // PictureLayerProperties

    // optional bool nearest_neighbor = 5;
    bool PictureLayerProperties::has_nearest_neighbor() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void PictureLayerProperties::set_has_nearest_neighbor()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void PictureLayerProperties::clear_has_nearest_neighbor()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void PictureLayerProperties::clear_nearest_neighbor()
    {
        nearest_neighbor_ = false;
        clear_has_nearest_neighbor();
    }
    bool PictureLayerProperties::nearest_neighbor() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.PictureLayerProperties.nearest_neighbor)
        return nearest_neighbor_;
    }
    void PictureLayerProperties::set_nearest_neighbor(bool value)
    {
        set_has_nearest_neighbor();
        nearest_neighbor_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.PictureLayerProperties.nearest_neighbor)
    }

    // optional .cc.proto.Rect recorded_viewport = 7;
    bool PictureLayerProperties::has_recorded_viewport() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void PictureLayerProperties::set_has_recorded_viewport()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void PictureLayerProperties::clear_has_recorded_viewport()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void PictureLayerProperties::clear_recorded_viewport()
    {
        if (recorded_viewport_ != NULL)
            recorded_viewport_->::cc::proto::Rect::Clear();
        clear_has_recorded_viewport();
    }
    const ::cc::proto::Rect& PictureLayerProperties::recorded_viewport() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.PictureLayerProperties.recorded_viewport)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return recorded_viewport_ != NULL ? *recorded_viewport_ : *default_instance().recorded_viewport_;
#else
        return recorded_viewport_ != NULL ? *recorded_viewport_ : *default_instance_->recorded_viewport_;
#endif
    }
    ::cc::proto::Rect* PictureLayerProperties::mutable_recorded_viewport()
    {
        set_has_recorded_viewport();
        if (recorded_viewport_ == NULL) {
            recorded_viewport_ = new ::cc::proto::Rect;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.PictureLayerProperties.recorded_viewport)
        return recorded_viewport_;
    }
    ::cc::proto::Rect* PictureLayerProperties::release_recorded_viewport()
    {
        // @@protoc_insertion_point(field_release:cc.proto.PictureLayerProperties.recorded_viewport)
        clear_has_recorded_viewport();
        ::cc::proto::Rect* temp = recorded_viewport_;
        recorded_viewport_ = NULL;
        return temp;
    }
    void PictureLayerProperties::set_allocated_recorded_viewport(::cc::proto::Rect* recorded_viewport)
    {
        delete recorded_viewport_;
        recorded_viewport_ = recorded_viewport;
        if (recorded_viewport) {
            set_has_recorded_viewport();
        } else {
            clear_has_recorded_viewport();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.PictureLayerProperties.recorded_viewport)
    }

    // optional .cc.proto.DisplayItemList display_list = 8;
    bool PictureLayerProperties::has_display_list() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void PictureLayerProperties::set_has_display_list()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void PictureLayerProperties::clear_has_display_list()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void PictureLayerProperties::clear_display_list()
    {
        if (display_list_ != NULL)
            display_list_->::cc::proto::DisplayItemList::Clear();
        clear_has_display_list();
    }
    const ::cc::proto::DisplayItemList& PictureLayerProperties::display_list() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.PictureLayerProperties.display_list)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return display_list_ != NULL ? *display_list_ : *default_instance().display_list_;
#else
        return display_list_ != NULL ? *display_list_ : *default_instance_->display_list_;
#endif
    }
    ::cc::proto::DisplayItemList* PictureLayerProperties::mutable_display_list()
    {
        set_has_display_list();
        if (display_list_ == NULL) {
            display_list_ = new ::cc::proto::DisplayItemList;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.PictureLayerProperties.display_list)
        return display_list_;
    }
    ::cc::proto::DisplayItemList* PictureLayerProperties::release_display_list()
    {
        // @@protoc_insertion_point(field_release:cc.proto.PictureLayerProperties.display_list)
        clear_has_display_list();
        ::cc::proto::DisplayItemList* temp = display_list_;
        display_list_ = NULL;
        return temp;
    }
    void PictureLayerProperties::set_allocated_display_list(::cc::proto::DisplayItemList* display_list)
    {
        delete display_list_;
        display_list_ = display_list;
        if (display_list) {
            set_has_display_list();
        } else {
            clear_has_display_list();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.PictureLayerProperties.display_list)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForSolidColorScrollbarLayerProperties(
        SolidColorScrollbarLayerProperties* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool SolidColorScrollbarLayerProperties_ScrollbarOrientation_IsValid(int value)
    {
        switch (value) {
        case 0:
        case 1:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties::HORIZONTAL;
    const SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties::VERTICAL;
    const SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties::ScrollbarOrientation_MIN;
    const SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties::ScrollbarOrientation_MAX;
    const int SolidColorScrollbarLayerProperties::ScrollbarOrientation_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int SolidColorScrollbarLayerProperties::kScrollLayerIdFieldNumber;
    const int SolidColorScrollbarLayerProperties::kThumbThicknessFieldNumber;
    const int SolidColorScrollbarLayerProperties::kTrackStartFieldNumber;
    const int SolidColorScrollbarLayerProperties::kIsLeftSideVerticalScrollbarFieldNumber;
    const int SolidColorScrollbarLayerProperties::kOrientationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    SolidColorScrollbarLayerProperties::SolidColorScrollbarLayerProperties()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:cc.proto.SolidColorScrollbarLayerProperties)
    }

    void SolidColorScrollbarLayerProperties::InitAsDefaultInstance()
    {
    }

    SolidColorScrollbarLayerProperties::SolidColorScrollbarLayerProperties(const SolidColorScrollbarLayerProperties& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:cc.proto.SolidColorScrollbarLayerProperties)
    }

    void SolidColorScrollbarLayerProperties::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        scroll_layer_id_ = 0;
        thumb_thickness_ = 0;
        track_start_ = 0;
        is_left_side_vertical_scrollbar_ = false;
        orientation_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    SolidColorScrollbarLayerProperties::~SolidColorScrollbarLayerProperties()
    {
        // @@protoc_insertion_point(destructor:cc.proto.SolidColorScrollbarLayerProperties)
        SharedDtor();
    }

    void SolidColorScrollbarLayerProperties::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void SolidColorScrollbarLayerProperties::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const SolidColorScrollbarLayerProperties& SolidColorScrollbarLayerProperties::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_layer_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_layer_2eproto();
#endif
        return *default_instance_;
    }

    SolidColorScrollbarLayerProperties* SolidColorScrollbarLayerProperties::default_instance_ = NULL;

    SolidColorScrollbarLayerProperties* SolidColorScrollbarLayerProperties::New(::google::protobuf::Arena* arena) const
    {
        SolidColorScrollbarLayerProperties* n = new SolidColorScrollbarLayerProperties;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void SolidColorScrollbarLayerProperties::Clear()
    {
// @@protoc_insertion_point(message_clear_start:cc.proto.SolidColorScrollbarLayerProperties)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                                        \
    _Pragma("clang diagnostic push")                                                                                         \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(SolidColorScrollbarLayerProperties, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<SolidColorScrollbarLayerProperties*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 31u) {
            ZR_(scroll_layer_id_, orientation_);
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool SolidColorScrollbarLayerProperties::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForSolidColorScrollbarLayerProperties, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:cc.proto.SolidColorScrollbarLayerProperties)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 scroll_layer_id = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &scroll_layer_id_)));
                    set_has_scroll_layer_id();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_thumb_thickness;
                break;
            }

            // optional int32 thumb_thickness = 2;
            case 2: {
                if (tag == 16) {
                parse_thumb_thickness:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &thumb_thickness_)));
                    set_has_thumb_thickness();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_track_start;
                break;
            }

            // optional int32 track_start = 3;
            case 3: {
                if (tag == 24) {
                parse_track_start:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &track_start_)));
                    set_has_track_start();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(32))
                    goto parse_is_left_side_vertical_scrollbar;
                break;
            }

            // optional bool is_left_side_vertical_scrollbar = 4;
            case 4: {
                if (tag == 32) {
                parse_is_left_side_vertical_scrollbar:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &is_left_side_vertical_scrollbar_)));
                    set_has_is_left_side_vertical_scrollbar();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(40))
                    goto parse_orientation;
                break;
            }

            // optional .cc.proto.SolidColorScrollbarLayerProperties.ScrollbarOrientation orientation = 5;
            case 5: {
                if (tag == 40) {
                parse_orientation:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation_IsValid(value)) {
                        set_orientation(static_cast<::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(40);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:cc.proto.SolidColorScrollbarLayerProperties)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:cc.proto.SolidColorScrollbarLayerProperties)
        return false;
#undef DO_
    }

    void SolidColorScrollbarLayerProperties::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:cc.proto.SolidColorScrollbarLayerProperties)
        // optional int32 scroll_layer_id = 1;
        if (has_scroll_layer_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->scroll_layer_id(), output);
        }

        // optional int32 thumb_thickness = 2;
        if (has_thumb_thickness()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->thumb_thickness(), output);
        }

        // optional int32 track_start = 3;
        if (has_track_start()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->track_start(), output);
        }

        // optional bool is_left_side_vertical_scrollbar = 4;
        if (has_is_left_side_vertical_scrollbar()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_left_side_vertical_scrollbar(), output);
        }

        // optional .cc.proto.SolidColorScrollbarLayerProperties.ScrollbarOrientation orientation = 5;
        if (has_orientation()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                5, this->orientation(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:cc.proto.SolidColorScrollbarLayerProperties)
    }

    int SolidColorScrollbarLayerProperties::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:cc.proto.SolidColorScrollbarLayerProperties)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 31u) {
            // optional int32 scroll_layer_id = 1;
            if (has_scroll_layer_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->scroll_layer_id());
            }

            // optional int32 thumb_thickness = 2;
            if (has_thumb_thickness()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->thumb_thickness());
            }

            // optional int32 track_start = 3;
            if (has_track_start()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->track_start());
            }

            // optional bool is_left_side_vertical_scrollbar = 4;
            if (has_is_left_side_vertical_scrollbar()) {
                total_size += 1 + 1;
            }

            // optional .cc.proto.SolidColorScrollbarLayerProperties.ScrollbarOrientation orientation = 5;
            if (has_orientation()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->orientation());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void SolidColorScrollbarLayerProperties::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const SolidColorScrollbarLayerProperties*>(&from));
    }

    void SolidColorScrollbarLayerProperties::MergeFrom(const SolidColorScrollbarLayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.SolidColorScrollbarLayerProperties)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_scroll_layer_id()) {
                set_scroll_layer_id(from.scroll_layer_id());
            }
            if (from.has_thumb_thickness()) {
                set_thumb_thickness(from.thumb_thickness());
            }
            if (from.has_track_start()) {
                set_track_start(from.track_start());
            }
            if (from.has_is_left_side_vertical_scrollbar()) {
                set_is_left_side_vertical_scrollbar(from.is_left_side_vertical_scrollbar());
            }
            if (from.has_orientation()) {
                set_orientation(from.orientation());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void SolidColorScrollbarLayerProperties::CopyFrom(const SolidColorScrollbarLayerProperties& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.SolidColorScrollbarLayerProperties)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool SolidColorScrollbarLayerProperties::IsInitialized() const
    {

        return true;
    }

    void SolidColorScrollbarLayerProperties::Swap(SolidColorScrollbarLayerProperties* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void SolidColorScrollbarLayerProperties::InternalSwap(SolidColorScrollbarLayerProperties* other)
    {
        std::swap(scroll_layer_id_, other->scroll_layer_id_);
        std::swap(thumb_thickness_, other->thumb_thickness_);
        std::swap(track_start_, other->track_start_);
        std::swap(is_left_side_vertical_scrollbar_, other->is_left_side_vertical_scrollbar_);
        std::swap(orientation_, other->orientation_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string SolidColorScrollbarLayerProperties::GetTypeName() const
    {
        return "cc.proto.SolidColorScrollbarLayerProperties";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // SolidColorScrollbarLayerProperties

    // optional int32 scroll_layer_id = 1;
    bool SolidColorScrollbarLayerProperties::has_scroll_layer_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void SolidColorScrollbarLayerProperties::set_has_scroll_layer_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void SolidColorScrollbarLayerProperties::clear_has_scroll_layer_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void SolidColorScrollbarLayerProperties::clear_scroll_layer_id()
    {
        scroll_layer_id_ = 0;
        clear_has_scroll_layer_id();
    }
    ::google::protobuf::int32 SolidColorScrollbarLayerProperties::scroll_layer_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.scroll_layer_id)
        return scroll_layer_id_;
    }
    void SolidColorScrollbarLayerProperties::set_scroll_layer_id(::google::protobuf::int32 value)
    {
        set_has_scroll_layer_id();
        scroll_layer_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.scroll_layer_id)
    }

    // optional int32 thumb_thickness = 2;
    bool SolidColorScrollbarLayerProperties::has_thumb_thickness() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void SolidColorScrollbarLayerProperties::set_has_thumb_thickness()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void SolidColorScrollbarLayerProperties::clear_has_thumb_thickness()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void SolidColorScrollbarLayerProperties::clear_thumb_thickness()
    {
        thumb_thickness_ = 0;
        clear_has_thumb_thickness();
    }
    ::google::protobuf::int32 SolidColorScrollbarLayerProperties::thumb_thickness() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.thumb_thickness)
        return thumb_thickness_;
    }
    void SolidColorScrollbarLayerProperties::set_thumb_thickness(::google::protobuf::int32 value)
    {
        set_has_thumb_thickness();
        thumb_thickness_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.thumb_thickness)
    }

    // optional int32 track_start = 3;
    bool SolidColorScrollbarLayerProperties::has_track_start() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void SolidColorScrollbarLayerProperties::set_has_track_start()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void SolidColorScrollbarLayerProperties::clear_has_track_start()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void SolidColorScrollbarLayerProperties::clear_track_start()
    {
        track_start_ = 0;
        clear_has_track_start();
    }
    ::google::protobuf::int32 SolidColorScrollbarLayerProperties::track_start() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.track_start)
        return track_start_;
    }
    void SolidColorScrollbarLayerProperties::set_track_start(::google::protobuf::int32 value)
    {
        set_has_track_start();
        track_start_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.track_start)
    }

    // optional bool is_left_side_vertical_scrollbar = 4;
    bool SolidColorScrollbarLayerProperties::has_is_left_side_vertical_scrollbar() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void SolidColorScrollbarLayerProperties::set_has_is_left_side_vertical_scrollbar()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void SolidColorScrollbarLayerProperties::clear_has_is_left_side_vertical_scrollbar()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void SolidColorScrollbarLayerProperties::clear_is_left_side_vertical_scrollbar()
    {
        is_left_side_vertical_scrollbar_ = false;
        clear_has_is_left_side_vertical_scrollbar();
    }
    bool SolidColorScrollbarLayerProperties::is_left_side_vertical_scrollbar() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.is_left_side_vertical_scrollbar)
        return is_left_side_vertical_scrollbar_;
    }
    void SolidColorScrollbarLayerProperties::set_is_left_side_vertical_scrollbar(bool value)
    {
        set_has_is_left_side_vertical_scrollbar();
        is_left_side_vertical_scrollbar_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.is_left_side_vertical_scrollbar)
    }

    // optional .cc.proto.SolidColorScrollbarLayerProperties.ScrollbarOrientation orientation = 5;
    bool SolidColorScrollbarLayerProperties::has_orientation() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void SolidColorScrollbarLayerProperties::set_has_orientation()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void SolidColorScrollbarLayerProperties::clear_has_orientation()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void SolidColorScrollbarLayerProperties::clear_orientation()
    {
        orientation_ = 0;
        clear_has_orientation();
    }
    ::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties::orientation() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.orientation)
        return static_cast<::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation>(orientation_);
    }
    void SolidColorScrollbarLayerProperties::set_orientation(::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation value)
    {
        assert(::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation_IsValid(value));
        set_has_orientation();
        orientation_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.orientation)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace cc

// @@protoc_insertion_point(global_scope)
