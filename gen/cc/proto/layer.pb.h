// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer.proto

#ifndef PROTOBUF_layer_2eproto__INCLUDED
#define PROTOBUF_layer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "display_item.pb.h"
#include "layer_position_constraint.pb.h"
#include "layer_sticky_position_constraint.pb.h"
#include "point3f.pb.h"
#include "pointf.pb.h"
#include "rect.pb.h"
#include "region.pb.h"
#include "scroll_offset.pb.h"
#include "size.pb.h"
#include "skxfermode.pb.h"
#include "transform.pb.h"
#include "vector2df.pb.h"
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

    // Internal implementation detail -- do not call these.
    void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
    void protobuf_AssignDesc_layer_2eproto();
    void protobuf_ShutdownFile_layer_2eproto();

    class BaseLayerProperties;
    class LayerNode;
    class LayerProperties;
    class LayerUpdate;
    class PictureLayerProperties;
    class SolidColorScrollbarLayerProperties;

    enum LayerNode_Type {
        LayerNode_Type_UNKNOWN = 0,
        LayerNode_Type_LAYER = 1,
        LayerNode_Type_PICTURE_LAYER = 2,
        LayerNode_Type_SOLID_COLOR_SCROLLBAR_LAYER = 4,
        LayerNode_Type_FAKE_PICTURE_LAYER = 5,
        LayerNode_Type_PUSH_PROPERTIES_COUNTING_LAYER = 6
    };
    CC_PROTO_EXPORT bool LayerNode_Type_IsValid(int value);
    const LayerNode_Type LayerNode_Type_Type_MIN = LayerNode_Type_UNKNOWN;
    const LayerNode_Type LayerNode_Type_Type_MAX = LayerNode_Type_PUSH_PROPERTIES_COUNTING_LAYER;
    const int LayerNode_Type_Type_ARRAYSIZE = LayerNode_Type_Type_MAX + 1;

    enum SolidColorScrollbarLayerProperties_ScrollbarOrientation {
        SolidColorScrollbarLayerProperties_ScrollbarOrientation_HORIZONTAL = 0,
        SolidColorScrollbarLayerProperties_ScrollbarOrientation_VERTICAL = 1
    };
    CC_PROTO_EXPORT bool SolidColorScrollbarLayerProperties_ScrollbarOrientation_IsValid(int value);
    const SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties_ScrollbarOrientation_ScrollbarOrientation_MIN = SolidColorScrollbarLayerProperties_ScrollbarOrientation_HORIZONTAL;
    const SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties_ScrollbarOrientation_ScrollbarOrientation_MAX = SolidColorScrollbarLayerProperties_ScrollbarOrientation_VERTICAL;
    const int SolidColorScrollbarLayerProperties_ScrollbarOrientation_ScrollbarOrientation_ARRAYSIZE = SolidColorScrollbarLayerProperties_ScrollbarOrientation_ScrollbarOrientation_MAX + 1;

    // ===================================================================

    class CC_PROTO_EXPORT LayerNode : public ::google::protobuf::MessageLite {
    public:
        LayerNode();
        virtual ~LayerNode();

        LayerNode(const LayerNode& from);

        inline LayerNode& operator=(const LayerNode& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const LayerNode& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const LayerNode* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(LayerNode* other);

        // implements Message ----------------------------------------------

        inline LayerNode* New() const { return New(NULL); }

        LayerNode* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const LayerNode& from);
        void MergeFrom(const LayerNode& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(LayerNode* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef LayerNode_Type Type;
        static const Type UNKNOWN = LayerNode_Type_UNKNOWN;
        static const Type LAYER = LayerNode_Type_LAYER;
        static const Type PICTURE_LAYER = LayerNode_Type_PICTURE_LAYER;
        static const Type SOLID_COLOR_SCROLLBAR_LAYER = LayerNode_Type_SOLID_COLOR_SCROLLBAR_LAYER;
        static const Type FAKE_PICTURE_LAYER = LayerNode_Type_FAKE_PICTURE_LAYER;
        static const Type PUSH_PROPERTIES_COUNTING_LAYER = LayerNode_Type_PUSH_PROPERTIES_COUNTING_LAYER;
        static inline bool Type_IsValid(int value)
        {
            return LayerNode_Type_IsValid(value);
        }
        static const Type Type_MIN = LayerNode_Type_Type_MIN;
        static const Type Type_MAX = LayerNode_Type_Type_MAX;
        static const int Type_ARRAYSIZE = LayerNode_Type_Type_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional int32 id = 1;
        bool has_id() const;
        void clear_id();
        static const int kIdFieldNumber = 1;
        ::google::protobuf::int32 id() const;
        void set_id(::google::protobuf::int32 value);

        // optional .cc.proto.LayerNode.Type type = 2;
        bool has_type() const;
        void clear_type();
        static const int kTypeFieldNumber = 2;
        ::cc::proto::LayerNode_Type type() const;
        void set_type(::cc::proto::LayerNode_Type value);

        // optional int32 parent_id = 3;
        bool has_parent_id() const;
        void clear_parent_id();
        static const int kParentIdFieldNumber = 3;
        ::google::protobuf::int32 parent_id() const;
        void set_parent_id(::google::protobuf::int32 value);

        // repeated .cc.proto.LayerNode children = 4;
        int children_size() const;
        void clear_children();
        static const int kChildrenFieldNumber = 4;
        const ::cc::proto::LayerNode& children(int index) const;
        ::cc::proto::LayerNode* mutable_children(int index);
        ::cc::proto::LayerNode* add_children();
        ::google::protobuf::RepeatedPtrField<::cc::proto::LayerNode>*
        mutable_children();
        const ::google::protobuf::RepeatedPtrField<::cc::proto::LayerNode>&
        children() const;

        // optional .cc.proto.LayerNode mask_layer = 5;
        bool has_mask_layer() const;
        void clear_mask_layer();
        static const int kMaskLayerFieldNumber = 5;
        const ::cc::proto::LayerNode& mask_layer() const;
        ::cc::proto::LayerNode* mutable_mask_layer();
        ::cc::proto::LayerNode* release_mask_layer();
        void set_allocated_mask_layer(::cc::proto::LayerNode* mask_layer);

        // optional .cc.proto.SolidColorScrollbarLayerProperties solid_scrollbar = 6;
        bool has_solid_scrollbar() const;
        void clear_solid_scrollbar();
        static const int kSolidScrollbarFieldNumber = 6;
        const ::cc::proto::SolidColorScrollbarLayerProperties& solid_scrollbar() const;
        ::cc::proto::SolidColorScrollbarLayerProperties* mutable_solid_scrollbar();
        ::cc::proto::SolidColorScrollbarLayerProperties* release_solid_scrollbar();
        void set_allocated_solid_scrollbar(::cc::proto::SolidColorScrollbarLayerProperties* solid_scrollbar);

        // @@protoc_insertion_point(class_scope:cc.proto.LayerNode)
    private:
        inline void set_has_id();
        inline void clear_has_id();
        inline void set_has_type();
        inline void clear_has_type();
        inline void set_has_parent_id();
        inline void clear_has_parent_id();
        inline void set_has_mask_layer();
        inline void clear_has_mask_layer();
        inline void set_has_solid_scrollbar();
        inline void clear_has_solid_scrollbar();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int32 id_;
        int type_;
        ::google::protobuf::RepeatedPtrField<::cc::proto::LayerNode> children_;
        ::cc::proto::LayerNode* mask_layer_;
        ::cc::proto::SolidColorScrollbarLayerProperties* solid_scrollbar_;
        ::google::protobuf::int32 parent_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
#endif
        friend void protobuf_AssignDesc_layer_2eproto();
        friend void protobuf_ShutdownFile_layer_2eproto();

        void InitAsDefaultInstance();
        static LayerNode* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT LayerUpdate : public ::google::protobuf::MessageLite {
    public:
        LayerUpdate();
        virtual ~LayerUpdate();

        LayerUpdate(const LayerUpdate& from);

        inline LayerUpdate& operator=(const LayerUpdate& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const LayerUpdate& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const LayerUpdate* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(LayerUpdate* other);

        // implements Message ----------------------------------------------

        inline LayerUpdate* New() const { return New(NULL); }

        LayerUpdate* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const LayerUpdate& from);
        void MergeFrom(const LayerUpdate& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(LayerUpdate* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .cc.proto.LayerProperties layers = 1;
        int layers_size() const;
        void clear_layers();
        static const int kLayersFieldNumber = 1;
        const ::cc::proto::LayerProperties& layers(int index) const;
        ::cc::proto::LayerProperties* mutable_layers(int index);
        ::cc::proto::LayerProperties* add_layers();
        ::google::protobuf::RepeatedPtrField<::cc::proto::LayerProperties>*
        mutable_layers();
        const ::google::protobuf::RepeatedPtrField<::cc::proto::LayerProperties>&
        layers() const;

        // @@protoc_insertion_point(class_scope:cc.proto.LayerUpdate)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::cc::proto::LayerProperties> layers_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
#endif
        friend void protobuf_AssignDesc_layer_2eproto();
        friend void protobuf_ShutdownFile_layer_2eproto();

        void InitAsDefaultInstance();
        static LayerUpdate* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT LayerProperties : public ::google::protobuf::MessageLite {
    public:
        LayerProperties();
        virtual ~LayerProperties();

        LayerProperties(const LayerProperties& from);

        inline LayerProperties& operator=(const LayerProperties& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const LayerProperties& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const LayerProperties* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(LayerProperties* other);

        // implements Message ----------------------------------------------

        inline LayerProperties* New() const { return New(NULL); }

        LayerProperties* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const LayerProperties& from);
        void MergeFrom(const LayerProperties& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(LayerProperties* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 id = 1;
        bool has_id() const;
        void clear_id();
        static const int kIdFieldNumber = 1;
        ::google::protobuf::int32 id() const;
        void set_id(::google::protobuf::int32 value);

        // optional .cc.proto.BaseLayerProperties base = 5;
        bool has_base() const;
        void clear_base();
        static const int kBaseFieldNumber = 5;
        const ::cc::proto::BaseLayerProperties& base() const;
        ::cc::proto::BaseLayerProperties* mutable_base();
        ::cc::proto::BaseLayerProperties* release_base();
        void set_allocated_base(::cc::proto::BaseLayerProperties* base);

        // optional .cc.proto.PictureLayerProperties picture = 6;
        bool has_picture() const;
        void clear_picture();
        static const int kPictureFieldNumber = 6;
        const ::cc::proto::PictureLayerProperties& picture() const;
        ::cc::proto::PictureLayerProperties* mutable_picture();
        ::cc::proto::PictureLayerProperties* release_picture();
        void set_allocated_picture(::cc::proto::PictureLayerProperties* picture);

        // @@protoc_insertion_point(class_scope:cc.proto.LayerProperties)
    private:
        inline void set_has_id();
        inline void clear_has_id();
        inline void set_has_base();
        inline void clear_has_base();
        inline void set_has_picture();
        inline void clear_has_picture();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::BaseLayerProperties* base_;
        ::cc::proto::PictureLayerProperties* picture_;
        ::google::protobuf::int32 id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
#endif
        friend void protobuf_AssignDesc_layer_2eproto();
        friend void protobuf_ShutdownFile_layer_2eproto();

        void InitAsDefaultInstance();
        static LayerProperties* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT BaseLayerProperties : public ::google::protobuf::MessageLite {
    public:
        BaseLayerProperties();
        virtual ~BaseLayerProperties();

        BaseLayerProperties(const BaseLayerProperties& from);

        inline BaseLayerProperties& operator=(const BaseLayerProperties& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const BaseLayerProperties& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const BaseLayerProperties* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(BaseLayerProperties* other);

        // implements Message ----------------------------------------------

        inline BaseLayerProperties* New() const { return New(NULL); }

        BaseLayerProperties* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const BaseLayerProperties& from);
        void MergeFrom(const BaseLayerProperties& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(BaseLayerProperties* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .cc.proto.Rect update_rect = 46;
        bool has_update_rect() const;
        void clear_update_rect();
        static const int kUpdateRectFieldNumber = 46;
        const ::cc::proto::Rect& update_rect() const;
        ::cc::proto::Rect* mutable_update_rect();
        ::cc::proto::Rect* release_update_rect();
        void set_allocated_update_rect(::cc::proto::Rect* update_rect);

        // optional .cc.proto.Size bounds = 3;
        bool has_bounds() const;
        void clear_bounds();
        static const int kBoundsFieldNumber = 3;
        const ::cc::proto::Size& bounds() const;
        ::cc::proto::Size* mutable_bounds();
        ::cc::proto::Size* release_bounds();
        void set_allocated_bounds(::cc::proto::Size* bounds);

        // optional bool masks_to_bounds = 14;
        bool has_masks_to_bounds() const;
        void clear_masks_to_bounds();
        static const int kMasksToBoundsFieldNumber = 14;
        bool masks_to_bounds() const;
        void set_masks_to_bounds(bool value);

        // optional float opacity = 22;
        bool has_opacity() const;
        void clear_opacity();
        static const int kOpacityFieldNumber = 22;
        float opacity() const;
        void set_opacity(float value);

        // optional .cc.proto.SkXfermode.Mode blend_mode = 23;
        bool has_blend_mode() const;
        void clear_blend_mode();
        static const int kBlendModeFieldNumber = 23;
        ::cc::proto::SkXfermode_Mode blend_mode() const;
        void set_blend_mode(::cc::proto::SkXfermode_Mode value);

        // optional bool is_root_for_isolated_group = 24;
        bool has_is_root_for_isolated_group() const;
        void clear_is_root_for_isolated_group();
        static const int kIsRootForIsolatedGroupFieldNumber = 24;
        bool is_root_for_isolated_group() const;
        void set_is_root_for_isolated_group(bool value);

        // optional bool contents_opaque = 21;
        bool has_contents_opaque() const;
        void clear_contents_opaque();
        static const int kContentsOpaqueFieldNumber = 21;
        bool contents_opaque() const;
        void set_contents_opaque(bool value);

        // optional .cc.proto.PointF position = 25;
        bool has_position() const;
        void clear_position();
        static const int kPositionFieldNumber = 25;
        const ::cc::proto::PointF& position() const;
        ::cc::proto::PointF* mutable_position();
        ::cc::proto::PointF* release_position();
        void set_allocated_position(::cc::proto::PointF* position);

        // optional .cc.proto.Transform transform = 33;
        bool has_transform() const;
        void clear_transform();
        static const int kTransformFieldNumber = 33;
        const ::cc::proto::Transform& transform() const;
        ::cc::proto::Transform* mutable_transform();
        ::cc::proto::Transform* release_transform();
        void set_allocated_transform(::cc::proto::Transform* transform);

        // optional .cc.proto.Point3F transform_origin = 1;
        bool has_transform_origin() const;
        void clear_transform_origin();
        static const int kTransformOriginFieldNumber = 1;
        const ::cc::proto::Point3F& transform_origin() const;
        ::cc::proto::Point3F* mutable_transform_origin();
        ::cc::proto::Point3F* release_transform_origin();
        void set_allocated_transform_origin(::cc::proto::Point3F* transform_origin);

        // optional bool is_drawable = 56;
        bool has_is_drawable() const;
        void clear_is_drawable();
        static const int kIsDrawableFieldNumber = 56;
        bool is_drawable() const;
        void set_is_drawable(bool value);

        // optional bool double_sided = 8;
        bool has_double_sided() const;
        void clear_double_sided();
        static const int kDoubleSidedFieldNumber = 8;
        bool double_sided() const;
        void set_double_sided(bool value);

        // optional bool should_flatten_transform = 28;
        bool has_should_flatten_transform() const;
        void clear_should_flatten_transform();
        static const int kShouldFlattenTransformFieldNumber = 28;
        bool should_flatten_transform() const;
        void set_should_flatten_transform(bool value);

        // optional int32 sorting_context_id = 35;
        bool has_sorting_context_id() const;
        void clear_sorting_context_id();
        static const int kSortingContextIdFieldNumber = 35;
        ::google::protobuf::int32 sorting_context_id() const;
        void set_sorting_context_id(::google::protobuf::int32 value);

        // optional bool use_parent_backface_visibility = 32;
        bool has_use_parent_backface_visibility() const;
        void clear_use_parent_backface_visibility();
        static const int kUseParentBackfaceVisibilityFieldNumber = 32;
        bool use_parent_backface_visibility() const;
        void set_use_parent_backface_visibility(bool value);

        // optional uint32 background_color = 2;
        bool has_background_color() const;
        void clear_background_color();
        static const int kBackgroundColorFieldNumber = 2;
        ::google::protobuf::uint32 background_color() const;
        void set_background_color(::google::protobuf::uint32 value);

        // optional .cc.proto.ScrollOffset scroll_offset = 44;
        bool has_scroll_offset() const;
        void clear_scroll_offset();
        static const int kScrollOffsetFieldNumber = 44;
        const ::cc::proto::ScrollOffset& scroll_offset() const;
        ::cc::proto::ScrollOffset* mutable_scroll_offset();
        ::cc::proto::ScrollOffset* release_scroll_offset();
        void set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset);

        // optional int32 scroll_clip_layer_id = 37;
        bool has_scroll_clip_layer_id() const;
        void clear_scroll_clip_layer_id();
        static const int kScrollClipLayerIdFieldNumber = 37;
        ::google::protobuf::int32 scroll_clip_layer_id() const;
        void set_scroll_clip_layer_id(::google::protobuf::int32 value);

        // optional bool user_scrollable_horizontal = 38;
        bool has_user_scrollable_horizontal() const;
        void clear_user_scrollable_horizontal();
        static const int kUserScrollableHorizontalFieldNumber = 38;
        bool user_scrollable_horizontal() const;
        void set_user_scrollable_horizontal(bool value);

        // optional bool user_scrollable_vertical = 39;
        bool has_user_scrollable_vertical() const;
        void clear_user_scrollable_vertical();
        static const int kUserScrollableVerticalFieldNumber = 39;
        bool user_scrollable_vertical() const;
        void set_user_scrollable_vertical(bool value);

        // optional uint32 main_thread_scrolling_reasons = 15;
        bool has_main_thread_scrolling_reasons() const;
        void clear_main_thread_scrolling_reasons();
        static const int kMainThreadScrollingReasonsFieldNumber = 15;
        ::google::protobuf::uint32 main_thread_scrolling_reasons() const;
        void set_main_thread_scrolling_reasons(::google::protobuf::uint32 value);

        // optional .cc.proto.Region non_fast_scrollable_region = 18;
        bool has_non_fast_scrollable_region() const;
        void clear_non_fast_scrollable_region();
        static const int kNonFastScrollableRegionFieldNumber = 18;
        const ::cc::proto::Region& non_fast_scrollable_region() const;
        ::cc::proto::Region* mutable_non_fast_scrollable_region();
        ::cc::proto::Region* release_non_fast_scrollable_region();
        void set_allocated_non_fast_scrollable_region(::cc::proto::Region* non_fast_scrollable_region);

        // optional .cc.proto.Region touch_event_handler_region = 19;
        bool has_touch_event_handler_region() const;
        void clear_touch_event_handler_region();
        static const int kTouchEventHandlerRegionFieldNumber = 19;
        const ::cc::proto::Region& touch_event_handler_region() const;
        ::cc::proto::Region* mutable_touch_event_handler_region();
        ::cc::proto::Region* release_touch_event_handler_region();
        void set_allocated_touch_event_handler_region(::cc::proto::Region* touch_event_handler_region);

        // optional bool is_container_for_fixed_position_layers = 26;
        bool has_is_container_for_fixed_position_layers() const;
        void clear_is_container_for_fixed_position_layers();
        static const int kIsContainerForFixedPositionLayersFieldNumber = 26;
        bool is_container_for_fixed_position_layers() const;
        void set_is_container_for_fixed_position_layers(bool value);

        // optional .cc.proto.LayerPositionConstraint position_constraint = 27;
        bool has_position_constraint() const;
        void clear_position_constraint();
        static const int kPositionConstraintFieldNumber = 27;
        const ::cc::proto::LayerPositionConstraint& position_constraint() const;
        ::cc::proto::LayerPositionConstraint* mutable_position_constraint();
        ::cc::proto::LayerPositionConstraint* release_position_constraint();
        void set_allocated_position_constraint(::cc::proto::LayerPositionConstraint* position_constraint);

        // optional .cc.proto.LayerStickyPositionConstraint sticky_position_constraint = 58;
        bool has_sticky_position_constraint() const;
        void clear_sticky_position_constraint();
        static const int kStickyPositionConstraintFieldNumber = 58;
        const ::cc::proto::LayerStickyPositionConstraint& sticky_position_constraint() const;
        ::cc::proto::LayerStickyPositionConstraint* mutable_sticky_position_constraint();
        ::cc::proto::LayerStickyPositionConstraint* release_sticky_position_constraint();
        void set_allocated_sticky_position_constraint(::cc::proto::LayerStickyPositionConstraint* sticky_position_constraint);

        // optional int32 scroll_parent_id = 40;
        bool has_scroll_parent_id() const;
        void clear_scroll_parent_id();
        static const int kScrollParentIdFieldNumber = 40;
        ::google::protobuf::int32 scroll_parent_id() const;
        void set_scroll_parent_id(::google::protobuf::int32 value);

        // optional int32 clip_parent_id = 42;
        bool has_clip_parent_id() const;
        void clear_clip_parent_id();
        static const int kClipParentIdFieldNumber = 42;
        ::google::protobuf::int32 clip_parent_id() const;
        void set_clip_parent_id(::google::protobuf::int32 value);

        // optional bool has_will_change_transform_hint = 48;
        bool has_has_will_change_transform_hint() const;
        void clear_has_will_change_transform_hint();
        static const int kHasWillChangeTransformHintFieldNumber = 48;
        bool has_will_change_transform_hint() const;
        void set_has_will_change_transform_hint(bool value);

        // optional bool hide_layer_and_subtree = 10;
        bool has_hide_layer_and_subtree() const;
        void clear_hide_layer_and_subtree();
        static const int kHideLayerAndSubtreeFieldNumber = 10;
        bool hide_layer_and_subtree() const;
        void set_hide_layer_and_subtree(bool value);

        // @@protoc_insertion_point(class_scope:cc.proto.BaseLayerProperties)
    private:
        inline void set_has_update_rect();
        inline void clear_has_update_rect();
        inline void set_has_bounds();
        inline void clear_has_bounds();
        inline void set_has_masks_to_bounds();
        inline void clear_has_masks_to_bounds();
        inline void set_has_opacity();
        inline void clear_has_opacity();
        inline void set_has_blend_mode();
        inline void clear_has_blend_mode();
        inline void set_has_is_root_for_isolated_group();
        inline void clear_has_is_root_for_isolated_group();
        inline void set_has_contents_opaque();
        inline void clear_has_contents_opaque();
        inline void set_has_position();
        inline void clear_has_position();
        inline void set_has_transform();
        inline void clear_has_transform();
        inline void set_has_transform_origin();
        inline void clear_has_transform_origin();
        inline void set_has_is_drawable();
        inline void clear_has_is_drawable();
        inline void set_has_double_sided();
        inline void clear_has_double_sided();
        inline void set_has_should_flatten_transform();
        inline void clear_has_should_flatten_transform();
        inline void set_has_sorting_context_id();
        inline void clear_has_sorting_context_id();
        inline void set_has_use_parent_backface_visibility();
        inline void clear_has_use_parent_backface_visibility();
        inline void set_has_background_color();
        inline void clear_has_background_color();
        inline void set_has_scroll_offset();
        inline void clear_has_scroll_offset();
        inline void set_has_scroll_clip_layer_id();
        inline void clear_has_scroll_clip_layer_id();
        inline void set_has_user_scrollable_horizontal();
        inline void clear_has_user_scrollable_horizontal();
        inline void set_has_user_scrollable_vertical();
        inline void clear_has_user_scrollable_vertical();
        inline void set_has_main_thread_scrolling_reasons();
        inline void clear_has_main_thread_scrolling_reasons();
        inline void set_has_non_fast_scrollable_region();
        inline void clear_has_non_fast_scrollable_region();
        inline void set_has_touch_event_handler_region();
        inline void clear_has_touch_event_handler_region();
        inline void set_has_is_container_for_fixed_position_layers();
        inline void clear_has_is_container_for_fixed_position_layers();
        inline void set_has_position_constraint();
        inline void clear_has_position_constraint();
        inline void set_has_sticky_position_constraint();
        inline void clear_has_sticky_position_constraint();
        inline void set_has_scroll_parent_id();
        inline void clear_has_scroll_parent_id();
        inline void set_has_clip_parent_id();
        inline void clear_has_clip_parent_id();
        inline void set_has_has_will_change_transform_hint();
        inline void clear_has_has_will_change_transform_hint();
        inline void set_has_hide_layer_and_subtree();
        inline void clear_has_hide_layer_and_subtree();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::Rect* update_rect_;
        ::cc::proto::Size* bounds_;
        float opacity_;
        int blend_mode_;
        ::cc::proto::PointF* position_;
        bool masks_to_bounds_;
        bool is_root_for_isolated_group_;
        bool contents_opaque_;
        bool is_drawable_;
        ::google::protobuf::int32 sorting_context_id_;
        ::cc::proto::Transform* transform_;
        ::cc::proto::Point3F* transform_origin_;
        bool double_sided_;
        bool should_flatten_transform_;
        bool use_parent_backface_visibility_;
        bool user_scrollable_horizontal_;
        ::google::protobuf::uint32 background_color_;
        ::cc::proto::ScrollOffset* scroll_offset_;
        ::google::protobuf::int32 scroll_clip_layer_id_;
        ::google::protobuf::uint32 main_thread_scrolling_reasons_;
        ::cc::proto::Region* non_fast_scrollable_region_;
        ::cc::proto::Region* touch_event_handler_region_;
        ::cc::proto::LayerPositionConstraint* position_constraint_;
        ::cc::proto::LayerStickyPositionConstraint* sticky_position_constraint_;
        bool user_scrollable_vertical_;
        bool is_container_for_fixed_position_layers_;
        bool has_will_change_transform_hint_;
        bool hide_layer_and_subtree_;
        ::google::protobuf::int32 scroll_parent_id_;
        ::google::protobuf::int32 clip_parent_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
#endif
        friend void protobuf_AssignDesc_layer_2eproto();
        friend void protobuf_ShutdownFile_layer_2eproto();

        void InitAsDefaultInstance();
        static BaseLayerProperties* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT PictureLayerProperties : public ::google::protobuf::MessageLite {
    public:
        PictureLayerProperties();
        virtual ~PictureLayerProperties();

        PictureLayerProperties(const PictureLayerProperties& from);

        inline PictureLayerProperties& operator=(const PictureLayerProperties& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const PictureLayerProperties& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const PictureLayerProperties* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(PictureLayerProperties* other);

        // implements Message ----------------------------------------------

        inline PictureLayerProperties* New() const { return New(NULL); }

        PictureLayerProperties* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const PictureLayerProperties& from);
        void MergeFrom(const PictureLayerProperties& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(PictureLayerProperties* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional bool nearest_neighbor = 5;
        bool has_nearest_neighbor() const;
        void clear_nearest_neighbor();
        static const int kNearestNeighborFieldNumber = 5;
        bool nearest_neighbor() const;
        void set_nearest_neighbor(bool value);

        // optional .cc.proto.Rect recorded_viewport = 7;
        bool has_recorded_viewport() const;
        void clear_recorded_viewport();
        static const int kRecordedViewportFieldNumber = 7;
        const ::cc::proto::Rect& recorded_viewport() const;
        ::cc::proto::Rect* mutable_recorded_viewport();
        ::cc::proto::Rect* release_recorded_viewport();
        void set_allocated_recorded_viewport(::cc::proto::Rect* recorded_viewport);

        // optional .cc.proto.DisplayItemList display_list = 8;
        bool has_display_list() const;
        void clear_display_list();
        static const int kDisplayListFieldNumber = 8;
        const ::cc::proto::DisplayItemList& display_list() const;
        ::cc::proto::DisplayItemList* mutable_display_list();
        ::cc::proto::DisplayItemList* release_display_list();
        void set_allocated_display_list(::cc::proto::DisplayItemList* display_list);

        // @@protoc_insertion_point(class_scope:cc.proto.PictureLayerProperties)
    private:
        inline void set_has_nearest_neighbor();
        inline void clear_has_nearest_neighbor();
        inline void set_has_recorded_viewport();
        inline void clear_has_recorded_viewport();
        inline void set_has_display_list();
        inline void clear_has_display_list();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::Rect* recorded_viewport_;
        ::cc::proto::DisplayItemList* display_list_;
        bool nearest_neighbor_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
#endif
        friend void protobuf_AssignDesc_layer_2eproto();
        friend void protobuf_ShutdownFile_layer_2eproto();

        void InitAsDefaultInstance();
        static PictureLayerProperties* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT SolidColorScrollbarLayerProperties : public ::google::protobuf::MessageLite {
    public:
        SolidColorScrollbarLayerProperties();
        virtual ~SolidColorScrollbarLayerProperties();

        SolidColorScrollbarLayerProperties(const SolidColorScrollbarLayerProperties& from);

        inline SolidColorScrollbarLayerProperties& operator=(const SolidColorScrollbarLayerProperties& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const SolidColorScrollbarLayerProperties& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const SolidColorScrollbarLayerProperties* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(SolidColorScrollbarLayerProperties* other);

        // implements Message ----------------------------------------------

        inline SolidColorScrollbarLayerProperties* New() const { return New(NULL); }

        SolidColorScrollbarLayerProperties* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const SolidColorScrollbarLayerProperties& from);
        void MergeFrom(const SolidColorScrollbarLayerProperties& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(SolidColorScrollbarLayerProperties* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef SolidColorScrollbarLayerProperties_ScrollbarOrientation ScrollbarOrientation;
        static const ScrollbarOrientation HORIZONTAL = SolidColorScrollbarLayerProperties_ScrollbarOrientation_HORIZONTAL;
        static const ScrollbarOrientation VERTICAL = SolidColorScrollbarLayerProperties_ScrollbarOrientation_VERTICAL;
        static inline bool ScrollbarOrientation_IsValid(int value)
        {
            return SolidColorScrollbarLayerProperties_ScrollbarOrientation_IsValid(value);
        }
        static const ScrollbarOrientation ScrollbarOrientation_MIN = SolidColorScrollbarLayerProperties_ScrollbarOrientation_ScrollbarOrientation_MIN;
        static const ScrollbarOrientation ScrollbarOrientation_MAX = SolidColorScrollbarLayerProperties_ScrollbarOrientation_ScrollbarOrientation_MAX;
        static const int ScrollbarOrientation_ARRAYSIZE = SolidColorScrollbarLayerProperties_ScrollbarOrientation_ScrollbarOrientation_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional int32 scroll_layer_id = 1;
        bool has_scroll_layer_id() const;
        void clear_scroll_layer_id();
        static const int kScrollLayerIdFieldNumber = 1;
        ::google::protobuf::int32 scroll_layer_id() const;
        void set_scroll_layer_id(::google::protobuf::int32 value);

        // optional int32 thumb_thickness = 2;
        bool has_thumb_thickness() const;
        void clear_thumb_thickness();
        static const int kThumbThicknessFieldNumber = 2;
        ::google::protobuf::int32 thumb_thickness() const;
        void set_thumb_thickness(::google::protobuf::int32 value);

        // optional int32 track_start = 3;
        bool has_track_start() const;
        void clear_track_start();
        static const int kTrackStartFieldNumber = 3;
        ::google::protobuf::int32 track_start() const;
        void set_track_start(::google::protobuf::int32 value);

        // optional bool is_left_side_vertical_scrollbar = 4;
        bool has_is_left_side_vertical_scrollbar() const;
        void clear_is_left_side_vertical_scrollbar();
        static const int kIsLeftSideVerticalScrollbarFieldNumber = 4;
        bool is_left_side_vertical_scrollbar() const;
        void set_is_left_side_vertical_scrollbar(bool value);

        // optional .cc.proto.SolidColorScrollbarLayerProperties.ScrollbarOrientation orientation = 5;
        bool has_orientation() const;
        void clear_orientation();
        static const int kOrientationFieldNumber = 5;
        ::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation orientation() const;
        void set_orientation(::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation value);

        // @@protoc_insertion_point(class_scope:cc.proto.SolidColorScrollbarLayerProperties)
    private:
        inline void set_has_scroll_layer_id();
        inline void clear_has_scroll_layer_id();
        inline void set_has_thumb_thickness();
        inline void clear_has_thumb_thickness();
        inline void set_has_track_start();
        inline void clear_has_track_start();
        inline void set_has_is_left_side_vertical_scrollbar();
        inline void clear_has_is_left_side_vertical_scrollbar();
        inline void set_has_orientation();
        inline void clear_has_orientation();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int32 scroll_layer_id_;
        ::google::protobuf::int32 thumb_thickness_;
        ::google::protobuf::int32 track_start_;
        bool is_left_side_vertical_scrollbar_;
        int orientation_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
#endif
        friend void protobuf_AssignDesc_layer_2eproto();
        friend void protobuf_ShutdownFile_layer_2eproto();

        void InitAsDefaultInstance();
        static SolidColorScrollbarLayerProperties* default_instance_;
    };
    // ===================================================================

    // ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
    // LayerNode

    // optional int32 id = 1;
    inline bool LayerNode::has_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void LayerNode::set_has_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void LayerNode::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void LayerNode::clear_id()
    {
        id_ = 0;
        clear_has_id();
    }
    inline ::google::protobuf::int32 LayerNode::id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.id)
        return id_;
    }
    inline void LayerNode::set_id(::google::protobuf::int32 value)
    {
        set_has_id();
        id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerNode.id)
    }

    // optional .cc.proto.LayerNode.Type type = 2;
    inline bool LayerNode::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void LayerNode::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void LayerNode::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void LayerNode::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    inline ::cc::proto::LayerNode_Type LayerNode::type() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.type)
        return static_cast<::cc::proto::LayerNode_Type>(type_);
    }
    inline void LayerNode::set_type(::cc::proto::LayerNode_Type value)
    {
        assert(::cc::proto::LayerNode_Type_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerNode.type)
    }

    // optional int32 parent_id = 3;
    inline bool LayerNode::has_parent_id() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void LayerNode::set_has_parent_id()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void LayerNode::clear_has_parent_id()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void LayerNode::clear_parent_id()
    {
        parent_id_ = 0;
        clear_has_parent_id();
    }
    inline ::google::protobuf::int32 LayerNode::parent_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.parent_id)
        return parent_id_;
    }
    inline void LayerNode::set_parent_id(::google::protobuf::int32 value)
    {
        set_has_parent_id();
        parent_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerNode.parent_id)
    }

    // repeated .cc.proto.LayerNode children = 4;
    inline int LayerNode::children_size() const
    {
        return children_.size();
    }
    inline void LayerNode::clear_children()
    {
        children_.Clear();
    }
    inline const ::cc::proto::LayerNode& LayerNode::children(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerNode.children)
        return children_.Get(index);
    }
    inline ::cc::proto::LayerNode* LayerNode::mutable_children(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerNode.children)
        return children_.Mutable(index);
    }
    inline ::cc::proto::LayerNode* LayerNode::add_children()
    {
        // @@protoc_insertion_point(field_add:cc.proto.LayerNode.children)
        return children_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::cc::proto::LayerNode>*
    LayerNode::mutable_children()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.LayerNode.children)
        return &children_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::cc::proto::LayerNode>&
    LayerNode::children() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.LayerNode.children)
        return children_;
    }

    // optional .cc.proto.LayerNode mask_layer = 5;
    inline bool LayerNode::has_mask_layer() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void LayerNode::set_has_mask_layer()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void LayerNode::clear_has_mask_layer()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void LayerNode::clear_mask_layer()
    {
        if (mask_layer_ != NULL)
            mask_layer_->::cc::proto::LayerNode::Clear();
        clear_has_mask_layer();
    }
    inline const ::cc::proto::LayerNode& LayerNode::mask_layer() const
    {
// @@protoc_insertion_point(field_get:cc.proto.LayerNode.mask_layer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return mask_layer_ != NULL ? *mask_layer_ : *default_instance().mask_layer_;
#else
        return mask_layer_ != NULL ? *mask_layer_ : *default_instance_->mask_layer_;
#endif
    }
    inline ::cc::proto::LayerNode* LayerNode::mutable_mask_layer()
    {
        set_has_mask_layer();
        if (mask_layer_ == NULL) {
            mask_layer_ = new ::cc::proto::LayerNode;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerNode.mask_layer)
        return mask_layer_;
    }
    inline ::cc::proto::LayerNode* LayerNode::release_mask_layer()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerNode.mask_layer)
        clear_has_mask_layer();
        ::cc::proto::LayerNode* temp = mask_layer_;
        mask_layer_ = NULL;
        return temp;
    }
    inline void LayerNode::set_allocated_mask_layer(::cc::proto::LayerNode* mask_layer)
    {
        delete mask_layer_;
        mask_layer_ = mask_layer;
        if (mask_layer) {
            set_has_mask_layer();
        } else {
            clear_has_mask_layer();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerNode.mask_layer)
    }

    // optional .cc.proto.SolidColorScrollbarLayerProperties solid_scrollbar = 6;
    inline bool LayerNode::has_solid_scrollbar() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void LayerNode::set_has_solid_scrollbar()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void LayerNode::clear_has_solid_scrollbar()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void LayerNode::clear_solid_scrollbar()
    {
        if (solid_scrollbar_ != NULL)
            solid_scrollbar_->::cc::proto::SolidColorScrollbarLayerProperties::Clear();
        clear_has_solid_scrollbar();
    }
    inline const ::cc::proto::SolidColorScrollbarLayerProperties& LayerNode::solid_scrollbar() const
    {
// @@protoc_insertion_point(field_get:cc.proto.LayerNode.solid_scrollbar)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return solid_scrollbar_ != NULL ? *solid_scrollbar_ : *default_instance().solid_scrollbar_;
#else
        return solid_scrollbar_ != NULL ? *solid_scrollbar_ : *default_instance_->solid_scrollbar_;
#endif
    }
    inline ::cc::proto::SolidColorScrollbarLayerProperties* LayerNode::mutable_solid_scrollbar()
    {
        set_has_solid_scrollbar();
        if (solid_scrollbar_ == NULL) {
            solid_scrollbar_ = new ::cc::proto::SolidColorScrollbarLayerProperties;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerNode.solid_scrollbar)
        return solid_scrollbar_;
    }
    inline ::cc::proto::SolidColorScrollbarLayerProperties* LayerNode::release_solid_scrollbar()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerNode.solid_scrollbar)
        clear_has_solid_scrollbar();
        ::cc::proto::SolidColorScrollbarLayerProperties* temp = solid_scrollbar_;
        solid_scrollbar_ = NULL;
        return temp;
    }
    inline void LayerNode::set_allocated_solid_scrollbar(::cc::proto::SolidColorScrollbarLayerProperties* solid_scrollbar)
    {
        delete solid_scrollbar_;
        solid_scrollbar_ = solid_scrollbar;
        if (solid_scrollbar) {
            set_has_solid_scrollbar();
        } else {
            clear_has_solid_scrollbar();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerNode.solid_scrollbar)
    }

    // -------------------------------------------------------------------

    // LayerUpdate

    // repeated .cc.proto.LayerProperties layers = 1;
    inline int LayerUpdate::layers_size() const
    {
        return layers_.size();
    }
    inline void LayerUpdate::clear_layers()
    {
        layers_.Clear();
    }
    inline const ::cc::proto::LayerProperties& LayerUpdate::layers(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerUpdate.layers)
        return layers_.Get(index);
    }
    inline ::cc::proto::LayerProperties* LayerUpdate::mutable_layers(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerUpdate.layers)
        return layers_.Mutable(index);
    }
    inline ::cc::proto::LayerProperties* LayerUpdate::add_layers()
    {
        // @@protoc_insertion_point(field_add:cc.proto.LayerUpdate.layers)
        return layers_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::cc::proto::LayerProperties>*
    LayerUpdate::mutable_layers()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.LayerUpdate.layers)
        return &layers_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::cc::proto::LayerProperties>&
    LayerUpdate::layers() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.LayerUpdate.layers)
        return layers_;
    }

    // -------------------------------------------------------------------

    // LayerProperties

    // optional int32 id = 1;
    inline bool LayerProperties::has_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void LayerProperties::set_has_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void LayerProperties::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void LayerProperties::clear_id()
    {
        id_ = 0;
        clear_has_id();
    }
    inline ::google::protobuf::int32 LayerProperties::id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.LayerProperties.id)
        return id_;
    }
    inline void LayerProperties::set_id(::google::protobuf::int32 value)
    {
        set_has_id();
        id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.LayerProperties.id)
    }

    // optional .cc.proto.BaseLayerProperties base = 5;
    inline bool LayerProperties::has_base() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void LayerProperties::set_has_base()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void LayerProperties::clear_has_base()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void LayerProperties::clear_base()
    {
        if (base_ != NULL)
            base_->::cc::proto::BaseLayerProperties::Clear();
        clear_has_base();
    }
    inline const ::cc::proto::BaseLayerProperties& LayerProperties::base() const
    {
// @@protoc_insertion_point(field_get:cc.proto.LayerProperties.base)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return base_ != NULL ? *base_ : *default_instance().base_;
#else
        return base_ != NULL ? *base_ : *default_instance_->base_;
#endif
    }
    inline ::cc::proto::BaseLayerProperties* LayerProperties::mutable_base()
    {
        set_has_base();
        if (base_ == NULL) {
            base_ = new ::cc::proto::BaseLayerProperties;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerProperties.base)
        return base_;
    }
    inline ::cc::proto::BaseLayerProperties* LayerProperties::release_base()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerProperties.base)
        clear_has_base();
        ::cc::proto::BaseLayerProperties* temp = base_;
        base_ = NULL;
        return temp;
    }
    inline void LayerProperties::set_allocated_base(::cc::proto::BaseLayerProperties* base)
    {
        delete base_;
        base_ = base;
        if (base) {
            set_has_base();
        } else {
            clear_has_base();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerProperties.base)
    }

    // optional .cc.proto.PictureLayerProperties picture = 6;
    inline bool LayerProperties::has_picture() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void LayerProperties::set_has_picture()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void LayerProperties::clear_has_picture()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void LayerProperties::clear_picture()
    {
        if (picture_ != NULL)
            picture_->::cc::proto::PictureLayerProperties::Clear();
        clear_has_picture();
    }
    inline const ::cc::proto::PictureLayerProperties& LayerProperties::picture() const
    {
// @@protoc_insertion_point(field_get:cc.proto.LayerProperties.picture)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return picture_ != NULL ? *picture_ : *default_instance().picture_;
#else
        return picture_ != NULL ? *picture_ : *default_instance_->picture_;
#endif
    }
    inline ::cc::proto::PictureLayerProperties* LayerProperties::mutable_picture()
    {
        set_has_picture();
        if (picture_ == NULL) {
            picture_ = new ::cc::proto::PictureLayerProperties;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.LayerProperties.picture)
        return picture_;
    }
    inline ::cc::proto::PictureLayerProperties* LayerProperties::release_picture()
    {
        // @@protoc_insertion_point(field_release:cc.proto.LayerProperties.picture)
        clear_has_picture();
        ::cc::proto::PictureLayerProperties* temp = picture_;
        picture_ = NULL;
        return temp;
    }
    inline void LayerProperties::set_allocated_picture(::cc::proto::PictureLayerProperties* picture)
    {
        delete picture_;
        picture_ = picture;
        if (picture) {
            set_has_picture();
        } else {
            clear_has_picture();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerProperties.picture)
    }

    // -------------------------------------------------------------------

    // BaseLayerProperties

    // optional .cc.proto.Rect update_rect = 46;
    inline bool BaseLayerProperties::has_update_rect() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void BaseLayerProperties::set_has_update_rect()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void BaseLayerProperties::clear_has_update_rect()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void BaseLayerProperties::clear_update_rect()
    {
        if (update_rect_ != NULL)
            update_rect_->::cc::proto::Rect::Clear();
        clear_has_update_rect();
    }
    inline const ::cc::proto::Rect& BaseLayerProperties::update_rect() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.update_rect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return update_rect_ != NULL ? *update_rect_ : *default_instance().update_rect_;
#else
        return update_rect_ != NULL ? *update_rect_ : *default_instance_->update_rect_;
#endif
    }
    inline ::cc::proto::Rect* BaseLayerProperties::mutable_update_rect()
    {
        set_has_update_rect();
        if (update_rect_ == NULL) {
            update_rect_ = new ::cc::proto::Rect;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.update_rect)
        return update_rect_;
    }
    inline ::cc::proto::Rect* BaseLayerProperties::release_update_rect()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.update_rect)
        clear_has_update_rect();
        ::cc::proto::Rect* temp = update_rect_;
        update_rect_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_update_rect(::cc::proto::Rect* update_rect)
    {
        delete update_rect_;
        update_rect_ = update_rect;
        if (update_rect) {
            set_has_update_rect();
        } else {
            clear_has_update_rect();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.update_rect)
    }

    // optional .cc.proto.Size bounds = 3;
    inline bool BaseLayerProperties::has_bounds() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void BaseLayerProperties::set_has_bounds()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void BaseLayerProperties::clear_has_bounds()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void BaseLayerProperties::clear_bounds()
    {
        if (bounds_ != NULL)
            bounds_->::cc::proto::Size::Clear();
        clear_has_bounds();
    }
    inline const ::cc::proto::Size& BaseLayerProperties::bounds() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
        return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
    }
    inline ::cc::proto::Size* BaseLayerProperties::mutable_bounds()
    {
        set_has_bounds();
        if (bounds_ == NULL) {
            bounds_ = new ::cc::proto::Size;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.bounds)
        return bounds_;
    }
    inline ::cc::proto::Size* BaseLayerProperties::release_bounds()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.bounds)
        clear_has_bounds();
        ::cc::proto::Size* temp = bounds_;
        bounds_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_bounds(::cc::proto::Size* bounds)
    {
        delete bounds_;
        bounds_ = bounds;
        if (bounds) {
            set_has_bounds();
        } else {
            clear_has_bounds();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.bounds)
    }

    // optional bool masks_to_bounds = 14;
    inline bool BaseLayerProperties::has_masks_to_bounds() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void BaseLayerProperties::set_has_masks_to_bounds()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void BaseLayerProperties::clear_has_masks_to_bounds()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void BaseLayerProperties::clear_masks_to_bounds()
    {
        masks_to_bounds_ = false;
        clear_has_masks_to_bounds();
    }
    inline bool BaseLayerProperties::masks_to_bounds() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.masks_to_bounds)
        return masks_to_bounds_;
    }
    inline void BaseLayerProperties::set_masks_to_bounds(bool value)
    {
        set_has_masks_to_bounds();
        masks_to_bounds_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.masks_to_bounds)
    }

    // optional float opacity = 22;
    inline bool BaseLayerProperties::has_opacity() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void BaseLayerProperties::set_has_opacity()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void BaseLayerProperties::clear_has_opacity()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void BaseLayerProperties::clear_opacity()
    {
        opacity_ = 0;
        clear_has_opacity();
    }
    inline float BaseLayerProperties::opacity() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.opacity)
        return opacity_;
    }
    inline void BaseLayerProperties::set_opacity(float value)
    {
        set_has_opacity();
        opacity_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.opacity)
    }

    // optional .cc.proto.SkXfermode.Mode blend_mode = 23;
    inline bool BaseLayerProperties::has_blend_mode() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void BaseLayerProperties::set_has_blend_mode()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void BaseLayerProperties::clear_has_blend_mode()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void BaseLayerProperties::clear_blend_mode()
    {
        blend_mode_ = 0;
        clear_has_blend_mode();
    }
    inline ::cc::proto::SkXfermode_Mode BaseLayerProperties::blend_mode() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.blend_mode)
        return static_cast<::cc::proto::SkXfermode_Mode>(blend_mode_);
    }
    inline void BaseLayerProperties::set_blend_mode(::cc::proto::SkXfermode_Mode value)
    {
        assert(::cc::proto::SkXfermode_Mode_IsValid(value));
        set_has_blend_mode();
        blend_mode_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.blend_mode)
    }

    // optional bool is_root_for_isolated_group = 24;
    inline bool BaseLayerProperties::has_is_root_for_isolated_group() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void BaseLayerProperties::set_has_is_root_for_isolated_group()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void BaseLayerProperties::clear_has_is_root_for_isolated_group()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void BaseLayerProperties::clear_is_root_for_isolated_group()
    {
        is_root_for_isolated_group_ = false;
        clear_has_is_root_for_isolated_group();
    }
    inline bool BaseLayerProperties::is_root_for_isolated_group() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.is_root_for_isolated_group)
        return is_root_for_isolated_group_;
    }
    inline void BaseLayerProperties::set_is_root_for_isolated_group(bool value)
    {
        set_has_is_root_for_isolated_group();
        is_root_for_isolated_group_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.is_root_for_isolated_group)
    }

    // optional bool contents_opaque = 21;
    inline bool BaseLayerProperties::has_contents_opaque() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void BaseLayerProperties::set_has_contents_opaque()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void BaseLayerProperties::clear_has_contents_opaque()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void BaseLayerProperties::clear_contents_opaque()
    {
        contents_opaque_ = false;
        clear_has_contents_opaque();
    }
    inline bool BaseLayerProperties::contents_opaque() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.contents_opaque)
        return contents_opaque_;
    }
    inline void BaseLayerProperties::set_contents_opaque(bool value)
    {
        set_has_contents_opaque();
        contents_opaque_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.contents_opaque)
    }

    // optional .cc.proto.PointF position = 25;
    inline bool BaseLayerProperties::has_position() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void BaseLayerProperties::set_has_position()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void BaseLayerProperties::clear_has_position()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void BaseLayerProperties::clear_position()
    {
        if (position_ != NULL)
            position_->::cc::proto::PointF::Clear();
        clear_has_position();
    }
    inline const ::cc::proto::PointF& BaseLayerProperties::position() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.position)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return position_ != NULL ? *position_ : *default_instance().position_;
#else
        return position_ != NULL ? *position_ : *default_instance_->position_;
#endif
    }
    inline ::cc::proto::PointF* BaseLayerProperties::mutable_position()
    {
        set_has_position();
        if (position_ == NULL) {
            position_ = new ::cc::proto::PointF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.position)
        return position_;
    }
    inline ::cc::proto::PointF* BaseLayerProperties::release_position()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.position)
        clear_has_position();
        ::cc::proto::PointF* temp = position_;
        position_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_position(::cc::proto::PointF* position)
    {
        delete position_;
        position_ = position;
        if (position) {
            set_has_position();
        } else {
            clear_has_position();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.position)
    }

    // optional .cc.proto.Transform transform = 33;
    inline bool BaseLayerProperties::has_transform() const
    {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void BaseLayerProperties::set_has_transform()
    {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void BaseLayerProperties::clear_has_transform()
    {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void BaseLayerProperties::clear_transform()
    {
        if (transform_ != NULL)
            transform_->::cc::proto::Transform::Clear();
        clear_has_transform();
    }
    inline const ::cc::proto::Transform& BaseLayerProperties::transform() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.transform)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_ != NULL ? *transform_ : *default_instance().transform_;
#else
        return transform_ != NULL ? *transform_ : *default_instance_->transform_;
#endif
    }
    inline ::cc::proto::Transform* BaseLayerProperties::mutable_transform()
    {
        set_has_transform();
        if (transform_ == NULL) {
            transform_ = new ::cc::proto::Transform;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.transform)
        return transform_;
    }
    inline ::cc::proto::Transform* BaseLayerProperties::release_transform()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.transform)
        clear_has_transform();
        ::cc::proto::Transform* temp = transform_;
        transform_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_transform(::cc::proto::Transform* transform)
    {
        delete transform_;
        transform_ = transform;
        if (transform) {
            set_has_transform();
        } else {
            clear_has_transform();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.transform)
    }

    // optional .cc.proto.Point3F transform_origin = 1;
    inline bool BaseLayerProperties::has_transform_origin() const
    {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void BaseLayerProperties::set_has_transform_origin()
    {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void BaseLayerProperties::clear_has_transform_origin()
    {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void BaseLayerProperties::clear_transform_origin()
    {
        if (transform_origin_ != NULL)
            transform_origin_->::cc::proto::Point3F::Clear();
        clear_has_transform_origin();
    }
    inline const ::cc::proto::Point3F& BaseLayerProperties::transform_origin() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.transform_origin)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_origin_ != NULL ? *transform_origin_ : *default_instance().transform_origin_;
#else
        return transform_origin_ != NULL ? *transform_origin_ : *default_instance_->transform_origin_;
#endif
    }
    inline ::cc::proto::Point3F* BaseLayerProperties::mutable_transform_origin()
    {
        set_has_transform_origin();
        if (transform_origin_ == NULL) {
            transform_origin_ = new ::cc::proto::Point3F;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.transform_origin)
        return transform_origin_;
    }
    inline ::cc::proto::Point3F* BaseLayerProperties::release_transform_origin()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.transform_origin)
        clear_has_transform_origin();
        ::cc::proto::Point3F* temp = transform_origin_;
        transform_origin_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_transform_origin(::cc::proto::Point3F* transform_origin)
    {
        delete transform_origin_;
        transform_origin_ = transform_origin;
        if (transform_origin) {
            set_has_transform_origin();
        } else {
            clear_has_transform_origin();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.transform_origin)
    }

    // optional bool is_drawable = 56;
    inline bool BaseLayerProperties::has_is_drawable() const
    {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void BaseLayerProperties::set_has_is_drawable()
    {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void BaseLayerProperties::clear_has_is_drawable()
    {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void BaseLayerProperties::clear_is_drawable()
    {
        is_drawable_ = false;
        clear_has_is_drawable();
    }
    inline bool BaseLayerProperties::is_drawable() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.is_drawable)
        return is_drawable_;
    }
    inline void BaseLayerProperties::set_is_drawable(bool value)
    {
        set_has_is_drawable();
        is_drawable_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.is_drawable)
    }

    // optional bool double_sided = 8;
    inline bool BaseLayerProperties::has_double_sided() const
    {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void BaseLayerProperties::set_has_double_sided()
    {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void BaseLayerProperties::clear_has_double_sided()
    {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void BaseLayerProperties::clear_double_sided()
    {
        double_sided_ = false;
        clear_has_double_sided();
    }
    inline bool BaseLayerProperties::double_sided() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.double_sided)
        return double_sided_;
    }
    inline void BaseLayerProperties::set_double_sided(bool value)
    {
        set_has_double_sided();
        double_sided_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.double_sided)
    }

    // optional bool should_flatten_transform = 28;
    inline bool BaseLayerProperties::has_should_flatten_transform() const
    {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void BaseLayerProperties::set_has_should_flatten_transform()
    {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void BaseLayerProperties::clear_has_should_flatten_transform()
    {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void BaseLayerProperties::clear_should_flatten_transform()
    {
        should_flatten_transform_ = false;
        clear_has_should_flatten_transform();
    }
    inline bool BaseLayerProperties::should_flatten_transform() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.should_flatten_transform)
        return should_flatten_transform_;
    }
    inline void BaseLayerProperties::set_should_flatten_transform(bool value)
    {
        set_has_should_flatten_transform();
        should_flatten_transform_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.should_flatten_transform)
    }

    // optional int32 sorting_context_id = 35;
    inline bool BaseLayerProperties::has_sorting_context_id() const
    {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void BaseLayerProperties::set_has_sorting_context_id()
    {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void BaseLayerProperties::clear_has_sorting_context_id()
    {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void BaseLayerProperties::clear_sorting_context_id()
    {
        sorting_context_id_ = 0;
        clear_has_sorting_context_id();
    }
    inline ::google::protobuf::int32 BaseLayerProperties::sorting_context_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.sorting_context_id)
        return sorting_context_id_;
    }
    inline void BaseLayerProperties::set_sorting_context_id(::google::protobuf::int32 value)
    {
        set_has_sorting_context_id();
        sorting_context_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.sorting_context_id)
    }

    // optional bool use_parent_backface_visibility = 32;
    inline bool BaseLayerProperties::has_use_parent_backface_visibility() const
    {
        return (_has_bits_[0] & 0x00004000u) != 0;
    }
    inline void BaseLayerProperties::set_has_use_parent_backface_visibility()
    {
        _has_bits_[0] |= 0x00004000u;
    }
    inline void BaseLayerProperties::clear_has_use_parent_backface_visibility()
    {
        _has_bits_[0] &= ~0x00004000u;
    }
    inline void BaseLayerProperties::clear_use_parent_backface_visibility()
    {
        use_parent_backface_visibility_ = false;
        clear_has_use_parent_backface_visibility();
    }
    inline bool BaseLayerProperties::use_parent_backface_visibility() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.use_parent_backface_visibility)
        return use_parent_backface_visibility_;
    }
    inline void BaseLayerProperties::set_use_parent_backface_visibility(bool value)
    {
        set_has_use_parent_backface_visibility();
        use_parent_backface_visibility_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.use_parent_backface_visibility)
    }

    // optional uint32 background_color = 2;
    inline bool BaseLayerProperties::has_background_color() const
    {
        return (_has_bits_[0] & 0x00008000u) != 0;
    }
    inline void BaseLayerProperties::set_has_background_color()
    {
        _has_bits_[0] |= 0x00008000u;
    }
    inline void BaseLayerProperties::clear_has_background_color()
    {
        _has_bits_[0] &= ~0x00008000u;
    }
    inline void BaseLayerProperties::clear_background_color()
    {
        background_color_ = 0u;
        clear_has_background_color();
    }
    inline ::google::protobuf::uint32 BaseLayerProperties::background_color() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.background_color)
        return background_color_;
    }
    inline void BaseLayerProperties::set_background_color(::google::protobuf::uint32 value)
    {
        set_has_background_color();
        background_color_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.background_color)
    }

    // optional .cc.proto.ScrollOffset scroll_offset = 44;
    inline bool BaseLayerProperties::has_scroll_offset() const
    {
        return (_has_bits_[0] & 0x00010000u) != 0;
    }
    inline void BaseLayerProperties::set_has_scroll_offset()
    {
        _has_bits_[0] |= 0x00010000u;
    }
    inline void BaseLayerProperties::clear_has_scroll_offset()
    {
        _has_bits_[0] &= ~0x00010000u;
    }
    inline void BaseLayerProperties::clear_scroll_offset()
    {
        if (scroll_offset_ != NULL)
            scroll_offset_->::cc::proto::ScrollOffset::Clear();
        clear_has_scroll_offset();
    }
    inline const ::cc::proto::ScrollOffset& BaseLayerProperties::scroll_offset() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.scroll_offset)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance().scroll_offset_;
#else
        return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance_->scroll_offset_;
#endif
    }
    inline ::cc::proto::ScrollOffset* BaseLayerProperties::mutable_scroll_offset()
    {
        set_has_scroll_offset();
        if (scroll_offset_ == NULL) {
            scroll_offset_ = new ::cc::proto::ScrollOffset;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.scroll_offset)
        return scroll_offset_;
    }
    inline ::cc::proto::ScrollOffset* BaseLayerProperties::release_scroll_offset()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.scroll_offset)
        clear_has_scroll_offset();
        ::cc::proto::ScrollOffset* temp = scroll_offset_;
        scroll_offset_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset)
    {
        delete scroll_offset_;
        scroll_offset_ = scroll_offset;
        if (scroll_offset) {
            set_has_scroll_offset();
        } else {
            clear_has_scroll_offset();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.scroll_offset)
    }

    // optional int32 scroll_clip_layer_id = 37;
    inline bool BaseLayerProperties::has_scroll_clip_layer_id() const
    {
        return (_has_bits_[0] & 0x00020000u) != 0;
    }
    inline void BaseLayerProperties::set_has_scroll_clip_layer_id()
    {
        _has_bits_[0] |= 0x00020000u;
    }
    inline void BaseLayerProperties::clear_has_scroll_clip_layer_id()
    {
        _has_bits_[0] &= ~0x00020000u;
    }
    inline void BaseLayerProperties::clear_scroll_clip_layer_id()
    {
        scroll_clip_layer_id_ = 0;
        clear_has_scroll_clip_layer_id();
    }
    inline ::google::protobuf::int32 BaseLayerProperties::scroll_clip_layer_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.scroll_clip_layer_id)
        return scroll_clip_layer_id_;
    }
    inline void BaseLayerProperties::set_scroll_clip_layer_id(::google::protobuf::int32 value)
    {
        set_has_scroll_clip_layer_id();
        scroll_clip_layer_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.scroll_clip_layer_id)
    }

    // optional bool user_scrollable_horizontal = 38;
    inline bool BaseLayerProperties::has_user_scrollable_horizontal() const
    {
        return (_has_bits_[0] & 0x00040000u) != 0;
    }
    inline void BaseLayerProperties::set_has_user_scrollable_horizontal()
    {
        _has_bits_[0] |= 0x00040000u;
    }
    inline void BaseLayerProperties::clear_has_user_scrollable_horizontal()
    {
        _has_bits_[0] &= ~0x00040000u;
    }
    inline void BaseLayerProperties::clear_user_scrollable_horizontal()
    {
        user_scrollable_horizontal_ = false;
        clear_has_user_scrollable_horizontal();
    }
    inline bool BaseLayerProperties::user_scrollable_horizontal() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.user_scrollable_horizontal)
        return user_scrollable_horizontal_;
    }
    inline void BaseLayerProperties::set_user_scrollable_horizontal(bool value)
    {
        set_has_user_scrollable_horizontal();
        user_scrollable_horizontal_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.user_scrollable_horizontal)
    }

    // optional bool user_scrollable_vertical = 39;
    inline bool BaseLayerProperties::has_user_scrollable_vertical() const
    {
        return (_has_bits_[0] & 0x00080000u) != 0;
    }
    inline void BaseLayerProperties::set_has_user_scrollable_vertical()
    {
        _has_bits_[0] |= 0x00080000u;
    }
    inline void BaseLayerProperties::clear_has_user_scrollable_vertical()
    {
        _has_bits_[0] &= ~0x00080000u;
    }
    inline void BaseLayerProperties::clear_user_scrollable_vertical()
    {
        user_scrollable_vertical_ = false;
        clear_has_user_scrollable_vertical();
    }
    inline bool BaseLayerProperties::user_scrollable_vertical() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.user_scrollable_vertical)
        return user_scrollable_vertical_;
    }
    inline void BaseLayerProperties::set_user_scrollable_vertical(bool value)
    {
        set_has_user_scrollable_vertical();
        user_scrollable_vertical_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.user_scrollable_vertical)
    }

    // optional uint32 main_thread_scrolling_reasons = 15;
    inline bool BaseLayerProperties::has_main_thread_scrolling_reasons() const
    {
        return (_has_bits_[0] & 0x00100000u) != 0;
    }
    inline void BaseLayerProperties::set_has_main_thread_scrolling_reasons()
    {
        _has_bits_[0] |= 0x00100000u;
    }
    inline void BaseLayerProperties::clear_has_main_thread_scrolling_reasons()
    {
        _has_bits_[0] &= ~0x00100000u;
    }
    inline void BaseLayerProperties::clear_main_thread_scrolling_reasons()
    {
        main_thread_scrolling_reasons_ = 0u;
        clear_has_main_thread_scrolling_reasons();
    }
    inline ::google::protobuf::uint32 BaseLayerProperties::main_thread_scrolling_reasons() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.main_thread_scrolling_reasons)
        return main_thread_scrolling_reasons_;
    }
    inline void BaseLayerProperties::set_main_thread_scrolling_reasons(::google::protobuf::uint32 value)
    {
        set_has_main_thread_scrolling_reasons();
        main_thread_scrolling_reasons_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.main_thread_scrolling_reasons)
    }

    // optional .cc.proto.Region non_fast_scrollable_region = 18;
    inline bool BaseLayerProperties::has_non_fast_scrollable_region() const
    {
        return (_has_bits_[0] & 0x00200000u) != 0;
    }
    inline void BaseLayerProperties::set_has_non_fast_scrollable_region()
    {
        _has_bits_[0] |= 0x00200000u;
    }
    inline void BaseLayerProperties::clear_has_non_fast_scrollable_region()
    {
        _has_bits_[0] &= ~0x00200000u;
    }
    inline void BaseLayerProperties::clear_non_fast_scrollable_region()
    {
        if (non_fast_scrollable_region_ != NULL)
            non_fast_scrollable_region_->::cc::proto::Region::Clear();
        clear_has_non_fast_scrollable_region();
    }
    inline const ::cc::proto::Region& BaseLayerProperties::non_fast_scrollable_region() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return non_fast_scrollable_region_ != NULL ? *non_fast_scrollable_region_ : *default_instance().non_fast_scrollable_region_;
#else
        return non_fast_scrollable_region_ != NULL ? *non_fast_scrollable_region_ : *default_instance_->non_fast_scrollable_region_;
#endif
    }
    inline ::cc::proto::Region* BaseLayerProperties::mutable_non_fast_scrollable_region()
    {
        set_has_non_fast_scrollable_region();
        if (non_fast_scrollable_region_ == NULL) {
            non_fast_scrollable_region_ = new ::cc::proto::Region;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
        return non_fast_scrollable_region_;
    }
    inline ::cc::proto::Region* BaseLayerProperties::release_non_fast_scrollable_region()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
        clear_has_non_fast_scrollable_region();
        ::cc::proto::Region* temp = non_fast_scrollable_region_;
        non_fast_scrollable_region_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_non_fast_scrollable_region(::cc::proto::Region* non_fast_scrollable_region)
    {
        delete non_fast_scrollable_region_;
        non_fast_scrollable_region_ = non_fast_scrollable_region;
        if (non_fast_scrollable_region) {
            set_has_non_fast_scrollable_region();
        } else {
            clear_has_non_fast_scrollable_region();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.non_fast_scrollable_region)
    }

    // optional .cc.proto.Region touch_event_handler_region = 19;
    inline bool BaseLayerProperties::has_touch_event_handler_region() const
    {
        return (_has_bits_[0] & 0x00400000u) != 0;
    }
    inline void BaseLayerProperties::set_has_touch_event_handler_region()
    {
        _has_bits_[0] |= 0x00400000u;
    }
    inline void BaseLayerProperties::clear_has_touch_event_handler_region()
    {
        _has_bits_[0] &= ~0x00400000u;
    }
    inline void BaseLayerProperties::clear_touch_event_handler_region()
    {
        if (touch_event_handler_region_ != NULL)
            touch_event_handler_region_->::cc::proto::Region::Clear();
        clear_has_touch_event_handler_region();
    }
    inline const ::cc::proto::Region& BaseLayerProperties::touch_event_handler_region() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.touch_event_handler_region)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return touch_event_handler_region_ != NULL ? *touch_event_handler_region_ : *default_instance().touch_event_handler_region_;
#else
        return touch_event_handler_region_ != NULL ? *touch_event_handler_region_ : *default_instance_->touch_event_handler_region_;
#endif
    }
    inline ::cc::proto::Region* BaseLayerProperties::mutable_touch_event_handler_region()
    {
        set_has_touch_event_handler_region();
        if (touch_event_handler_region_ == NULL) {
            touch_event_handler_region_ = new ::cc::proto::Region;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.touch_event_handler_region)
        return touch_event_handler_region_;
    }
    inline ::cc::proto::Region* BaseLayerProperties::release_touch_event_handler_region()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.touch_event_handler_region)
        clear_has_touch_event_handler_region();
        ::cc::proto::Region* temp = touch_event_handler_region_;
        touch_event_handler_region_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_touch_event_handler_region(::cc::proto::Region* touch_event_handler_region)
    {
        delete touch_event_handler_region_;
        touch_event_handler_region_ = touch_event_handler_region;
        if (touch_event_handler_region) {
            set_has_touch_event_handler_region();
        } else {
            clear_has_touch_event_handler_region();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.touch_event_handler_region)
    }

    // optional bool is_container_for_fixed_position_layers = 26;
    inline bool BaseLayerProperties::has_is_container_for_fixed_position_layers() const
    {
        return (_has_bits_[0] & 0x00800000u) != 0;
    }
    inline void BaseLayerProperties::set_has_is_container_for_fixed_position_layers()
    {
        _has_bits_[0] |= 0x00800000u;
    }
    inline void BaseLayerProperties::clear_has_is_container_for_fixed_position_layers()
    {
        _has_bits_[0] &= ~0x00800000u;
    }
    inline void BaseLayerProperties::clear_is_container_for_fixed_position_layers()
    {
        is_container_for_fixed_position_layers_ = false;
        clear_has_is_container_for_fixed_position_layers();
    }
    inline bool BaseLayerProperties::is_container_for_fixed_position_layers() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.is_container_for_fixed_position_layers)
        return is_container_for_fixed_position_layers_;
    }
    inline void BaseLayerProperties::set_is_container_for_fixed_position_layers(bool value)
    {
        set_has_is_container_for_fixed_position_layers();
        is_container_for_fixed_position_layers_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.is_container_for_fixed_position_layers)
    }

    // optional .cc.proto.LayerPositionConstraint position_constraint = 27;
    inline bool BaseLayerProperties::has_position_constraint() const
    {
        return (_has_bits_[0] & 0x01000000u) != 0;
    }
    inline void BaseLayerProperties::set_has_position_constraint()
    {
        _has_bits_[0] |= 0x01000000u;
    }
    inline void BaseLayerProperties::clear_has_position_constraint()
    {
        _has_bits_[0] &= ~0x01000000u;
    }
    inline void BaseLayerProperties::clear_position_constraint()
    {
        if (position_constraint_ != NULL)
            position_constraint_->::cc::proto::LayerPositionConstraint::Clear();
        clear_has_position_constraint();
    }
    inline const ::cc::proto::LayerPositionConstraint& BaseLayerProperties::position_constraint() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.position_constraint)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return position_constraint_ != NULL ? *position_constraint_ : *default_instance().position_constraint_;
#else
        return position_constraint_ != NULL ? *position_constraint_ : *default_instance_->position_constraint_;
#endif
    }
    inline ::cc::proto::LayerPositionConstraint* BaseLayerProperties::mutable_position_constraint()
    {
        set_has_position_constraint();
        if (position_constraint_ == NULL) {
            position_constraint_ = new ::cc::proto::LayerPositionConstraint;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.position_constraint)
        return position_constraint_;
    }
    inline ::cc::proto::LayerPositionConstraint* BaseLayerProperties::release_position_constraint()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.position_constraint)
        clear_has_position_constraint();
        ::cc::proto::LayerPositionConstraint* temp = position_constraint_;
        position_constraint_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_position_constraint(::cc::proto::LayerPositionConstraint* position_constraint)
    {
        delete position_constraint_;
        position_constraint_ = position_constraint;
        if (position_constraint) {
            set_has_position_constraint();
        } else {
            clear_has_position_constraint();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.position_constraint)
    }

    // optional .cc.proto.LayerStickyPositionConstraint sticky_position_constraint = 58;
    inline bool BaseLayerProperties::has_sticky_position_constraint() const
    {
        return (_has_bits_[0] & 0x02000000u) != 0;
    }
    inline void BaseLayerProperties::set_has_sticky_position_constraint()
    {
        _has_bits_[0] |= 0x02000000u;
    }
    inline void BaseLayerProperties::clear_has_sticky_position_constraint()
    {
        _has_bits_[0] &= ~0x02000000u;
    }
    inline void BaseLayerProperties::clear_sticky_position_constraint()
    {
        if (sticky_position_constraint_ != NULL)
            sticky_position_constraint_->::cc::proto::LayerStickyPositionConstraint::Clear();
        clear_has_sticky_position_constraint();
    }
    inline const ::cc::proto::LayerStickyPositionConstraint& BaseLayerProperties::sticky_position_constraint() const
    {
// @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.sticky_position_constraint)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return sticky_position_constraint_ != NULL ? *sticky_position_constraint_ : *default_instance().sticky_position_constraint_;
#else
        return sticky_position_constraint_ != NULL ? *sticky_position_constraint_ : *default_instance_->sticky_position_constraint_;
#endif
    }
    inline ::cc::proto::LayerStickyPositionConstraint* BaseLayerProperties::mutable_sticky_position_constraint()
    {
        set_has_sticky_position_constraint();
        if (sticky_position_constraint_ == NULL) {
            sticky_position_constraint_ = new ::cc::proto::LayerStickyPositionConstraint;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.BaseLayerProperties.sticky_position_constraint)
        return sticky_position_constraint_;
    }
    inline ::cc::proto::LayerStickyPositionConstraint* BaseLayerProperties::release_sticky_position_constraint()
    {
        // @@protoc_insertion_point(field_release:cc.proto.BaseLayerProperties.sticky_position_constraint)
        clear_has_sticky_position_constraint();
        ::cc::proto::LayerStickyPositionConstraint* temp = sticky_position_constraint_;
        sticky_position_constraint_ = NULL;
        return temp;
    }
    inline void BaseLayerProperties::set_allocated_sticky_position_constraint(::cc::proto::LayerStickyPositionConstraint* sticky_position_constraint)
    {
        delete sticky_position_constraint_;
        sticky_position_constraint_ = sticky_position_constraint;
        if (sticky_position_constraint) {
            set_has_sticky_position_constraint();
        } else {
            clear_has_sticky_position_constraint();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.BaseLayerProperties.sticky_position_constraint)
    }

    // optional int32 scroll_parent_id = 40;
    inline bool BaseLayerProperties::has_scroll_parent_id() const
    {
        return (_has_bits_[0] & 0x04000000u) != 0;
    }
    inline void BaseLayerProperties::set_has_scroll_parent_id()
    {
        _has_bits_[0] |= 0x04000000u;
    }
    inline void BaseLayerProperties::clear_has_scroll_parent_id()
    {
        _has_bits_[0] &= ~0x04000000u;
    }
    inline void BaseLayerProperties::clear_scroll_parent_id()
    {
        scroll_parent_id_ = 0;
        clear_has_scroll_parent_id();
    }
    inline ::google::protobuf::int32 BaseLayerProperties::scroll_parent_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.scroll_parent_id)
        return scroll_parent_id_;
    }
    inline void BaseLayerProperties::set_scroll_parent_id(::google::protobuf::int32 value)
    {
        set_has_scroll_parent_id();
        scroll_parent_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.scroll_parent_id)
    }

    // optional int32 clip_parent_id = 42;
    inline bool BaseLayerProperties::has_clip_parent_id() const
    {
        return (_has_bits_[0] & 0x08000000u) != 0;
    }
    inline void BaseLayerProperties::set_has_clip_parent_id()
    {
        _has_bits_[0] |= 0x08000000u;
    }
    inline void BaseLayerProperties::clear_has_clip_parent_id()
    {
        _has_bits_[0] &= ~0x08000000u;
    }
    inline void BaseLayerProperties::clear_clip_parent_id()
    {
        clip_parent_id_ = 0;
        clear_has_clip_parent_id();
    }
    inline ::google::protobuf::int32 BaseLayerProperties::clip_parent_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.clip_parent_id)
        return clip_parent_id_;
    }
    inline void BaseLayerProperties::set_clip_parent_id(::google::protobuf::int32 value)
    {
        set_has_clip_parent_id();
        clip_parent_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.clip_parent_id)
    }

    // optional bool has_will_change_transform_hint = 48;
    inline bool BaseLayerProperties::has_has_will_change_transform_hint() const
    {
        return (_has_bits_[0] & 0x10000000u) != 0;
    }
    inline void BaseLayerProperties::set_has_has_will_change_transform_hint()
    {
        _has_bits_[0] |= 0x10000000u;
    }
    inline void BaseLayerProperties::clear_has_has_will_change_transform_hint()
    {
        _has_bits_[0] &= ~0x10000000u;
    }
    inline void BaseLayerProperties::clear_has_will_change_transform_hint()
    {
        has_will_change_transform_hint_ = false;
        clear_has_has_will_change_transform_hint();
    }
    inline bool BaseLayerProperties::has_will_change_transform_hint() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.has_will_change_transform_hint)
        return has_will_change_transform_hint_;
    }
    inline void BaseLayerProperties::set_has_will_change_transform_hint(bool value)
    {
        set_has_has_will_change_transform_hint();
        has_will_change_transform_hint_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.has_will_change_transform_hint)
    }

    // optional bool hide_layer_and_subtree = 10;
    inline bool BaseLayerProperties::has_hide_layer_and_subtree() const
    {
        return (_has_bits_[0] & 0x20000000u) != 0;
    }
    inline void BaseLayerProperties::set_has_hide_layer_and_subtree()
    {
        _has_bits_[0] |= 0x20000000u;
    }
    inline void BaseLayerProperties::clear_has_hide_layer_and_subtree()
    {
        _has_bits_[0] &= ~0x20000000u;
    }
    inline void BaseLayerProperties::clear_hide_layer_and_subtree()
    {
        hide_layer_and_subtree_ = false;
        clear_has_hide_layer_and_subtree();
    }
    inline bool BaseLayerProperties::hide_layer_and_subtree() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.BaseLayerProperties.hide_layer_and_subtree)
        return hide_layer_and_subtree_;
    }
    inline void BaseLayerProperties::set_hide_layer_and_subtree(bool value)
    {
        set_has_hide_layer_and_subtree();
        hide_layer_and_subtree_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.BaseLayerProperties.hide_layer_and_subtree)
    }

    // -------------------------------------------------------------------

    // PictureLayerProperties

    // optional bool nearest_neighbor = 5;
    inline bool PictureLayerProperties::has_nearest_neighbor() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void PictureLayerProperties::set_has_nearest_neighbor()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void PictureLayerProperties::clear_has_nearest_neighbor()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void PictureLayerProperties::clear_nearest_neighbor()
    {
        nearest_neighbor_ = false;
        clear_has_nearest_neighbor();
    }
    inline bool PictureLayerProperties::nearest_neighbor() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.PictureLayerProperties.nearest_neighbor)
        return nearest_neighbor_;
    }
    inline void PictureLayerProperties::set_nearest_neighbor(bool value)
    {
        set_has_nearest_neighbor();
        nearest_neighbor_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.PictureLayerProperties.nearest_neighbor)
    }

    // optional .cc.proto.Rect recorded_viewport = 7;
    inline bool PictureLayerProperties::has_recorded_viewport() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void PictureLayerProperties::set_has_recorded_viewport()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void PictureLayerProperties::clear_has_recorded_viewport()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void PictureLayerProperties::clear_recorded_viewport()
    {
        if (recorded_viewport_ != NULL)
            recorded_viewport_->::cc::proto::Rect::Clear();
        clear_has_recorded_viewport();
    }
    inline const ::cc::proto::Rect& PictureLayerProperties::recorded_viewport() const
    {
// @@protoc_insertion_point(field_get:cc.proto.PictureLayerProperties.recorded_viewport)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return recorded_viewport_ != NULL ? *recorded_viewport_ : *default_instance().recorded_viewport_;
#else
        return recorded_viewport_ != NULL ? *recorded_viewport_ : *default_instance_->recorded_viewport_;
#endif
    }
    inline ::cc::proto::Rect* PictureLayerProperties::mutable_recorded_viewport()
    {
        set_has_recorded_viewport();
        if (recorded_viewport_ == NULL) {
            recorded_viewport_ = new ::cc::proto::Rect;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.PictureLayerProperties.recorded_viewport)
        return recorded_viewport_;
    }
    inline ::cc::proto::Rect* PictureLayerProperties::release_recorded_viewport()
    {
        // @@protoc_insertion_point(field_release:cc.proto.PictureLayerProperties.recorded_viewport)
        clear_has_recorded_viewport();
        ::cc::proto::Rect* temp = recorded_viewport_;
        recorded_viewport_ = NULL;
        return temp;
    }
    inline void PictureLayerProperties::set_allocated_recorded_viewport(::cc::proto::Rect* recorded_viewport)
    {
        delete recorded_viewport_;
        recorded_viewport_ = recorded_viewport;
        if (recorded_viewport) {
            set_has_recorded_viewport();
        } else {
            clear_has_recorded_viewport();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.PictureLayerProperties.recorded_viewport)
    }

    // optional .cc.proto.DisplayItemList display_list = 8;
    inline bool PictureLayerProperties::has_display_list() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void PictureLayerProperties::set_has_display_list()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void PictureLayerProperties::clear_has_display_list()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void PictureLayerProperties::clear_display_list()
    {
        if (display_list_ != NULL)
            display_list_->::cc::proto::DisplayItemList::Clear();
        clear_has_display_list();
    }
    inline const ::cc::proto::DisplayItemList& PictureLayerProperties::display_list() const
    {
// @@protoc_insertion_point(field_get:cc.proto.PictureLayerProperties.display_list)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return display_list_ != NULL ? *display_list_ : *default_instance().display_list_;
#else
        return display_list_ != NULL ? *display_list_ : *default_instance_->display_list_;
#endif
    }
    inline ::cc::proto::DisplayItemList* PictureLayerProperties::mutable_display_list()
    {
        set_has_display_list();
        if (display_list_ == NULL) {
            display_list_ = new ::cc::proto::DisplayItemList;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.PictureLayerProperties.display_list)
        return display_list_;
    }
    inline ::cc::proto::DisplayItemList* PictureLayerProperties::release_display_list()
    {
        // @@protoc_insertion_point(field_release:cc.proto.PictureLayerProperties.display_list)
        clear_has_display_list();
        ::cc::proto::DisplayItemList* temp = display_list_;
        display_list_ = NULL;
        return temp;
    }
    inline void PictureLayerProperties::set_allocated_display_list(::cc::proto::DisplayItemList* display_list)
    {
        delete display_list_;
        display_list_ = display_list;
        if (display_list) {
            set_has_display_list();
        } else {
            clear_has_display_list();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.PictureLayerProperties.display_list)
    }

    // -------------------------------------------------------------------

    // SolidColorScrollbarLayerProperties

    // optional int32 scroll_layer_id = 1;
    inline bool SolidColorScrollbarLayerProperties::has_scroll_layer_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void SolidColorScrollbarLayerProperties::set_has_scroll_layer_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_has_scroll_layer_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_scroll_layer_id()
    {
        scroll_layer_id_ = 0;
        clear_has_scroll_layer_id();
    }
    inline ::google::protobuf::int32 SolidColorScrollbarLayerProperties::scroll_layer_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.scroll_layer_id)
        return scroll_layer_id_;
    }
    inline void SolidColorScrollbarLayerProperties::set_scroll_layer_id(::google::protobuf::int32 value)
    {
        set_has_scroll_layer_id();
        scroll_layer_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.scroll_layer_id)
    }

    // optional int32 thumb_thickness = 2;
    inline bool SolidColorScrollbarLayerProperties::has_thumb_thickness() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void SolidColorScrollbarLayerProperties::set_has_thumb_thickness()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_has_thumb_thickness()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_thumb_thickness()
    {
        thumb_thickness_ = 0;
        clear_has_thumb_thickness();
    }
    inline ::google::protobuf::int32 SolidColorScrollbarLayerProperties::thumb_thickness() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.thumb_thickness)
        return thumb_thickness_;
    }
    inline void SolidColorScrollbarLayerProperties::set_thumb_thickness(::google::protobuf::int32 value)
    {
        set_has_thumb_thickness();
        thumb_thickness_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.thumb_thickness)
    }

    // optional int32 track_start = 3;
    inline bool SolidColorScrollbarLayerProperties::has_track_start() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void SolidColorScrollbarLayerProperties::set_has_track_start()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_has_track_start()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_track_start()
    {
        track_start_ = 0;
        clear_has_track_start();
    }
    inline ::google::protobuf::int32 SolidColorScrollbarLayerProperties::track_start() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.track_start)
        return track_start_;
    }
    inline void SolidColorScrollbarLayerProperties::set_track_start(::google::protobuf::int32 value)
    {
        set_has_track_start();
        track_start_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.track_start)
    }

    // optional bool is_left_side_vertical_scrollbar = 4;
    inline bool SolidColorScrollbarLayerProperties::has_is_left_side_vertical_scrollbar() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void SolidColorScrollbarLayerProperties::set_has_is_left_side_vertical_scrollbar()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_has_is_left_side_vertical_scrollbar()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_is_left_side_vertical_scrollbar()
    {
        is_left_side_vertical_scrollbar_ = false;
        clear_has_is_left_side_vertical_scrollbar();
    }
    inline bool SolidColorScrollbarLayerProperties::is_left_side_vertical_scrollbar() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.is_left_side_vertical_scrollbar)
        return is_left_side_vertical_scrollbar_;
    }
    inline void SolidColorScrollbarLayerProperties::set_is_left_side_vertical_scrollbar(bool value)
    {
        set_has_is_left_side_vertical_scrollbar();
        is_left_side_vertical_scrollbar_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.is_left_side_vertical_scrollbar)
    }

    // optional .cc.proto.SolidColorScrollbarLayerProperties.ScrollbarOrientation orientation = 5;
    inline bool SolidColorScrollbarLayerProperties::has_orientation() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void SolidColorScrollbarLayerProperties::set_has_orientation()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_has_orientation()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void SolidColorScrollbarLayerProperties::clear_orientation()
    {
        orientation_ = 0;
        clear_has_orientation();
    }
    inline ::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation SolidColorScrollbarLayerProperties::orientation() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SolidColorScrollbarLayerProperties.orientation)
        return static_cast<::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation>(orientation_);
    }
    inline void SolidColorScrollbarLayerProperties::set_orientation(::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation value)
    {
        assert(::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation_IsValid(value));
        set_has_orientation();
        orientation_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SolidColorScrollbarLayerProperties.orientation)
    }

#endif // !PROTOBUF_INLINE_NOT_IN_HEADERS
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace cc

#ifndef SWIG
namespace google {
namespace protobuf {

    template <>
    struct is_proto_enum<::cc::proto::LayerNode_Type> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::cc::proto::SolidColorScrollbarLayerProperties_ScrollbarOrientation> : ::google::protobuf::internal::true_type {
    };

} // namespace protobuf
} // namespace google
#endif // SWIG

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_layer_2eproto__INCLUDED
