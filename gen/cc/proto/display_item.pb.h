// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: display_item.proto

#ifndef PROTOBUF_display_5fitem_2eproto__INCLUDED
#define PROTOBUF_display_5fitem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "rect.pb.h"
#include "rectf.pb.h"
#include "skclipop.pb.h"
#include "skrrect.pb.h"
#include "skxfermode.pb.h"
#include "transform.pb.h"
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

    // Internal implementation detail -- do not call these.
    void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
    void protobuf_AssignDesc_display_5fitem_2eproto();
    void protobuf_ShutdownFile_display_5fitem_2eproto();

    class ClipDisplayItem;
    class ClipPathDisplayItem;
    class CompositingDisplayItem;
    class DisplayItem;
    class DisplayItemList;
    class DisplayItemListSettings;
    class DrawingDisplayItem;
    class FilterDisplayItem;
    class FloatClipDisplayItem;
    class SkPictureID;
    class TransformDisplayItem;

    enum DisplayItem_Type {
        DisplayItem_Type_Type_Clip = 1,
        DisplayItem_Type_Type_EndClip = 2,
        DisplayItem_Type_Type_ClipPath = 3,
        DisplayItem_Type_Type_EndClipPath = 4,
        DisplayItem_Type_Type_Compositing = 5,
        DisplayItem_Type_Type_EndCompositing = 6,
        DisplayItem_Type_Type_Drawing = 7,
        DisplayItem_Type_Type_Filter = 8,
        DisplayItem_Type_Type_EndFilter = 9,
        DisplayItem_Type_Type_FloatClip = 10,
        DisplayItem_Type_Type_EndFloatClip = 11,
        DisplayItem_Type_Type_Transform = 12,
        DisplayItem_Type_Type_EndTransform = 13
    };
    CC_PROTO_EXPORT bool DisplayItem_Type_IsValid(int value);
    const DisplayItem_Type DisplayItem_Type_Type_MIN = DisplayItem_Type_Type_Clip;
    const DisplayItem_Type DisplayItem_Type_Type_MAX = DisplayItem_Type_Type_EndTransform;
    const int DisplayItem_Type_Type_ARRAYSIZE = DisplayItem_Type_Type_MAX + 1;

    // ===================================================================

    class CC_PROTO_EXPORT DisplayItemListSettings : public ::google::protobuf::MessageLite {
    public:
        DisplayItemListSettings();
        virtual ~DisplayItemListSettings();

        DisplayItemListSettings(const DisplayItemListSettings& from);

        inline DisplayItemListSettings& operator=(const DisplayItemListSettings& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const DisplayItemListSettings& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const DisplayItemListSettings* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(DisplayItemListSettings* other);

        // implements Message ----------------------------------------------

        inline DisplayItemListSettings* New() const { return New(NULL); }

        DisplayItemListSettings* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const DisplayItemListSettings& from);
        void MergeFrom(const DisplayItemListSettings& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(DisplayItemListSettings* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional bool use_cached_picture = 1;
        bool has_use_cached_picture() const;
        void clear_use_cached_picture();
        static const int kUseCachedPictureFieldNumber = 1;
        bool use_cached_picture() const;
        void set_use_cached_picture(bool value);

        // @@protoc_insertion_point(class_scope:cc.proto.DisplayItemListSettings)
    private:
        inline void set_has_use_cached_picture();
        inline void clear_has_use_cached_picture();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        bool use_cached_picture_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static DisplayItemListSettings* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT DisplayItemList : public ::google::protobuf::MessageLite {
    public:
        DisplayItemList();
        virtual ~DisplayItemList();

        DisplayItemList(const DisplayItemList& from);

        inline DisplayItemList& operator=(const DisplayItemList& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const DisplayItemList& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const DisplayItemList* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(DisplayItemList* other);

        // implements Message ----------------------------------------------

        inline DisplayItemList* New() const { return New(NULL); }

        DisplayItemList* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const DisplayItemList& from);
        void MergeFrom(const DisplayItemList& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(DisplayItemList* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .cc.proto.DisplayItem items = 1;
        int items_size() const;
        void clear_items();
        static const int kItemsFieldNumber = 1;
        const ::cc::proto::DisplayItem& items(int index) const;
        ::cc::proto::DisplayItem* mutable_items(int index);
        ::cc::proto::DisplayItem* add_items();
        ::google::protobuf::RepeatedPtrField<::cc::proto::DisplayItem>*
        mutable_items();
        const ::google::protobuf::RepeatedPtrField<::cc::proto::DisplayItem>&
        items() const;

        // optional .cc.proto.DisplayItemListSettings settings = 3;
        bool has_settings() const;
        void clear_settings();
        static const int kSettingsFieldNumber = 3;
        const ::cc::proto::DisplayItemListSettings& settings() const;
        ::cc::proto::DisplayItemListSettings* mutable_settings();
        ::cc::proto::DisplayItemListSettings* release_settings();
        void set_allocated_settings(::cc::proto::DisplayItemListSettings* settings);

        // repeated .cc.proto.Rect visual_rects = 4;
        int visual_rects_size() const;
        void clear_visual_rects();
        static const int kVisualRectsFieldNumber = 4;
        const ::cc::proto::Rect& visual_rects(int index) const;
        ::cc::proto::Rect* mutable_visual_rects(int index);
        ::cc::proto::Rect* add_visual_rects();
        ::google::protobuf::RepeatedPtrField<::cc::proto::Rect>*
        mutable_visual_rects();
        const ::google::protobuf::RepeatedPtrField<::cc::proto::Rect>&
        visual_rects() const;

        // @@protoc_insertion_point(class_scope:cc.proto.DisplayItemList)
    private:
        inline void set_has_settings();
        inline void clear_has_settings();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::cc::proto::DisplayItem> items_;
        ::cc::proto::DisplayItemListSettings* settings_;
        ::google::protobuf::RepeatedPtrField<::cc::proto::Rect> visual_rects_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static DisplayItemList* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT DisplayItem : public ::google::protobuf::MessageLite {
    public:
        DisplayItem();
        virtual ~DisplayItem();

        DisplayItem(const DisplayItem& from);

        inline DisplayItem& operator=(const DisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const DisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const DisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(DisplayItem* other);

        // implements Message ----------------------------------------------

        inline DisplayItem* New() const { return New(NULL); }

        DisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const DisplayItem& from);
        void MergeFrom(const DisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(DisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef DisplayItem_Type Type;
        static const Type Type_Clip = DisplayItem_Type_Type_Clip;
        static const Type Type_EndClip = DisplayItem_Type_Type_EndClip;
        static const Type Type_ClipPath = DisplayItem_Type_Type_ClipPath;
        static const Type Type_EndClipPath = DisplayItem_Type_Type_EndClipPath;
        static const Type Type_Compositing = DisplayItem_Type_Type_Compositing;
        static const Type Type_EndCompositing = DisplayItem_Type_Type_EndCompositing;
        static const Type Type_Drawing = DisplayItem_Type_Type_Drawing;
        static const Type Type_Filter = DisplayItem_Type_Type_Filter;
        static const Type Type_EndFilter = DisplayItem_Type_Type_EndFilter;
        static const Type Type_FloatClip = DisplayItem_Type_Type_FloatClip;
        static const Type Type_EndFloatClip = DisplayItem_Type_Type_EndFloatClip;
        static const Type Type_Transform = DisplayItem_Type_Type_Transform;
        static const Type Type_EndTransform = DisplayItem_Type_Type_EndTransform;
        static inline bool Type_IsValid(int value)
        {
            return DisplayItem_Type_IsValid(value);
        }
        static const Type Type_MIN = DisplayItem_Type_Type_MIN;
        static const Type Type_MAX = DisplayItem_Type_Type_MAX;
        static const int Type_ARRAYSIZE = DisplayItem_Type_Type_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional .cc.proto.DisplayItem.Type type = 1;
        bool has_type() const;
        void clear_type();
        static const int kTypeFieldNumber = 1;
        ::cc::proto::DisplayItem_Type type() const;
        void set_type(::cc::proto::DisplayItem_Type value);

        // optional .cc.proto.ClipDisplayItem clip_item = 1000;
        bool has_clip_item() const;
        void clear_clip_item();
        static const int kClipItemFieldNumber = 1000;
        const ::cc::proto::ClipDisplayItem& clip_item() const;
        ::cc::proto::ClipDisplayItem* mutable_clip_item();
        ::cc::proto::ClipDisplayItem* release_clip_item();
        void set_allocated_clip_item(::cc::proto::ClipDisplayItem* clip_item);

        // optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
        bool has_clip_path_item() const;
        void clear_clip_path_item();
        static const int kClipPathItemFieldNumber = 1001;
        const ::cc::proto::ClipPathDisplayItem& clip_path_item() const;
        ::cc::proto::ClipPathDisplayItem* mutable_clip_path_item();
        ::cc::proto::ClipPathDisplayItem* release_clip_path_item();
        void set_allocated_clip_path_item(::cc::proto::ClipPathDisplayItem* clip_path_item);

        // optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
        bool has_compositing_item() const;
        void clear_compositing_item();
        static const int kCompositingItemFieldNumber = 1002;
        const ::cc::proto::CompositingDisplayItem& compositing_item() const;
        ::cc::proto::CompositingDisplayItem* mutable_compositing_item();
        ::cc::proto::CompositingDisplayItem* release_compositing_item();
        void set_allocated_compositing_item(::cc::proto::CompositingDisplayItem* compositing_item);

        // optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
        bool has_drawing_item() const;
        void clear_drawing_item();
        static const int kDrawingItemFieldNumber = 1003;
        const ::cc::proto::DrawingDisplayItem& drawing_item() const;
        ::cc::proto::DrawingDisplayItem* mutable_drawing_item();
        ::cc::proto::DrawingDisplayItem* release_drawing_item();
        void set_allocated_drawing_item(::cc::proto::DrawingDisplayItem* drawing_item);

        // optional .cc.proto.FilterDisplayItem filter_item = 1004;
        bool has_filter_item() const;
        void clear_filter_item();
        static const int kFilterItemFieldNumber = 1004;
        const ::cc::proto::FilterDisplayItem& filter_item() const;
        ::cc::proto::FilterDisplayItem* mutable_filter_item();
        ::cc::proto::FilterDisplayItem* release_filter_item();
        void set_allocated_filter_item(::cc::proto::FilterDisplayItem* filter_item);

        // optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
        bool has_float_clip_item() const;
        void clear_float_clip_item();
        static const int kFloatClipItemFieldNumber = 1005;
        const ::cc::proto::FloatClipDisplayItem& float_clip_item() const;
        ::cc::proto::FloatClipDisplayItem* mutable_float_clip_item();
        ::cc::proto::FloatClipDisplayItem* release_float_clip_item();
        void set_allocated_float_clip_item(::cc::proto::FloatClipDisplayItem* float_clip_item);

        // optional .cc.proto.TransformDisplayItem transform_item = 1006;
        bool has_transform_item() const;
        void clear_transform_item();
        static const int kTransformItemFieldNumber = 1006;
        const ::cc::proto::TransformDisplayItem& transform_item() const;
        ::cc::proto::TransformDisplayItem* mutable_transform_item();
        ::cc::proto::TransformDisplayItem* release_transform_item();
        void set_allocated_transform_item(::cc::proto::TransformDisplayItem* transform_item);

        // @@protoc_insertion_point(class_scope:cc.proto.DisplayItem)
    private:
        inline void set_has_type();
        inline void clear_has_type();
        inline void set_has_clip_item();
        inline void clear_has_clip_item();
        inline void set_has_clip_path_item();
        inline void clear_has_clip_path_item();
        inline void set_has_compositing_item();
        inline void clear_has_compositing_item();
        inline void set_has_drawing_item();
        inline void clear_has_drawing_item();
        inline void set_has_filter_item();
        inline void clear_has_filter_item();
        inline void set_has_float_clip_item();
        inline void clear_has_float_clip_item();
        inline void set_has_transform_item();
        inline void clear_has_transform_item();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::ClipDisplayItem* clip_item_;
        ::cc::proto::ClipPathDisplayItem* clip_path_item_;
        ::cc::proto::CompositingDisplayItem* compositing_item_;
        ::cc::proto::DrawingDisplayItem* drawing_item_;
        ::cc::proto::FilterDisplayItem* filter_item_;
        ::cc::proto::FloatClipDisplayItem* float_clip_item_;
        ::cc::proto::TransformDisplayItem* transform_item_;
        int type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static DisplayItem* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT ClipDisplayItem : public ::google::protobuf::MessageLite {
    public:
        ClipDisplayItem();
        virtual ~ClipDisplayItem();

        ClipDisplayItem(const ClipDisplayItem& from);

        inline ClipDisplayItem& operator=(const ClipDisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ClipDisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ClipDisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ClipDisplayItem* other);

        // implements Message ----------------------------------------------

        inline ClipDisplayItem* New() const { return New(NULL); }

        ClipDisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ClipDisplayItem& from);
        void MergeFrom(const ClipDisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ClipDisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .cc.proto.Rect clip_rect = 1;
        bool has_clip_rect() const;
        void clear_clip_rect();
        static const int kClipRectFieldNumber = 1;
        const ::cc::proto::Rect& clip_rect() const;
        ::cc::proto::Rect* mutable_clip_rect();
        ::cc::proto::Rect* release_clip_rect();
        void set_allocated_clip_rect(::cc::proto::Rect* clip_rect);

        // repeated .cc.proto.SkRRect rounded_rects = 2;
        int rounded_rects_size() const;
        void clear_rounded_rects();
        static const int kRoundedRectsFieldNumber = 2;
        const ::cc::proto::SkRRect& rounded_rects(int index) const;
        ::cc::proto::SkRRect* mutable_rounded_rects(int index);
        ::cc::proto::SkRRect* add_rounded_rects();
        ::google::protobuf::RepeatedPtrField<::cc::proto::SkRRect>*
        mutable_rounded_rects();
        const ::google::protobuf::RepeatedPtrField<::cc::proto::SkRRect>&
        rounded_rects() const;

        // optional bool antialias = 3;
        bool has_antialias() const;
        void clear_antialias();
        static const int kAntialiasFieldNumber = 3;
        bool antialias() const;
        void set_antialias(bool value);

        // @@protoc_insertion_point(class_scope:cc.proto.ClipDisplayItem)
    private:
        inline void set_has_clip_rect();
        inline void clear_has_clip_rect();
        inline void set_has_antialias();
        inline void clear_has_antialias();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::Rect* clip_rect_;
        ::google::protobuf::RepeatedPtrField<::cc::proto::SkRRect> rounded_rects_;
        bool antialias_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static ClipDisplayItem* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT ClipPathDisplayItem : public ::google::protobuf::MessageLite {
    public:
        ClipPathDisplayItem();
        virtual ~ClipPathDisplayItem();

        ClipPathDisplayItem(const ClipPathDisplayItem& from);

        inline ClipPathDisplayItem& operator=(const ClipPathDisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ClipPathDisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ClipPathDisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ClipPathDisplayItem* other);

        // implements Message ----------------------------------------------

        inline ClipPathDisplayItem* New() const { return New(NULL); }

        ClipPathDisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ClipPathDisplayItem& from);
        void MergeFrom(const ClipPathDisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ClipPathDisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .cc.proto.SkClipOp.Op clip_op = 1;
        bool has_clip_op() const;
        void clear_clip_op();
        static const int kClipOpFieldNumber = 1;
        ::cc::proto::SkClipOp_Op clip_op() const;
        void set_clip_op(::cc::proto::SkClipOp_Op value);

        // optional bool antialias = 2;
        bool has_antialias() const;
        void clear_antialias();
        static const int kAntialiasFieldNumber = 2;
        bool antialias() const;
        void set_antialias(bool value);

        // optional bytes clip_path = 3;
        bool has_clip_path() const;
        void clear_clip_path();
        static const int kClipPathFieldNumber = 3;
        const ::std::string& clip_path() const;
        void set_clip_path(const ::std::string& value);
        void set_clip_path(const char* value);
        void set_clip_path(const void* value, size_t size);
        ::std::string* mutable_clip_path();
        ::std::string* release_clip_path();
        void set_allocated_clip_path(::std::string* clip_path);

        // @@protoc_insertion_point(class_scope:cc.proto.ClipPathDisplayItem)
    private:
        inline void set_has_clip_op();
        inline void clear_has_clip_op();
        inline void set_has_antialias();
        inline void clear_has_antialias();
        inline void set_has_clip_path();
        inline void clear_has_clip_path();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        int clip_op_;
        bool antialias_;
        ::google::protobuf::internal::ArenaStringPtr clip_path_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static ClipPathDisplayItem* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT CompositingDisplayItem : public ::google::protobuf::MessageLite {
    public:
        CompositingDisplayItem();
        virtual ~CompositingDisplayItem();

        CompositingDisplayItem(const CompositingDisplayItem& from);

        inline CompositingDisplayItem& operator=(const CompositingDisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const CompositingDisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const CompositingDisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(CompositingDisplayItem* other);

        // implements Message ----------------------------------------------

        inline CompositingDisplayItem* New() const { return New(NULL); }

        CompositingDisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const CompositingDisplayItem& from);
        void MergeFrom(const CompositingDisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(CompositingDisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional uint32 alpha = 1;
        bool has_alpha() const;
        void clear_alpha();
        static const int kAlphaFieldNumber = 1;
        ::google::protobuf::uint32 alpha() const;
        void set_alpha(::google::protobuf::uint32 value);

        // optional .cc.proto.SkXfermode.Mode mode = 2;
        bool has_mode() const;
        void clear_mode();
        static const int kModeFieldNumber = 2;
        ::cc::proto::SkXfermode_Mode mode() const;
        void set_mode(::cc::proto::SkXfermode_Mode value);

        // optional .cc.proto.RectF bounds = 3;
        bool has_bounds() const;
        void clear_bounds();
        static const int kBoundsFieldNumber = 3;
        const ::cc::proto::RectF& bounds() const;
        ::cc::proto::RectF* mutable_bounds();
        ::cc::proto::RectF* release_bounds();
        void set_allocated_bounds(::cc::proto::RectF* bounds);

        // optional bytes color_filter = 4;
        bool has_color_filter() const;
        void clear_color_filter();
        static const int kColorFilterFieldNumber = 4;
        const ::std::string& color_filter() const;
        void set_color_filter(const ::std::string& value);
        void set_color_filter(const char* value);
        void set_color_filter(const void* value, size_t size);
        ::std::string* mutable_color_filter();
        ::std::string* release_color_filter();
        void set_allocated_color_filter(::std::string* color_filter);

        // optional bool lcd_text_requires_opaque_layer = 5;
        bool has_lcd_text_requires_opaque_layer() const;
        void clear_lcd_text_requires_opaque_layer();
        static const int kLcdTextRequiresOpaqueLayerFieldNumber = 5;
        bool lcd_text_requires_opaque_layer() const;
        void set_lcd_text_requires_opaque_layer(bool value);

        // @@protoc_insertion_point(class_scope:cc.proto.CompositingDisplayItem)
    private:
        inline void set_has_alpha();
        inline void clear_has_alpha();
        inline void set_has_mode();
        inline void clear_has_mode();
        inline void set_has_bounds();
        inline void clear_has_bounds();
        inline void set_has_color_filter();
        inline void clear_has_color_filter();
        inline void set_has_lcd_text_requires_opaque_layer();
        inline void clear_has_lcd_text_requires_opaque_layer();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint32 alpha_;
        int mode_;
        ::cc::proto::RectF* bounds_;
        ::google::protobuf::internal::ArenaStringPtr color_filter_;
        bool lcd_text_requires_opaque_layer_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static CompositingDisplayItem* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT SkPictureID : public ::google::protobuf::MessageLite {
    public:
        SkPictureID();
        virtual ~SkPictureID();

        SkPictureID(const SkPictureID& from);

        inline SkPictureID& operator=(const SkPictureID& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const SkPictureID& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const SkPictureID* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(SkPictureID* other);

        // implements Message ----------------------------------------------

        inline SkPictureID* New() const { return New(NULL); }

        SkPictureID* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const SkPictureID& from);
        void MergeFrom(const SkPictureID& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(SkPictureID* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional uint32 unique_id = 1;
        bool has_unique_id() const;
        void clear_unique_id();
        static const int kUniqueIdFieldNumber = 1;
        ::google::protobuf::uint32 unique_id() const;
        void set_unique_id(::google::protobuf::uint32 value);

        // @@protoc_insertion_point(class_scope:cc.proto.SkPictureID)
    private:
        inline void set_has_unique_id();
        inline void clear_has_unique_id();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint32 unique_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static SkPictureID* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT DrawingDisplayItem : public ::google::protobuf::MessageLite {
    public:
        DrawingDisplayItem();
        virtual ~DrawingDisplayItem();

        DrawingDisplayItem(const DrawingDisplayItem& from);

        inline DrawingDisplayItem& operator=(const DrawingDisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const DrawingDisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const DrawingDisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(DrawingDisplayItem* other);

        // implements Message ----------------------------------------------

        inline DrawingDisplayItem* New() const { return New(NULL); }

        DrawingDisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const DrawingDisplayItem& from);
        void MergeFrom(const DrawingDisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(DrawingDisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .cc.proto.SkPictureID id = 1;
        bool has_id() const;
        void clear_id();
        static const int kIdFieldNumber = 1;
        const ::cc::proto::SkPictureID& id() const;
        ::cc::proto::SkPictureID* mutable_id();
        ::cc::proto::SkPictureID* release_id();
        void set_allocated_id(::cc::proto::SkPictureID* id);

        // @@protoc_insertion_point(class_scope:cc.proto.DrawingDisplayItem)
    private:
        inline void set_has_id();
        inline void clear_has_id();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::SkPictureID* id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static DrawingDisplayItem* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT FilterDisplayItem : public ::google::protobuf::MessageLite {
    public:
        FilterDisplayItem();
        virtual ~FilterDisplayItem();

        FilterDisplayItem(const FilterDisplayItem& from);

        inline FilterDisplayItem& operator=(const FilterDisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const FilterDisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const FilterDisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(FilterDisplayItem* other);

        // implements Message ----------------------------------------------

        inline FilterDisplayItem* New() const { return New(NULL); }

        FilterDisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const FilterDisplayItem& from);
        void MergeFrom(const FilterDisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(FilterDisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .cc.proto.RectF bounds = 1;
        bool has_bounds() const;
        void clear_bounds();
        static const int kBoundsFieldNumber = 1;
        const ::cc::proto::RectF& bounds() const;
        ::cc::proto::RectF* mutable_bounds();
        ::cc::proto::RectF* release_bounds();
        void set_allocated_bounds(::cc::proto::RectF* bounds);

        // @@protoc_insertion_point(class_scope:cc.proto.FilterDisplayItem)
    private:
        inline void set_has_bounds();
        inline void clear_has_bounds();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::RectF* bounds_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static FilterDisplayItem* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT FloatClipDisplayItem : public ::google::protobuf::MessageLite {
    public:
        FloatClipDisplayItem();
        virtual ~FloatClipDisplayItem();

        FloatClipDisplayItem(const FloatClipDisplayItem& from);

        inline FloatClipDisplayItem& operator=(const FloatClipDisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const FloatClipDisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const FloatClipDisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(FloatClipDisplayItem* other);

        // implements Message ----------------------------------------------

        inline FloatClipDisplayItem* New() const { return New(NULL); }

        FloatClipDisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const FloatClipDisplayItem& from);
        void MergeFrom(const FloatClipDisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(FloatClipDisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .cc.proto.RectF clip_rect = 1;
        bool has_clip_rect() const;
        void clear_clip_rect();
        static const int kClipRectFieldNumber = 1;
        const ::cc::proto::RectF& clip_rect() const;
        ::cc::proto::RectF* mutable_clip_rect();
        ::cc::proto::RectF* release_clip_rect();
        void set_allocated_clip_rect(::cc::proto::RectF* clip_rect);

        // @@protoc_insertion_point(class_scope:cc.proto.FloatClipDisplayItem)
    private:
        inline void set_has_clip_rect();
        inline void clear_has_clip_rect();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::RectF* clip_rect_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static FloatClipDisplayItem* default_instance_;
    };
    // -------------------------------------------------------------------

    class CC_PROTO_EXPORT TransformDisplayItem : public ::google::protobuf::MessageLite {
    public:
        TransformDisplayItem();
        virtual ~TransformDisplayItem();

        TransformDisplayItem(const TransformDisplayItem& from);

        inline TransformDisplayItem& operator=(const TransformDisplayItem& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const TransformDisplayItem& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const TransformDisplayItem* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(TransformDisplayItem* other);

        // implements Message ----------------------------------------------

        inline TransformDisplayItem* New() const { return New(NULL); }

        TransformDisplayItem* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const TransformDisplayItem& from);
        void MergeFrom(const TransformDisplayItem& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(TransformDisplayItem* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .cc.proto.Transform transform = 1;
        bool has_transform() const;
        void clear_transform();
        static const int kTransformFieldNumber = 1;
        const ::cc::proto::Transform& transform() const;
        ::cc::proto::Transform* mutable_transform();
        ::cc::proto::Transform* release_transform();
        void set_allocated_transform(::cc::proto::Transform* transform);

        // @@protoc_insertion_point(class_scope:cc.proto.TransformDisplayItem)
    private:
        inline void set_has_transform();
        inline void clear_has_transform();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::cc::proto::Transform* transform_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
#else
        friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
#endif
        friend void protobuf_AssignDesc_display_5fitem_2eproto();
        friend void protobuf_ShutdownFile_display_5fitem_2eproto();

        void InitAsDefaultInstance();
        static TransformDisplayItem* default_instance_;
    };
    // ===================================================================

    // ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
    // DisplayItemListSettings

    // optional bool use_cached_picture = 1;
    inline bool DisplayItemListSettings::has_use_cached_picture() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void DisplayItemListSettings::set_has_use_cached_picture()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void DisplayItemListSettings::clear_has_use_cached_picture()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void DisplayItemListSettings::clear_use_cached_picture()
    {
        use_cached_picture_ = false;
        clear_has_use_cached_picture();
    }
    inline bool DisplayItemListSettings::use_cached_picture() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItemListSettings.use_cached_picture)
        return use_cached_picture_;
    }
    inline void DisplayItemListSettings::set_use_cached_picture(bool value)
    {
        set_has_use_cached_picture();
        use_cached_picture_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.DisplayItemListSettings.use_cached_picture)
    }

    // -------------------------------------------------------------------

    // DisplayItemList

    // repeated .cc.proto.DisplayItem items = 1;
    inline int DisplayItemList::items_size() const
    {
        return items_.size();
    }
    inline void DisplayItemList::clear_items()
    {
        items_.Clear();
    }
    inline const ::cc::proto::DisplayItem& DisplayItemList::items(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItemList.items)
        return items_.Get(index);
    }
    inline ::cc::proto::DisplayItem* DisplayItemList::mutable_items(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItemList.items)
        return items_.Mutable(index);
    }
    inline ::cc::proto::DisplayItem* DisplayItemList::add_items()
    {
        // @@protoc_insertion_point(field_add:cc.proto.DisplayItemList.items)
        return items_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::cc::proto::DisplayItem>*
    DisplayItemList::mutable_items()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.DisplayItemList.items)
        return &items_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::cc::proto::DisplayItem>&
    DisplayItemList::items() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.DisplayItemList.items)
        return items_;
    }

    // optional .cc.proto.DisplayItemListSettings settings = 3;
    inline bool DisplayItemList::has_settings() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void DisplayItemList::set_has_settings()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void DisplayItemList::clear_has_settings()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void DisplayItemList::clear_settings()
    {
        if (settings_ != NULL)
            settings_->::cc::proto::DisplayItemListSettings::Clear();
        clear_has_settings();
    }
    inline const ::cc::proto::DisplayItemListSettings& DisplayItemList::settings() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItemList.settings)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return settings_ != NULL ? *settings_ : *default_instance().settings_;
#else
        return settings_ != NULL ? *settings_ : *default_instance_->settings_;
#endif
    }
    inline ::cc::proto::DisplayItemListSettings* DisplayItemList::mutable_settings()
    {
        set_has_settings();
        if (settings_ == NULL) {
            settings_ = new ::cc::proto::DisplayItemListSettings;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItemList.settings)
        return settings_;
    }
    inline ::cc::proto::DisplayItemListSettings* DisplayItemList::release_settings()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItemList.settings)
        clear_has_settings();
        ::cc::proto::DisplayItemListSettings* temp = settings_;
        settings_ = NULL;
        return temp;
    }
    inline void DisplayItemList::set_allocated_settings(::cc::proto::DisplayItemListSettings* settings)
    {
        delete settings_;
        settings_ = settings;
        if (settings) {
            set_has_settings();
        } else {
            clear_has_settings();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItemList.settings)
    }

    // repeated .cc.proto.Rect visual_rects = 4;
    inline int DisplayItemList::visual_rects_size() const
    {
        return visual_rects_.size();
    }
    inline void DisplayItemList::clear_visual_rects()
    {
        visual_rects_.Clear();
    }
    inline const ::cc::proto::Rect& DisplayItemList::visual_rects(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_.Get(index);
    }
    inline ::cc::proto::Rect* DisplayItemList::mutable_visual_rects(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_.Mutable(index);
    }
    inline ::cc::proto::Rect* DisplayItemList::add_visual_rects()
    {
        // @@protoc_insertion_point(field_add:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::cc::proto::Rect>*
    DisplayItemList::mutable_visual_rects()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.DisplayItemList.visual_rects)
        return &visual_rects_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::cc::proto::Rect>&
    DisplayItemList::visual_rects() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.DisplayItemList.visual_rects)
        return visual_rects_;
    }

    // -------------------------------------------------------------------

    // DisplayItem

    // optional .cc.proto.DisplayItem.Type type = 1;
    inline bool DisplayItem::has_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void DisplayItem::set_has_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void DisplayItem::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void DisplayItem::clear_type()
    {
        type_ = 1;
        clear_has_type();
    }
    inline ::cc::proto::DisplayItem_Type DisplayItem::type() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.DisplayItem.type)
        return static_cast<::cc::proto::DisplayItem_Type>(type_);
    }
    inline void DisplayItem::set_type(::cc::proto::DisplayItem_Type value)
    {
        assert(::cc::proto::DisplayItem_Type_IsValid(value));
        set_has_type();
        type_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.DisplayItem.type)
    }

    // optional .cc.proto.ClipDisplayItem clip_item = 1000;
    inline bool DisplayItem::has_clip_item() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void DisplayItem::set_has_clip_item()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void DisplayItem::clear_has_clip_item()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void DisplayItem::clear_clip_item()
    {
        if (clip_item_ != NULL)
            clip_item_->::cc::proto::ClipDisplayItem::Clear();
        clear_has_clip_item();
    }
    inline const ::cc::proto::ClipDisplayItem& DisplayItem::clip_item() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItem.clip_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_item_ != NULL ? *clip_item_ : *default_instance().clip_item_;
#else
        return clip_item_ != NULL ? *clip_item_ : *default_instance_->clip_item_;
#endif
    }
    inline ::cc::proto::ClipDisplayItem* DisplayItem::mutable_clip_item()
    {
        set_has_clip_item();
        if (clip_item_ == NULL) {
            clip_item_ = new ::cc::proto::ClipDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.clip_item)
        return clip_item_;
    }
    inline ::cc::proto::ClipDisplayItem* DisplayItem::release_clip_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.clip_item)
        clear_has_clip_item();
        ::cc::proto::ClipDisplayItem* temp = clip_item_;
        clip_item_ = NULL;
        return temp;
    }
    inline void DisplayItem::set_allocated_clip_item(::cc::proto::ClipDisplayItem* clip_item)
    {
        delete clip_item_;
        clip_item_ = clip_item;
        if (clip_item) {
            set_has_clip_item();
        } else {
            clear_has_clip_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.clip_item)
    }

    // optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
    inline bool DisplayItem::has_clip_path_item() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void DisplayItem::set_has_clip_path_item()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void DisplayItem::clear_has_clip_path_item()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void DisplayItem::clear_clip_path_item()
    {
        if (clip_path_item_ != NULL)
            clip_path_item_->::cc::proto::ClipPathDisplayItem::Clear();
        clear_has_clip_path_item();
    }
    inline const ::cc::proto::ClipPathDisplayItem& DisplayItem::clip_path_item() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItem.clip_path_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_path_item_ != NULL ? *clip_path_item_ : *default_instance().clip_path_item_;
#else
        return clip_path_item_ != NULL ? *clip_path_item_ : *default_instance_->clip_path_item_;
#endif
    }
    inline ::cc::proto::ClipPathDisplayItem* DisplayItem::mutable_clip_path_item()
    {
        set_has_clip_path_item();
        if (clip_path_item_ == NULL) {
            clip_path_item_ = new ::cc::proto::ClipPathDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.clip_path_item)
        return clip_path_item_;
    }
    inline ::cc::proto::ClipPathDisplayItem* DisplayItem::release_clip_path_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.clip_path_item)
        clear_has_clip_path_item();
        ::cc::proto::ClipPathDisplayItem* temp = clip_path_item_;
        clip_path_item_ = NULL;
        return temp;
    }
    inline void DisplayItem::set_allocated_clip_path_item(::cc::proto::ClipPathDisplayItem* clip_path_item)
    {
        delete clip_path_item_;
        clip_path_item_ = clip_path_item;
        if (clip_path_item) {
            set_has_clip_path_item();
        } else {
            clear_has_clip_path_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.clip_path_item)
    }

    // optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
    inline bool DisplayItem::has_compositing_item() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void DisplayItem::set_has_compositing_item()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void DisplayItem::clear_has_compositing_item()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void DisplayItem::clear_compositing_item()
    {
        if (compositing_item_ != NULL)
            compositing_item_->::cc::proto::CompositingDisplayItem::Clear();
        clear_has_compositing_item();
    }
    inline const ::cc::proto::CompositingDisplayItem& DisplayItem::compositing_item() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItem.compositing_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return compositing_item_ != NULL ? *compositing_item_ : *default_instance().compositing_item_;
#else
        return compositing_item_ != NULL ? *compositing_item_ : *default_instance_->compositing_item_;
#endif
    }
    inline ::cc::proto::CompositingDisplayItem* DisplayItem::mutable_compositing_item()
    {
        set_has_compositing_item();
        if (compositing_item_ == NULL) {
            compositing_item_ = new ::cc::proto::CompositingDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.compositing_item)
        return compositing_item_;
    }
    inline ::cc::proto::CompositingDisplayItem* DisplayItem::release_compositing_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.compositing_item)
        clear_has_compositing_item();
        ::cc::proto::CompositingDisplayItem* temp = compositing_item_;
        compositing_item_ = NULL;
        return temp;
    }
    inline void DisplayItem::set_allocated_compositing_item(::cc::proto::CompositingDisplayItem* compositing_item)
    {
        delete compositing_item_;
        compositing_item_ = compositing_item;
        if (compositing_item) {
            set_has_compositing_item();
        } else {
            clear_has_compositing_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.compositing_item)
    }

    // optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
    inline bool DisplayItem::has_drawing_item() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void DisplayItem::set_has_drawing_item()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void DisplayItem::clear_has_drawing_item()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void DisplayItem::clear_drawing_item()
    {
        if (drawing_item_ != NULL)
            drawing_item_->::cc::proto::DrawingDisplayItem::Clear();
        clear_has_drawing_item();
    }
    inline const ::cc::proto::DrawingDisplayItem& DisplayItem::drawing_item() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItem.drawing_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return drawing_item_ != NULL ? *drawing_item_ : *default_instance().drawing_item_;
#else
        return drawing_item_ != NULL ? *drawing_item_ : *default_instance_->drawing_item_;
#endif
    }
    inline ::cc::proto::DrawingDisplayItem* DisplayItem::mutable_drawing_item()
    {
        set_has_drawing_item();
        if (drawing_item_ == NULL) {
            drawing_item_ = new ::cc::proto::DrawingDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.drawing_item)
        return drawing_item_;
    }
    inline ::cc::proto::DrawingDisplayItem* DisplayItem::release_drawing_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.drawing_item)
        clear_has_drawing_item();
        ::cc::proto::DrawingDisplayItem* temp = drawing_item_;
        drawing_item_ = NULL;
        return temp;
    }
    inline void DisplayItem::set_allocated_drawing_item(::cc::proto::DrawingDisplayItem* drawing_item)
    {
        delete drawing_item_;
        drawing_item_ = drawing_item;
        if (drawing_item) {
            set_has_drawing_item();
        } else {
            clear_has_drawing_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.drawing_item)
    }

    // optional .cc.proto.FilterDisplayItem filter_item = 1004;
    inline bool DisplayItem::has_filter_item() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void DisplayItem::set_has_filter_item()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void DisplayItem::clear_has_filter_item()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void DisplayItem::clear_filter_item()
    {
        if (filter_item_ != NULL)
            filter_item_->::cc::proto::FilterDisplayItem::Clear();
        clear_has_filter_item();
    }
    inline const ::cc::proto::FilterDisplayItem& DisplayItem::filter_item() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItem.filter_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return filter_item_ != NULL ? *filter_item_ : *default_instance().filter_item_;
#else
        return filter_item_ != NULL ? *filter_item_ : *default_instance_->filter_item_;
#endif
    }
    inline ::cc::proto::FilterDisplayItem* DisplayItem::mutable_filter_item()
    {
        set_has_filter_item();
        if (filter_item_ == NULL) {
            filter_item_ = new ::cc::proto::FilterDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.filter_item)
        return filter_item_;
    }
    inline ::cc::proto::FilterDisplayItem* DisplayItem::release_filter_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.filter_item)
        clear_has_filter_item();
        ::cc::proto::FilterDisplayItem* temp = filter_item_;
        filter_item_ = NULL;
        return temp;
    }
    inline void DisplayItem::set_allocated_filter_item(::cc::proto::FilterDisplayItem* filter_item)
    {
        delete filter_item_;
        filter_item_ = filter_item;
        if (filter_item) {
            set_has_filter_item();
        } else {
            clear_has_filter_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.filter_item)
    }

    // optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
    inline bool DisplayItem::has_float_clip_item() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void DisplayItem::set_has_float_clip_item()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void DisplayItem::clear_has_float_clip_item()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void DisplayItem::clear_float_clip_item()
    {
        if (float_clip_item_ != NULL)
            float_clip_item_->::cc::proto::FloatClipDisplayItem::Clear();
        clear_has_float_clip_item();
    }
    inline const ::cc::proto::FloatClipDisplayItem& DisplayItem::float_clip_item() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItem.float_clip_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return float_clip_item_ != NULL ? *float_clip_item_ : *default_instance().float_clip_item_;
#else
        return float_clip_item_ != NULL ? *float_clip_item_ : *default_instance_->float_clip_item_;
#endif
    }
    inline ::cc::proto::FloatClipDisplayItem* DisplayItem::mutable_float_clip_item()
    {
        set_has_float_clip_item();
        if (float_clip_item_ == NULL) {
            float_clip_item_ = new ::cc::proto::FloatClipDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.float_clip_item)
        return float_clip_item_;
    }
    inline ::cc::proto::FloatClipDisplayItem* DisplayItem::release_float_clip_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.float_clip_item)
        clear_has_float_clip_item();
        ::cc::proto::FloatClipDisplayItem* temp = float_clip_item_;
        float_clip_item_ = NULL;
        return temp;
    }
    inline void DisplayItem::set_allocated_float_clip_item(::cc::proto::FloatClipDisplayItem* float_clip_item)
    {
        delete float_clip_item_;
        float_clip_item_ = float_clip_item;
        if (float_clip_item) {
            set_has_float_clip_item();
        } else {
            clear_has_float_clip_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.float_clip_item)
    }

    // optional .cc.proto.TransformDisplayItem transform_item = 1006;
    inline bool DisplayItem::has_transform_item() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void DisplayItem::set_has_transform_item()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void DisplayItem::clear_has_transform_item()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void DisplayItem::clear_transform_item()
    {
        if (transform_item_ != NULL)
            transform_item_->::cc::proto::TransformDisplayItem::Clear();
        clear_has_transform_item();
    }
    inline const ::cc::proto::TransformDisplayItem& DisplayItem::transform_item() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DisplayItem.transform_item)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_item_ != NULL ? *transform_item_ : *default_instance().transform_item_;
#else
        return transform_item_ != NULL ? *transform_item_ : *default_instance_->transform_item_;
#endif
    }
    inline ::cc::proto::TransformDisplayItem* DisplayItem::mutable_transform_item()
    {
        set_has_transform_item();
        if (transform_item_ == NULL) {
            transform_item_ = new ::cc::proto::TransformDisplayItem;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DisplayItem.transform_item)
        return transform_item_;
    }
    inline ::cc::proto::TransformDisplayItem* DisplayItem::release_transform_item()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DisplayItem.transform_item)
        clear_has_transform_item();
        ::cc::proto::TransformDisplayItem* temp = transform_item_;
        transform_item_ = NULL;
        return temp;
    }
    inline void DisplayItem::set_allocated_transform_item(::cc::proto::TransformDisplayItem* transform_item)
    {
        delete transform_item_;
        transform_item_ = transform_item;
        if (transform_item) {
            set_has_transform_item();
        } else {
            clear_has_transform_item();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DisplayItem.transform_item)
    }

    // -------------------------------------------------------------------

    // ClipDisplayItem

    // optional .cc.proto.Rect clip_rect = 1;
    inline bool ClipDisplayItem::has_clip_rect() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ClipDisplayItem::set_has_clip_rect()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ClipDisplayItem::clear_has_clip_rect()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ClipDisplayItem::clear_clip_rect()
    {
        if (clip_rect_ != NULL)
            clip_rect_->::cc::proto::Rect::Clear();
        clear_has_clip_rect();
    }
    inline const ::cc::proto::Rect& ClipDisplayItem::clip_rect() const
    {
// @@protoc_insertion_point(field_get:cc.proto.ClipDisplayItem.clip_rect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance().clip_rect_;
#else
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance_->clip_rect_;
#endif
    }
    inline ::cc::proto::Rect* ClipDisplayItem::mutable_clip_rect()
    {
        set_has_clip_rect();
        if (clip_rect_ == NULL) {
            clip_rect_ = new ::cc::proto::Rect;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.ClipDisplayItem.clip_rect)
        return clip_rect_;
    }
    inline ::cc::proto::Rect* ClipDisplayItem::release_clip_rect()
    {
        // @@protoc_insertion_point(field_release:cc.proto.ClipDisplayItem.clip_rect)
        clear_has_clip_rect();
        ::cc::proto::Rect* temp = clip_rect_;
        clip_rect_ = NULL;
        return temp;
    }
    inline void ClipDisplayItem::set_allocated_clip_rect(::cc::proto::Rect* clip_rect)
    {
        delete clip_rect_;
        clip_rect_ = clip_rect;
        if (clip_rect) {
            set_has_clip_rect();
        } else {
            clear_has_clip_rect();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.ClipDisplayItem.clip_rect)
    }

    // repeated .cc.proto.SkRRect rounded_rects = 2;
    inline int ClipDisplayItem::rounded_rects_size() const
    {
        return rounded_rects_.size();
    }
    inline void ClipDisplayItem::clear_rounded_rects()
    {
        rounded_rects_.Clear();
    }
    inline const ::cc::proto::SkRRect& ClipDisplayItem::rounded_rects(int index) const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_.Get(index);
    }
    inline ::cc::proto::SkRRect* ClipDisplayItem::mutable_rounded_rects(int index)
    {
        // @@protoc_insertion_point(field_mutable:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_.Mutable(index);
    }
    inline ::cc::proto::SkRRect* ClipDisplayItem::add_rounded_rects()
    {
        // @@protoc_insertion_point(field_add:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::cc::proto::SkRRect>*
    ClipDisplayItem::mutable_rounded_rects()
    {
        // @@protoc_insertion_point(field_mutable_list:cc.proto.ClipDisplayItem.rounded_rects)
        return &rounded_rects_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::cc::proto::SkRRect>&
    ClipDisplayItem::rounded_rects() const
    {
        // @@protoc_insertion_point(field_list:cc.proto.ClipDisplayItem.rounded_rects)
        return rounded_rects_;
    }

    // optional bool antialias = 3;
    inline bool ClipDisplayItem::has_antialias() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ClipDisplayItem::set_has_antialias()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ClipDisplayItem::clear_has_antialias()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ClipDisplayItem::clear_antialias()
    {
        antialias_ = false;
        clear_has_antialias();
    }
    inline bool ClipDisplayItem::antialias() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipDisplayItem.antialias)
        return antialias_;
    }
    inline void ClipDisplayItem::set_antialias(bool value)
    {
        set_has_antialias();
        antialias_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.ClipDisplayItem.antialias)
    }

    // -------------------------------------------------------------------

    // ClipPathDisplayItem

    // optional .cc.proto.SkClipOp.Op clip_op = 1;
    inline bool ClipPathDisplayItem::has_clip_op() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ClipPathDisplayItem::set_has_clip_op()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ClipPathDisplayItem::clear_has_clip_op()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ClipPathDisplayItem::clear_clip_op()
    {
        clip_op_ = 0;
        clear_has_clip_op();
    }
    inline ::cc::proto::SkClipOp_Op ClipPathDisplayItem::clip_op() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipPathDisplayItem.clip_op)
        return static_cast<::cc::proto::SkClipOp_Op>(clip_op_);
    }
    inline void ClipPathDisplayItem::set_clip_op(::cc::proto::SkClipOp_Op value)
    {
        assert(::cc::proto::SkClipOp_Op_IsValid(value));
        set_has_clip_op();
        clip_op_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.ClipPathDisplayItem.clip_op)
    }

    // optional bool antialias = 2;
    inline bool ClipPathDisplayItem::has_antialias() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ClipPathDisplayItem::set_has_antialias()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ClipPathDisplayItem::clear_has_antialias()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ClipPathDisplayItem::clear_antialias()
    {
        antialias_ = false;
        clear_has_antialias();
    }
    inline bool ClipPathDisplayItem::antialias() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipPathDisplayItem.antialias)
        return antialias_;
    }
    inline void ClipPathDisplayItem::set_antialias(bool value)
    {
        set_has_antialias();
        antialias_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.ClipPathDisplayItem.antialias)
    }

    // optional bytes clip_path = 3;
    inline bool ClipPathDisplayItem::has_clip_path() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ClipPathDisplayItem::set_has_clip_path()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ClipPathDisplayItem::clear_has_clip_path()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ClipPathDisplayItem::clear_clip_path()
    {
        clip_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_clip_path();
    }
    inline const ::std::string& ClipPathDisplayItem::clip_path() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.ClipPathDisplayItem.clip_path)
        return clip_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClipPathDisplayItem::set_clip_path(const ::std::string& value)
    {
        set_has_clip_path();
        clip_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:cc.proto.ClipPathDisplayItem.clip_path)
    }
    inline void ClipPathDisplayItem::set_clip_path(const char* value)
    {
        set_has_clip_path();
        clip_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:cc.proto.ClipPathDisplayItem.clip_path)
    }
    inline void ClipPathDisplayItem::set_clip_path(const void* value, size_t size)
    {
        set_has_clip_path();
        clip_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:cc.proto.ClipPathDisplayItem.clip_path)
    }
    inline ::std::string* ClipPathDisplayItem::mutable_clip_path()
    {
        set_has_clip_path();
        // @@protoc_insertion_point(field_mutable:cc.proto.ClipPathDisplayItem.clip_path)
        return clip_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ClipPathDisplayItem::release_clip_path()
    {
        // @@protoc_insertion_point(field_release:cc.proto.ClipPathDisplayItem.clip_path)
        clear_has_clip_path();
        return clip_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClipPathDisplayItem::set_allocated_clip_path(::std::string* clip_path)
    {
        if (clip_path != NULL) {
            set_has_clip_path();
        } else {
            clear_has_clip_path();
        }
        clip_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clip_path);
        // @@protoc_insertion_point(field_set_allocated:cc.proto.ClipPathDisplayItem.clip_path)
    }

    // -------------------------------------------------------------------

    // CompositingDisplayItem

    // optional uint32 alpha = 1;
    inline bool CompositingDisplayItem::has_alpha() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void CompositingDisplayItem::set_has_alpha()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void CompositingDisplayItem::clear_has_alpha()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void CompositingDisplayItem::clear_alpha()
    {
        alpha_ = 0u;
        clear_has_alpha();
    }
    inline ::google::protobuf::uint32 CompositingDisplayItem::alpha() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.alpha)
        return alpha_;
    }
    inline void CompositingDisplayItem::set_alpha(::google::protobuf::uint32 value)
    {
        set_has_alpha();
        alpha_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.alpha)
    }

    // optional .cc.proto.SkXfermode.Mode mode = 2;
    inline bool CompositingDisplayItem::has_mode() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void CompositingDisplayItem::set_has_mode()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void CompositingDisplayItem::clear_has_mode()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void CompositingDisplayItem::clear_mode()
    {
        mode_ = 0;
        clear_has_mode();
    }
    inline ::cc::proto::SkXfermode_Mode CompositingDisplayItem::mode() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.mode)
        return static_cast<::cc::proto::SkXfermode_Mode>(mode_);
    }
    inline void CompositingDisplayItem::set_mode(::cc::proto::SkXfermode_Mode value)
    {
        assert(::cc::proto::SkXfermode_Mode_IsValid(value));
        set_has_mode();
        mode_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.mode)
    }

    // optional .cc.proto.RectF bounds = 3;
    inline bool CompositingDisplayItem::has_bounds() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void CompositingDisplayItem::set_has_bounds()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void CompositingDisplayItem::clear_has_bounds()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void CompositingDisplayItem::clear_bounds()
    {
        if (bounds_ != NULL)
            bounds_->::cc::proto::RectF::Clear();
        clear_has_bounds();
    }
    inline const ::cc::proto::RectF& CompositingDisplayItem::bounds() const
    {
// @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
        return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
    }
    inline ::cc::proto::RectF* CompositingDisplayItem::mutable_bounds()
    {
        set_has_bounds();
        if (bounds_ == NULL) {
            bounds_ = new ::cc::proto::RectF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.CompositingDisplayItem.bounds)
        return bounds_;
    }
    inline ::cc::proto::RectF* CompositingDisplayItem::release_bounds()
    {
        // @@protoc_insertion_point(field_release:cc.proto.CompositingDisplayItem.bounds)
        clear_has_bounds();
        ::cc::proto::RectF* temp = bounds_;
        bounds_ = NULL;
        return temp;
    }
    inline void CompositingDisplayItem::set_allocated_bounds(::cc::proto::RectF* bounds)
    {
        delete bounds_;
        bounds_ = bounds;
        if (bounds) {
            set_has_bounds();
        } else {
            clear_has_bounds();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.CompositingDisplayItem.bounds)
    }

    // optional bytes color_filter = 4;
    inline bool CompositingDisplayItem::has_color_filter() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void CompositingDisplayItem::set_has_color_filter()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void CompositingDisplayItem::clear_has_color_filter()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void CompositingDisplayItem::clear_color_filter()
    {
        color_filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_color_filter();
    }
    inline const ::std::string& CompositingDisplayItem::color_filter() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.color_filter)
        return color_filter_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void CompositingDisplayItem::set_color_filter(const ::std::string& value)
    {
        set_has_color_filter();
        color_filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.color_filter)
    }
    inline void CompositingDisplayItem::set_color_filter(const char* value)
    {
        set_has_color_filter();
        color_filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:cc.proto.CompositingDisplayItem.color_filter)
    }
    inline void CompositingDisplayItem::set_color_filter(const void* value, size_t size)
    {
        set_has_color_filter();
        color_filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:cc.proto.CompositingDisplayItem.color_filter)
    }
    inline ::std::string* CompositingDisplayItem::mutable_color_filter()
    {
        set_has_color_filter();
        // @@protoc_insertion_point(field_mutable:cc.proto.CompositingDisplayItem.color_filter)
        return color_filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* CompositingDisplayItem::release_color_filter()
    {
        // @@protoc_insertion_point(field_release:cc.proto.CompositingDisplayItem.color_filter)
        clear_has_color_filter();
        return color_filter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void CompositingDisplayItem::set_allocated_color_filter(::std::string* color_filter)
    {
        if (color_filter != NULL) {
            set_has_color_filter();
        } else {
            clear_has_color_filter();
        }
        color_filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color_filter);
        // @@protoc_insertion_point(field_set_allocated:cc.proto.CompositingDisplayItem.color_filter)
    }

    // optional bool lcd_text_requires_opaque_layer = 5;
    inline bool CompositingDisplayItem::has_lcd_text_requires_opaque_layer() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void CompositingDisplayItem::set_has_lcd_text_requires_opaque_layer()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void CompositingDisplayItem::clear_has_lcd_text_requires_opaque_layer()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void CompositingDisplayItem::clear_lcd_text_requires_opaque_layer()
    {
        lcd_text_requires_opaque_layer_ = false;
        clear_has_lcd_text_requires_opaque_layer();
    }
    inline bool CompositingDisplayItem::lcd_text_requires_opaque_layer() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.CompositingDisplayItem.lcd_text_requires_opaque_layer)
        return lcd_text_requires_opaque_layer_;
    }
    inline void CompositingDisplayItem::set_lcd_text_requires_opaque_layer(bool value)
    {
        set_has_lcd_text_requires_opaque_layer();
        lcd_text_requires_opaque_layer_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.CompositingDisplayItem.lcd_text_requires_opaque_layer)
    }

    // -------------------------------------------------------------------

    // SkPictureID

    // optional uint32 unique_id = 1;
    inline bool SkPictureID::has_unique_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void SkPictureID::set_has_unique_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void SkPictureID::clear_has_unique_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void SkPictureID::clear_unique_id()
    {
        unique_id_ = 0u;
        clear_has_unique_id();
    }
    inline ::google::protobuf::uint32 SkPictureID::unique_id() const
    {
        // @@protoc_insertion_point(field_get:cc.proto.SkPictureID.unique_id)
        return unique_id_;
    }
    inline void SkPictureID::set_unique_id(::google::protobuf::uint32 value)
    {
        set_has_unique_id();
        unique_id_ = value;
        // @@protoc_insertion_point(field_set:cc.proto.SkPictureID.unique_id)
    }

    // -------------------------------------------------------------------

    // DrawingDisplayItem

    // optional .cc.proto.SkPictureID id = 1;
    inline bool DrawingDisplayItem::has_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void DrawingDisplayItem::set_has_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void DrawingDisplayItem::clear_has_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void DrawingDisplayItem::clear_id()
    {
        if (id_ != NULL)
            id_->::cc::proto::SkPictureID::Clear();
        clear_has_id();
    }
    inline const ::cc::proto::SkPictureID& DrawingDisplayItem::id() const
    {
// @@protoc_insertion_point(field_get:cc.proto.DrawingDisplayItem.id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return id_ != NULL ? *id_ : *default_instance().id_;
#else
        return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
    }
    inline ::cc::proto::SkPictureID* DrawingDisplayItem::mutable_id()
    {
        set_has_id();
        if (id_ == NULL) {
            id_ = new ::cc::proto::SkPictureID;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.DrawingDisplayItem.id)
        return id_;
    }
    inline ::cc::proto::SkPictureID* DrawingDisplayItem::release_id()
    {
        // @@protoc_insertion_point(field_release:cc.proto.DrawingDisplayItem.id)
        clear_has_id();
        ::cc::proto::SkPictureID* temp = id_;
        id_ = NULL;
        return temp;
    }
    inline void DrawingDisplayItem::set_allocated_id(::cc::proto::SkPictureID* id)
    {
        delete id_;
        id_ = id;
        if (id) {
            set_has_id();
        } else {
            clear_has_id();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.DrawingDisplayItem.id)
    }

    // -------------------------------------------------------------------

    // FilterDisplayItem

    // optional .cc.proto.RectF bounds = 1;
    inline bool FilterDisplayItem::has_bounds() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void FilterDisplayItem::set_has_bounds()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void FilterDisplayItem::clear_has_bounds()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void FilterDisplayItem::clear_bounds()
    {
        if (bounds_ != NULL)
            bounds_->::cc::proto::RectF::Clear();
        clear_has_bounds();
    }
    inline const ::cc::proto::RectF& FilterDisplayItem::bounds() const
    {
// @@protoc_insertion_point(field_get:cc.proto.FilterDisplayItem.bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
        return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
    }
    inline ::cc::proto::RectF* FilterDisplayItem::mutable_bounds()
    {
        set_has_bounds();
        if (bounds_ == NULL) {
            bounds_ = new ::cc::proto::RectF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.FilterDisplayItem.bounds)
        return bounds_;
    }
    inline ::cc::proto::RectF* FilterDisplayItem::release_bounds()
    {
        // @@protoc_insertion_point(field_release:cc.proto.FilterDisplayItem.bounds)
        clear_has_bounds();
        ::cc::proto::RectF* temp = bounds_;
        bounds_ = NULL;
        return temp;
    }
    inline void FilterDisplayItem::set_allocated_bounds(::cc::proto::RectF* bounds)
    {
        delete bounds_;
        bounds_ = bounds;
        if (bounds) {
            set_has_bounds();
        } else {
            clear_has_bounds();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.FilterDisplayItem.bounds)
    }

    // -------------------------------------------------------------------

    // FloatClipDisplayItem

    // optional .cc.proto.RectF clip_rect = 1;
    inline bool FloatClipDisplayItem::has_clip_rect() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void FloatClipDisplayItem::set_has_clip_rect()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void FloatClipDisplayItem::clear_has_clip_rect()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void FloatClipDisplayItem::clear_clip_rect()
    {
        if (clip_rect_ != NULL)
            clip_rect_->::cc::proto::RectF::Clear();
        clear_has_clip_rect();
    }
    inline const ::cc::proto::RectF& FloatClipDisplayItem::clip_rect() const
    {
// @@protoc_insertion_point(field_get:cc.proto.FloatClipDisplayItem.clip_rect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance().clip_rect_;
#else
        return clip_rect_ != NULL ? *clip_rect_ : *default_instance_->clip_rect_;
#endif
    }
    inline ::cc::proto::RectF* FloatClipDisplayItem::mutable_clip_rect()
    {
        set_has_clip_rect();
        if (clip_rect_ == NULL) {
            clip_rect_ = new ::cc::proto::RectF;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.FloatClipDisplayItem.clip_rect)
        return clip_rect_;
    }
    inline ::cc::proto::RectF* FloatClipDisplayItem::release_clip_rect()
    {
        // @@protoc_insertion_point(field_release:cc.proto.FloatClipDisplayItem.clip_rect)
        clear_has_clip_rect();
        ::cc::proto::RectF* temp = clip_rect_;
        clip_rect_ = NULL;
        return temp;
    }
    inline void FloatClipDisplayItem::set_allocated_clip_rect(::cc::proto::RectF* clip_rect)
    {
        delete clip_rect_;
        clip_rect_ = clip_rect;
        if (clip_rect) {
            set_has_clip_rect();
        } else {
            clear_has_clip_rect();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.FloatClipDisplayItem.clip_rect)
    }

    // -------------------------------------------------------------------

    // TransformDisplayItem

    // optional .cc.proto.Transform transform = 1;
    inline bool TransformDisplayItem::has_transform() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void TransformDisplayItem::set_has_transform()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void TransformDisplayItem::clear_has_transform()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void TransformDisplayItem::clear_transform()
    {
        if (transform_ != NULL)
            transform_->::cc::proto::Transform::Clear();
        clear_has_transform();
    }
    inline const ::cc::proto::Transform& TransformDisplayItem::transform() const
    {
// @@protoc_insertion_point(field_get:cc.proto.TransformDisplayItem.transform)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transform_ != NULL ? *transform_ : *default_instance().transform_;
#else
        return transform_ != NULL ? *transform_ : *default_instance_->transform_;
#endif
    }
    inline ::cc::proto::Transform* TransformDisplayItem::mutable_transform()
    {
        set_has_transform();
        if (transform_ == NULL) {
            transform_ = new ::cc::proto::Transform;
        }
        // @@protoc_insertion_point(field_mutable:cc.proto.TransformDisplayItem.transform)
        return transform_;
    }
    inline ::cc::proto::Transform* TransformDisplayItem::release_transform()
    {
        // @@protoc_insertion_point(field_release:cc.proto.TransformDisplayItem.transform)
        clear_has_transform();
        ::cc::proto::Transform* temp = transform_;
        transform_ = NULL;
        return temp;
    }
    inline void TransformDisplayItem::set_allocated_transform(::cc::proto::Transform* transform)
    {
        delete transform_;
        transform_ = transform;
        if (transform) {
            set_has_transform();
        } else {
            clear_has_transform();
        }
        // @@protoc_insertion_point(field_set_allocated:cc.proto.TransformDisplayItem.transform)
    }

#endif // !PROTOBUF_INLINE_NOT_IN_HEADERS
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace cc

#ifndef SWIG
namespace google {
namespace protobuf {

    template <>
    struct is_proto_enum<::cc::proto::DisplayItem_Type> : ::google::protobuf::internal::true_type {
    };

} // namespace protobuf
} // namespace google
#endif // SWIG

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_display_5fitem_2eproto__INCLUDED
