// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: disk_cache_proto.proto

#ifndef PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED
#define PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

class GpuProgramProto;
class ShaderAttributeProto;
class ShaderInterfaceBlockFieldProto;
class ShaderInterfaceBlockProto;
class ShaderOutputVariableProto;
class ShaderProto;
class ShaderUniformProto;
class ShaderVariableProto;
class ShaderVaryingProto;

// ===================================================================

class ShaderVariableProto : public ::google::protobuf::MessageLite {
public:
    ShaderVariableProto();
    virtual ~ShaderVariableProto();

    ShaderVariableProto(const ShaderVariableProto& from);

    inline ShaderVariableProto& operator=(const ShaderVariableProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderVariableProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderVariableProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderVariableProto* other);

    // implements Message ----------------------------------------------

    inline ShaderVariableProto* New() const { return New(NULL); }

    ShaderVariableProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderVariableProto& from);
    void MergeFrom(const ShaderVariableProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderVariableProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 type = 1;
    bool has_type() const;
    void clear_type();
    static const int kTypeFieldNumber = 1;
    ::google::protobuf::uint32 type() const;
    void set_type(::google::protobuf::uint32 value);

    // optional uint32 precision = 2;
    bool has_precision() const;
    void clear_precision();
    static const int kPrecisionFieldNumber = 2;
    ::google::protobuf::uint32 precision() const;
    void set_precision(::google::protobuf::uint32 value);

    // optional string name = 3;
    bool has_name() const;
    void clear_name();
    static const int kNameFieldNumber = 3;
    const ::std::string& name() const;
    void set_name(const ::std::string& value);
    void set_name(const char* value);
    void set_name(const char* value, size_t size);
    ::std::string* mutable_name();
    ::std::string* release_name();
    void set_allocated_name(::std::string* name);

    // optional string mapped_name = 4;
    bool has_mapped_name() const;
    void clear_mapped_name();
    static const int kMappedNameFieldNumber = 4;
    const ::std::string& mapped_name() const;
    void set_mapped_name(const ::std::string& value);
    void set_mapped_name(const char* value);
    void set_mapped_name(const char* value, size_t size);
    ::std::string* mutable_mapped_name();
    ::std::string* release_mapped_name();
    void set_allocated_mapped_name(::std::string* mapped_name);

    // optional uint32 array_size = 5;
    bool has_array_size() const;
    void clear_array_size();
    static const int kArraySizeFieldNumber = 5;
    ::google::protobuf::uint32 array_size() const;
    void set_array_size(::google::protobuf::uint32 value);

    // optional bool static_use = 6;
    bool has_static_use() const;
    void clear_static_use();
    static const int kStaticUseFieldNumber = 6;
    bool static_use() const;
    void set_static_use(bool value);

    // repeated .ShaderVariableProto fields = 7;
    int fields_size() const;
    void clear_fields();
    static const int kFieldsFieldNumber = 7;
    const ::ShaderVariableProto& fields(int index) const;
    ::ShaderVariableProto* mutable_fields(int index);
    ::ShaderVariableProto* add_fields();
    ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>*
    mutable_fields();
    const ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>&
    fields() const;

    // optional string struct_name = 8;
    bool has_struct_name() const;
    void clear_struct_name();
    static const int kStructNameFieldNumber = 8;
    const ::std::string& struct_name() const;
    void set_struct_name(const ::std::string& value);
    void set_struct_name(const char* value);
    void set_struct_name(const char* value, size_t size);
    ::std::string* mutable_struct_name();
    ::std::string* release_struct_name();
    void set_allocated_struct_name(::std::string* struct_name);

    // @@protoc_insertion_point(class_scope:ShaderVariableProto)
private:
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_precision();
    inline void clear_has_precision();
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_mapped_name();
    inline void clear_has_mapped_name();
    inline void set_has_array_size();
    inline void clear_has_array_size();
    inline void set_has_static_use();
    inline void clear_has_static_use();
    inline void set_has_struct_name();
    inline void clear_has_struct_name();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::uint32 type_;
    ::google::protobuf::uint32 precision_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mapped_name_;
    ::google::protobuf::uint32 array_size_;
    bool static_use_;
    ::google::protobuf::RepeatedPtrField<::ShaderVariableProto> fields_;
    ::google::protobuf::internal::ArenaStringPtr struct_name_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderAttributeProto : public ::google::protobuf::MessageLite {
public:
    ShaderAttributeProto();
    virtual ~ShaderAttributeProto();

    ShaderAttributeProto(const ShaderAttributeProto& from);

    inline ShaderAttributeProto& operator=(const ShaderAttributeProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderAttributeProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderAttributeProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderAttributeProto* other);

    // implements Message ----------------------------------------------

    inline ShaderAttributeProto* New() const { return New(NULL); }

    ShaderAttributeProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderAttributeProto& from);
    void MergeFrom(const ShaderAttributeProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderAttributeProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    bool has_basic() const;
    void clear_basic();
    static const int kBasicFieldNumber = 1;
    const ::ShaderVariableProto& basic() const;
    ::ShaderVariableProto* mutable_basic();
    ::ShaderVariableProto* release_basic();
    void set_allocated_basic(::ShaderVariableProto* basic);

    // optional int32 location = 2;
    bool has_location() const;
    void clear_location();
    static const int kLocationFieldNumber = 2;
    ::google::protobuf::int32 location() const;
    void set_location(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:ShaderAttributeProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();
    inline void set_has_location();
    inline void clear_has_location();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::ShaderVariableProto* basic_;
    ::google::protobuf::int32 location_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderAttributeProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderUniformProto : public ::google::protobuf::MessageLite {
public:
    ShaderUniformProto();
    virtual ~ShaderUniformProto();

    ShaderUniformProto(const ShaderUniformProto& from);

    inline ShaderUniformProto& operator=(const ShaderUniformProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderUniformProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderUniformProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderUniformProto* other);

    // implements Message ----------------------------------------------

    inline ShaderUniformProto* New() const { return New(NULL); }

    ShaderUniformProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderUniformProto& from);
    void MergeFrom(const ShaderUniformProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderUniformProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    bool has_basic() const;
    void clear_basic();
    static const int kBasicFieldNumber = 1;
    const ::ShaderVariableProto& basic() const;
    ::ShaderVariableProto* mutable_basic();
    ::ShaderVariableProto* release_basic();
    void set_allocated_basic(::ShaderVariableProto* basic);

    // @@protoc_insertion_point(class_scope:ShaderUniformProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::ShaderVariableProto* basic_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderUniformProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderVaryingProto : public ::google::protobuf::MessageLite {
public:
    ShaderVaryingProto();
    virtual ~ShaderVaryingProto();

    ShaderVaryingProto(const ShaderVaryingProto& from);

    inline ShaderVaryingProto& operator=(const ShaderVaryingProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderVaryingProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderVaryingProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderVaryingProto* other);

    // implements Message ----------------------------------------------

    inline ShaderVaryingProto* New() const { return New(NULL); }

    ShaderVaryingProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderVaryingProto& from);
    void MergeFrom(const ShaderVaryingProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderVaryingProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    bool has_basic() const;
    void clear_basic();
    static const int kBasicFieldNumber = 1;
    const ::ShaderVariableProto& basic() const;
    ::ShaderVariableProto* mutable_basic();
    ::ShaderVariableProto* release_basic();
    void set_allocated_basic(::ShaderVariableProto* basic);

    // optional int32 interpolation = 2;
    bool has_interpolation() const;
    void clear_interpolation();
    static const int kInterpolationFieldNumber = 2;
    ::google::protobuf::int32 interpolation() const;
    void set_interpolation(::google::protobuf::int32 value);

    // optional bool is_invariant = 3;
    bool has_is_invariant() const;
    void clear_is_invariant();
    static const int kIsInvariantFieldNumber = 3;
    bool is_invariant() const;
    void set_is_invariant(bool value);

    // @@protoc_insertion_point(class_scope:ShaderVaryingProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();
    inline void set_has_interpolation();
    inline void clear_has_interpolation();
    inline void set_has_is_invariant();
    inline void clear_has_is_invariant();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::ShaderVariableProto* basic_;
    ::google::protobuf::int32 interpolation_;
    bool is_invariant_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderVaryingProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderOutputVariableProto : public ::google::protobuf::MessageLite {
public:
    ShaderOutputVariableProto();
    virtual ~ShaderOutputVariableProto();

    ShaderOutputVariableProto(const ShaderOutputVariableProto& from);

    inline ShaderOutputVariableProto& operator=(const ShaderOutputVariableProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderOutputVariableProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderOutputVariableProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderOutputVariableProto* other);

    // implements Message ----------------------------------------------

    inline ShaderOutputVariableProto* New() const { return New(NULL); }

    ShaderOutputVariableProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderOutputVariableProto& from);
    void MergeFrom(const ShaderOutputVariableProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderOutputVariableProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    bool has_basic() const;
    void clear_basic();
    static const int kBasicFieldNumber = 1;
    const ::ShaderVariableProto& basic() const;
    ::ShaderVariableProto* mutable_basic();
    ::ShaderVariableProto* release_basic();
    void set_allocated_basic(::ShaderVariableProto* basic);

    // optional int32 location = 2;
    bool has_location() const;
    void clear_location();
    static const int kLocationFieldNumber = 2;
    ::google::protobuf::int32 location() const;
    void set_location(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:ShaderOutputVariableProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();
    inline void set_has_location();
    inline void clear_has_location();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::ShaderVariableProto* basic_;
    ::google::protobuf::int32 location_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderOutputVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderInterfaceBlockFieldProto : public ::google::protobuf::MessageLite {
public:
    ShaderInterfaceBlockFieldProto();
    virtual ~ShaderInterfaceBlockFieldProto();

    ShaderInterfaceBlockFieldProto(const ShaderInterfaceBlockFieldProto& from);

    inline ShaderInterfaceBlockFieldProto& operator=(const ShaderInterfaceBlockFieldProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderInterfaceBlockFieldProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderInterfaceBlockFieldProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderInterfaceBlockFieldProto* other);

    // implements Message ----------------------------------------------

    inline ShaderInterfaceBlockFieldProto* New() const { return New(NULL); }

    ShaderInterfaceBlockFieldProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderInterfaceBlockFieldProto& from);
    void MergeFrom(const ShaderInterfaceBlockFieldProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderInterfaceBlockFieldProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    bool has_basic() const;
    void clear_basic();
    static const int kBasicFieldNumber = 1;
    const ::ShaderVariableProto& basic() const;
    ::ShaderVariableProto* mutable_basic();
    ::ShaderVariableProto* release_basic();
    void set_allocated_basic(::ShaderVariableProto* basic);

    // optional bool is_row_major_layout = 2;
    bool has_is_row_major_layout() const;
    void clear_is_row_major_layout();
    static const int kIsRowMajorLayoutFieldNumber = 2;
    bool is_row_major_layout() const;
    void set_is_row_major_layout(bool value);

    // @@protoc_insertion_point(class_scope:ShaderInterfaceBlockFieldProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();
    inline void set_has_is_row_major_layout();
    inline void clear_has_is_row_major_layout();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::ShaderVariableProto* basic_;
    bool is_row_major_layout_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderInterfaceBlockFieldProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderInterfaceBlockProto : public ::google::protobuf::MessageLite {
public:
    ShaderInterfaceBlockProto();
    virtual ~ShaderInterfaceBlockProto();

    ShaderInterfaceBlockProto(const ShaderInterfaceBlockProto& from);

    inline ShaderInterfaceBlockProto& operator=(const ShaderInterfaceBlockProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderInterfaceBlockProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderInterfaceBlockProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderInterfaceBlockProto* other);

    // implements Message ----------------------------------------------

    inline ShaderInterfaceBlockProto* New() const { return New(NULL); }

    ShaderInterfaceBlockProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderInterfaceBlockProto& from);
    void MergeFrom(const ShaderInterfaceBlockProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderInterfaceBlockProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string name = 1;
    bool has_name() const;
    void clear_name();
    static const int kNameFieldNumber = 1;
    const ::std::string& name() const;
    void set_name(const ::std::string& value);
    void set_name(const char* value);
    void set_name(const char* value, size_t size);
    ::std::string* mutable_name();
    ::std::string* release_name();
    void set_allocated_name(::std::string* name);

    // optional string mapped_name = 2;
    bool has_mapped_name() const;
    void clear_mapped_name();
    static const int kMappedNameFieldNumber = 2;
    const ::std::string& mapped_name() const;
    void set_mapped_name(const ::std::string& value);
    void set_mapped_name(const char* value);
    void set_mapped_name(const char* value, size_t size);
    ::std::string* mutable_mapped_name();
    ::std::string* release_mapped_name();
    void set_allocated_mapped_name(::std::string* mapped_name);

    // optional string instance_name = 3;
    bool has_instance_name() const;
    void clear_instance_name();
    static const int kInstanceNameFieldNumber = 3;
    const ::std::string& instance_name() const;
    void set_instance_name(const ::std::string& value);
    void set_instance_name(const char* value);
    void set_instance_name(const char* value, size_t size);
    ::std::string* mutable_instance_name();
    ::std::string* release_instance_name();
    void set_allocated_instance_name(::std::string* instance_name);

    // optional uint32 array_size = 4;
    bool has_array_size() const;
    void clear_array_size();
    static const int kArraySizeFieldNumber = 4;
    ::google::protobuf::uint32 array_size() const;
    void set_array_size(::google::protobuf::uint32 value);

    // optional int32 layout = 5;
    bool has_layout() const;
    void clear_layout();
    static const int kLayoutFieldNumber = 5;
    ::google::protobuf::int32 layout() const;
    void set_layout(::google::protobuf::int32 value);

    // optional bool is_row_major_layout = 6;
    bool has_is_row_major_layout() const;
    void clear_is_row_major_layout();
    static const int kIsRowMajorLayoutFieldNumber = 6;
    bool is_row_major_layout() const;
    void set_is_row_major_layout(bool value);

    // optional bool static_use = 7;
    bool has_static_use() const;
    void clear_static_use();
    static const int kStaticUseFieldNumber = 7;
    bool static_use() const;
    void set_static_use(bool value);

    // repeated .ShaderInterfaceBlockFieldProto fields = 8;
    int fields_size() const;
    void clear_fields();
    static const int kFieldsFieldNumber = 8;
    const ::ShaderInterfaceBlockFieldProto& fields(int index) const;
    ::ShaderInterfaceBlockFieldProto* mutable_fields(int index);
    ::ShaderInterfaceBlockFieldProto* add_fields();
    ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockFieldProto>*
    mutable_fields();
    const ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockFieldProto>&
    fields() const;

    // @@protoc_insertion_point(class_scope:ShaderInterfaceBlockProto)
private:
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_mapped_name();
    inline void clear_has_mapped_name();
    inline void set_has_instance_name();
    inline void clear_has_instance_name();
    inline void set_has_array_size();
    inline void clear_has_array_size();
    inline void set_has_layout();
    inline void clear_has_layout();
    inline void set_has_is_row_major_layout();
    inline void clear_has_is_row_major_layout();
    inline void set_has_static_use();
    inline void clear_has_static_use();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mapped_name_;
    ::google::protobuf::internal::ArenaStringPtr instance_name_;
    ::google::protobuf::uint32 array_size_;
    ::google::protobuf::int32 layout_;
    ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockFieldProto> fields_;
    bool is_row_major_layout_;
    bool static_use_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderInterfaceBlockProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderProto : public ::google::protobuf::MessageLite {
public:
    ShaderProto();
    virtual ~ShaderProto();

    ShaderProto(const ShaderProto& from);

    inline ShaderProto& operator=(const ShaderProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ShaderProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderProto* other);

    // implements Message ----------------------------------------------

    inline ShaderProto* New() const { return New(NULL); }

    ShaderProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderProto& from);
    void MergeFrom(const ShaderProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ShaderProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes sha = 1;
    bool has_sha() const;
    void clear_sha();
    static const int kShaFieldNumber = 1;
    const ::std::string& sha() const;
    void set_sha(const ::std::string& value);
    void set_sha(const char* value);
    void set_sha(const void* value, size_t size);
    ::std::string* mutable_sha();
    ::std::string* release_sha();
    void set_allocated_sha(::std::string* sha);

    // repeated .ShaderAttributeProto attribs = 2;
    int attribs_size() const;
    void clear_attribs();
    static const int kAttribsFieldNumber = 2;
    const ::ShaderAttributeProto& attribs(int index) const;
    ::ShaderAttributeProto* mutable_attribs(int index);
    ::ShaderAttributeProto* add_attribs();
    ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>*
    mutable_attribs();
    const ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>&
    attribs() const;

    // repeated .ShaderUniformProto uniforms = 3;
    int uniforms_size() const;
    void clear_uniforms();
    static const int kUniformsFieldNumber = 3;
    const ::ShaderUniformProto& uniforms(int index) const;
    ::ShaderUniformProto* mutable_uniforms(int index);
    ::ShaderUniformProto* add_uniforms();
    ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>*
    mutable_uniforms();
    const ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>&
    uniforms() const;

    // repeated .ShaderVaryingProto varyings = 4;
    int varyings_size() const;
    void clear_varyings();
    static const int kVaryingsFieldNumber = 4;
    const ::ShaderVaryingProto& varyings(int index) const;
    ::ShaderVaryingProto* mutable_varyings(int index);
    ::ShaderVaryingProto* add_varyings();
    ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>*
    mutable_varyings();
    const ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>&
    varyings() const;

    // repeated .ShaderOutputVariableProto output_variables = 5;
    int output_variables_size() const;
    void clear_output_variables();
    static const int kOutputVariablesFieldNumber = 5;
    const ::ShaderOutputVariableProto& output_variables(int index) const;
    ::ShaderOutputVariableProto* mutable_output_variables(int index);
    ::ShaderOutputVariableProto* add_output_variables();
    ::google::protobuf::RepeatedPtrField<::ShaderOutputVariableProto>*
    mutable_output_variables();
    const ::google::protobuf::RepeatedPtrField<::ShaderOutputVariableProto>&
    output_variables() const;

    // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
    int interface_blocks_size() const;
    void clear_interface_blocks();
    static const int kInterfaceBlocksFieldNumber = 6;
    const ::ShaderInterfaceBlockProto& interface_blocks(int index) const;
    ::ShaderInterfaceBlockProto* mutable_interface_blocks(int index);
    ::ShaderInterfaceBlockProto* add_interface_blocks();
    ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockProto>*
    mutable_interface_blocks();
    const ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockProto>&
    interface_blocks() const;

    // @@protoc_insertion_point(class_scope:ShaderProto)
private:
    inline void set_has_sha();
    inline void clear_has_sha();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sha_;
    ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto> attribs_;
    ::google::protobuf::RepeatedPtrField<::ShaderUniformProto> uniforms_;
    ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto> varyings_;
    ::google::protobuf::RepeatedPtrField<::ShaderOutputVariableProto> output_variables_;
    ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockProto> interface_blocks_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderProto* default_instance_;
};
// -------------------------------------------------------------------

class GpuProgramProto : public ::google::protobuf::MessageLite {
public:
    GpuProgramProto();
    virtual ~GpuProgramProto();

    GpuProgramProto(const GpuProgramProto& from);

    inline GpuProgramProto& operator=(const GpuProgramProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const GpuProgramProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const GpuProgramProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(GpuProgramProto* other);

    // implements Message ----------------------------------------------

    inline GpuProgramProto* New() const { return New(NULL); }

    GpuProgramProto* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const GpuProgramProto& from);
    void MergeFrom(const GpuProgramProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GpuProgramProto* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes sha = 1;
    bool has_sha() const;
    void clear_sha();
    static const int kShaFieldNumber = 1;
    const ::std::string& sha() const;
    void set_sha(const ::std::string& value);
    void set_sha(const char* value);
    void set_sha(const void* value, size_t size);
    ::std::string* mutable_sha();
    ::std::string* release_sha();
    void set_allocated_sha(::std::string* sha);

    // optional uint32 format = 2;
    bool has_format() const;
    void clear_format();
    static const int kFormatFieldNumber = 2;
    ::google::protobuf::uint32 format() const;
    void set_format(::google::protobuf::uint32 value);

    // optional bytes program = 3;
    bool has_program() const;
    void clear_program();
    static const int kProgramFieldNumber = 3;
    const ::std::string& program() const;
    void set_program(const ::std::string& value);
    void set_program(const char* value);
    void set_program(const void* value, size_t size);
    ::std::string* mutable_program();
    ::std::string* release_program();
    void set_allocated_program(::std::string* program);

    // optional .ShaderProto vertex_shader = 4;
    bool has_vertex_shader() const;
    void clear_vertex_shader();
    static const int kVertexShaderFieldNumber = 4;
    const ::ShaderProto& vertex_shader() const;
    ::ShaderProto* mutable_vertex_shader();
    ::ShaderProto* release_vertex_shader();
    void set_allocated_vertex_shader(::ShaderProto* vertex_shader);

    // optional .ShaderProto fragment_shader = 5;
    bool has_fragment_shader() const;
    void clear_fragment_shader();
    static const int kFragmentShaderFieldNumber = 5;
    const ::ShaderProto& fragment_shader() const;
    ::ShaderProto* mutable_fragment_shader();
    ::ShaderProto* release_fragment_shader();
    void set_allocated_fragment_shader(::ShaderProto* fragment_shader);

    // @@protoc_insertion_point(class_scope:GpuProgramProto)
private:
    inline void set_has_sha();
    inline void clear_has_sha();
    inline void set_has_format();
    inline void clear_has_format();
    inline void set_has_program();
    inline void clear_has_program();
    inline void set_has_vertex_shader();
    inline void clear_has_vertex_shader();
    inline void set_has_fragment_shader();
    inline void clear_has_fragment_shader();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sha_;
    ::google::protobuf::internal::ArenaStringPtr program_;
    ::ShaderProto* vertex_shader_;
    ::ShaderProto* fragment_shader_;
    ::google::protobuf::uint32 format_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static GpuProgramProto* default_instance_;
};
// ===================================================================

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderVariableProto

// optional uint32 type = 1;
inline bool ShaderVariableProto::has_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVariableProto::set_has_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVariableProto::clear_has_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVariableProto::clear_type()
{
    type_ = 0u;
    clear_has_type();
}
inline ::google::protobuf::uint32 ShaderVariableProto::type() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.type)
    return type_;
}
inline void ShaderVariableProto::set_type(::google::protobuf::uint32 value)
{
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.type)
}

// optional uint32 precision = 2;
inline bool ShaderVariableProto::has_precision() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVariableProto::set_has_precision()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVariableProto::clear_has_precision()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVariableProto::clear_precision()
{
    precision_ = 0u;
    clear_has_precision();
}
inline ::google::protobuf::uint32 ShaderVariableProto::precision() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.precision)
    return precision_;
}
inline void ShaderVariableProto::set_precision(::google::protobuf::uint32 value)
{
    set_has_precision();
    precision_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.precision)
}

// optional string name = 3;
inline bool ShaderVariableProto::has_name() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVariableProto::set_has_name()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVariableProto::clear_has_name()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVariableProto::clear_name()
{
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_name();
}
inline const ::std::string& ShaderVariableProto::name() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.name)
    return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_name(const ::std::string& value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderVariableProto.name)
}
inline void ShaderVariableProto::set_name(const char* value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderVariableProto.name)
}
inline void ShaderVariableProto::set_name(const char* value, size_t size)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.name)
}
inline ::std::string* ShaderVariableProto::mutable_name()
{
    set_has_name();
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.name)
    return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderVariableProto::release_name()
{
    // @@protoc_insertion_point(field_release:ShaderVariableProto.name)
    clear_has_name();
    return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_allocated_name(::std::string* name)
{
    if (name != NULL) {
        set_has_name();
    } else {
        clear_has_name();
    }
    name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
    // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.name)
}

// optional string mapped_name = 4;
inline bool ShaderVariableProto::has_mapped_name() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShaderVariableProto::set_has_mapped_name()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void ShaderVariableProto::clear_has_mapped_name()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void ShaderVariableProto::clear_mapped_name()
{
    mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_mapped_name();
}
inline const ::std::string& ShaderVariableProto::mapped_name() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.mapped_name)
    return mapped_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_mapped_name(const ::std::string& value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderVariableProto.mapped_name)
}
inline void ShaderVariableProto::set_mapped_name(const char* value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderVariableProto.mapped_name)
}
inline void ShaderVariableProto::set_mapped_name(const char* value, size_t size)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.mapped_name)
}
inline ::std::string* ShaderVariableProto::mutable_mapped_name()
{
    set_has_mapped_name();
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.mapped_name)
    return mapped_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderVariableProto::release_mapped_name()
{
    // @@protoc_insertion_point(field_release:ShaderVariableProto.mapped_name)
    clear_has_mapped_name();
    return mapped_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_allocated_mapped_name(::std::string* mapped_name)
{
    if (mapped_name != NULL) {
        set_has_mapped_name();
    } else {
        clear_has_mapped_name();
    }
    mapped_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapped_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.mapped_name)
}

// optional uint32 array_size = 5;
inline bool ShaderVariableProto::has_array_size() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShaderVariableProto::set_has_array_size()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void ShaderVariableProto::clear_has_array_size()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void ShaderVariableProto::clear_array_size()
{
    array_size_ = 0u;
    clear_has_array_size();
}
inline ::google::protobuf::uint32 ShaderVariableProto::array_size() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.array_size)
    return array_size_;
}
inline void ShaderVariableProto::set_array_size(::google::protobuf::uint32 value)
{
    set_has_array_size();
    array_size_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.array_size)
}

// optional bool static_use = 6;
inline bool ShaderVariableProto::has_static_use() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShaderVariableProto::set_has_static_use()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void ShaderVariableProto::clear_has_static_use()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void ShaderVariableProto::clear_static_use()
{
    static_use_ = false;
    clear_has_static_use();
}
inline bool ShaderVariableProto::static_use() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.static_use)
    return static_use_;
}
inline void ShaderVariableProto::set_static_use(bool value)
{
    set_has_static_use();
    static_use_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.static_use)
}

// repeated .ShaderVariableProto fields = 7;
inline int ShaderVariableProto::fields_size() const
{
    return fields_.size();
}
inline void ShaderVariableProto::clear_fields()
{
    fields_.Clear();
}
inline const ::ShaderVariableProto& ShaderVariableProto::fields(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.fields)
    return fields_.Get(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::mutable_fields(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.fields)
    return fields_.Mutable(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::add_fields()
{
    // @@protoc_insertion_point(field_add:ShaderVariableProto.fields)
    return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>*
ShaderVariableProto::mutable_fields()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderVariableProto.fields)
    return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>&
ShaderVariableProto::fields() const
{
    // @@protoc_insertion_point(field_list:ShaderVariableProto.fields)
    return fields_;
}

// optional string struct_name = 8;
inline bool ShaderVariableProto::has_struct_name() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShaderVariableProto::set_has_struct_name()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void ShaderVariableProto::clear_has_struct_name()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void ShaderVariableProto::clear_struct_name()
{
    struct_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_struct_name();
}
inline const ::std::string& ShaderVariableProto::struct_name() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.struct_name)
    return struct_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_struct_name(const ::std::string& value)
{
    set_has_struct_name();
    struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderVariableProto.struct_name)
}
inline void ShaderVariableProto::set_struct_name(const char* value)
{
    set_has_struct_name();
    struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderVariableProto.struct_name)
}
inline void ShaderVariableProto::set_struct_name(const char* value, size_t size)
{
    set_has_struct_name();
    struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.struct_name)
}
inline ::std::string* ShaderVariableProto::mutable_struct_name()
{
    set_has_struct_name();
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.struct_name)
    return struct_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderVariableProto::release_struct_name()
{
    // @@protoc_insertion_point(field_release:ShaderVariableProto.struct_name)
    clear_has_struct_name();
    return struct_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_allocated_struct_name(::std::string* struct_name)
{
    if (struct_name != NULL) {
        set_has_struct_name();
    } else {
        clear_has_struct_name();
    }
    struct_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), struct_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.struct_name)
}

// -------------------------------------------------------------------

// ShaderAttributeProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderAttributeProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderAttributeProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderAttributeProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderAttributeProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderAttributeProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderAttributeProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderAttributeProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderAttributeProto.basic)
    return basic_;
}
inline ::ShaderVariableProto* ShaderAttributeProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderAttributeProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderAttributeProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderAttributeProto.basic)
}

// optional int32 location = 2;
inline bool ShaderAttributeProto::has_location() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderAttributeProto::set_has_location()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderAttributeProto::clear_has_location()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderAttributeProto::clear_location()
{
    location_ = 0;
    clear_has_location();
}
inline ::google::protobuf::int32 ShaderAttributeProto::location() const
{
    // @@protoc_insertion_point(field_get:ShaderAttributeProto.location)
    return location_;
}
inline void ShaderAttributeProto::set_location(::google::protobuf::int32 value)
{
    set_has_location();
    location_ = value;
    // @@protoc_insertion_point(field_set:ShaderAttributeProto.location)
}

// -------------------------------------------------------------------

// ShaderUniformProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderUniformProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderUniformProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderUniformProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderUniformProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderUniformProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderUniformProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderUniformProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderUniformProto.basic)
    return basic_;
}
inline ::ShaderVariableProto* ShaderUniformProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderUniformProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderUniformProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderUniformProto.basic)
}

// -------------------------------------------------------------------

// ShaderVaryingProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderVaryingProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVaryingProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVaryingProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVaryingProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderVaryingProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderVaryingProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderVaryingProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderVaryingProto.basic)
    return basic_;
}
inline ::ShaderVariableProto* ShaderVaryingProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderVaryingProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderVaryingProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderVaryingProto.basic)
}

// optional int32 interpolation = 2;
inline bool ShaderVaryingProto::has_interpolation() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVaryingProto::set_has_interpolation()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVaryingProto::clear_has_interpolation()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVaryingProto::clear_interpolation()
{
    interpolation_ = 0;
    clear_has_interpolation();
}
inline ::google::protobuf::int32 ShaderVaryingProto::interpolation() const
{
    // @@protoc_insertion_point(field_get:ShaderVaryingProto.interpolation)
    return interpolation_;
}
inline void ShaderVaryingProto::set_interpolation(::google::protobuf::int32 value)
{
    set_has_interpolation();
    interpolation_ = value;
    // @@protoc_insertion_point(field_set:ShaderVaryingProto.interpolation)
}

// optional bool is_invariant = 3;
inline bool ShaderVaryingProto::has_is_invariant() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVaryingProto::set_has_is_invariant()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVaryingProto::clear_has_is_invariant()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVaryingProto::clear_is_invariant()
{
    is_invariant_ = false;
    clear_has_is_invariant();
}
inline bool ShaderVaryingProto::is_invariant() const
{
    // @@protoc_insertion_point(field_get:ShaderVaryingProto.is_invariant)
    return is_invariant_;
}
inline void ShaderVaryingProto::set_is_invariant(bool value)
{
    set_has_is_invariant();
    is_invariant_ = value;
    // @@protoc_insertion_point(field_set:ShaderVaryingProto.is_invariant)
}

// -------------------------------------------------------------------

// ShaderOutputVariableProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderOutputVariableProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderOutputVariableProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderOutputVariableProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderOutputVariableProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderOutputVariableProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderOutputVariableProto.basic)
    return basic_;
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderOutputVariableProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderOutputVariableProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderOutputVariableProto.basic)
}

// optional int32 location = 2;
inline bool ShaderOutputVariableProto::has_location() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderOutputVariableProto::set_has_location()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderOutputVariableProto::clear_has_location()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderOutputVariableProto::clear_location()
{
    location_ = 0;
    clear_has_location();
}
inline ::google::protobuf::int32 ShaderOutputVariableProto::location() const
{
    // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.location)
    return location_;
}
inline void ShaderOutputVariableProto::set_location(::google::protobuf::int32 value)
{
    set_has_location();
    location_ = value;
    // @@protoc_insertion_point(field_set:ShaderOutputVariableProto.location)
}

// -------------------------------------------------------------------

// ShaderInterfaceBlockFieldProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderInterfaceBlockFieldProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderInterfaceBlockFieldProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderInterfaceBlockFieldProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderInterfaceBlockFieldProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderInterfaceBlockFieldProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockFieldProto.basic)
    return basic_;
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockFieldProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderInterfaceBlockFieldProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockFieldProto.basic)
}

// optional bool is_row_major_layout = 2;
inline bool ShaderInterfaceBlockFieldProto::has_is_row_major_layout() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderInterfaceBlockFieldProto::set_has_is_row_major_layout()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderInterfaceBlockFieldProto::clear_has_is_row_major_layout()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderInterfaceBlockFieldProto::clear_is_row_major_layout()
{
    is_row_major_layout_ = false;
    clear_has_is_row_major_layout();
}
inline bool ShaderInterfaceBlockFieldProto::is_row_major_layout() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.is_row_major_layout)
    return is_row_major_layout_;
}
inline void ShaderInterfaceBlockFieldProto::set_is_row_major_layout(bool value)
{
    set_has_is_row_major_layout();
    is_row_major_layout_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockFieldProto.is_row_major_layout)
}

// -------------------------------------------------------------------

// ShaderInterfaceBlockProto

// optional string name = 1;
inline bool ShaderInterfaceBlockProto::has_name() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_name()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderInterfaceBlockProto::clear_has_name()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderInterfaceBlockProto::clear_name()
{
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_name();
}
inline const ::std::string& ShaderInterfaceBlockProto::name() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.name)
    return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_name(const ::std::string& value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.name)
}
inline void ShaderInterfaceBlockProto::set_name(const char* value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.name)
}
inline void ShaderInterfaceBlockProto::set_name(const char* value, size_t size)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.name)
}
inline ::std::string* ShaderInterfaceBlockProto::mutable_name()
{
    set_has_name();
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.name)
    return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderInterfaceBlockProto::release_name()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.name)
    clear_has_name();
    return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_allocated_name(::std::string* name)
{
    if (name != NULL) {
        set_has_name();
    } else {
        clear_has_name();
    }
    name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.name)
}

// optional string mapped_name = 2;
inline bool ShaderInterfaceBlockProto::has_mapped_name() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_mapped_name()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderInterfaceBlockProto::clear_has_mapped_name()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderInterfaceBlockProto::clear_mapped_name()
{
    mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_mapped_name();
}
inline const ::std::string& ShaderInterfaceBlockProto::mapped_name() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.mapped_name)
    return mapped_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_mapped_name(const ::std::string& value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.mapped_name)
}
inline void ShaderInterfaceBlockProto::set_mapped_name(const char* value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.mapped_name)
}
inline void ShaderInterfaceBlockProto::set_mapped_name(const char* value, size_t size)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.mapped_name)
}
inline ::std::string* ShaderInterfaceBlockProto::mutable_mapped_name()
{
    set_has_mapped_name();
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.mapped_name)
    return mapped_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderInterfaceBlockProto::release_mapped_name()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.mapped_name)
    clear_has_mapped_name();
    return mapped_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_allocated_mapped_name(::std::string* mapped_name)
{
    if (mapped_name != NULL) {
        set_has_mapped_name();
    } else {
        clear_has_mapped_name();
    }
    mapped_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapped_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.mapped_name)
}

// optional string instance_name = 3;
inline bool ShaderInterfaceBlockProto::has_instance_name() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_instance_name()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void ShaderInterfaceBlockProto::clear_has_instance_name()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderInterfaceBlockProto::clear_instance_name()
{
    instance_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_instance_name();
}
inline const ::std::string& ShaderInterfaceBlockProto::instance_name() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.instance_name)
    return instance_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_instance_name(const ::std::string& value)
{
    set_has_instance_name();
    instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.instance_name)
}
inline void ShaderInterfaceBlockProto::set_instance_name(const char* value)
{
    set_has_instance_name();
    instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.instance_name)
}
inline void ShaderInterfaceBlockProto::set_instance_name(const char* value, size_t size)
{
    set_has_instance_name();
    instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.instance_name)
}
inline ::std::string* ShaderInterfaceBlockProto::mutable_instance_name()
{
    set_has_instance_name();
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.instance_name)
    return instance_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderInterfaceBlockProto::release_instance_name()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.instance_name)
    clear_has_instance_name();
    return instance_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_allocated_instance_name(::std::string* instance_name)
{
    if (instance_name != NULL) {
        set_has_instance_name();
    } else {
        clear_has_instance_name();
    }
    instance_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.instance_name)
}

// optional uint32 array_size = 4;
inline bool ShaderInterfaceBlockProto::has_array_size() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_array_size()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void ShaderInterfaceBlockProto::clear_has_array_size()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void ShaderInterfaceBlockProto::clear_array_size()
{
    array_size_ = 0u;
    clear_has_array_size();
}
inline ::google::protobuf::uint32 ShaderInterfaceBlockProto::array_size() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.array_size)
    return array_size_;
}
inline void ShaderInterfaceBlockProto::set_array_size(::google::protobuf::uint32 value)
{
    set_has_array_size();
    array_size_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.array_size)
}

// optional int32 layout = 5;
inline bool ShaderInterfaceBlockProto::has_layout() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_layout()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void ShaderInterfaceBlockProto::clear_has_layout()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void ShaderInterfaceBlockProto::clear_layout()
{
    layout_ = 0;
    clear_has_layout();
}
inline ::google::protobuf::int32 ShaderInterfaceBlockProto::layout() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.layout)
    return layout_;
}
inline void ShaderInterfaceBlockProto::set_layout(::google::protobuf::int32 value)
{
    set_has_layout();
    layout_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.layout)
}

// optional bool is_row_major_layout = 6;
inline bool ShaderInterfaceBlockProto::has_is_row_major_layout() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_is_row_major_layout()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void ShaderInterfaceBlockProto::clear_has_is_row_major_layout()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void ShaderInterfaceBlockProto::clear_is_row_major_layout()
{
    is_row_major_layout_ = false;
    clear_has_is_row_major_layout();
}
inline bool ShaderInterfaceBlockProto::is_row_major_layout() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.is_row_major_layout)
    return is_row_major_layout_;
}
inline void ShaderInterfaceBlockProto::set_is_row_major_layout(bool value)
{
    set_has_is_row_major_layout();
    is_row_major_layout_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.is_row_major_layout)
}

// optional bool static_use = 7;
inline bool ShaderInterfaceBlockProto::has_static_use() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_static_use()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void ShaderInterfaceBlockProto::clear_has_static_use()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void ShaderInterfaceBlockProto::clear_static_use()
{
    static_use_ = false;
    clear_has_static_use();
}
inline bool ShaderInterfaceBlockProto::static_use() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.static_use)
    return static_use_;
}
inline void ShaderInterfaceBlockProto::set_static_use(bool value)
{
    set_has_static_use();
    static_use_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.static_use)
}

// repeated .ShaderInterfaceBlockFieldProto fields = 8;
inline int ShaderInterfaceBlockProto::fields_size() const
{
    return fields_.size();
}
inline void ShaderInterfaceBlockProto::clear_fields()
{
    fields_.Clear();
}
inline const ::ShaderInterfaceBlockFieldProto& ShaderInterfaceBlockProto::fields(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.fields)
    return fields_.Get(index);
}
inline ::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::mutable_fields(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.fields)
    return fields_.Mutable(index);
}
inline ::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::add_fields()
{
    // @@protoc_insertion_point(field_add:ShaderInterfaceBlockProto.fields)
    return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockFieldProto>*
ShaderInterfaceBlockProto::mutable_fields()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderInterfaceBlockProto.fields)
    return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockFieldProto>&
ShaderInterfaceBlockProto::fields() const
{
    // @@protoc_insertion_point(field_list:ShaderInterfaceBlockProto.fields)
    return fields_;
}

// -------------------------------------------------------------------

// ShaderProto

// optional bytes sha = 1;
inline bool ShaderProto::has_sha() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderProto::set_has_sha()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderProto::clear_has_sha()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderProto::clear_sha()
{
    sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_sha();
}
inline const ::std::string& ShaderProto::sha() const
{
    // @@protoc_insertion_point(field_get:ShaderProto.sha)
    return sha_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderProto::set_sha(const ::std::string& value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderProto.sha)
}
inline void ShaderProto::set_sha(const char* value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderProto.sha)
}
inline void ShaderProto::set_sha(const void* value, size_t size)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderProto.sha)
}
inline ::std::string* ShaderProto::mutable_sha()
{
    set_has_sha();
    // @@protoc_insertion_point(field_mutable:ShaderProto.sha)
    return sha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderProto::release_sha()
{
    // @@protoc_insertion_point(field_release:ShaderProto.sha)
    clear_has_sha();
    return sha_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderProto::set_allocated_sha(::std::string* sha)
{
    if (sha != NULL) {
        set_has_sha();
    } else {
        clear_has_sha();
    }
    sha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha);
    // @@protoc_insertion_point(field_set_allocated:ShaderProto.sha)
}

// repeated .ShaderAttributeProto attribs = 2;
inline int ShaderProto::attribs_size() const
{
    return attribs_.size();
}
inline void ShaderProto::clear_attribs()
{
    attribs_.Clear();
}
inline const ::ShaderAttributeProto& ShaderProto::attribs(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.attribs)
    return attribs_.Get(index);
}
inline ::ShaderAttributeProto* ShaderProto::mutable_attribs(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.attribs)
    return attribs_.Mutable(index);
}
inline ::ShaderAttributeProto* ShaderProto::add_attribs()
{
    // @@protoc_insertion_point(field_add:ShaderProto.attribs)
    return attribs_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>*
ShaderProto::mutable_attribs()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.attribs)
    return &attribs_;
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>&
ShaderProto::attribs() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.attribs)
    return attribs_;
}

// repeated .ShaderUniformProto uniforms = 3;
inline int ShaderProto::uniforms_size() const
{
    return uniforms_.size();
}
inline void ShaderProto::clear_uniforms()
{
    uniforms_.Clear();
}
inline const ::ShaderUniformProto& ShaderProto::uniforms(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.uniforms)
    return uniforms_.Get(index);
}
inline ::ShaderUniformProto* ShaderProto::mutable_uniforms(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.uniforms)
    return uniforms_.Mutable(index);
}
inline ::ShaderUniformProto* ShaderProto::add_uniforms()
{
    // @@protoc_insertion_point(field_add:ShaderProto.uniforms)
    return uniforms_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>*
ShaderProto::mutable_uniforms()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.uniforms)
    return &uniforms_;
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>&
ShaderProto::uniforms() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.uniforms)
    return uniforms_;
}

// repeated .ShaderVaryingProto varyings = 4;
inline int ShaderProto::varyings_size() const
{
    return varyings_.size();
}
inline void ShaderProto::clear_varyings()
{
    varyings_.Clear();
}
inline const ::ShaderVaryingProto& ShaderProto::varyings(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.varyings)
    return varyings_.Get(index);
}
inline ::ShaderVaryingProto* ShaderProto::mutable_varyings(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.varyings)
    return varyings_.Mutable(index);
}
inline ::ShaderVaryingProto* ShaderProto::add_varyings()
{
    // @@protoc_insertion_point(field_add:ShaderProto.varyings)
    return varyings_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>*
ShaderProto::mutable_varyings()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.varyings)
    return &varyings_;
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>&
ShaderProto::varyings() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.varyings)
    return varyings_;
}

// repeated .ShaderOutputVariableProto output_variables = 5;
inline int ShaderProto::output_variables_size() const
{
    return output_variables_.size();
}
inline void ShaderProto::clear_output_variables()
{
    output_variables_.Clear();
}
inline const ::ShaderOutputVariableProto& ShaderProto::output_variables(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.output_variables)
    return output_variables_.Get(index);
}
inline ::ShaderOutputVariableProto* ShaderProto::mutable_output_variables(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.output_variables)
    return output_variables_.Mutable(index);
}
inline ::ShaderOutputVariableProto* ShaderProto::add_output_variables()
{
    // @@protoc_insertion_point(field_add:ShaderProto.output_variables)
    return output_variables_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::ShaderOutputVariableProto>*
ShaderProto::mutable_output_variables()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.output_variables)
    return &output_variables_;
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderOutputVariableProto>&
ShaderProto::output_variables() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.output_variables)
    return output_variables_;
}

// repeated .ShaderInterfaceBlockProto interface_blocks = 6;
inline int ShaderProto::interface_blocks_size() const
{
    return interface_blocks_.size();
}
inline void ShaderProto::clear_interface_blocks()
{
    interface_blocks_.Clear();
}
inline const ::ShaderInterfaceBlockProto& ShaderProto::interface_blocks(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.interface_blocks)
    return interface_blocks_.Get(index);
}
inline ::ShaderInterfaceBlockProto* ShaderProto::mutable_interface_blocks(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.interface_blocks)
    return interface_blocks_.Mutable(index);
}
inline ::ShaderInterfaceBlockProto* ShaderProto::add_interface_blocks()
{
    // @@protoc_insertion_point(field_add:ShaderProto.interface_blocks)
    return interface_blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockProto>*
ShaderProto::mutable_interface_blocks()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.interface_blocks)
    return &interface_blocks_;
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockProto>&
ShaderProto::interface_blocks() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.interface_blocks)
    return interface_blocks_;
}

// -------------------------------------------------------------------

// GpuProgramProto

// optional bytes sha = 1;
inline bool GpuProgramProto::has_sha() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuProgramProto::set_has_sha()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void GpuProgramProto::clear_has_sha()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void GpuProgramProto::clear_sha()
{
    sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_sha();
}
inline const ::std::string& GpuProgramProto::sha() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.sha)
    return sha_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuProgramProto::set_sha(const ::std::string& value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:GpuProgramProto.sha)
}
inline void GpuProgramProto::set_sha(const char* value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:GpuProgramProto.sha)
}
inline void GpuProgramProto::set_sha(const void* value, size_t size)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:GpuProgramProto.sha)
}
inline ::std::string* GpuProgramProto::mutable_sha()
{
    set_has_sha();
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.sha)
    return sha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuProgramProto::release_sha()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.sha)
    clear_has_sha();
    return sha_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuProgramProto::set_allocated_sha(::std::string* sha)
{
    if (sha != NULL) {
        set_has_sha();
    } else {
        clear_has_sha();
    }
    sha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha);
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.sha)
}

// optional uint32 format = 2;
inline bool GpuProgramProto::has_format() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuProgramProto::set_has_format()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void GpuProgramProto::clear_has_format()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void GpuProgramProto::clear_format()
{
    format_ = 0u;
    clear_has_format();
}
inline ::google::protobuf::uint32 GpuProgramProto::format() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.format)
    return format_;
}
inline void GpuProgramProto::set_format(::google::protobuf::uint32 value)
{
    set_has_format();
    format_ = value;
    // @@protoc_insertion_point(field_set:GpuProgramProto.format)
}

// optional bytes program = 3;
inline bool GpuProgramProto::has_program() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuProgramProto::set_has_program()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void GpuProgramProto::clear_has_program()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void GpuProgramProto::clear_program()
{
    program_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_program();
}
inline const ::std::string& GpuProgramProto::program() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.program)
    return program_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuProgramProto::set_program(const ::std::string& value)
{
    set_has_program();
    program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:GpuProgramProto.program)
}
inline void GpuProgramProto::set_program(const char* value)
{
    set_has_program();
    program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:GpuProgramProto.program)
}
inline void GpuProgramProto::set_program(const void* value, size_t size)
{
    set_has_program();
    program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:GpuProgramProto.program)
}
inline ::std::string* GpuProgramProto::mutable_program()
{
    set_has_program();
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.program)
    return program_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuProgramProto::release_program()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.program)
    clear_has_program();
    return program_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuProgramProto::set_allocated_program(::std::string* program)
{
    if (program != NULL) {
        set_has_program();
    } else {
        clear_has_program();
    }
    program_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), program);
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.program)
}

// optional .ShaderProto vertex_shader = 4;
inline bool GpuProgramProto::has_vertex_shader() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuProgramProto::set_has_vertex_shader()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void GpuProgramProto::clear_has_vertex_shader()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void GpuProgramProto::clear_vertex_shader()
{
    if (vertex_shader_ != NULL)
        vertex_shader_->::ShaderProto::Clear();
    clear_has_vertex_shader();
}
inline const ::ShaderProto& GpuProgramProto::vertex_shader() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.vertex_shader)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance().vertex_shader_;
#else
    return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance_->vertex_shader_;
#endif
}
inline ::ShaderProto* GpuProgramProto::mutable_vertex_shader()
{
    set_has_vertex_shader();
    if (vertex_shader_ == NULL) {
        vertex_shader_ = new ::ShaderProto;
    }
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.vertex_shader)
    return vertex_shader_;
}
inline ::ShaderProto* GpuProgramProto::release_vertex_shader()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.vertex_shader)
    clear_has_vertex_shader();
    ::ShaderProto* temp = vertex_shader_;
    vertex_shader_ = NULL;
    return temp;
}
inline void GpuProgramProto::set_allocated_vertex_shader(::ShaderProto* vertex_shader)
{
    delete vertex_shader_;
    vertex_shader_ = vertex_shader;
    if (vertex_shader) {
        set_has_vertex_shader();
    } else {
        clear_has_vertex_shader();
    }
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.vertex_shader)
}

// optional .ShaderProto fragment_shader = 5;
inline bool GpuProgramProto::has_fragment_shader() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpuProgramProto::set_has_fragment_shader()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void GpuProgramProto::clear_has_fragment_shader()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void GpuProgramProto::clear_fragment_shader()
{
    if (fragment_shader_ != NULL)
        fragment_shader_->::ShaderProto::Clear();
    clear_has_fragment_shader();
}
inline const ::ShaderProto& GpuProgramProto::fragment_shader() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.fragment_shader)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance().fragment_shader_;
#else
    return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance_->fragment_shader_;
#endif
}
inline ::ShaderProto* GpuProgramProto::mutable_fragment_shader()
{
    set_has_fragment_shader();
    if (fragment_shader_ == NULL) {
        fragment_shader_ = new ::ShaderProto;
    }
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.fragment_shader)
    return fragment_shader_;
}
inline ::ShaderProto* GpuProgramProto::release_fragment_shader()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.fragment_shader)
    clear_has_fragment_shader();
    ::ShaderProto* temp = fragment_shader_;
    fragment_shader_ = NULL;
    return temp;
}
inline void GpuProgramProto::set_allocated_fragment_shader(::ShaderProto* fragment_shader)
{
    delete fragment_shader_;
    fragment_shader_ = fragment_shader;
    if (fragment_shader) {
        set_has_fragment_shader();
    } else {
        clear_has_fragment_shader();
    }
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.fragment_shader)
}

#endif // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED
