// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: disk_cache_proto.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "disk_cache_proto.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto()
{
    delete ShaderVariableProto::default_instance_;
    delete ShaderAttributeProto::default_instance_;
    delete ShaderUniformProto::default_instance_;
    delete ShaderVaryingProto::default_instance_;
    delete ShaderOutputVariableProto::default_instance_;
    delete ShaderInterfaceBlockFieldProto::default_instance_;
    delete ShaderInterfaceBlockProto::default_instance_;
    delete ShaderProto::default_instance_;
    delete GpuProgramProto::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl()
{
    GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_disk_5fcache_5fproto_2eproto()
{
    static bool already_here = false;
    if (already_here)
        return;
    already_here = true;
    GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
    ShaderVariableProto::default_instance_ = new ShaderVariableProto();
    ShaderAttributeProto::default_instance_ = new ShaderAttributeProto();
    ShaderUniformProto::default_instance_ = new ShaderUniformProto();
    ShaderVaryingProto::default_instance_ = new ShaderVaryingProto();
    ShaderOutputVariableProto::default_instance_ = new ShaderOutputVariableProto();
    ShaderInterfaceBlockFieldProto::default_instance_ = new ShaderInterfaceBlockFieldProto();
    ShaderInterfaceBlockProto::default_instance_ = new ShaderInterfaceBlockProto();
    ShaderProto::default_instance_ = new ShaderProto();
    GpuProgramProto::default_instance_ = new GpuProgramProto();
    ShaderVariableProto::default_instance_->InitAsDefaultInstance();
    ShaderAttributeProto::default_instance_->InitAsDefaultInstance();
    ShaderUniformProto::default_instance_->InitAsDefaultInstance();
    ShaderVaryingProto::default_instance_->InitAsDefaultInstance();
    ShaderOutputVariableProto::default_instance_->InitAsDefaultInstance();
    ShaderInterfaceBlockFieldProto::default_instance_->InitAsDefaultInstance();
    ShaderInterfaceBlockProto::default_instance_->InitAsDefaultInstance();
    ShaderProto::default_instance_->InitAsDefaultInstance();
    GpuProgramProto::default_instance_->InitAsDefaultInstance();
    ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_disk_5fcache_5fproto_2eproto_once_);
void protobuf_AddDesc_disk_5fcache_5fproto_2eproto()
{
    ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_disk_5fcache_5fproto_2eproto_once_,
        &protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_disk_5fcache_5fproto_2eproto {
    StaticDescriptorInitializer_disk_5fcache_5fproto_2eproto()
    {
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
    }
} static_descriptor_initializer_disk_5fcache_5fproto_2eproto_;
#endif

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line)
{
    GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

} // namespace

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderVariableProto(
    ShaderVariableProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderVariableProto::kTypeFieldNumber;
const int ShaderVariableProto::kPrecisionFieldNumber;
const int ShaderVariableProto::kNameFieldNumber;
const int ShaderVariableProto::kMappedNameFieldNumber;
const int ShaderVariableProto::kArraySizeFieldNumber;
const int ShaderVariableProto::kStaticUseFieldNumber;
const int ShaderVariableProto::kFieldsFieldNumber;
const int ShaderVariableProto::kStructNameFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderVariableProto::ShaderVariableProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderVariableProto)
}

void ShaderVariableProto::InitAsDefaultInstance()
{
}

ShaderVariableProto::ShaderVariableProto(const ShaderVariableProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderVariableProto)
}

void ShaderVariableProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    type_ = 0u;
    precision_ = 0u;
    name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    mapped_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    array_size_ = 0u;
    static_use_ = false;
    struct_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderVariableProto::~ShaderVariableProto()
{
    // @@protoc_insertion_point(destructor:ShaderVariableProto)
    SharedDtor();
}

void ShaderVariableProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    mapped_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    struct_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ShaderVariableProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderVariableProto& ShaderVariableProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderVariableProto* ShaderVariableProto::default_instance_ = NULL;

ShaderVariableProto* ShaderVariableProto::New(::google::protobuf::Arena* arena) const
{
    ShaderVariableProto* n = new ShaderVariableProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderVariableProto::Clear()
{
// @@protoc_insertion_point(message_clear_start:ShaderVariableProto)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                         \
    _Pragma("clang diagnostic push")                                                                          \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ShaderVariableProto, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ShaderVariableProto*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 191u) {
        ZR_(type_, precision_);
        ZR_(array_size_, static_use_);
        if (has_name()) {
            name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_mapped_name()) {
            mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_struct_name()) {
            struct_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }

#undef ZR_HELPER_
#undef ZR_

    fields_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderVariableProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderVariableProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderVariableProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional uint32 type = 1;
        case 1: {
            if (tag == 8) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                    input, &type_)));
                set_has_type();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_precision;
            break;
        }

        // optional uint32 precision = 2;
        case 2: {
            if (tag == 16) {
            parse_precision:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                    input, &precision_)));
                set_has_precision();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_name;
            break;
        }

        // optional string name = 3;
        case 3: {
            if (tag == 26) {
            parse_name:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_name()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_mapped_name;
            break;
        }

        // optional string mapped_name = 4;
        case 4: {
            if (tag == 34) {
            parse_mapped_name:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_mapped_name()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(40))
                goto parse_array_size;
            break;
        }

        // optional uint32 array_size = 5;
        case 5: {
            if (tag == 40) {
            parse_array_size:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                    input, &array_size_)));
                set_has_array_size();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(48))
                goto parse_static_use;
            break;
        }

        // optional bool static_use = 6;
        case 6: {
            if (tag == 48) {
            parse_static_use:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                    input, &static_use_)));
                set_has_static_use();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(58))
                goto parse_fields;
            break;
        }

        // repeated .ShaderVariableProto fields = 7;
        case 7: {
            if (tag == 58) {
            parse_fields:
                DO_(input->IncrementRecursionDepth());
            parse_loop_fields:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_fields()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(58))
                goto parse_loop_fields;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectTag(66))
                goto parse_struct_name;
            break;
        }

        // optional string struct_name = 8;
        case 8: {
            if (tag == 66) {
            parse_struct_name:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_struct_name()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderVariableProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderVariableProto)
    return false;
#undef DO_
}

void ShaderVariableProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderVariableProto)
    // optional uint32 type = 1;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
    }

    // optional uint32 precision = 2;
    if (has_precision()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->precision(), output);
    }

    // optional string name = 3;
    if (has_name()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            3, this->name(), output);
    }

    // optional string mapped_name = 4;
    if (has_mapped_name()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            4, this->mapped_name(), output);
    }

    // optional uint32 array_size = 5;
    if (has_array_size()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->array_size(), output);
    }

    // optional bool static_use = 6;
    if (has_static_use()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->static_use(), output);
    }

    // repeated .ShaderVariableProto fields = 7;
    for (unsigned int i = 0, n = this->fields_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            7, this->fields(i), output);
    }

    // optional string struct_name = 8;
    if (has_struct_name()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            8, this->struct_name(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderVariableProto)
}

int ShaderVariableProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderVariableProto)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 191u) {
        // optional uint32 type = 1;
        if (has_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->type());
        }

        // optional uint32 precision = 2;
        if (has_precision()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->precision());
        }

        // optional string name = 3;
        if (has_name()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->name());
        }

        // optional string mapped_name = 4;
        if (has_mapped_name()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->mapped_name());
        }

        // optional uint32 array_size = 5;
        if (has_array_size()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->array_size());
        }

        // optional bool static_use = 6;
        if (has_static_use()) {
            total_size += 1 + 1;
        }

        // optional string struct_name = 8;
        if (has_struct_name()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->struct_name());
        }
    }
    // repeated .ShaderVariableProto fields = 7;
    total_size += 1 * this->fields_size();
    for (int i = 0; i < this->fields_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->fields(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderVariableProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderVariableProto*>(&from));
}

void ShaderVariableProto::MergeFrom(const ShaderVariableProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderVariableProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    fields_.MergeFrom(from.fields_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_type()) {
            set_type(from.type());
        }
        if (from.has_precision()) {
            set_precision(from.precision());
        }
        if (from.has_name()) {
            set_has_name();
            name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
        }
        if (from.has_mapped_name()) {
            set_has_mapped_name();
            mapped_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapped_name_);
        }
        if (from.has_array_size()) {
            set_array_size(from.array_size());
        }
        if (from.has_static_use()) {
            set_static_use(from.static_use());
        }
        if (from.has_struct_name()) {
            set_has_struct_name();
            struct_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.struct_name_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderVariableProto::CopyFrom(const ShaderVariableProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderVariableProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderVariableProto::IsInitialized() const
{

    return true;
}

void ShaderVariableProto::Swap(ShaderVariableProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderVariableProto::InternalSwap(ShaderVariableProto* other)
{
    std::swap(type_, other->type_);
    std::swap(precision_, other->precision_);
    name_.Swap(&other->name_);
    mapped_name_.Swap(&other->mapped_name_);
    std::swap(array_size_, other->array_size_);
    std::swap(static_use_, other->static_use_);
    fields_.UnsafeArenaSwap(&other->fields_);
    struct_name_.Swap(&other->struct_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderVariableProto::GetTypeName() const
{
    return "ShaderVariableProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderVariableProto

// optional uint32 type = 1;
bool ShaderVariableProto::has_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderVariableProto::set_has_type()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderVariableProto::clear_has_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderVariableProto::clear_type()
{
    type_ = 0u;
    clear_has_type();
}
::google::protobuf::uint32 ShaderVariableProto::type() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.type)
    return type_;
}
void ShaderVariableProto::set_type(::google::protobuf::uint32 value)
{
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.type)
}

// optional uint32 precision = 2;
bool ShaderVariableProto::has_precision() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ShaderVariableProto::set_has_precision()
{
    _has_bits_[0] |= 0x00000002u;
}
void ShaderVariableProto::clear_has_precision()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ShaderVariableProto::clear_precision()
{
    precision_ = 0u;
    clear_has_precision();
}
::google::protobuf::uint32 ShaderVariableProto::precision() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.precision)
    return precision_;
}
void ShaderVariableProto::set_precision(::google::protobuf::uint32 value)
{
    set_has_precision();
    precision_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.precision)
}

// optional string name = 3;
bool ShaderVariableProto::has_name() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ShaderVariableProto::set_has_name()
{
    _has_bits_[0] |= 0x00000004u;
}
void ShaderVariableProto::clear_has_name()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ShaderVariableProto::clear_name()
{
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_name();
}
const ::std::string& ShaderVariableProto::name() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.name)
    return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderVariableProto::set_name(const ::std::string& value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderVariableProto.name)
}
void ShaderVariableProto::set_name(const char* value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderVariableProto.name)
}
void ShaderVariableProto::set_name(const char* value, size_t size)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.name)
}
::std::string* ShaderVariableProto::mutable_name()
{
    set_has_name();
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.name)
    return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShaderVariableProto::release_name()
{
    // @@protoc_insertion_point(field_release:ShaderVariableProto.name)
    clear_has_name();
    return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderVariableProto::set_allocated_name(::std::string* name)
{
    if (name != NULL) {
        set_has_name();
    } else {
        clear_has_name();
    }
    name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
    // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.name)
}

// optional string mapped_name = 4;
bool ShaderVariableProto::has_mapped_name() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void ShaderVariableProto::set_has_mapped_name()
{
    _has_bits_[0] |= 0x00000008u;
}
void ShaderVariableProto::clear_has_mapped_name()
{
    _has_bits_[0] &= ~0x00000008u;
}
void ShaderVariableProto::clear_mapped_name()
{
    mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_mapped_name();
}
const ::std::string& ShaderVariableProto::mapped_name() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.mapped_name)
    return mapped_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderVariableProto::set_mapped_name(const ::std::string& value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderVariableProto.mapped_name)
}
void ShaderVariableProto::set_mapped_name(const char* value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderVariableProto.mapped_name)
}
void ShaderVariableProto::set_mapped_name(const char* value, size_t size)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.mapped_name)
}
::std::string* ShaderVariableProto::mutable_mapped_name()
{
    set_has_mapped_name();
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.mapped_name)
    return mapped_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShaderVariableProto::release_mapped_name()
{
    // @@protoc_insertion_point(field_release:ShaderVariableProto.mapped_name)
    clear_has_mapped_name();
    return mapped_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderVariableProto::set_allocated_mapped_name(::std::string* mapped_name)
{
    if (mapped_name != NULL) {
        set_has_mapped_name();
    } else {
        clear_has_mapped_name();
    }
    mapped_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapped_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.mapped_name)
}

// optional uint32 array_size = 5;
bool ShaderVariableProto::has_array_size() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
void ShaderVariableProto::set_has_array_size()
{
    _has_bits_[0] |= 0x00000010u;
}
void ShaderVariableProto::clear_has_array_size()
{
    _has_bits_[0] &= ~0x00000010u;
}
void ShaderVariableProto::clear_array_size()
{
    array_size_ = 0u;
    clear_has_array_size();
}
::google::protobuf::uint32 ShaderVariableProto::array_size() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.array_size)
    return array_size_;
}
void ShaderVariableProto::set_array_size(::google::protobuf::uint32 value)
{
    set_has_array_size();
    array_size_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.array_size)
}

// optional bool static_use = 6;
bool ShaderVariableProto::has_static_use() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
void ShaderVariableProto::set_has_static_use()
{
    _has_bits_[0] |= 0x00000020u;
}
void ShaderVariableProto::clear_has_static_use()
{
    _has_bits_[0] &= ~0x00000020u;
}
void ShaderVariableProto::clear_static_use()
{
    static_use_ = false;
    clear_has_static_use();
}
bool ShaderVariableProto::static_use() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.static_use)
    return static_use_;
}
void ShaderVariableProto::set_static_use(bool value)
{
    set_has_static_use();
    static_use_ = value;
    // @@protoc_insertion_point(field_set:ShaderVariableProto.static_use)
}

// repeated .ShaderVariableProto fields = 7;
int ShaderVariableProto::fields_size() const
{
    return fields_.size();
}
void ShaderVariableProto::clear_fields()
{
    fields_.Clear();
}
const ::ShaderVariableProto& ShaderVariableProto::fields(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.fields)
    return fields_.Get(index);
}
::ShaderVariableProto* ShaderVariableProto::mutable_fields(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.fields)
    return fields_.Mutable(index);
}
::ShaderVariableProto* ShaderVariableProto::add_fields()
{
    // @@protoc_insertion_point(field_add:ShaderVariableProto.fields)
    return fields_.Add();
}
::google::protobuf::RepeatedPtrField<::ShaderVariableProto>*
ShaderVariableProto::mutable_fields()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderVariableProto.fields)
    return &fields_;
}
const ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>&
ShaderVariableProto::fields() const
{
    // @@protoc_insertion_point(field_list:ShaderVariableProto.fields)
    return fields_;
}

// optional string struct_name = 8;
bool ShaderVariableProto::has_struct_name() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
void ShaderVariableProto::set_has_struct_name()
{
    _has_bits_[0] |= 0x00000080u;
}
void ShaderVariableProto::clear_has_struct_name()
{
    _has_bits_[0] &= ~0x00000080u;
}
void ShaderVariableProto::clear_struct_name()
{
    struct_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_struct_name();
}
const ::std::string& ShaderVariableProto::struct_name() const
{
    // @@protoc_insertion_point(field_get:ShaderVariableProto.struct_name)
    return struct_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderVariableProto::set_struct_name(const ::std::string& value)
{
    set_has_struct_name();
    struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderVariableProto.struct_name)
}
void ShaderVariableProto::set_struct_name(const char* value)
{
    set_has_struct_name();
    struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderVariableProto.struct_name)
}
void ShaderVariableProto::set_struct_name(const char* value, size_t size)
{
    set_has_struct_name();
    struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.struct_name)
}
::std::string* ShaderVariableProto::mutable_struct_name()
{
    set_has_struct_name();
    // @@protoc_insertion_point(field_mutable:ShaderVariableProto.struct_name)
    return struct_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShaderVariableProto::release_struct_name()
{
    // @@protoc_insertion_point(field_release:ShaderVariableProto.struct_name)
    clear_has_struct_name();
    return struct_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderVariableProto::set_allocated_struct_name(::std::string* struct_name)
{
    if (struct_name != NULL) {
        set_has_struct_name();
    } else {
        clear_has_struct_name();
    }
    struct_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), struct_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.struct_name)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderAttributeProto(
    ShaderAttributeProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderAttributeProto::kBasicFieldNumber;
const int ShaderAttributeProto::kLocationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderAttributeProto::ShaderAttributeProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderAttributeProto)
}

void ShaderAttributeProto::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    basic_ = const_cast<::ShaderVariableProto*>(
        ::ShaderVariableProto::internal_default_instance());
#else
    basic_ = const_cast<::ShaderVariableProto*>(&::ShaderVariableProto::default_instance());
#endif
}

ShaderAttributeProto::ShaderAttributeProto(const ShaderAttributeProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderAttributeProto)
}

void ShaderAttributeProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    basic_ = NULL;
    location_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderAttributeProto::~ShaderAttributeProto()
{
    // @@protoc_insertion_point(destructor:ShaderAttributeProto)
    SharedDtor();
}

void ShaderAttributeProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete basic_;
    }
}

void ShaderAttributeProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderAttributeProto& ShaderAttributeProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderAttributeProto* ShaderAttributeProto::default_instance_ = NULL;

ShaderAttributeProto* ShaderAttributeProto::New(::google::protobuf::Arena* arena) const
{
    ShaderAttributeProto* n = new ShaderAttributeProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderAttributeProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderAttributeProto)
    if (_has_bits_[0 / 32] & 3u) {
        if (has_basic()) {
            if (basic_ != NULL)
                basic_->::ShaderVariableProto::Clear();
        }
        location_ = 0;
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderAttributeProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderAttributeProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderAttributeProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .ShaderVariableProto basic = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_basic()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_location;
            break;
        }

        // optional int32 location = 2;
        case 2: {
            if (tag == 16) {
            parse_location:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &location_)));
                set_has_location();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderAttributeProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderAttributeProto)
    return false;
#undef DO_
}

void ShaderAttributeProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderAttributeProto)
    // optional .ShaderVariableProto basic = 1;
    if (has_basic()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->basic_, output);
    }

    // optional int32 location = 2;
    if (has_location()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->location(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderAttributeProto)
}

int ShaderAttributeProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderAttributeProto)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional .ShaderVariableProto basic = 1;
        if (has_basic()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->basic_);
        }

        // optional int32 location = 2;
        if (has_location()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->location());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderAttributeProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderAttributeProto*>(&from));
}

void ShaderAttributeProto::MergeFrom(const ShaderAttributeProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderAttributeProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_basic()) {
            mutable_basic()->::ShaderVariableProto::MergeFrom(from.basic());
        }
        if (from.has_location()) {
            set_location(from.location());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderAttributeProto::CopyFrom(const ShaderAttributeProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderAttributeProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderAttributeProto::IsInitialized() const
{

    return true;
}

void ShaderAttributeProto::Swap(ShaderAttributeProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderAttributeProto::InternalSwap(ShaderAttributeProto* other)
{
    std::swap(basic_, other->basic_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderAttributeProto::GetTypeName() const
{
    return "ShaderAttributeProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderAttributeProto

// optional .ShaderVariableProto basic = 1;
bool ShaderAttributeProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderAttributeProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderAttributeProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderAttributeProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
const ::ShaderVariableProto& ShaderAttributeProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderAttributeProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
::ShaderVariableProto* ShaderAttributeProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderAttributeProto.basic)
    return basic_;
}
::ShaderVariableProto* ShaderAttributeProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderAttributeProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
void ShaderAttributeProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderAttributeProto.basic)
}

// optional int32 location = 2;
bool ShaderAttributeProto::has_location() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ShaderAttributeProto::set_has_location()
{
    _has_bits_[0] |= 0x00000002u;
}
void ShaderAttributeProto::clear_has_location()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ShaderAttributeProto::clear_location()
{
    location_ = 0;
    clear_has_location();
}
::google::protobuf::int32 ShaderAttributeProto::location() const
{
    // @@protoc_insertion_point(field_get:ShaderAttributeProto.location)
    return location_;
}
void ShaderAttributeProto::set_location(::google::protobuf::int32 value)
{
    set_has_location();
    location_ = value;
    // @@protoc_insertion_point(field_set:ShaderAttributeProto.location)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderUniformProto(
    ShaderUniformProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderUniformProto::kBasicFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderUniformProto::ShaderUniformProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderUniformProto)
}

void ShaderUniformProto::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    basic_ = const_cast<::ShaderVariableProto*>(
        ::ShaderVariableProto::internal_default_instance());
#else
    basic_ = const_cast<::ShaderVariableProto*>(&::ShaderVariableProto::default_instance());
#endif
}

ShaderUniformProto::ShaderUniformProto(const ShaderUniformProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderUniformProto)
}

void ShaderUniformProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    basic_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderUniformProto::~ShaderUniformProto()
{
    // @@protoc_insertion_point(destructor:ShaderUniformProto)
    SharedDtor();
}

void ShaderUniformProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete basic_;
    }
}

void ShaderUniformProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderUniformProto& ShaderUniformProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderUniformProto* ShaderUniformProto::default_instance_ = NULL;

ShaderUniformProto* ShaderUniformProto::New(::google::protobuf::Arena* arena) const
{
    ShaderUniformProto* n = new ShaderUniformProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderUniformProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderUniformProto)
    if (has_basic()) {
        if (basic_ != NULL)
            basic_->::ShaderVariableProto::Clear();
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderUniformProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderUniformProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderUniformProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .ShaderVariableProto basic = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_basic()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderUniformProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderUniformProto)
    return false;
#undef DO_
}

void ShaderUniformProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderUniformProto)
    // optional .ShaderVariableProto basic = 1;
    if (has_basic()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->basic_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderUniformProto)
}

int ShaderUniformProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderUniformProto)
    int total_size = 0;

    // optional .ShaderVariableProto basic = 1;
    if (has_basic()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->basic_);
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderUniformProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderUniformProto*>(&from));
}

void ShaderUniformProto::MergeFrom(const ShaderUniformProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderUniformProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_basic()) {
            mutable_basic()->::ShaderVariableProto::MergeFrom(from.basic());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderUniformProto::CopyFrom(const ShaderUniformProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderUniformProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderUniformProto::IsInitialized() const
{

    return true;
}

void ShaderUniformProto::Swap(ShaderUniformProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderUniformProto::InternalSwap(ShaderUniformProto* other)
{
    std::swap(basic_, other->basic_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderUniformProto::GetTypeName() const
{
    return "ShaderUniformProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderUniformProto

// optional .ShaderVariableProto basic = 1;
bool ShaderUniformProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderUniformProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderUniformProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderUniformProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
const ::ShaderVariableProto& ShaderUniformProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderUniformProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
::ShaderVariableProto* ShaderUniformProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderUniformProto.basic)
    return basic_;
}
::ShaderVariableProto* ShaderUniformProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderUniformProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
void ShaderUniformProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderUniformProto.basic)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderVaryingProto(
    ShaderVaryingProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderVaryingProto::kBasicFieldNumber;
const int ShaderVaryingProto::kInterpolationFieldNumber;
const int ShaderVaryingProto::kIsInvariantFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderVaryingProto::ShaderVaryingProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderVaryingProto)
}

void ShaderVaryingProto::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    basic_ = const_cast<::ShaderVariableProto*>(
        ::ShaderVariableProto::internal_default_instance());
#else
    basic_ = const_cast<::ShaderVariableProto*>(&::ShaderVariableProto::default_instance());
#endif
}

ShaderVaryingProto::ShaderVaryingProto(const ShaderVaryingProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderVaryingProto)
}

void ShaderVaryingProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    basic_ = NULL;
    interpolation_ = 0;
    is_invariant_ = false;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderVaryingProto::~ShaderVaryingProto()
{
    // @@protoc_insertion_point(destructor:ShaderVaryingProto)
    SharedDtor();
}

void ShaderVaryingProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete basic_;
    }
}

void ShaderVaryingProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderVaryingProto& ShaderVaryingProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderVaryingProto* ShaderVaryingProto::default_instance_ = NULL;

ShaderVaryingProto* ShaderVaryingProto::New(::google::protobuf::Arena* arena) const
{
    ShaderVaryingProto* n = new ShaderVaryingProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderVaryingProto::Clear()
{
// @@protoc_insertion_point(message_clear_start:ShaderVaryingProto)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                        \
    _Pragma("clang diagnostic push")                                                                         \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ShaderVaryingProto, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ShaderVaryingProto*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 7u) {
        ZR_(interpolation_, is_invariant_);
        if (has_basic()) {
            if (basic_ != NULL)
                basic_->::ShaderVariableProto::Clear();
        }
    }

#undef ZR_HELPER_
#undef ZR_

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderVaryingProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderVaryingProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderVaryingProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .ShaderVariableProto basic = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_basic()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_interpolation;
            break;
        }

        // optional int32 interpolation = 2;
        case 2: {
            if (tag == 16) {
            parse_interpolation:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &interpolation_)));
                set_has_interpolation();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(24))
                goto parse_is_invariant;
            break;
        }

        // optional bool is_invariant = 3;
        case 3: {
            if (tag == 24) {
            parse_is_invariant:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                    input, &is_invariant_)));
                set_has_is_invariant();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderVaryingProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderVaryingProto)
    return false;
#undef DO_
}

void ShaderVaryingProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderVaryingProto)
    // optional .ShaderVariableProto basic = 1;
    if (has_basic()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->basic_, output);
    }

    // optional int32 interpolation = 2;
    if (has_interpolation()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interpolation(), output);
    }

    // optional bool is_invariant = 3;
    if (has_is_invariant()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_invariant(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderVaryingProto)
}

int ShaderVaryingProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderVaryingProto)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 7u) {
        // optional .ShaderVariableProto basic = 1;
        if (has_basic()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->basic_);
        }

        // optional int32 interpolation = 2;
        if (has_interpolation()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->interpolation());
        }

        // optional bool is_invariant = 3;
        if (has_is_invariant()) {
            total_size += 1 + 1;
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderVaryingProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderVaryingProto*>(&from));
}

void ShaderVaryingProto::MergeFrom(const ShaderVaryingProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderVaryingProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_basic()) {
            mutable_basic()->::ShaderVariableProto::MergeFrom(from.basic());
        }
        if (from.has_interpolation()) {
            set_interpolation(from.interpolation());
        }
        if (from.has_is_invariant()) {
            set_is_invariant(from.is_invariant());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderVaryingProto::CopyFrom(const ShaderVaryingProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderVaryingProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderVaryingProto::IsInitialized() const
{

    return true;
}

void ShaderVaryingProto::Swap(ShaderVaryingProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderVaryingProto::InternalSwap(ShaderVaryingProto* other)
{
    std::swap(basic_, other->basic_);
    std::swap(interpolation_, other->interpolation_);
    std::swap(is_invariant_, other->is_invariant_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderVaryingProto::GetTypeName() const
{
    return "ShaderVaryingProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderVaryingProto

// optional .ShaderVariableProto basic = 1;
bool ShaderVaryingProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderVaryingProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderVaryingProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderVaryingProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
const ::ShaderVariableProto& ShaderVaryingProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderVaryingProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
::ShaderVariableProto* ShaderVaryingProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderVaryingProto.basic)
    return basic_;
}
::ShaderVariableProto* ShaderVaryingProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderVaryingProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
void ShaderVaryingProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderVaryingProto.basic)
}

// optional int32 interpolation = 2;
bool ShaderVaryingProto::has_interpolation() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ShaderVaryingProto::set_has_interpolation()
{
    _has_bits_[0] |= 0x00000002u;
}
void ShaderVaryingProto::clear_has_interpolation()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ShaderVaryingProto::clear_interpolation()
{
    interpolation_ = 0;
    clear_has_interpolation();
}
::google::protobuf::int32 ShaderVaryingProto::interpolation() const
{
    // @@protoc_insertion_point(field_get:ShaderVaryingProto.interpolation)
    return interpolation_;
}
void ShaderVaryingProto::set_interpolation(::google::protobuf::int32 value)
{
    set_has_interpolation();
    interpolation_ = value;
    // @@protoc_insertion_point(field_set:ShaderVaryingProto.interpolation)
}

// optional bool is_invariant = 3;
bool ShaderVaryingProto::has_is_invariant() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ShaderVaryingProto::set_has_is_invariant()
{
    _has_bits_[0] |= 0x00000004u;
}
void ShaderVaryingProto::clear_has_is_invariant()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ShaderVaryingProto::clear_is_invariant()
{
    is_invariant_ = false;
    clear_has_is_invariant();
}
bool ShaderVaryingProto::is_invariant() const
{
    // @@protoc_insertion_point(field_get:ShaderVaryingProto.is_invariant)
    return is_invariant_;
}
void ShaderVaryingProto::set_is_invariant(bool value)
{
    set_has_is_invariant();
    is_invariant_ = value;
    // @@protoc_insertion_point(field_set:ShaderVaryingProto.is_invariant)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderOutputVariableProto(
    ShaderOutputVariableProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderOutputVariableProto::kBasicFieldNumber;
const int ShaderOutputVariableProto::kLocationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderOutputVariableProto::ShaderOutputVariableProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderOutputVariableProto)
}

void ShaderOutputVariableProto::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    basic_ = const_cast<::ShaderVariableProto*>(
        ::ShaderVariableProto::internal_default_instance());
#else
    basic_ = const_cast<::ShaderVariableProto*>(&::ShaderVariableProto::default_instance());
#endif
}

ShaderOutputVariableProto::ShaderOutputVariableProto(const ShaderOutputVariableProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderOutputVariableProto)
}

void ShaderOutputVariableProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    basic_ = NULL;
    location_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderOutputVariableProto::~ShaderOutputVariableProto()
{
    // @@protoc_insertion_point(destructor:ShaderOutputVariableProto)
    SharedDtor();
}

void ShaderOutputVariableProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete basic_;
    }
}

void ShaderOutputVariableProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderOutputVariableProto& ShaderOutputVariableProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderOutputVariableProto* ShaderOutputVariableProto::default_instance_ = NULL;

ShaderOutputVariableProto* ShaderOutputVariableProto::New(::google::protobuf::Arena* arena) const
{
    ShaderOutputVariableProto* n = new ShaderOutputVariableProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderOutputVariableProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderOutputVariableProto)
    if (_has_bits_[0 / 32] & 3u) {
        if (has_basic()) {
            if (basic_ != NULL)
                basic_->::ShaderVariableProto::Clear();
        }
        location_ = 0;
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderOutputVariableProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderOutputVariableProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderOutputVariableProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .ShaderVariableProto basic = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_basic()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_location;
            break;
        }

        // optional int32 location = 2;
        case 2: {
            if (tag == 16) {
            parse_location:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &location_)));
                set_has_location();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderOutputVariableProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderOutputVariableProto)
    return false;
#undef DO_
}

void ShaderOutputVariableProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderOutputVariableProto)
    // optional .ShaderVariableProto basic = 1;
    if (has_basic()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->basic_, output);
    }

    // optional int32 location = 2;
    if (has_location()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->location(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderOutputVariableProto)
}

int ShaderOutputVariableProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderOutputVariableProto)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional .ShaderVariableProto basic = 1;
        if (has_basic()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->basic_);
        }

        // optional int32 location = 2;
        if (has_location()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->location());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderOutputVariableProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderOutputVariableProto*>(&from));
}

void ShaderOutputVariableProto::MergeFrom(const ShaderOutputVariableProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderOutputVariableProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_basic()) {
            mutable_basic()->::ShaderVariableProto::MergeFrom(from.basic());
        }
        if (from.has_location()) {
            set_location(from.location());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderOutputVariableProto::CopyFrom(const ShaderOutputVariableProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderOutputVariableProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderOutputVariableProto::IsInitialized() const
{

    return true;
}

void ShaderOutputVariableProto::Swap(ShaderOutputVariableProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderOutputVariableProto::InternalSwap(ShaderOutputVariableProto* other)
{
    std::swap(basic_, other->basic_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderOutputVariableProto::GetTypeName() const
{
    return "ShaderOutputVariableProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderOutputVariableProto

// optional .ShaderVariableProto basic = 1;
bool ShaderOutputVariableProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderOutputVariableProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderOutputVariableProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderOutputVariableProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
const ::ShaderVariableProto& ShaderOutputVariableProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
::ShaderVariableProto* ShaderOutputVariableProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderOutputVariableProto.basic)
    return basic_;
}
::ShaderVariableProto* ShaderOutputVariableProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderOutputVariableProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
void ShaderOutputVariableProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderOutputVariableProto.basic)
}

// optional int32 location = 2;
bool ShaderOutputVariableProto::has_location() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ShaderOutputVariableProto::set_has_location()
{
    _has_bits_[0] |= 0x00000002u;
}
void ShaderOutputVariableProto::clear_has_location()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ShaderOutputVariableProto::clear_location()
{
    location_ = 0;
    clear_has_location();
}
::google::protobuf::int32 ShaderOutputVariableProto::location() const
{
    // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.location)
    return location_;
}
void ShaderOutputVariableProto::set_location(::google::protobuf::int32 value)
{
    set_has_location();
    location_ = value;
    // @@protoc_insertion_point(field_set:ShaderOutputVariableProto.location)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderInterfaceBlockFieldProto(
    ShaderInterfaceBlockFieldProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderInterfaceBlockFieldProto::kBasicFieldNumber;
const int ShaderInterfaceBlockFieldProto::kIsRowMajorLayoutFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderInterfaceBlockFieldProto::ShaderInterfaceBlockFieldProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderInterfaceBlockFieldProto)
}

void ShaderInterfaceBlockFieldProto::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    basic_ = const_cast<::ShaderVariableProto*>(
        ::ShaderVariableProto::internal_default_instance());
#else
    basic_ = const_cast<::ShaderVariableProto*>(&::ShaderVariableProto::default_instance());
#endif
}

ShaderInterfaceBlockFieldProto::ShaderInterfaceBlockFieldProto(const ShaderInterfaceBlockFieldProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderInterfaceBlockFieldProto)
}

void ShaderInterfaceBlockFieldProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    basic_ = NULL;
    is_row_major_layout_ = false;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderInterfaceBlockFieldProto::~ShaderInterfaceBlockFieldProto()
{
    // @@protoc_insertion_point(destructor:ShaderInterfaceBlockFieldProto)
    SharedDtor();
}

void ShaderInterfaceBlockFieldProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete basic_;
    }
}

void ShaderInterfaceBlockFieldProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderInterfaceBlockFieldProto& ShaderInterfaceBlockFieldProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockFieldProto::default_instance_ = NULL;

ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockFieldProto::New(::google::protobuf::Arena* arena) const
{
    ShaderInterfaceBlockFieldProto* n = new ShaderInterfaceBlockFieldProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderInterfaceBlockFieldProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderInterfaceBlockFieldProto)
    if (_has_bits_[0 / 32] & 3u) {
        if (has_basic()) {
            if (basic_ != NULL)
                basic_->::ShaderVariableProto::Clear();
        }
        is_row_major_layout_ = false;
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderInterfaceBlockFieldProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderInterfaceBlockFieldProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderInterfaceBlockFieldProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .ShaderVariableProto basic = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_basic()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_is_row_major_layout;
            break;
        }

        // optional bool is_row_major_layout = 2;
        case 2: {
            if (tag == 16) {
            parse_is_row_major_layout:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                    input, &is_row_major_layout_)));
                set_has_is_row_major_layout();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderInterfaceBlockFieldProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderInterfaceBlockFieldProto)
    return false;
#undef DO_
}

void ShaderInterfaceBlockFieldProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderInterfaceBlockFieldProto)
    // optional .ShaderVariableProto basic = 1;
    if (has_basic()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->basic_, output);
    }

    // optional bool is_row_major_layout = 2;
    if (has_is_row_major_layout()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_row_major_layout(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderInterfaceBlockFieldProto)
}

int ShaderInterfaceBlockFieldProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderInterfaceBlockFieldProto)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional .ShaderVariableProto basic = 1;
        if (has_basic()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->basic_);
        }

        // optional bool is_row_major_layout = 2;
        if (has_is_row_major_layout()) {
            total_size += 1 + 1;
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderInterfaceBlockFieldProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderInterfaceBlockFieldProto*>(&from));
}

void ShaderInterfaceBlockFieldProto::MergeFrom(const ShaderInterfaceBlockFieldProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderInterfaceBlockFieldProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_basic()) {
            mutable_basic()->::ShaderVariableProto::MergeFrom(from.basic());
        }
        if (from.has_is_row_major_layout()) {
            set_is_row_major_layout(from.is_row_major_layout());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderInterfaceBlockFieldProto::CopyFrom(const ShaderInterfaceBlockFieldProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderInterfaceBlockFieldProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderInterfaceBlockFieldProto::IsInitialized() const
{

    return true;
}

void ShaderInterfaceBlockFieldProto::Swap(ShaderInterfaceBlockFieldProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderInterfaceBlockFieldProto::InternalSwap(ShaderInterfaceBlockFieldProto* other)
{
    std::swap(basic_, other->basic_);
    std::swap(is_row_major_layout_, other->is_row_major_layout_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderInterfaceBlockFieldProto::GetTypeName() const
{
    return "ShaderInterfaceBlockFieldProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderInterfaceBlockFieldProto

// optional .ShaderVariableProto basic = 1;
bool ShaderInterfaceBlockFieldProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderInterfaceBlockFieldProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderInterfaceBlockFieldProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderInterfaceBlockFieldProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
const ::ShaderVariableProto& ShaderInterfaceBlockFieldProto::basic() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.basic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
::ShaderVariableProto* ShaderInterfaceBlockFieldProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL) {
        basic_ = new ::ShaderVariableProto;
    }
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockFieldProto.basic)
    return basic_;
}
::ShaderVariableProto* ShaderInterfaceBlockFieldProto::release_basic()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockFieldProto.basic)
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
void ShaderInterfaceBlockFieldProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockFieldProto.basic)
}

// optional bool is_row_major_layout = 2;
bool ShaderInterfaceBlockFieldProto::has_is_row_major_layout() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ShaderInterfaceBlockFieldProto::set_has_is_row_major_layout()
{
    _has_bits_[0] |= 0x00000002u;
}
void ShaderInterfaceBlockFieldProto::clear_has_is_row_major_layout()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ShaderInterfaceBlockFieldProto::clear_is_row_major_layout()
{
    is_row_major_layout_ = false;
    clear_has_is_row_major_layout();
}
bool ShaderInterfaceBlockFieldProto::is_row_major_layout() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.is_row_major_layout)
    return is_row_major_layout_;
}
void ShaderInterfaceBlockFieldProto::set_is_row_major_layout(bool value)
{
    set_has_is_row_major_layout();
    is_row_major_layout_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockFieldProto.is_row_major_layout)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderInterfaceBlockProto(
    ShaderInterfaceBlockProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderInterfaceBlockProto::kNameFieldNumber;
const int ShaderInterfaceBlockProto::kMappedNameFieldNumber;
const int ShaderInterfaceBlockProto::kInstanceNameFieldNumber;
const int ShaderInterfaceBlockProto::kArraySizeFieldNumber;
const int ShaderInterfaceBlockProto::kLayoutFieldNumber;
const int ShaderInterfaceBlockProto::kIsRowMajorLayoutFieldNumber;
const int ShaderInterfaceBlockProto::kStaticUseFieldNumber;
const int ShaderInterfaceBlockProto::kFieldsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderInterfaceBlockProto::ShaderInterfaceBlockProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderInterfaceBlockProto)
}

void ShaderInterfaceBlockProto::InitAsDefaultInstance()
{
}

ShaderInterfaceBlockProto::ShaderInterfaceBlockProto(const ShaderInterfaceBlockProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderInterfaceBlockProto)
}

void ShaderInterfaceBlockProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    mapped_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    instance_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    array_size_ = 0u;
    layout_ = 0;
    is_row_major_layout_ = false;
    static_use_ = false;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderInterfaceBlockProto::~ShaderInterfaceBlockProto()
{
    // @@protoc_insertion_point(destructor:ShaderInterfaceBlockProto)
    SharedDtor();
}

void ShaderInterfaceBlockProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    mapped_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    instance_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ShaderInterfaceBlockProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderInterfaceBlockProto& ShaderInterfaceBlockProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderInterfaceBlockProto* ShaderInterfaceBlockProto::default_instance_ = NULL;

ShaderInterfaceBlockProto* ShaderInterfaceBlockProto::New(::google::protobuf::Arena* arena) const
{
    ShaderInterfaceBlockProto* n = new ShaderInterfaceBlockProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderInterfaceBlockProto::Clear()
{
// @@protoc_insertion_point(message_clear_start:ShaderInterfaceBlockProto)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                               \
    _Pragma("clang diagnostic push")                                                                                \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ShaderInterfaceBlockProto, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ShaderInterfaceBlockProto*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 127u) {
        ZR_(array_size_, layout_);
        ZR_(is_row_major_layout_, static_use_);
        if (has_name()) {
            name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_mapped_name()) {
            mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_instance_name()) {
            instance_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }

#undef ZR_HELPER_
#undef ZR_

    fields_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderInterfaceBlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderInterfaceBlockProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderInterfaceBlockProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional string name = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_name()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_mapped_name;
            break;
        }

        // optional string mapped_name = 2;
        case 2: {
            if (tag == 18) {
            parse_mapped_name:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_mapped_name()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_instance_name;
            break;
        }

        // optional string instance_name = 3;
        case 3: {
            if (tag == 26) {
            parse_instance_name:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_instance_name()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(32))
                goto parse_array_size;
            break;
        }

        // optional uint32 array_size = 4;
        case 4: {
            if (tag == 32) {
            parse_array_size:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                    input, &array_size_)));
                set_has_array_size();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(40))
                goto parse_layout;
            break;
        }

        // optional int32 layout = 5;
        case 5: {
            if (tag == 40) {
            parse_layout:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &layout_)));
                set_has_layout();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(48))
                goto parse_is_row_major_layout;
            break;
        }

        // optional bool is_row_major_layout = 6;
        case 6: {
            if (tag == 48) {
            parse_is_row_major_layout:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                    input, &is_row_major_layout_)));
                set_has_is_row_major_layout();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(56))
                goto parse_static_use;
            break;
        }

        // optional bool static_use = 7;
        case 7: {
            if (tag == 56) {
            parse_static_use:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                    input, &static_use_)));
                set_has_static_use();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(66))
                goto parse_fields;
            break;
        }

        // repeated .ShaderInterfaceBlockFieldProto fields = 8;
        case 8: {
            if (tag == 66) {
            parse_fields:
                DO_(input->IncrementRecursionDepth());
            parse_loop_fields:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_fields()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(66))
                goto parse_loop_fields;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderInterfaceBlockProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderInterfaceBlockProto)
    return false;
#undef DO_
}

void ShaderInterfaceBlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderInterfaceBlockProto)
    // optional string name = 1;
    if (has_name()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            1, this->name(), output);
    }

    // optional string mapped_name = 2;
    if (has_mapped_name()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            2, this->mapped_name(), output);
    }

    // optional string instance_name = 3;
    if (has_instance_name()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            3, this->instance_name(), output);
    }

    // optional uint32 array_size = 4;
    if (has_array_size()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->array_size(), output);
    }

    // optional int32 layout = 5;
    if (has_layout()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->layout(), output);
    }

    // optional bool is_row_major_layout = 6;
    if (has_is_row_major_layout()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->is_row_major_layout(), output);
    }

    // optional bool static_use = 7;
    if (has_static_use()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->static_use(), output);
    }

    // repeated .ShaderInterfaceBlockFieldProto fields = 8;
    for (unsigned int i = 0, n = this->fields_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            8, this->fields(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderInterfaceBlockProto)
}

int ShaderInterfaceBlockProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderInterfaceBlockProto)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 127u) {
        // optional string name = 1;
        if (has_name()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->name());
        }

        // optional string mapped_name = 2;
        if (has_mapped_name()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->mapped_name());
        }

        // optional string instance_name = 3;
        if (has_instance_name()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->instance_name());
        }

        // optional uint32 array_size = 4;
        if (has_array_size()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->array_size());
        }

        // optional int32 layout = 5;
        if (has_layout()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->layout());
        }

        // optional bool is_row_major_layout = 6;
        if (has_is_row_major_layout()) {
            total_size += 1 + 1;
        }

        // optional bool static_use = 7;
        if (has_static_use()) {
            total_size += 1 + 1;
        }
    }
    // repeated .ShaderInterfaceBlockFieldProto fields = 8;
    total_size += 1 * this->fields_size();
    for (int i = 0; i < this->fields_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->fields(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderInterfaceBlockProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderInterfaceBlockProto*>(&from));
}

void ShaderInterfaceBlockProto::MergeFrom(const ShaderInterfaceBlockProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderInterfaceBlockProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    fields_.MergeFrom(from.fields_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_name()) {
            set_has_name();
            name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
        }
        if (from.has_mapped_name()) {
            set_has_mapped_name();
            mapped_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapped_name_);
        }
        if (from.has_instance_name()) {
            set_has_instance_name();
            instance_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.instance_name_);
        }
        if (from.has_array_size()) {
            set_array_size(from.array_size());
        }
        if (from.has_layout()) {
            set_layout(from.layout());
        }
        if (from.has_is_row_major_layout()) {
            set_is_row_major_layout(from.is_row_major_layout());
        }
        if (from.has_static_use()) {
            set_static_use(from.static_use());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderInterfaceBlockProto::CopyFrom(const ShaderInterfaceBlockProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderInterfaceBlockProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderInterfaceBlockProto::IsInitialized() const
{

    return true;
}

void ShaderInterfaceBlockProto::Swap(ShaderInterfaceBlockProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderInterfaceBlockProto::InternalSwap(ShaderInterfaceBlockProto* other)
{
    name_.Swap(&other->name_);
    mapped_name_.Swap(&other->mapped_name_);
    instance_name_.Swap(&other->instance_name_);
    std::swap(array_size_, other->array_size_);
    std::swap(layout_, other->layout_);
    std::swap(is_row_major_layout_, other->is_row_major_layout_);
    std::swap(static_use_, other->static_use_);
    fields_.UnsafeArenaSwap(&other->fields_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderInterfaceBlockProto::GetTypeName() const
{
    return "ShaderInterfaceBlockProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderInterfaceBlockProto

// optional string name = 1;
bool ShaderInterfaceBlockProto::has_name() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderInterfaceBlockProto::set_has_name()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderInterfaceBlockProto::clear_has_name()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderInterfaceBlockProto::clear_name()
{
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_name();
}
const ::std::string& ShaderInterfaceBlockProto::name() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.name)
    return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderInterfaceBlockProto::set_name(const ::std::string& value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.name)
}
void ShaderInterfaceBlockProto::set_name(const char* value)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.name)
}
void ShaderInterfaceBlockProto::set_name(const char* value, size_t size)
{
    set_has_name();
    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.name)
}
::std::string* ShaderInterfaceBlockProto::mutable_name()
{
    set_has_name();
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.name)
    return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShaderInterfaceBlockProto::release_name()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.name)
    clear_has_name();
    return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderInterfaceBlockProto::set_allocated_name(::std::string* name)
{
    if (name != NULL) {
        set_has_name();
    } else {
        clear_has_name();
    }
    name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.name)
}

// optional string mapped_name = 2;
bool ShaderInterfaceBlockProto::has_mapped_name() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ShaderInterfaceBlockProto::set_has_mapped_name()
{
    _has_bits_[0] |= 0x00000002u;
}
void ShaderInterfaceBlockProto::clear_has_mapped_name()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ShaderInterfaceBlockProto::clear_mapped_name()
{
    mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_mapped_name();
}
const ::std::string& ShaderInterfaceBlockProto::mapped_name() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.mapped_name)
    return mapped_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderInterfaceBlockProto::set_mapped_name(const ::std::string& value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.mapped_name)
}
void ShaderInterfaceBlockProto::set_mapped_name(const char* value)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.mapped_name)
}
void ShaderInterfaceBlockProto::set_mapped_name(const char* value, size_t size)
{
    set_has_mapped_name();
    mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.mapped_name)
}
::std::string* ShaderInterfaceBlockProto::mutable_mapped_name()
{
    set_has_mapped_name();
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.mapped_name)
    return mapped_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShaderInterfaceBlockProto::release_mapped_name()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.mapped_name)
    clear_has_mapped_name();
    return mapped_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderInterfaceBlockProto::set_allocated_mapped_name(::std::string* mapped_name)
{
    if (mapped_name != NULL) {
        set_has_mapped_name();
    } else {
        clear_has_mapped_name();
    }
    mapped_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapped_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.mapped_name)
}

// optional string instance_name = 3;
bool ShaderInterfaceBlockProto::has_instance_name() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ShaderInterfaceBlockProto::set_has_instance_name()
{
    _has_bits_[0] |= 0x00000004u;
}
void ShaderInterfaceBlockProto::clear_has_instance_name()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ShaderInterfaceBlockProto::clear_instance_name()
{
    instance_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_instance_name();
}
const ::std::string& ShaderInterfaceBlockProto::instance_name() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.instance_name)
    return instance_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderInterfaceBlockProto::set_instance_name(const ::std::string& value)
{
    set_has_instance_name();
    instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.instance_name)
}
void ShaderInterfaceBlockProto::set_instance_name(const char* value)
{
    set_has_instance_name();
    instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.instance_name)
}
void ShaderInterfaceBlockProto::set_instance_name(const char* value, size_t size)
{
    set_has_instance_name();
    instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.instance_name)
}
::std::string* ShaderInterfaceBlockProto::mutable_instance_name()
{
    set_has_instance_name();
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.instance_name)
    return instance_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShaderInterfaceBlockProto::release_instance_name()
{
    // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.instance_name)
    clear_has_instance_name();
    return instance_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderInterfaceBlockProto::set_allocated_instance_name(::std::string* instance_name)
{
    if (instance_name != NULL) {
        set_has_instance_name();
    } else {
        clear_has_instance_name();
    }
    instance_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance_name);
    // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.instance_name)
}

// optional uint32 array_size = 4;
bool ShaderInterfaceBlockProto::has_array_size() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void ShaderInterfaceBlockProto::set_has_array_size()
{
    _has_bits_[0] |= 0x00000008u;
}
void ShaderInterfaceBlockProto::clear_has_array_size()
{
    _has_bits_[0] &= ~0x00000008u;
}
void ShaderInterfaceBlockProto::clear_array_size()
{
    array_size_ = 0u;
    clear_has_array_size();
}
::google::protobuf::uint32 ShaderInterfaceBlockProto::array_size() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.array_size)
    return array_size_;
}
void ShaderInterfaceBlockProto::set_array_size(::google::protobuf::uint32 value)
{
    set_has_array_size();
    array_size_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.array_size)
}

// optional int32 layout = 5;
bool ShaderInterfaceBlockProto::has_layout() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
void ShaderInterfaceBlockProto::set_has_layout()
{
    _has_bits_[0] |= 0x00000010u;
}
void ShaderInterfaceBlockProto::clear_has_layout()
{
    _has_bits_[0] &= ~0x00000010u;
}
void ShaderInterfaceBlockProto::clear_layout()
{
    layout_ = 0;
    clear_has_layout();
}
::google::protobuf::int32 ShaderInterfaceBlockProto::layout() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.layout)
    return layout_;
}
void ShaderInterfaceBlockProto::set_layout(::google::protobuf::int32 value)
{
    set_has_layout();
    layout_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.layout)
}

// optional bool is_row_major_layout = 6;
bool ShaderInterfaceBlockProto::has_is_row_major_layout() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
void ShaderInterfaceBlockProto::set_has_is_row_major_layout()
{
    _has_bits_[0] |= 0x00000020u;
}
void ShaderInterfaceBlockProto::clear_has_is_row_major_layout()
{
    _has_bits_[0] &= ~0x00000020u;
}
void ShaderInterfaceBlockProto::clear_is_row_major_layout()
{
    is_row_major_layout_ = false;
    clear_has_is_row_major_layout();
}
bool ShaderInterfaceBlockProto::is_row_major_layout() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.is_row_major_layout)
    return is_row_major_layout_;
}
void ShaderInterfaceBlockProto::set_is_row_major_layout(bool value)
{
    set_has_is_row_major_layout();
    is_row_major_layout_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.is_row_major_layout)
}

// optional bool static_use = 7;
bool ShaderInterfaceBlockProto::has_static_use() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
void ShaderInterfaceBlockProto::set_has_static_use()
{
    _has_bits_[0] |= 0x00000040u;
}
void ShaderInterfaceBlockProto::clear_has_static_use()
{
    _has_bits_[0] &= ~0x00000040u;
}
void ShaderInterfaceBlockProto::clear_static_use()
{
    static_use_ = false;
    clear_has_static_use();
}
bool ShaderInterfaceBlockProto::static_use() const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.static_use)
    return static_use_;
}
void ShaderInterfaceBlockProto::set_static_use(bool value)
{
    set_has_static_use();
    static_use_ = value;
    // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.static_use)
}

// repeated .ShaderInterfaceBlockFieldProto fields = 8;
int ShaderInterfaceBlockProto::fields_size() const
{
    return fields_.size();
}
void ShaderInterfaceBlockProto::clear_fields()
{
    fields_.Clear();
}
const ::ShaderInterfaceBlockFieldProto& ShaderInterfaceBlockProto::fields(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.fields)
    return fields_.Get(index);
}
::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::mutable_fields(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.fields)
    return fields_.Mutable(index);
}
::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::add_fields()
{
    // @@protoc_insertion_point(field_add:ShaderInterfaceBlockProto.fields)
    return fields_.Add();
}
::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockFieldProto>*
ShaderInterfaceBlockProto::mutable_fields()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderInterfaceBlockProto.fields)
    return &fields_;
}
const ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockFieldProto>&
ShaderInterfaceBlockProto::fields() const
{
    // @@protoc_insertion_point(field_list:ShaderInterfaceBlockProto.fields)
    return fields_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderProto(
    ShaderProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderProto::kShaFieldNumber;
const int ShaderProto::kAttribsFieldNumber;
const int ShaderProto::kUniformsFieldNumber;
const int ShaderProto::kVaryingsFieldNumber;
const int ShaderProto::kOutputVariablesFieldNumber;
const int ShaderProto::kInterfaceBlocksFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderProto::ShaderProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:ShaderProto)
}

void ShaderProto::InitAsDefaultInstance()
{
}

ShaderProto::ShaderProto(const ShaderProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:ShaderProto)
}

void ShaderProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    sha_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderProto::~ShaderProto()
{
    // @@protoc_insertion_point(destructor:ShaderProto)
    SharedDtor();
}

void ShaderProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    sha_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ShaderProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderProto& ShaderProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

ShaderProto* ShaderProto::default_instance_ = NULL;

ShaderProto* ShaderProto::New(::google::protobuf::Arena* arena) const
{
    ShaderProto* n = new ShaderProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ShaderProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderProto)
    if (has_sha()) {
        sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    attribs_.Clear();
    uniforms_.Clear();
    varyings_.Clear();
    output_variables_.Clear();
    interface_blocks_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForShaderProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:ShaderProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional bytes sha = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_sha()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_attribs;
            break;
        }

        // repeated .ShaderAttributeProto attribs = 2;
        case 2: {
            if (tag == 18) {
            parse_attribs:
                DO_(input->IncrementRecursionDepth());
            parse_loop_attribs:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_attribs()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_loop_attribs;
            if (input->ExpectTag(26))
                goto parse_loop_uniforms;
            input->UnsafeDecrementRecursionDepth();
            break;
        }

        // repeated .ShaderUniformProto uniforms = 3;
        case 3: {
            if (tag == 26) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_uniforms:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_uniforms()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_loop_uniforms;
            if (input->ExpectTag(34))
                goto parse_loop_varyings;
            input->UnsafeDecrementRecursionDepth();
            break;
        }

        // repeated .ShaderVaryingProto varyings = 4;
        case 4: {
            if (tag == 34) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_varyings:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_varyings()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_loop_varyings;
            if (input->ExpectTag(42))
                goto parse_loop_output_variables;
            input->UnsafeDecrementRecursionDepth();
            break;
        }

        // repeated .ShaderOutputVariableProto output_variables = 5;
        case 5: {
            if (tag == 42) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_output_variables:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_output_variables()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(42))
                goto parse_loop_output_variables;
            if (input->ExpectTag(50))
                goto parse_loop_interface_blocks;
            input->UnsafeDecrementRecursionDepth();
            break;
        }

        // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
        case 6: {
            if (tag == 50) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_interface_blocks:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_interface_blocks()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(50))
                goto parse_loop_interface_blocks;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:ShaderProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:ShaderProto)
    return false;
#undef DO_
}

void ShaderProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:ShaderProto)
    // optional bytes sha = 1;
    if (has_sha()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            1, this->sha(), output);
    }

    // repeated .ShaderAttributeProto attribs = 2;
    for (unsigned int i = 0, n = this->attribs_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, this->attribs(i), output);
    }

    // repeated .ShaderUniformProto uniforms = 3;
    for (unsigned int i = 0, n = this->uniforms_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->uniforms(i), output);
    }

    // repeated .ShaderVaryingProto varyings = 4;
    for (unsigned int i = 0, n = this->varyings_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, this->varyings(i), output);
    }

    // repeated .ShaderOutputVariableProto output_variables = 5;
    for (unsigned int i = 0, n = this->output_variables_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            5, this->output_variables(i), output);
    }

    // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
    for (unsigned int i = 0, n = this->interface_blocks_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            6, this->interface_blocks(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:ShaderProto)
}

int ShaderProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderProto)
    int total_size = 0;

    // optional bytes sha = 1;
    if (has_sha()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->sha());
    }

    // repeated .ShaderAttributeProto attribs = 2;
    total_size += 1 * this->attribs_size();
    for (int i = 0; i < this->attribs_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->attribs(i));
    }

    // repeated .ShaderUniformProto uniforms = 3;
    total_size += 1 * this->uniforms_size();
    for (int i = 0; i < this->uniforms_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->uniforms(i));
    }

    // repeated .ShaderVaryingProto varyings = 4;
    total_size += 1 * this->varyings_size();
    for (int i = 0; i < this->varyings_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->varyings(i));
    }

    // repeated .ShaderOutputVariableProto output_variables = 5;
    total_size += 1 * this->output_variables_size();
    for (int i = 0; i < this->output_variables_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->output_variables(i));
    }

    // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
    total_size += 1 * this->interface_blocks_size();
    for (int i = 0; i < this->interface_blocks_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->interface_blocks(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ShaderProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ShaderProto*>(&from));
}

void ShaderProto::MergeFrom(const ShaderProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    attribs_.MergeFrom(from.attribs_);
    uniforms_.MergeFrom(from.uniforms_);
    varyings_.MergeFrom(from.varyings_);
    output_variables_.MergeFrom(from.output_variables_);
    interface_blocks_.MergeFrom(from.interface_blocks_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_sha()) {
            set_has_sha();
            sha_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sha_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ShaderProto::CopyFrom(const ShaderProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderProto::IsInitialized() const
{

    return true;
}

void ShaderProto::Swap(ShaderProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ShaderProto::InternalSwap(ShaderProto* other)
{
    sha_.Swap(&other->sha_);
    attribs_.UnsafeArenaSwap(&other->attribs_);
    uniforms_.UnsafeArenaSwap(&other->uniforms_);
    varyings_.UnsafeArenaSwap(&other->varyings_);
    output_variables_.UnsafeArenaSwap(&other->output_variables_);
    interface_blocks_.UnsafeArenaSwap(&other->interface_blocks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderProto::GetTypeName() const
{
    return "ShaderProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderProto

// optional bytes sha = 1;
bool ShaderProto::has_sha() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderProto::set_has_sha()
{
    _has_bits_[0] |= 0x00000001u;
}
void ShaderProto::clear_has_sha()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ShaderProto::clear_sha()
{
    sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_sha();
}
const ::std::string& ShaderProto::sha() const
{
    // @@protoc_insertion_point(field_get:ShaderProto.sha)
    return sha_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderProto::set_sha(const ::std::string& value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:ShaderProto.sha)
}
void ShaderProto::set_sha(const char* value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:ShaderProto.sha)
}
void ShaderProto::set_sha(const void* value, size_t size)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:ShaderProto.sha)
}
::std::string* ShaderProto::mutable_sha()
{
    set_has_sha();
    // @@protoc_insertion_point(field_mutable:ShaderProto.sha)
    return sha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShaderProto::release_sha()
{
    // @@protoc_insertion_point(field_release:ShaderProto.sha)
    clear_has_sha();
    return sha_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShaderProto::set_allocated_sha(::std::string* sha)
{
    if (sha != NULL) {
        set_has_sha();
    } else {
        clear_has_sha();
    }
    sha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha);
    // @@protoc_insertion_point(field_set_allocated:ShaderProto.sha)
}

// repeated .ShaderAttributeProto attribs = 2;
int ShaderProto::attribs_size() const
{
    return attribs_.size();
}
void ShaderProto::clear_attribs()
{
    attribs_.Clear();
}
const ::ShaderAttributeProto& ShaderProto::attribs(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.attribs)
    return attribs_.Get(index);
}
::ShaderAttributeProto* ShaderProto::mutable_attribs(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.attribs)
    return attribs_.Mutable(index);
}
::ShaderAttributeProto* ShaderProto::add_attribs()
{
    // @@protoc_insertion_point(field_add:ShaderProto.attribs)
    return attribs_.Add();
}
::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>*
ShaderProto::mutable_attribs()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.attribs)
    return &attribs_;
}
const ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>&
ShaderProto::attribs() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.attribs)
    return attribs_;
}

// repeated .ShaderUniformProto uniforms = 3;
int ShaderProto::uniforms_size() const
{
    return uniforms_.size();
}
void ShaderProto::clear_uniforms()
{
    uniforms_.Clear();
}
const ::ShaderUniformProto& ShaderProto::uniforms(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.uniforms)
    return uniforms_.Get(index);
}
::ShaderUniformProto* ShaderProto::mutable_uniforms(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.uniforms)
    return uniforms_.Mutable(index);
}
::ShaderUniformProto* ShaderProto::add_uniforms()
{
    // @@protoc_insertion_point(field_add:ShaderProto.uniforms)
    return uniforms_.Add();
}
::google::protobuf::RepeatedPtrField<::ShaderUniformProto>*
ShaderProto::mutable_uniforms()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.uniforms)
    return &uniforms_;
}
const ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>&
ShaderProto::uniforms() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.uniforms)
    return uniforms_;
}

// repeated .ShaderVaryingProto varyings = 4;
int ShaderProto::varyings_size() const
{
    return varyings_.size();
}
void ShaderProto::clear_varyings()
{
    varyings_.Clear();
}
const ::ShaderVaryingProto& ShaderProto::varyings(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.varyings)
    return varyings_.Get(index);
}
::ShaderVaryingProto* ShaderProto::mutable_varyings(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.varyings)
    return varyings_.Mutable(index);
}
::ShaderVaryingProto* ShaderProto::add_varyings()
{
    // @@protoc_insertion_point(field_add:ShaderProto.varyings)
    return varyings_.Add();
}
::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>*
ShaderProto::mutable_varyings()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.varyings)
    return &varyings_;
}
const ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>&
ShaderProto::varyings() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.varyings)
    return varyings_;
}

// repeated .ShaderOutputVariableProto output_variables = 5;
int ShaderProto::output_variables_size() const
{
    return output_variables_.size();
}
void ShaderProto::clear_output_variables()
{
    output_variables_.Clear();
}
const ::ShaderOutputVariableProto& ShaderProto::output_variables(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.output_variables)
    return output_variables_.Get(index);
}
::ShaderOutputVariableProto* ShaderProto::mutable_output_variables(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.output_variables)
    return output_variables_.Mutable(index);
}
::ShaderOutputVariableProto* ShaderProto::add_output_variables()
{
    // @@protoc_insertion_point(field_add:ShaderProto.output_variables)
    return output_variables_.Add();
}
::google::protobuf::RepeatedPtrField<::ShaderOutputVariableProto>*
ShaderProto::mutable_output_variables()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.output_variables)
    return &output_variables_;
}
const ::google::protobuf::RepeatedPtrField<::ShaderOutputVariableProto>&
ShaderProto::output_variables() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.output_variables)
    return output_variables_;
}

// repeated .ShaderInterfaceBlockProto interface_blocks = 6;
int ShaderProto::interface_blocks_size() const
{
    return interface_blocks_.size();
}
void ShaderProto::clear_interface_blocks()
{
    interface_blocks_.Clear();
}
const ::ShaderInterfaceBlockProto& ShaderProto::interface_blocks(int index) const
{
    // @@protoc_insertion_point(field_get:ShaderProto.interface_blocks)
    return interface_blocks_.Get(index);
}
::ShaderInterfaceBlockProto* ShaderProto::mutable_interface_blocks(int index)
{
    // @@protoc_insertion_point(field_mutable:ShaderProto.interface_blocks)
    return interface_blocks_.Mutable(index);
}
::ShaderInterfaceBlockProto* ShaderProto::add_interface_blocks()
{
    // @@protoc_insertion_point(field_add:ShaderProto.interface_blocks)
    return interface_blocks_.Add();
}
::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockProto>*
ShaderProto::mutable_interface_blocks()
{
    // @@protoc_insertion_point(field_mutable_list:ShaderProto.interface_blocks)
    return &interface_blocks_;
}
const ::google::protobuf::RepeatedPtrField<::ShaderInterfaceBlockProto>&
ShaderProto::interface_blocks() const
{
    // @@protoc_insertion_point(field_list:ShaderProto.interface_blocks)
    return interface_blocks_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGpuProgramProto(
    GpuProgramProto* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GpuProgramProto::kShaFieldNumber;
const int GpuProgramProto::kFormatFieldNumber;
const int GpuProgramProto::kProgramFieldNumber;
const int GpuProgramProto::kVertexShaderFieldNumber;
const int GpuProgramProto::kFragmentShaderFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

GpuProgramProto::GpuProgramProto()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:GpuProgramProto)
}

void GpuProgramProto::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    vertex_shader_ = const_cast<::ShaderProto*>(
        ::ShaderProto::internal_default_instance());
#else
    vertex_shader_ = const_cast<::ShaderProto*>(&::ShaderProto::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    fragment_shader_ = const_cast<::ShaderProto*>(
        ::ShaderProto::internal_default_instance());
#else
    fragment_shader_ = const_cast<::ShaderProto*>(&::ShaderProto::default_instance());
#endif
}

GpuProgramProto::GpuProgramProto(const GpuProgramProto& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:GpuProgramProto)
}

void GpuProgramProto::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    sha_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    format_ = 0u;
    program_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    vertex_shader_ = NULL;
    fragment_shader_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpuProgramProto::~GpuProgramProto()
{
    // @@protoc_insertion_point(destructor:GpuProgramProto)
    SharedDtor();
}

void GpuProgramProto::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    sha_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    program_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete vertex_shader_;
        delete fragment_shader_;
    }
}

void GpuProgramProto::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GpuProgramProto& GpuProgramProto::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    return *default_instance_;
}

GpuProgramProto* GpuProgramProto::default_instance_ = NULL;

GpuProgramProto* GpuProgramProto::New(::google::protobuf::Arena* arena) const
{
    GpuProgramProto* n = new GpuProgramProto;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void GpuProgramProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:GpuProgramProto)
    if (_has_bits_[0 / 32] & 31u) {
        if (has_sha()) {
            sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        format_ = 0u;
        if (has_program()) {
            program_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_vertex_shader()) {
            if (vertex_shader_ != NULL)
                vertex_shader_->::ShaderProto::Clear();
        }
        if (has_fragment_shader()) {
            if (fragment_shader_ != NULL)
                fragment_shader_->::ShaderProto::Clear();
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GpuProgramProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForGpuProgramProto, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:GpuProgramProto)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional bytes sha = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_sha()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_format;
            break;
        }

        // optional uint32 format = 2;
        case 2: {
            if (tag == 16) {
            parse_format:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                    input, &format_)));
                set_has_format();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_program;
            break;
        }

        // optional bytes program = 3;
        case 3: {
            if (tag == 26) {
            parse_program:
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_program()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_vertex_shader;
            break;
        }

        // optional .ShaderProto vertex_shader = 4;
        case 4: {
            if (tag == 34) {
            parse_vertex_shader:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_vertex_shader()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(42))
                goto parse_fragment_shader;
            break;
        }

        // optional .ShaderProto fragment_shader = 5;
        case 5: {
            if (tag == 42) {
            parse_fragment_shader:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_fragment_shader()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:GpuProgramProto)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:GpuProgramProto)
    return false;
#undef DO_
}

void GpuProgramProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:GpuProgramProto)
    // optional bytes sha = 1;
    if (has_sha()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            1, this->sha(), output);
    }

    // optional uint32 format = 2;
    if (has_format()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->format(), output);
    }

    // optional bytes program = 3;
    if (has_program()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            3, this->program(), output);
    }

    // optional .ShaderProto vertex_shader = 4;
    if (has_vertex_shader()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, *this->vertex_shader_, output);
    }

    // optional .ShaderProto fragment_shader = 5;
    if (has_fragment_shader()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            5, *this->fragment_shader_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:GpuProgramProto)
}

int GpuProgramProto::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:GpuProgramProto)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 31u) {
        // optional bytes sha = 1;
        if (has_sha()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->sha());
        }

        // optional uint32 format = 2;
        if (has_format()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::UInt32Size(this->format());
        }

        // optional bytes program = 3;
        if (has_program()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->program());
        }

        // optional .ShaderProto vertex_shader = 4;
        if (has_vertex_shader()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->vertex_shader_);
        }

        // optional .ShaderProto fragment_shader = 5;
        if (has_fragment_shader()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->fragment_shader_);
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void GpuProgramProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const GpuProgramProto*>(&from));
}

void GpuProgramProto::MergeFrom(const GpuProgramProto& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:GpuProgramProto)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_sha()) {
            set_has_sha();
            sha_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sha_);
        }
        if (from.has_format()) {
            set_format(from.format());
        }
        if (from.has_program()) {
            set_has_program();
            program_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.program_);
        }
        if (from.has_vertex_shader()) {
            mutable_vertex_shader()->::ShaderProto::MergeFrom(from.vertex_shader());
        }
        if (from.has_fragment_shader()) {
            mutable_fragment_shader()->::ShaderProto::MergeFrom(from.fragment_shader());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void GpuProgramProto::CopyFrom(const GpuProgramProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:GpuProgramProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GpuProgramProto::IsInitialized() const
{

    return true;
}

void GpuProgramProto::Swap(GpuProgramProto* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void GpuProgramProto::InternalSwap(GpuProgramProto* other)
{
    sha_.Swap(&other->sha_);
    std::swap(format_, other->format_);
    program_.Swap(&other->program_);
    std::swap(vertex_shader_, other->vertex_shader_);
    std::swap(fragment_shader_, other->fragment_shader_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string GpuProgramProto::GetTypeName() const
{
    return "GpuProgramProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuProgramProto

// optional bytes sha = 1;
bool GpuProgramProto::has_sha() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void GpuProgramProto::set_has_sha()
{
    _has_bits_[0] |= 0x00000001u;
}
void GpuProgramProto::clear_has_sha()
{
    _has_bits_[0] &= ~0x00000001u;
}
void GpuProgramProto::clear_sha()
{
    sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_sha();
}
const ::std::string& GpuProgramProto::sha() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.sha)
    return sha_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void GpuProgramProto::set_sha(const ::std::string& value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:GpuProgramProto.sha)
}
void GpuProgramProto::set_sha(const char* value)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:GpuProgramProto.sha)
}
void GpuProgramProto::set_sha(const void* value, size_t size)
{
    set_has_sha();
    sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:GpuProgramProto.sha)
}
::std::string* GpuProgramProto::mutable_sha()
{
    set_has_sha();
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.sha)
    return sha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* GpuProgramProto::release_sha()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.sha)
    clear_has_sha();
    return sha_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void GpuProgramProto::set_allocated_sha(::std::string* sha)
{
    if (sha != NULL) {
        set_has_sha();
    } else {
        clear_has_sha();
    }
    sha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha);
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.sha)
}

// optional uint32 format = 2;
bool GpuProgramProto::has_format() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void GpuProgramProto::set_has_format()
{
    _has_bits_[0] |= 0x00000002u;
}
void GpuProgramProto::clear_has_format()
{
    _has_bits_[0] &= ~0x00000002u;
}
void GpuProgramProto::clear_format()
{
    format_ = 0u;
    clear_has_format();
}
::google::protobuf::uint32 GpuProgramProto::format() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.format)
    return format_;
}
void GpuProgramProto::set_format(::google::protobuf::uint32 value)
{
    set_has_format();
    format_ = value;
    // @@protoc_insertion_point(field_set:GpuProgramProto.format)
}

// optional bytes program = 3;
bool GpuProgramProto::has_program() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void GpuProgramProto::set_has_program()
{
    _has_bits_[0] |= 0x00000004u;
}
void GpuProgramProto::clear_has_program()
{
    _has_bits_[0] &= ~0x00000004u;
}
void GpuProgramProto::clear_program()
{
    program_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_program();
}
const ::std::string& GpuProgramProto::program() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.program)
    return program_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void GpuProgramProto::set_program(const ::std::string& value)
{
    set_has_program();
    program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:GpuProgramProto.program)
}
void GpuProgramProto::set_program(const char* value)
{
    set_has_program();
    program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:GpuProgramProto.program)
}
void GpuProgramProto::set_program(const void* value, size_t size)
{
    set_has_program();
    program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:GpuProgramProto.program)
}
::std::string* GpuProgramProto::mutable_program()
{
    set_has_program();
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.program)
    return program_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* GpuProgramProto::release_program()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.program)
    clear_has_program();
    return program_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void GpuProgramProto::set_allocated_program(::std::string* program)
{
    if (program != NULL) {
        set_has_program();
    } else {
        clear_has_program();
    }
    program_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), program);
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.program)
}

// optional .ShaderProto vertex_shader = 4;
bool GpuProgramProto::has_vertex_shader() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void GpuProgramProto::set_has_vertex_shader()
{
    _has_bits_[0] |= 0x00000008u;
}
void GpuProgramProto::clear_has_vertex_shader()
{
    _has_bits_[0] &= ~0x00000008u;
}
void GpuProgramProto::clear_vertex_shader()
{
    if (vertex_shader_ != NULL)
        vertex_shader_->::ShaderProto::Clear();
    clear_has_vertex_shader();
}
const ::ShaderProto& GpuProgramProto::vertex_shader() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.vertex_shader)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance().vertex_shader_;
#else
    return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance_->vertex_shader_;
#endif
}
::ShaderProto* GpuProgramProto::mutable_vertex_shader()
{
    set_has_vertex_shader();
    if (vertex_shader_ == NULL) {
        vertex_shader_ = new ::ShaderProto;
    }
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.vertex_shader)
    return vertex_shader_;
}
::ShaderProto* GpuProgramProto::release_vertex_shader()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.vertex_shader)
    clear_has_vertex_shader();
    ::ShaderProto* temp = vertex_shader_;
    vertex_shader_ = NULL;
    return temp;
}
void GpuProgramProto::set_allocated_vertex_shader(::ShaderProto* vertex_shader)
{
    delete vertex_shader_;
    vertex_shader_ = vertex_shader;
    if (vertex_shader) {
        set_has_vertex_shader();
    } else {
        clear_has_vertex_shader();
    }
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.vertex_shader)
}

// optional .ShaderProto fragment_shader = 5;
bool GpuProgramProto::has_fragment_shader() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
void GpuProgramProto::set_has_fragment_shader()
{
    _has_bits_[0] |= 0x00000010u;
}
void GpuProgramProto::clear_has_fragment_shader()
{
    _has_bits_[0] &= ~0x00000010u;
}
void GpuProgramProto::clear_fragment_shader()
{
    if (fragment_shader_ != NULL)
        fragment_shader_->::ShaderProto::Clear();
    clear_has_fragment_shader();
}
const ::ShaderProto& GpuProgramProto::fragment_shader() const
{
    // @@protoc_insertion_point(field_get:GpuProgramProto.fragment_shader)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance().fragment_shader_;
#else
    return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance_->fragment_shader_;
#endif
}
::ShaderProto* GpuProgramProto::mutable_fragment_shader()
{
    set_has_fragment_shader();
    if (fragment_shader_ == NULL) {
        fragment_shader_ = new ::ShaderProto;
    }
    // @@protoc_insertion_point(field_mutable:GpuProgramProto.fragment_shader)
    return fragment_shader_;
}
::ShaderProto* GpuProgramProto::release_fragment_shader()
{
    // @@protoc_insertion_point(field_release:GpuProgramProto.fragment_shader)
    clear_has_fragment_shader();
    ::ShaderProto* temp = fragment_shader_;
    fragment_shader_ = NULL;
    return temp;
}
void GpuProgramProto::set_allocated_fragment_shader(::ShaderProto* fragment_shader)
{
    delete fragment_shader_;
    fragment_shader_ = fragment_shader;
    if (fragment_shader) {
        set_has_fragment_shader();
    } else {
        clear_has_fragment_shader();
    }
    // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.fragment_shader)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
