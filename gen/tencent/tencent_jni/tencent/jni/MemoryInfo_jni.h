// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by
//     base/android/jni_generator/jni_generator.py
// For
//     com/tencent/smtt/memory/MemoryInfo

#ifndef com_tencent_smtt_memory_MemoryInfo_JNI
#define com_tencent_smtt_memory_MemoryInfo_JNI

#include <jni.h>

#include "../../../../../../../base/android/jni_generator/jni_generator_helper.h"

#include "base/android/jni_int_wrapper.h"

// Step 1: forward declarations.
namespace {
const char kMemoryInfoClassPath[] = "com/tencent/smtt/memory/MemoryInfo";
// Leaking this jclass as we cannot use LazyInstance from some threads.
base::subtle::AtomicWord g_MemoryInfo_clazz __attribute__((unused)) = 0;
#define MemoryInfo_clazz(env) base::android::LazyGetClass(env, kMemoryInfoClassPath, &g_MemoryInfo_clazz)

} // namespace

// Step 2: method stubs.

static base::android::ScopedJavaLocalRef<jobject> GetMemInfo(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller);

JNI_GENERATOR_EXPORT jobject
Java_com_tencent_smtt_memory_MemoryInfo_nativeGetMemInfo(JNIEnv* env, jclass jcaller)
{
    return GetMemInfo(env, base::android::JavaParamRef<jclass>(env, jcaller)).Release();
}

static void UpdateMemLimit(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller,
    jint vssLimit,
    jint pssLimit);

JNI_GENERATOR_EXPORT void
Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateMemLimit(JNIEnv* env,
    jclass jcaller,
    jint vssLimit,
    jint pssLimit)
{
    return UpdateMemLimit(env, base::android::JavaParamRef<jclass>(env, jcaller),
        vssLimit, pssLimit);
}

static void UpdateTrimThreshold(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller,
    jint runningMemAgressiveGrowthLimit,
    jint runningMemGentleGrowthLimit,
    jint availableThreshold);

JNI_GENERATOR_EXPORT void
Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateTrimThreshold(JNIEnv*
                                                                      env,
    jclass jcaller,
    jint runningMemAgressiveGrowthLimit,
    jint runningMemGentleGrowthLimit,
    jint availableThreshold)
{
    return UpdateTrimThreshold(env, base::android::JavaParamRef<jclass>(env, jcaller), runningMemAgressiveGrowthLimit, runningMemGentleGrowthLimit,
        availableThreshold);
}

static void UpdateBootupMemory(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller,
    jint vss,
    jint pss);

JNI_GENERATOR_EXPORT void
Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateBootupMemory(JNIEnv*
                                                                     env,
    jclass jcaller,
    jint vss,
    jint pss)
{
    return UpdateBootupMemory(env, base::android::JavaParamRef<jclass>(env, jcaller), vss, pss);
}

static void UpdateTrimMemory(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller,
    jint vss,
    jint pss,
    jint available,
    jint trimFrom,
    jint checkFrom);

JNI_GENERATOR_EXPORT void
Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateTrimMemory(JNIEnv* env,
    jclass jcaller,
    jint vss,
    jint pss,
    jint available,
    jint trimFrom,
    jint checkFrom)
{
    return UpdateTrimMemory(env, base::android::JavaParamRef<jclass>(env, jcaller), vss, pss, available, trimFrom, checkFrom);
}

static void UpdateTrimStatus(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller,
    jint status);

JNI_GENERATOR_EXPORT void
Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateTrimStatus(JNIEnv* env,
    jclass jcaller,
    jint status)
{
    return UpdateTrimStatus(env, base::android::JavaParamRef<jclass>(env, jcaller), status);
}

static void UpdateMemInfoForReport(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller);

JNI_GENERATOR_EXPORT void
Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateMemInfoForReport(JNIEnv*
                                                                         env,
    jclass jcaller)
{
    return UpdateMemInfoForReport(env, base::android::JavaParamRef<jclass>(env, jcaller));
}

static jint NeedTrimMemory(JNIEnv* env, const base::android::JavaParamRef<jclass>& jcaller);

JNI_GENERATOR_EXPORT jint
Java_com_tencent_smtt_memory_MemoryInfo_nativeNeedTrimMemory(JNIEnv* env,
    jclass jcaller)
{
    return NeedTrimMemory(env, base::android::JavaParamRef<jclass>(env, jcaller));
}

static base::subtle::AtomicWord g_MemoryInfo_createNativeMemInfo = 0;
static base::android::ScopedJavaLocalRef<jobject>
Java_MemoryInfo_createNativeMemInfo(JNIEnv* env, JniIntWrapper partitionAlloc,
    JniIntWrapper v8Alloc,
    JniIntWrapper discardableMemLocked,
    JniIntWrapper discardableMemPinned,
    JniIntWrapper sharedMemAlloc,
    JniIntWrapper textureAlloc,
    JniIntWrapper mallocAlloc,
    JniIntWrapper cachedPage,
    JniIntWrapper naviNaviViews,
    JniIntWrapper deactiveNaviViews,
    JniIntWrapper prunedNaviViews)
{
    CHECK_CLAZZ(env, MemoryInfo_clazz(env),
        MemoryInfo_clazz(env), NULL);
    jmethodID method_id = base::android::MethodID::LazyGet<
        base::android::MethodID::TYPE_STATIC>(
        env, MemoryInfo_clazz(env),
        "createNativeMemInfo",
        "("
        "I"
        "I"
        "I"
        "I"
        "I"
        "I"
        "I"
        "I"
        "I"
        "I"
        "I"
        ")"
        "Lcom/tencent/smtt/memory/MemoryInfo$NativeMemInfo;",
        &g_MemoryInfo_createNativeMemInfo);

    jobject ret = env->CallStaticObjectMethod(MemoryInfo_clazz(env),
        method_id, as_jint(partitionAlloc), as_jint(v8Alloc),
        as_jint(discardableMemLocked), as_jint(discardableMemPinned),
        as_jint(sharedMemAlloc), as_jint(textureAlloc),
        as_jint(mallocAlloc), as_jint(cachedPage), as_jint(naviNaviViews),
        as_jint(deactiveNaviViews), as_jint(prunedNaviViews));
    jni_generator::CheckException(env);
    return base::android::ScopedJavaLocalRef<jobject>(env, ret);
}

static base::subtle::AtomicWord g_MemoryInfo_getCurVss = 0;
static jint Java_MemoryInfo_getCurVss(JNIEnv* env)
{
    CHECK_CLAZZ(env, MemoryInfo_clazz(env),
        MemoryInfo_clazz(env), 0);
    jmethodID method_id = base::android::MethodID::LazyGet<
        base::android::MethodID::TYPE_STATIC>(
        env, MemoryInfo_clazz(env),
        "getCurVss",
        "("
        ")"
        "I",
        &g_MemoryInfo_getCurVss);

    jint ret = env->CallStaticIntMethod(MemoryInfo_clazz(env),
        method_id);
    jni_generator::CheckException(env);
    return ret;
}

static base::subtle::AtomicWord g_MemoryInfo_getCurPss = 0;
static jint Java_MemoryInfo_getCurPss(JNIEnv* env, JniIntWrapper timeout)
{
    CHECK_CLAZZ(env, MemoryInfo_clazz(env),
        MemoryInfo_clazz(env), 0);
    jmethodID method_id = base::android::MethodID::LazyGet<
        base::android::MethodID::TYPE_STATIC>(
        env, MemoryInfo_clazz(env),
        "getCurPss",
        "("
        "I"
        ")"
        "I",
        &g_MemoryInfo_getCurPss);

    jint ret = env->CallStaticIntMethod(MemoryInfo_clazz(env),
        method_id, as_jint(timeout));
    jni_generator::CheckException(env);
    return ret;
}

static base::subtle::AtomicWord g_MemoryInfo_getCurAvailMem = 0;
static jint Java_MemoryInfo_getCurAvailMem(JNIEnv* env)
{
    CHECK_CLAZZ(env, MemoryInfo_clazz(env),
        MemoryInfo_clazz(env), 0);
    jmethodID method_id = base::android::MethodID::LazyGet<
        base::android::MethodID::TYPE_STATIC>(
        env, MemoryInfo_clazz(env),
        "getCurAvailMem",
        "("
        ")"
        "I",
        &g_MemoryInfo_getCurAvailMem);

    jint ret = env->CallStaticIntMethod(MemoryInfo_clazz(env),
        method_id);
    jni_generator::CheckException(env);
    return ret;
}

static base::subtle::AtomicWord g_MemoryInfo_onOOMHandler = 0;
static void Java_MemoryInfo_onOOMHandler(JNIEnv* env, JniIntWrapper dstSize,
    jboolean success)
{
    CHECK_CLAZZ(env, MemoryInfo_clazz(env),
        MemoryInfo_clazz(env));
    jmethodID method_id = base::android::MethodID::LazyGet<
        base::android::MethodID::TYPE_STATIC>(
        env, MemoryInfo_clazz(env),
        "onOOMHandler",
        "("
        "I"
        "Z"
        ")"
        "V",
        &g_MemoryInfo_onOOMHandler);

    env->CallStaticVoidMethod(MemoryInfo_clazz(env),
        method_id, as_jint(dstSize), success);
    jni_generator::CheckException(env);
}

static base::subtle::AtomicWord g_MemoryInfo_onLargeMemAlloc = 0;
static void Java_MemoryInfo_onLargeMemAlloc(JNIEnv* env, JniIntWrapper size)
{
    CHECK_CLAZZ(env, MemoryInfo_clazz(env),
        MemoryInfo_clazz(env));
    jmethodID method_id = base::android::MethodID::LazyGet<
        base::android::MethodID::TYPE_STATIC>(
        env, MemoryInfo_clazz(env),
        "onLargeMemAlloc",
        "("
        "I"
        ")"
        "V",
        &g_MemoryInfo_onLargeMemAlloc);

    env->CallStaticVoidMethod(MemoryInfo_clazz(env),
        method_id, as_jint(size));
    jni_generator::CheckException(env);
}

// Step 3: RegisterNatives.

static const JNINativeMethod kMethodsMemoryInfo[] = {
    { "nativeGetMemInfo",
        "("
        ")"
        "Lcom/tencent/smtt/memory/MemoryInfo$NativeMemInfo;",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeGetMemInfo) },
    { "nativeUpdateMemLimit",
        "("
        "I"
        "I"
        ")"
        "V",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateMemLimit) },
    { "nativeUpdateTrimThreshold",
        "("
        "I"
        "I"
        "I"
        ")"
        "V",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateTrimThreshold) },
    { "nativeUpdateBootupMemory",
        "("
        "I"
        "I"
        ")"
        "V",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateBootupMemory) },
    { "nativeUpdateTrimMemory",
        "("
        "I"
        "I"
        "I"
        "I"
        "I"
        ")"
        "V",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateTrimMemory) },
    { "nativeUpdateTrimStatus",
        "("
        "I"
        ")"
        "V",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateTrimStatus) },
    { "nativeUpdateMemInfoForReport",
        "("
        ")"
        "V",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeUpdateMemInfoForReport) },
    { "nativeNeedTrimMemory",
        "("
        ")"
        "I",
        reinterpret_cast<void*>(Java_com_tencent_smtt_memory_MemoryInfo_nativeNeedTrimMemory) },
};

static bool RegisterNativesImpl(JNIEnv* env)
{
    if (base::android::IsManualJniRegistrationDisabled())
        return true;

    const int kMethodsMemoryInfoSize = arraysize(kMethodsMemoryInfo);

    if (env->RegisterNatives(MemoryInfo_clazz(env),
            kMethodsMemoryInfo,
            kMethodsMemoryInfoSize)
        < 0) {
        jni_generator::HandleRegistrationError(
            env, MemoryInfo_clazz(env), __FILE__);
        return false;
    }

    return true;
}

#endif // com_tencent_smtt_memory_MemoryInfo_JNI
