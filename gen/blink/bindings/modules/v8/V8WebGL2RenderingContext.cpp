// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/interface.cpp.tmpl

// clang-format on
#include "V8WebGL2RenderingContext.h"

#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/GeneratedCodeHelper.h"
#include "bindings/core/v8/ScriptPromise.h"
#include "bindings/core/v8/ScriptState.h"
#include "bindings/core/v8/ScriptValue.h"
#include "bindings/core/v8/V8ArrayBuffer.h"
#include "bindings/core/v8/V8ArrayBufferView.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8Float32Array.h"
#include "bindings/core/v8/V8GCController.h"
#include "bindings/core/v8/V8HTMLCanvasElement.h"
#include "bindings/core/v8/V8HTMLImageElement.h"
#include "bindings/core/v8/V8HTMLVideoElement.h"
#include "bindings/core/v8/V8ImageBitmap.h"
#include "bindings/core/v8/V8ImageData.h"
#include "bindings/core/v8/V8Int32Array.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "bindings/core/v8/V8OffscreenCanvas.h"
#include "bindings/core/v8/V8Uint32Array.h"
#include "bindings/modules/v8/V8WebGLActiveInfo.h"
#include "bindings/modules/v8/V8WebGLBuffer.h"
#include "bindings/modules/v8/V8WebGLContextAttributes.h"
#include "bindings/modules/v8/V8WebGLFramebuffer.h"
#include "bindings/modules/v8/V8WebGLProgram.h"
#include "bindings/modules/v8/V8WebGLQuery.h"
#include "bindings/modules/v8/V8WebGLRenderbuffer.h"
#include "bindings/modules/v8/V8WebGLSampler.h"
#include "bindings/modules/v8/V8WebGLShader.h"
#include "bindings/modules/v8/V8WebGLShaderPrecisionFormat.h"
#include "bindings/modules/v8/V8WebGLSync.h"
#include "bindings/modules/v8/V8WebGLTexture.h"
#include "bindings/modules/v8/V8WebGLTransformFeedback.h"
#include "bindings/modules/v8/V8WebGLUniformLocation.h"
#include "bindings/modules/v8/V8WebGLVertexArrayObject.h"
#include "core/dom/Document.h"
#include "core/dom/Element.h"
#include "core/dom/FlexibleArrayBufferView.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
const WrapperTypeInfo V8WebGL2RenderingContext::wrapperTypeInfo = { gin::kEmbedderBlink, V8WebGL2RenderingContext::domTemplate, V8WebGL2RenderingContext::trace, V8WebGL2RenderingContext::traceWrappers, V8WebGL2RenderingContext::visitDOMWrapper, nullptr, "WebGL2RenderingContext", 0, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::ObjectClassId, WrapperTypeInfo::NotInheritFromActiveScriptWrappable, WrapperTypeInfo::NotInheritFromEventTarget, WrapperTypeInfo::Dependent };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in WebGL2RenderingContext.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& WebGL2RenderingContext::s_wrapperTypeInfo = V8WebGL2RenderingContext::wrapperTypeInfo;

// not [ActiveScriptWrappable]
static_assert(
    !std::is_base_of<ActiveScriptWrappableBase, WebGL2RenderingContext>::value,
    "WebGL2RenderingContext inherits from ActiveScriptWrappable<>, but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");
static_assert(
    std::is_same<decltype(&WebGL2RenderingContext::hasPendingActivity),
        decltype(&ScriptWrappable::hasPendingActivity)>::value,
    "WebGL2RenderingContext is overriding hasPendingActivity(), but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");

namespace WebGL2RenderingContextV8Internal {

    static void canvasAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(holder);

        HTMLCanvasElementOrOffscreenCanvas result;
        impl->getHTMLOrOffscreenCanvas(result);

        v8SetReturnValue(info, result);
    }

    MODULES_EXPORT void canvasAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::canvasAttributeGetter(info);
    }

    static void drawingBufferWidthAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(holder);

        v8SetReturnValueInt(info, impl->drawingBufferWidth());
    }

    MODULES_EXPORT void drawingBufferWidthAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawingBufferWidthAttributeGetter(info);
    }

    static void drawingBufferHeightAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(holder);

        v8SetReturnValueInt(info, impl->drawingBufferHeight());
    }

    MODULES_EXPORT void drawingBufferHeightAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawingBufferHeightAttributeGetter(info);
    }

    static void bufferData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        DOMArrayBufferView* srcData;
        unsigned usage;
        unsigned srcOffset;
        unsigned length;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcData = info[1]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[1])) : 0;
        if (!srcData) {
            exceptionState.throwTypeError("parameter 2 is not of type 'ArrayBufferView'.");

            return;
        }

        usage = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            length = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            length = 0u;
        }

        impl->bufferData(target, srcData, usage, srcOffset, length);
    }

    static void bufferSubData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferSubData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        long long dstByteOffset;
        DOMArrayBufferView* srcData;
        unsigned srcOffset;
        unsigned length;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstByteOffset = toInt64(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcData = info[2]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[2])) : 0;
        if (!srcData) {
            exceptionState.throwTypeError("parameter 3 is not of type 'ArrayBufferView'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            length = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            length = 0u;
        }

        impl->bufferSubData(target, dstByteOffset, srcData, srcOffset, length);
    }

    static void copyBufferSubDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "copyBufferSubData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned readTarget;
        unsigned writeTarget;
        long long readOffset;
        long long writeOffset;
        long long size;
        readTarget = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        writeTarget = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        readOffset = toInt64(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        writeOffset = toInt64(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        size = toInt64(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
    }

    MODULES_EXPORT void copyBufferSubDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::copyBufferSubDataMethod(info);
    }

    static void getBufferSubDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getBufferSubData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned target;
        long long srcByteOffset;
        DOMArrayBufferView* dstData;
        unsigned dstOffset;
        unsigned length;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcByteOffset = toInt64(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstData = info[2]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[2])) : 0;
        if (!dstData) {
            exceptionState.throwTypeError("parameter 3 is not of type 'ArrayBufferView'.");

            return;
        }

        if (!info[3]->IsUndefined()) {
            dstOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            dstOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            length = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            length = 0u;
        }

        impl->getBufferSubData(target, srcByteOffset, dstData, dstOffset, length);
    }

    MODULES_EXPORT void getBufferSubDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getBufferSubDataMethod(info);
    }

    static void blitFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "blitFramebuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 10)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(10, info.Length()));
            return;
        }

        int srcX0;
        int srcY0;
        int srcX1;
        int srcY1;
        int dstX0;
        int dstY0;
        int dstX1;
        int dstY1;
        unsigned mask;
        unsigned filter;
        srcX0 = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcY0 = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcX1 = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcY1 = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstX0 = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstY0 = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstX1 = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstY1 = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        mask = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        filter = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    }

    MODULES_EXPORT void blitFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::blitFramebufferMethod(info);
    }

    static void framebufferTextureLayerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "framebufferTextureLayer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned target;
        unsigned attachment;
        WebGLTexture* texture;
        int level;
        int layer;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        attachment = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        texture = V8WebGLTexture::toImplWithTypeCheck(info.GetIsolate(), info[2]);
        if (!texture && !isUndefinedOrNull(info[2])) {
            exceptionState.throwTypeError("parameter 3 is not of type 'WebGLTexture'.");

            return;
        }

        level = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        layer = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->framebufferTextureLayer(target, attachment, texture, level, layer);
    }

    MODULES_EXPORT void framebufferTextureLayerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::framebufferTextureLayerMethod(info);
    }

    static void getInternalformatParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getInternalformatParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned target;
        unsigned internalformat;
        unsigned pname;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getInternalformatParameter(scriptState, target, internalformat, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getInternalformatParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getInternalformatParameterMethod(info);
    }

    static void invalidateFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "invalidateFramebuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        Vector<unsigned> attachments;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        attachments = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->invalidateFramebuffer(target, attachments);
    }

    MODULES_EXPORT void invalidateFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::invalidateFramebufferMethod(info);
    }

    static void invalidateSubFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "invalidateSubFramebuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 6)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(6, info.Length()));
            return;
        }

        unsigned target;
        Vector<unsigned> attachments;
        int x;
        int y;
        int width;
        int height;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        attachments = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        x = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->invalidateSubFramebuffer(target, attachments, x, y, width, height);
    }

    MODULES_EXPORT void invalidateSubFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::invalidateSubFramebufferMethod(info);
    }

    static void readBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "readBuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned mode;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->readBuffer(mode);
    }

    MODULES_EXPORT void readBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::readBufferMethod(info);
    }

    static void renderbufferStorageMultisampleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "renderbufferStorageMultisample");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned target;
        int samples;
        unsigned internalformat;
        int width;
        int height;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        samples = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->renderbufferStorageMultisample(target, samples, internalformat, width, height);
    }

    MODULES_EXPORT void renderbufferStorageMultisampleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::renderbufferStorageMultisampleMethod(info);
    }

    static void texImage2D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, offset);
    }

    static void texImage2D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        ImageData* data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!data) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ImageData'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, data);
    }

    static void texImage2D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        HTMLImageElement* image;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        image = V8HTMLImageElement::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!image) {
            exceptionState.throwTypeError("parameter 9 is not of type 'HTMLImageElement'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, image, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2D4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        HTMLCanvasElement* canvas;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        canvas = V8HTMLCanvasElement::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!canvas) {
            exceptionState.throwTypeError("parameter 9 is not of type 'HTMLCanvasElement'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, canvas, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2D5Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        HTMLVideoElement* video;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        video = V8HTMLVideoElement::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!video) {
            exceptionState.throwTypeError("parameter 9 is not of type 'HTMLVideoElement'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, video, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2D6Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        ImageBitmap* bitmap;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bitmap = V8ImageBitmap::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!bitmap) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ImageBitmap'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, bitmap, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2D7Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* srcData;
        unsigned srcOffset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcData = info[8]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[8])) : 0;
        if (!srcData) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ArrayBufferView'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, srcData, srcOffset);
    }

    static void texSubImage2D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, offset);
    }

    static void texSubImage2D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        ImageData* data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!data) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ImageData'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, data);
    }

    static void texSubImage2D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        HTMLImageElement* image;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        image = V8HTMLImageElement::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!image) {
            exceptionState.throwTypeError("parameter 9 is not of type 'HTMLImageElement'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, image, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2D4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        HTMLCanvasElement* canvas;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        canvas = V8HTMLCanvasElement::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!canvas) {
            exceptionState.throwTypeError("parameter 9 is not of type 'HTMLCanvasElement'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, canvas, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2D5Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        HTMLVideoElement* video;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        video = V8HTMLVideoElement::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!video) {
            exceptionState.throwTypeError("parameter 9 is not of type 'HTMLVideoElement'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, video, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2D6Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        ImageBitmap* bitmap;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bitmap = V8ImageBitmap::toImplWithTypeCheck(info.GetIsolate(), info[8]);
        if (!bitmap) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ImageBitmap'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, bitmap, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2D7Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* srcData;
        unsigned srcOffset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcData = info[8]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[8])) : 0;
        if (!srcData) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ArrayBufferView'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, srcData, srcOffset);
    }

    static void texStorage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texStorage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned target;
        int levels;
        unsigned internalformat;
        int width;
        int height;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        levels = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texStorage2D(target, levels, internalformat, width, height);
    }

    MODULES_EXPORT void texStorage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texStorage2DMethod(info);
    }

    static void texStorage3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texStorage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 6)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(6, info.Length()));
            return;
        }

        unsigned target;
        int levels;
        unsigned internalformat;
        int width;
        int height;
        int depth;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        levels = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texStorage3D(target, levels, internalformat, width, height, depth);
    }

    MODULES_EXPORT void texStorage3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texStorage3DMethod(info);
    }

    static void texImage3D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, offset);
    }

    static void texImage3D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        ImageData* data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[9]);
        if (!data) {
            exceptionState.throwTypeError("parameter 10 is not of type 'ImageData'.");

            return;
        }

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, data);
    }

    static void texImage3D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        HTMLImageElement* image;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        image = V8HTMLImageElement::toImplWithTypeCheck(info.GetIsolate(), info[9]);
        if (!image) {
            exceptionState.throwTypeError("parameter 10 is not of type 'HTMLImageElement'.");

            return;
        }

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, image, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage3D4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        HTMLCanvasElement* canvas;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        canvas = V8HTMLCanvasElement::toImplWithTypeCheck(info.GetIsolate(), info[9]);
        if (!canvas) {
            exceptionState.throwTypeError("parameter 10 is not of type 'HTMLCanvasElement'.");

            return;
        }

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, canvas, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage3D5Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        HTMLVideoElement* video;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        video = V8HTMLVideoElement::toImplWithTypeCheck(info.GetIsolate(), info[9]);
        if (!video) {
            exceptionState.throwTypeError("parameter 10 is not of type 'HTMLVideoElement'.");

            return;
        }

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, video, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage3D6Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        ImageBitmap* bitmap;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bitmap = V8ImageBitmap::toImplWithTypeCheck(info.GetIsolate(), info[9]);
        if (!bitmap) {
            exceptionState.throwTypeError("parameter 10 is not of type 'ImageBitmap'.");

            return;
        }

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, bitmap, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage3D7Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* pixels;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = info[9]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[9])) : 0;
        if (!pixels && !isUndefinedOrNull(info[9])) {
            exceptionState.throwTypeError("parameter 10 is not of type 'ArrayBufferView'.");

            return;
        }

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
    }

    static void texImage3D8Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int depth;
        int border;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* pixels;
        unsigned srcOffset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = info[9]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[9])) : 0;
        if (!pixels) {
            exceptionState.throwTypeError("parameter 10 is not of type 'ArrayBufferView'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[10], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels, srcOffset);
    }

    static void texImage3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(11, info.Length())) {
        case 10:
            if (isUndefinedOrNull(info[9])) {
                texImage3D7Method(info);
                return;
            }
            if (V8ImageData::hasInstance(info[9], info.GetIsolate())) {
                texImage3D2Method(info);
                return;
            }
            if (V8HTMLImageElement::hasInstance(info[9], info.GetIsolate())) {
                texImage3D3Method(info);
                return;
            }
            if (V8HTMLCanvasElement::hasInstance(info[9], info.GetIsolate())) {
                texImage3D4Method(info);
                return;
            }
            if (V8HTMLVideoElement::hasInstance(info[9], info.GetIsolate())) {
                texImage3D5Method(info);
                return;
            }
            if (V8ImageBitmap::hasInstance(info[9], info.GetIsolate())) {
                texImage3D6Method(info);
                return;
            }
            if (info[9]->IsArrayBufferView()) {
                texImage3D7Method(info);
                return;
            }
            if (true) {
                texImage3D1Method(info);
                return;
            }
            break;
        case 11:
            if (true) {
                texImage3D8Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage3D");

        if (isArityError) {
            if (info.Length() < 10) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(10, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void texImage3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texImage3DMethod(info);
    }

    static void texSubImage3D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        unsigned type;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[10], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
    }

    static void texSubImage3D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        unsigned type;
        ImageData* data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[10]);
        if (!data) {
            exceptionState.throwTypeError("parameter 11 is not of type 'ImageData'.");

            return;
        }

        impl->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    }

    static void texSubImage3D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        unsigned type;
        HTMLImageElement* image;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        image = V8HTMLImageElement::toImplWithTypeCheck(info.GetIsolate(), info[10]);
        if (!image) {
            exceptionState.throwTypeError("parameter 11 is not of type 'HTMLImageElement'.");

            return;
        }

        impl->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, image, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage3D4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        unsigned type;
        HTMLCanvasElement* canvas;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        canvas = V8HTMLCanvasElement::toImplWithTypeCheck(info.GetIsolate(), info[10]);
        if (!canvas) {
            exceptionState.throwTypeError("parameter 11 is not of type 'HTMLCanvasElement'.");

            return;
        }

        impl->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, canvas, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage3D5Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        unsigned type;
        HTMLVideoElement* video;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        video = V8HTMLVideoElement::toImplWithTypeCheck(info.GetIsolate(), info[10]);
        if (!video) {
            exceptionState.throwTypeError("parameter 11 is not of type 'HTMLVideoElement'.");

            return;
        }

        impl->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, video, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage3D6Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        unsigned type;
        ImageBitmap* bitmap;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bitmap = V8ImageBitmap::toImplWithTypeCheck(info.GetIsolate(), info[10]);
        if (!bitmap) {
            exceptionState.throwTypeError("parameter 11 is not of type 'ImageBitmap'.");

            return;
        }

        impl->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bitmap, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage3D7Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* pixels;
        unsigned srcOffset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = info[10]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[10])) : 0;
        if (!pixels) {
            exceptionState.throwTypeError("parameter 11 is not of type 'ArrayBufferView'.");

            return;
        }

        if (!info[11]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[11], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }

        impl->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels, srcOffset);
    }

    static void texSubImage3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(12, info.Length())) {
        case 11:
            if (V8ImageData::hasInstance(info[10], info.GetIsolate())) {
                texSubImage3D2Method(info);
                return;
            }
            if (V8HTMLImageElement::hasInstance(info[10], info.GetIsolate())) {
                texSubImage3D3Method(info);
                return;
            }
            if (V8HTMLCanvasElement::hasInstance(info[10], info.GetIsolate())) {
                texSubImage3D4Method(info);
                return;
            }
            if (V8HTMLVideoElement::hasInstance(info[10], info.GetIsolate())) {
                texSubImage3D5Method(info);
                return;
            }
            if (V8ImageBitmap::hasInstance(info[10], info.GetIsolate())) {
                texSubImage3D6Method(info);
                return;
            }
            if (info[10]->IsArrayBufferView()) {
                texSubImage3D7Method(info);
                return;
            }
            if (true) {
                texSubImage3D1Method(info);
                return;
            }
            break;
        case 12:
            if (true) {
                texSubImage3D7Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage3D");

        if (isArityError) {
            if (info.Length() < 11) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(11, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void texSubImage3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texSubImage3DMethod(info);
    }

    static void copyTexSubImage3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "copyTexSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 9)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(9, info.Length()));
            return;
        }

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int x;
        int y;
        int width;
        int height;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->copyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    }

    MODULES_EXPORT void copyTexSubImage3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::copyTexSubImage3DMethod(info);
    }

    static void compressedTexImage2D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        unsigned internalformat;
        int width;
        int height;
        int border;
        DOMArrayBufferView* data;
        unsigned srcOffset;
        unsigned srcLengthOverride;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[6]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[6])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ArrayBufferView'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[8]->IsUndefined()) {
            srcLengthOverride = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLengthOverride = 0u;
        }

        impl->compressedTexImage2D(target, level, internalformat, width, height, border, data, srcOffset, srcLengthOverride);
    }

    static void compressedTexSubImage2D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        DOMArrayBufferView* data;
        unsigned srcOffset;
        unsigned srcLengthOverride;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[7]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[7])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 8 is not of type 'ArrayBufferView'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[9]->IsUndefined()) {
            srcLengthOverride = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLengthOverride = 0u;
        }

        impl->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data, srcOffset, srcLengthOverride);
    }

    static void compressedTexImage3D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        unsigned internalformat;
        int width;
        int height;
        int depth;
        int border;
        DOMArrayBufferView* data;
        unsigned srcOffset;
        unsigned srcLengthOverride;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[7]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[7])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 8 is not of type 'ArrayBufferView'.");

            return;
        }

        if (!info[8]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[9]->IsUndefined()) {
            srcLengthOverride = toUInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLengthOverride = 0u;
        }

        impl->compressedTexImage3D(target, level, internalformat, width, height, depth, border, data, srcOffset, srcLengthOverride);
    }

    static void compressedTexSubImage3D1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        DOMArrayBufferView* data;
        unsigned srcOffset;
        unsigned srcLengthOverride;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[9]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[9])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 10 is not of type 'ArrayBufferView'.");

            return;
        }

        if (!info[10]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[10], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[11]->IsUndefined()) {
            srcLengthOverride = toUInt32(info.GetIsolate(), info[11], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLengthOverride = 0u;
        }

        impl->compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, data, srcOffset, srcLengthOverride);
    }

    static void compressedTexImage2D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        unsigned internalformat;
        int width;
        int height;
        int border;
        int imageSize;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        imageSize = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->compressedTexImage2D(target, level, internalformat, width, height, border, imageSize, offset);
    }

    static void compressedTexSubImage2D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        int imageSize;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        imageSize = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, offset);
    }

    static void compressedTexImage3D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        unsigned internalformat;
        int width;
        int height;
        int depth;
        int border;
        int imageSize;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        imageSize = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->compressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, offset);
    }

    static void compressedTexImage3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(10, info.Length())) {
        case 8:
            if (true) {
                compressedTexImage3D1Method(info);
                return;
            }
            break;
        case 9:
            if (info[7]->IsArrayBufferView()) {
                compressedTexImage3D1Method(info);
                return;
            }
            if (true) {
                compressedTexImage3D2Method(info);
                return;
            }
            break;
        case 10:
            if (true) {
                compressedTexImage3D1Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexImage3D");

        if (isArityError) {
            if (info.Length() < 8) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(8, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void compressedTexImage3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::compressedTexImage3DMethod(info);
    }

    static void compressedTexSubImage3D2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexSubImage3D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int zoffset;
        int width;
        int height;
        int depth;
        unsigned format;
        int imageSize;
        long long offset;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zoffset = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[8], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        imageSize = toInt32(info.GetIsolate(), info[9], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[10], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, offset);
    }

    static void compressedTexSubImage3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(12, info.Length())) {
        case 10:
            if (true) {
                compressedTexSubImage3D1Method(info);
                return;
            }
            break;
        case 11:
            if (info[9]->IsArrayBufferView()) {
                compressedTexSubImage3D1Method(info);
                return;
            }
            if (true) {
                compressedTexSubImage3D2Method(info);
                return;
            }
            break;
        case 12:
            if (true) {
                compressedTexSubImage3D1Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexSubImage3D");

        if (isArityError) {
            if (info.Length() < 10) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(10, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void compressedTexSubImage3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::compressedTexSubImage3DMethod(info);
    }

    static void getFragDataLocationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getFragDataLocation", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLProgram* program;
        V8StringResource<> name;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getFragDataLocation", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        name = info[1];
        if (!name.prepare())
            return;

        v8SetReturnValueInt(info, impl->getFragDataLocation(program, name));
    }

    MODULES_EXPORT void getFragDataLocationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getFragDataLocationMethod(info);
    }

    static void uniform1uiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1ui");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        unsigned v0;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v0 = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform1ui(location, v0);
    }

    MODULES_EXPORT void uniform1uiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform1uiMethod(info);
    }

    static void uniform2uiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2ui");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        unsigned v0;
        unsigned v1;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v0 = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v1 = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform2ui(location, v0, v1);
    }

    MODULES_EXPORT void uniform2uiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform2uiMethod(info);
    }

    static void uniform3uiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3ui");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        unsigned v0;
        unsigned v1;
        unsigned v2;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v0 = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v1 = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v2 = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform3ui(location, v0, v1, v2);
    }

    MODULES_EXPORT void uniform3uiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform3uiMethod(info);
    }

    static void uniform4uiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4ui");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        unsigned v0;
        unsigned v1;
        unsigned v2;
        unsigned v3;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v0 = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v1 = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v2 = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v3 = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform4ui(location, v0, v1, v2, v3);
    }

    MODULES_EXPORT void uniform4uiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform4uiMethod(info);
    }

    static void uniform1fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform1fv(location, v, srcOffset, srcLength);
    }

    static void uniform1fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform1fv(location, v, srcOffset, srcLength);
    }

    static void uniform2fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform2fv(location, v, srcOffset, srcLength);
    }

    static void uniform2fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform2fv(location, v, srcOffset, srcLength);
    }

    static void uniform3fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform3fv(location, v, srcOffset, srcLength);
    }

    static void uniform3fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform3fv(location, v, srcOffset, srcLength);
    }

    static void uniform4fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform4fv(location, v, srcOffset, srcLength);
    }

    static void uniform4fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform4fv(location, v, srcOffset, srcLength);
    }

    static void uniform1iv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Int32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform1iv(location, v, srcOffset, srcLength);
    }

    static void uniform1iv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform1iv(location, v, srcOffset, srcLength);
    }

    static void uniform2iv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Int32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform2iv(location, v, srcOffset, srcLength);
    }

    static void uniform2iv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform2iv(location, v, srcOffset, srcLength);
    }

    static void uniform3iv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Int32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform3iv(location, v, srcOffset, srcLength);
    }

    static void uniform3iv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform3iv(location, v, srcOffset, srcLength);
    }

    static void uniform4iv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Int32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform4iv(location, v, srcOffset, srcLength);
    }

    static void uniform4iv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform4iv(location, v, srcOffset, srcLength);
    }

    static void uniform1uiv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleUint32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Uint32Array'.");

            return;
        }

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform1uiv(location, v, srcOffset, srcLength);
    }

    static void uniform1uiv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<unsigned> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform1uiv(location, v, srcOffset, srcLength);
    }

    static void uniform1uivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsUint32Array()) {
                uniform1uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1uiv2Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsUint32Array()) {
                uniform1uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1uiv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsUint32Array()) {
                uniform1uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1uiv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1uiv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform1uivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform1uivMethod(info);
    }

    static void uniform2uiv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleUint32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Uint32Array'.");

            return;
        }

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform2uiv(location, v, srcOffset, srcLength);
    }

    static void uniform2uiv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<unsigned> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform2uiv(location, v, srcOffset, srcLength);
    }

    static void uniform2uivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsUint32Array()) {
                uniform2uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2uiv2Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsUint32Array()) {
                uniform2uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2uiv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsUint32Array()) {
                uniform2uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2uiv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2uiv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform2uivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform2uivMethod(info);
    }

    static void uniform3uiv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleUint32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Uint32Array'.");

            return;
        }

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform3uiv(location, v, srcOffset, srcLength);
    }

    static void uniform3uiv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<unsigned> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform3uiv(location, v, srcOffset, srcLength);
    }

    static void uniform3uivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsUint32Array()) {
                uniform3uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3uiv2Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsUint32Array()) {
                uniform3uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3uiv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsUint32Array()) {
                uniform3uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3uiv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3uiv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform3uivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform3uivMethod(info);
    }

    static void uniform4uiv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleUint32ArrayView v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Uint32Array'.");

            return;
        }

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform4uiv(location, v, srcOffset, srcLength);
    }

    static void uniform4uiv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<unsigned> v;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[2]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[3]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniform4uiv(location, v, srcOffset, srcLength);
    }

    static void uniform4uivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsUint32Array()) {
                uniform4uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4uiv2Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsUint32Array()) {
                uniform4uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4uiv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsUint32Array()) {
                uniform4uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4uiv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4uiv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform4uivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform4uivMethod(info);
    }

    static void uniformMatrix2fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* array;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!array) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix2fv(location, transpose, array, srcOffset, srcLength);
    }

    static void uniformMatrix2fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> array;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix2fv(location, transpose, array, srcOffset, srcLength);
    }

    static void uniformMatrix3fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* array;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!array) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix3fv(location, transpose, array, srcOffset, srcLength);
    }

    static void uniformMatrix3fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> array;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix3fv(location, transpose, array, srcOffset, srcLength);
    }

    static void uniformMatrix4fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* array;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!array) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix4fv(location, transpose, array, srcOffset, srcLength);
    }

    static void uniformMatrix4fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> array;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix4fv(location, transpose, array, srcOffset, srcLength);
    }

    static void uniformMatrix2x3fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2x3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix2x3fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix2x3fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2x3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix2x3fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix2x3fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2x3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2x3fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2x3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2x3fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2x3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2x3fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2x3fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix2x3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix2x3fvMethod(info);
    }

    static void uniformMatrix3x2fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3x2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix3x2fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix3x2fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3x2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix3x2fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix3x2fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3x2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3x2fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3x2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3x2fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3x2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3x2fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3x2fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix3x2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix3x2fvMethod(info);
    }

    static void uniformMatrix2x4fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2x4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix2x4fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix2x4fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2x4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix2x4fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix2x4fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2x4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2x4fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2x4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2x4fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2x4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2x4fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2x4fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix2x4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix2x4fvMethod(info);
    }

    static void uniformMatrix4x2fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4x2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix4x2fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix4x2fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4x2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix4x2fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix4x2fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4x2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4x2fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4x2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4x2fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4x2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4x2fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4x2fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix4x2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix4x2fvMethod(info);
    }

    static void uniformMatrix3x4fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3x4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix3x4fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix3x4fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3x4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix3x4fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix3x4fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3x4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3x4fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3x4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3x4fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3x4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3x4fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3x4fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix3x4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix3x4fvMethod(info);
    }

    static void uniformMatrix4x3fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4x3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix4x3fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix4x3fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4x3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> value;
        unsigned srcOffset;
        unsigned srcLength;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        if (!info[3]->IsUndefined()) {
            srcOffset = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcOffset = 0u;
        }
        if (!info[4]->IsUndefined()) {
            srcLength = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            srcLength = 0u;
        }

        impl->uniformMatrix4x3fv(location, transpose, value, srcOffset, srcLength);
    }

    static void uniformMatrix4x3fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4x3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4x3fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4x3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4x3fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4x3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4x3fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4x3fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix4x3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix4x3fvMethod(info);
    }

    static void vertexAttribI4iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4i");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned index;
        int x;
        int y;
        int z;
        int w;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        z = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        w = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttribI4i(index, x, y, z, w);
    }

    MODULES_EXPORT void vertexAttribI4iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttribI4iMethod(info);
    }

    static void vertexAttribI4iv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned index;
        DOMInt32Array* v;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v = info[1]->IsInt32Array() ? V8Int32Array::toImpl(v8::Local<v8::Int32Array>::Cast(info[1])) : 0;
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Int32Array'.");

            return;
        }

        impl->vertexAttribI4iv(index, v);
    }

    static void vertexAttribI4iv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned index;
        Vector<int> v;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttribI4iv(index, v);
    }

    static void vertexAttribI4ivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(2, info.Length())) {
        case 2:
            if (info[1]->IsInt32Array()) {
                vertexAttribI4iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                vertexAttribI4iv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4iv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void vertexAttribI4ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttribI4ivMethod(info);
    }

    static void vertexAttribI4uiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4ui");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned index;
        unsigned x;
        unsigned y;
        unsigned z;
        unsigned w;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        z = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        w = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttribI4ui(index, x, y, z, w);
    }

    MODULES_EXPORT void vertexAttribI4uiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttribI4uiMethod(info);
    }

    static void vertexAttribI4uiv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned index;
        DOMUint32Array* v;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v = info[1]->IsUint32Array() ? V8Uint32Array::toImpl(v8::Local<v8::Uint32Array>::Cast(info[1])) : 0;
        if (!v) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Uint32Array'.");

            return;
        }

        impl->vertexAttribI4uiv(index, v);
    }

    static void vertexAttribI4uiv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4uiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned index;
        Vector<unsigned> v;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttribI4uiv(index, v);
    }

    static void vertexAttribI4uivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(2, info.Length())) {
        case 2:
            if (info[1]->IsUint32Array()) {
                vertexAttribI4uiv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                vertexAttribI4uiv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribI4uiv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void vertexAttribI4uivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttribI4uivMethod(info);
    }

    static void vertexAttribIPointerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribIPointer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned index;
        int size;
        unsigned type;
        int stride;
        long long offset;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        size = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        stride = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttribIPointer(index, size, type, stride, offset);
    }

    MODULES_EXPORT void vertexAttribIPointerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttribIPointerMethod(info);
    }

    static void vertexAttribDivisorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribDivisor");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned index;
        unsigned divisor;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        divisor = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttribDivisor(index, divisor);
    }

    MODULES_EXPORT void vertexAttribDivisorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttribDivisorMethod(info);
    }

    static void drawArraysInstancedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "drawArraysInstanced");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned mode;
        int first;
        int count;
        int instanceCount;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        first = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        count = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        instanceCount = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->drawArraysInstanced(mode, first, count, instanceCount);
    }

    MODULES_EXPORT void drawArraysInstancedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawArraysInstancedMethod(info);
    }

    static void drawElementsInstancedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "drawElementsInstanced");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned mode;
        int count;
        unsigned type;
        long long offset;
        int instanceCount;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        count = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        instanceCount = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->drawElementsInstanced(mode, count, type, offset, instanceCount);
    }

    MODULES_EXPORT void drawElementsInstancedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawElementsInstancedMethod(info);
    }

    static void drawRangeElementsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "drawRangeElements");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 6)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(6, info.Length()));
            return;
        }

        unsigned mode;
        unsigned start;
        unsigned end;
        int count;
        unsigned type;
        long long offset;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        start = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        end = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        count = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->drawRangeElements(mode, start, end, count, type, offset);
    }

    MODULES_EXPORT void drawRangeElementsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawRangeElementsMethod(info);
    }

    static void drawBuffersMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "drawBuffers");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Vector<unsigned> buffers;
        buffers = toImplArray<Vector<unsigned>>(info[0], 1, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->drawBuffers(buffers);
    }

    MODULES_EXPORT void drawBuffersMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawBuffersMethod(info);
    }

    static void clearBufferiv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned buffer;
        int drawbuffer;
        DOMInt32Array* value;
        buffer = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        drawbuffer = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsInt32Array() ? V8Int32Array::toImpl(v8::Local<v8::Int32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Int32Array'.");

            return;
        }

        impl->clearBufferiv(buffer, drawbuffer, value);
    }

    static void clearBufferiv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned buffer;
        int drawbuffer;
        Vector<int> value;
        buffer = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        drawbuffer = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<int>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clearBufferiv(buffer, drawbuffer, value);
    }

    static void clearBufferivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(3, info.Length())) {
        case 3:
            if (info[2]->IsInt32Array()) {
                clearBufferiv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                clearBufferiv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferiv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void clearBufferivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearBufferivMethod(info);
    }

    static void clearBufferuiv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferuiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned buffer;
        int drawbuffer;
        DOMUint32Array* value;
        buffer = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        drawbuffer = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsUint32Array() ? V8Uint32Array::toImpl(v8::Local<v8::Uint32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Uint32Array'.");

            return;
        }

        impl->clearBufferuiv(buffer, drawbuffer, value);
    }

    static void clearBufferuiv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferuiv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned buffer;
        int drawbuffer;
        Vector<unsigned> value;
        buffer = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        drawbuffer = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<unsigned>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clearBufferuiv(buffer, drawbuffer, value);
    }

    static void clearBufferuivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(3, info.Length())) {
        case 3:
            if (info[2]->IsUint32Array()) {
                clearBufferuiv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                clearBufferuiv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferuiv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void clearBufferuivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearBufferuivMethod(info);
    }

    static void clearBufferfv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferfv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned buffer;
        int drawbuffer;
        DOMFloat32Array* value;
        buffer = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        drawbuffer = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        value = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!value) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        impl->clearBufferfv(buffer, drawbuffer, value);
    }

    static void clearBufferfv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferfv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned buffer;
        int drawbuffer;
        Vector<float> value;
        buffer = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        drawbuffer = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        value = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clearBufferfv(buffer, drawbuffer, value);
    }

    static void clearBufferfvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(3, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                clearBufferfv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                clearBufferfv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferfv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void clearBufferfvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearBufferfvMethod(info);
    }

    static void clearBufferfiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearBufferfi");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned buffer;
        int drawbuffer;
        float depth;
        int stencil;
        buffer = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        drawbuffer = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        depth = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        stencil = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clearBufferfi(buffer, drawbuffer, depth, stencil);
    }

    MODULES_EXPORT void clearBufferfiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearBufferfiMethod(info);
    }

    static void createQueryMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createQuery());
    }

    MODULES_EXPORT void createQueryMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createQueryMethod(info);
    }

    static void deleteQueryMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteQuery", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLQuery* query;
        query = V8WebGLQuery::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!query && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteQuery", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLQuery'."));

            return;
        }

        impl->deleteQuery(query);
    }

    MODULES_EXPORT void deleteQueryMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteQueryMethod(info);
    }

    static void isQueryMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isQuery", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLQuery* query;
        query = V8WebGLQuery::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!query && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isQuery", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLQuery'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isQuery(query));
    }

    MODULES_EXPORT void isQueryMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isQueryMethod(info);
    }

    static void beginQueryMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "beginQuery");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        WebGLQuery* query;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        query = V8WebGLQuery::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!query) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLQuery'.");

            return;
        }

        impl->beginQuery(target, query);
    }

    MODULES_EXPORT void beginQueryMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::beginQueryMethod(info);
    }

    static void endQueryMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "endQuery");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned target;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->endQuery(target);
    }

    MODULES_EXPORT void endQueryMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::endQueryMethod(info);
    }

    static void getQueryMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getQuery");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        unsigned pname;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getQuery(scriptState, target, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getQueryMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getQueryMethod(info);
    }

    static void getQueryParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getQueryParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLQuery* query;
        unsigned pname;
        query = V8WebGLQuery::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!query) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLQuery'.");

            return;
        }

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getQueryParameter(scriptState, query, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getQueryParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getQueryParameterMethod(info);
    }

    static void createSamplerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createSampler());
    }

    MODULES_EXPORT void createSamplerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createSamplerMethod(info);
    }

    static void deleteSamplerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteSampler", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLSampler* sampler;
        sampler = V8WebGLSampler::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sampler && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteSampler", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLSampler'."));

            return;
        }

        impl->deleteSampler(sampler);
    }

    MODULES_EXPORT void deleteSamplerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteSamplerMethod(info);
    }

    static void isSamplerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSampler", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLSampler* sampler;
        sampler = V8WebGLSampler::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sampler && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSampler", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLSampler'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isSampler(sampler));
    }

    MODULES_EXPORT void isSamplerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isSamplerMethod(info);
    }

    static void bindSamplerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindSampler");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned unit;
        WebGLSampler* sampler;
        unit = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        sampler = V8WebGLSampler::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!sampler && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLSampler'.");

            return;
        }

        impl->bindSampler(unit, sampler);
    }

    MODULES_EXPORT void bindSamplerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindSamplerMethod(info);
    }

    static void samplerParameteriMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "samplerParameteri");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLSampler* sampler;
        unsigned pname;
        int param;
        sampler = V8WebGLSampler::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sampler) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLSampler'.");

            return;
        }

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        param = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->samplerParameteri(sampler, pname, param);
    }

    MODULES_EXPORT void samplerParameteriMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::samplerParameteriMethod(info);
    }

    static void samplerParameterfMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "samplerParameterf");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLSampler* sampler;
        unsigned pname;
        float param;
        sampler = V8WebGLSampler::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sampler) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLSampler'.");

            return;
        }

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        param = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->samplerParameterf(sampler, pname, param);
    }

    MODULES_EXPORT void samplerParameterfMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::samplerParameterfMethod(info);
    }

    static void getSamplerParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getSamplerParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLSampler* sampler;
        unsigned pname;
        sampler = V8WebGLSampler::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sampler) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLSampler'.");

            return;
        }

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getSamplerParameter(scriptState, sampler, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getSamplerParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getSamplerParameterMethod(info);
    }

    static void fenceSyncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "fenceSync");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned condition;
        unsigned flags;
        condition = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        flags = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->fenceSync(condition, flags));
    }

    MODULES_EXPORT void fenceSyncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::fenceSyncMethod(info);
    }

    static void isSyncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSync", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLSync* sync;
        sync = V8WebGLSync::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sync && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSync", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLSync'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isSync(sync));
    }

    MODULES_EXPORT void isSyncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isSyncMethod(info);
    }

    static void deleteSyncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteSync", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLSync* sync;
        sync = V8WebGLSync::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sync && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteSync", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLSync'."));

            return;
        }

        impl->deleteSync(sync);
    }

    MODULES_EXPORT void deleteSyncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteSyncMethod(info);
    }

    static void clientWaitSyncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clientWaitSync");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLSync* sync;
        unsigned flags;
        unsigned long long timeout;
        sync = V8WebGLSync::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sync) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLSync'.");

            return;
        }

        flags = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        timeout = toUInt64(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueUnsigned(info, impl->clientWaitSync(sync, flags, timeout));
    }

    MODULES_EXPORT void clientWaitSyncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clientWaitSyncMethod(info);
    }

    static void waitSyncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "waitSync");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLSync* sync;
        unsigned flags;
        long long timeout;
        sync = V8WebGLSync::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sync) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLSync'.");

            return;
        }

        flags = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        timeout = toInt64(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->waitSync(sync, flags, timeout);
    }

    MODULES_EXPORT void waitSyncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::waitSyncMethod(info);
    }

    static void getSyncParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getSyncParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLSync* sync;
        unsigned pname;
        sync = V8WebGLSync::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!sync) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLSync'.");

            return;
        }

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getSyncParameter(scriptState, sync, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getSyncParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getSyncParameterMethod(info);
    }

    static void createTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createTransformFeedback());
    }

    MODULES_EXPORT void createTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createTransformFeedbackMethod(info);
    }

    static void deleteTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteTransformFeedback", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLTransformFeedback* feedback;
        feedback = V8WebGLTransformFeedback::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!feedback && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteTransformFeedback", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLTransformFeedback'."));

            return;
        }

        impl->deleteTransformFeedback(feedback);
    }

    MODULES_EXPORT void deleteTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteTransformFeedbackMethod(info);
    }

    static void isTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isTransformFeedback", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLTransformFeedback* feedback;
        feedback = V8WebGLTransformFeedback::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!feedback && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isTransformFeedback", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLTransformFeedback'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isTransformFeedback(feedback));
    }

    MODULES_EXPORT void isTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isTransformFeedbackMethod(info);
    }

    static void bindTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindTransformFeedback");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        WebGLTransformFeedback* feedback;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        feedback = V8WebGLTransformFeedback::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!feedback && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLTransformFeedback'.");

            return;
        }

        impl->bindTransformFeedback(target, feedback);
    }

    MODULES_EXPORT void bindTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindTransformFeedbackMethod(info);
    }

    static void beginTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "beginTransformFeedback");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned primitiveMode;
        primitiveMode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->beginTransformFeedback(primitiveMode);
    }

    MODULES_EXPORT void beginTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::beginTransformFeedbackMethod(info);
    }

    static void endTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        impl->endTransformFeedback();
    }

    MODULES_EXPORT void endTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::endTransformFeedbackMethod(info);
    }

    static void transformFeedbackVaryingsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "transformFeedbackVaryings");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLProgram* program;
        Vector<String> varyings;
        unsigned bufferMode;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        varyings = toImplArray<Vector<String>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        bufferMode = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->transformFeedbackVaryings(program, varyings, bufferMode);
    }

    MODULES_EXPORT void transformFeedbackVaryingsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::transformFeedbackVaryingsMethod(info);
    }

    static void getTransformFeedbackVaryingMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getTransformFeedbackVarying");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned index;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        index = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->getTransformFeedbackVarying(program, index));
    }

    MODULES_EXPORT void getTransformFeedbackVaryingMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getTransformFeedbackVaryingMethod(info);
    }

    static void pauseTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        impl->pauseTransformFeedback();
    }

    MODULES_EXPORT void pauseTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::pauseTransformFeedbackMethod(info);
    }

    static void resumeTransformFeedbackMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        impl->resumeTransformFeedback();
    }

    MODULES_EXPORT void resumeTransformFeedbackMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::resumeTransformFeedbackMethod(info);
    }

    static void bindBufferBaseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindBufferBase");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned target;
        unsigned index;
        WebGLBuffer* buffer;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        index = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        buffer = V8WebGLBuffer::toImplWithTypeCheck(info.GetIsolate(), info[2]);
        if (!buffer && !isUndefinedOrNull(info[2])) {
            exceptionState.throwTypeError("parameter 3 is not of type 'WebGLBuffer'.");

            return;
        }

        impl->bindBufferBase(target, index, buffer);
    }

    MODULES_EXPORT void bindBufferBaseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindBufferBaseMethod(info);
    }

    static void bindBufferRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindBufferRange");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned target;
        unsigned index;
        WebGLBuffer* buffer;
        long long offset;
        long long size;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        index = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        buffer = V8WebGLBuffer::toImplWithTypeCheck(info.GetIsolate(), info[2]);
        if (!buffer && !isUndefinedOrNull(info[2])) {
            exceptionState.throwTypeError("parameter 3 is not of type 'WebGLBuffer'.");

            return;
        }

        offset = toInt64(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        size = toInt64(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->bindBufferRange(target, index, buffer, offset, size);
    }

    MODULES_EXPORT void bindBufferRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindBufferRangeMethod(info);
    }

    static void getIndexedParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getIndexedParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        unsigned index;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        index = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getIndexedParameter(scriptState, target, index);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getIndexedParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getIndexedParameterMethod(info);
    }

    static void getUniformIndicesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getUniformIndices");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLProgram* program;
        Vector<String> uniformNames;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        uniformNames = toImplArray<Vector<String>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        Nullable<Vector<unsigned>> result = impl->getUniformIndices(program, uniformNames);
        if (result.isNull())
            v8SetReturnValueNull(info);
        else
            v8SetReturnValue(info, ToV8(result.get(), info.Holder(), info.GetIsolate()));
    }

    MODULES_EXPORT void getUniformIndicesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getUniformIndicesMethod(info);
    }

    static void getActiveUniformsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getActiveUniforms");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLProgram* program;
        Vector<unsigned> uniformIndices;
        unsigned pname;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        uniformIndices = toImplArray<Vector<unsigned>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getActiveUniforms(scriptState, program, uniformIndices, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getActiveUniformsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getActiveUniformsMethod(info);
    }

    static void getUniformBlockIndexMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getUniformBlockIndex", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLProgram* program;
        V8StringResource<> uniformBlockName;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getUniformBlockIndex", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        uniformBlockName = info[1];
        if (!uniformBlockName.prepare())
            return;

        v8SetReturnValueUnsigned(info, impl->getUniformBlockIndex(program, uniformBlockName));
    }

    MODULES_EXPORT void getUniformBlockIndexMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getUniformBlockIndexMethod(info);
    }

    static void getActiveUniformBlockParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getActiveUniformBlockParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned uniformBlockIndex;
        unsigned pname;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        uniformBlockIndex = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getActiveUniformBlockParameter(scriptState, program, uniformBlockIndex, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getActiveUniformBlockParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getActiveUniformBlockParameterMethod(info);
    }

    static void getActiveUniformBlockNameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getActiveUniformBlockName");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned uniformBlockIndex;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        uniformBlockIndex = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueStringOrNull(info, impl->getActiveUniformBlockName(program, uniformBlockIndex), info.GetIsolate());
    }

    MODULES_EXPORT void getActiveUniformBlockNameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getActiveUniformBlockNameMethod(info);
    }

    static void uniformBlockBindingMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformBlockBinding");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned uniformBlockIndex;
        unsigned uniformBlockBinding;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        uniformBlockIndex = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        uniformBlockBinding = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
    }

    MODULES_EXPORT void uniformBlockBindingMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformBlockBindingMethod(info);
    }

    static void createVertexArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createVertexArray());
    }

    MODULES_EXPORT void createVertexArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createVertexArrayMethod(info);
    }

    static void deleteVertexArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteVertexArray", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLVertexArrayObject* vertexArray;
        vertexArray = V8WebGLVertexArrayObject::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!vertexArray && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteVertexArray", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLVertexArrayObject'."));

            return;
        }

        impl->deleteVertexArray(vertexArray);
    }

    MODULES_EXPORT void deleteVertexArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteVertexArrayMethod(info);
    }

    static void isVertexArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isVertexArray", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLVertexArrayObject* vertexArray;
        vertexArray = V8WebGLVertexArrayObject::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!vertexArray && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isVertexArray", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLVertexArrayObject'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isVertexArray(vertexArray));
    }

    MODULES_EXPORT void isVertexArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isVertexArrayMethod(info);
    }

    static void bindVertexArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("bindVertexArray", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLVertexArrayObject* vertexArray;
        vertexArray = V8WebGLVertexArrayObject::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!vertexArray && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("bindVertexArray", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLVertexArrayObject'."));

            return;
        }

        impl->bindVertexArray(vertexArray);
    }

    MODULES_EXPORT void bindVertexArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindVertexArrayMethod(info);
    }

    static void readPixels1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "readPixels");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        int x;
        int y;
        int width;
        int height;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* dstData;
        long long offset;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstData = info[6]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[6])) : 0;
        if (!dstData) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ArrayBufferView'.");

            return;
        }

        offset = toInt64(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->readPixels(x, y, width, height, format, type, dstData, offset);
    }

    static void readPixels2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "readPixels");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        int x;
        int y;
        int width;
        int height;
        unsigned format;
        unsigned type;
        long long offset;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->readPixels(x, y, width, height, format, type, offset);
    }

    static void activeTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "activeTexture");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned texture;
        texture = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->activeTexture(texture);
    }

    MODULES_EXPORT void activeTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::activeTextureMethod(info);
    }

    static void attachShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("attachShader", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLProgram* program;
        WebGLShader* shader;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("attachShader", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!shader) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("attachShader", "WebGL2RenderingContext", "parameter 2 is not of type 'WebGLShader'."));

            return;
        }

        impl->attachShader(program, shader);
    }

    MODULES_EXPORT void attachShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::attachShaderMethod(info);
    }

    static void bindAttribLocationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindAttribLocation");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned index;
        V8StringResource<> name;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        index = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        name = info[2];
        if (!name.prepare())
            return;

        impl->bindAttribLocation(program, index, name);
    }

    MODULES_EXPORT void bindAttribLocationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindAttribLocationMethod(info);
    }

    static void bindBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindBuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        WebGLBuffer* buffer;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        buffer = V8WebGLBuffer::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!buffer && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLBuffer'.");

            return;
        }

        impl->bindBuffer(target, buffer);
    }

    MODULES_EXPORT void bindBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindBufferMethod(info);
    }

    static void bindFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindFramebuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        WebGLFramebuffer* framebuffer;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        framebuffer = V8WebGLFramebuffer::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!framebuffer && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLFramebuffer'.");

            return;
        }

        impl->bindFramebuffer(target, framebuffer);
    }

    MODULES_EXPORT void bindFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindFramebufferMethod(info);
    }

    static void bindRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindRenderbuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        WebGLRenderbuffer* renderbuffer;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        renderbuffer = V8WebGLRenderbuffer::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!renderbuffer && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLRenderbuffer'.");

            return;
        }

        impl->bindRenderbuffer(target, renderbuffer);
    }

    MODULES_EXPORT void bindRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindRenderbufferMethod(info);
    }

    static void bindTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bindTexture");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        WebGLTexture* texture;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        texture = V8WebGLTexture::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!texture && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'WebGLTexture'.");

            return;
        }

        impl->bindTexture(target, texture);
    }

    MODULES_EXPORT void bindTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bindTextureMethod(info);
    }

    static void blendColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "blendColor");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        float red;
        float green;
        float blue;
        float alpha;
        red = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        green = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        blue = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        alpha = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->blendColor(red, green, blue, alpha);
    }

    MODULES_EXPORT void blendColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::blendColorMethod(info);
    }

    static void blendEquationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "blendEquation");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned mode;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->blendEquation(mode);
    }

    MODULES_EXPORT void blendEquationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::blendEquationMethod(info);
    }

    static void blendEquationSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "blendEquationSeparate");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned modeRGB;
        unsigned modeAlpha;
        modeRGB = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        modeAlpha = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->blendEquationSeparate(modeRGB, modeAlpha);
    }

    MODULES_EXPORT void blendEquationSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::blendEquationSeparateMethod(info);
    }

    static void blendFuncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "blendFunc");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned sfactor;
        unsigned dfactor;
        sfactor = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dfactor = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->blendFunc(sfactor, dfactor);
    }

    MODULES_EXPORT void blendFuncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::blendFuncMethod(info);
    }

    static void blendFuncSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "blendFuncSeparate");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned srcRGB;
        unsigned dstRGB;
        unsigned srcAlpha;
        unsigned dstAlpha;
        srcRGB = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstRGB = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        srcAlpha = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        dstAlpha = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }

    MODULES_EXPORT void blendFuncSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::blendFuncSeparateMethod(info);
    }

    static void bufferData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        long long size;
        unsigned usage;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        size = toInt64(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        usage = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->bufferData(target, size, usage);
    }

    static void bufferData3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        DOMArrayBufferView* data;
        unsigned usage;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[1]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[1])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 2 is not of type 'ArrayBufferView'.");

            return;
        }

        usage = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->bufferData(target, data, usage);
    }

    static void bufferData4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        DOMArrayBuffer* data;
        unsigned usage;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[1]->IsArrayBuffer() ? V8ArrayBuffer::toImpl(v8::Local<v8::ArrayBuffer>::Cast(info[1])) : 0;
        if (!data && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'ArrayBuffer'.");

            return;
        }

        usage = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->bufferData(target, data, usage);
    }

    static void bufferDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (isUndefinedOrNull(info[1])) {
                bufferData4Method(info);
                return;
            }
            if (info[1]->IsArrayBufferView()) {
                bufferData3Method(info);
                return;
            }
            if (info[1]->IsArrayBuffer()) {
                bufferData4Method(info);
                return;
            }
            if (true) {
                bufferData2Method(info);
                return;
            }
            break;
        case 4:
            if (true) {
                bufferData1Method(info);
                return;
            }
            break;
        case 5:
            if (true) {
                bufferData1Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferData");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void bufferDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bufferDataMethod(info);
    }

    static void bufferSubData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferSubData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        long long offset;
        FlexibleArrayBufferView data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        toFlexibleArrayBufferView(info.GetIsolate(), info[2], data, allocateFlexibleArrayBufferViewStorage(info[2]));
        if (!data) {
            exceptionState.throwTypeError("parameter 3 is not of type 'ArrayBufferView'.");

            return;
        }

        impl->bufferSubData(target, offset, data);
    }

    static void bufferSubData3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferSubData");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        long long offset;
        DOMArrayBuffer* data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[2]->IsArrayBuffer() ? V8ArrayBuffer::toImpl(v8::Local<v8::ArrayBuffer>::Cast(info[2])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 3 is not of type 'ArrayBuffer'.");

            return;
        }

        impl->bufferSubData(target, offset, data);
    }

    static void bufferSubDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsArrayBufferView()) {
                bufferSubData2Method(info);
                return;
            }
            if (info[2]->IsArrayBuffer()) {
                bufferSubData3Method(info);
                return;
            }
            break;
        case 4:
            if (true) {
                bufferSubData1Method(info);
                return;
            }
            break;
        case 5:
            if (true) {
                bufferSubData1Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "bufferSubData");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void bufferSubDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::bufferSubDataMethod(info);
    }

    static void checkFramebufferStatusMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "checkFramebufferStatus");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned target;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueUnsigned(info, impl->checkFramebufferStatus(target));
    }

    MODULES_EXPORT void checkFramebufferStatusMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::checkFramebufferStatusMethod(info);
    }

    static void clearMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clear");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned mask;
        mask = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clear(mask);
    }

    MODULES_EXPORT void clearMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearMethod(info);
    }

    static void clearColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearColor");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        float red;
        float green;
        float blue;
        float alpha;
        red = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        green = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        blue = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        alpha = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clearColor(red, green, blue, alpha);
    }

    MODULES_EXPORT void clearColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearColorMethod(info);
    }

    static void clearDepthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearDepth");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        float depth;
        depth = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clearDepth(depth);
    }

    MODULES_EXPORT void clearDepthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearDepthMethod(info);
    }

    static void clearStencilMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "clearStencil");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int s;
        s = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->clearStencil(s);
    }

    MODULES_EXPORT void clearStencilMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::clearStencilMethod(info);
    }

    static void colorMaskMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "colorMask");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        bool red;
        bool green;
        bool blue;
        bool alpha;
        red = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        green = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        blue = toBoolean(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        alpha = toBoolean(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->colorMask(red, green, blue, alpha);
    }

    MODULES_EXPORT void colorMaskMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::colorMaskMethod(info);
    }

    static void compileShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("compileShader", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLShader* shader;
        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!shader) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("compileShader", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLShader'."));

            return;
        }

        impl->compileShader(shader);
    }

    MODULES_EXPORT void compileShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::compileShaderMethod(info);
    }

    static void compressedTexImage2D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        unsigned internalformat;
        int width;
        int height;
        int border;
        DOMArrayBufferView* data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[6]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[6])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ArrayBufferView'.");

            return;
        }

        impl->compressedTexImage2D(target, level, internalformat, width, height, border, data);
    }

    static void compressedTexImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(9, info.Length())) {
        case 7:
            if (true) {
                compressedTexImage2D3Method(info);
                return;
            }
            break;
        case 8:
            if (info[6]->IsArrayBufferView()) {
                compressedTexImage2D1Method(info);
                return;
            }
            if (true) {
                compressedTexImage2D2Method(info);
                return;
            }
            break;
        case 9:
            if (true) {
                compressedTexImage2D1Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexImage2D");

        if (isArityError) {
            if (info.Length() < 7) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(7, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void compressedTexImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::compressedTexImage2DMethod(info);
    }

    static void compressedTexSubImage2D3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        DOMArrayBufferView* data;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        data = info[7]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[7])) : 0;
        if (!data) {
            exceptionState.throwTypeError("parameter 8 is not of type 'ArrayBufferView'.");

            return;
        }

        impl->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data);
    }

    static void compressedTexSubImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(10, info.Length())) {
        case 8:
            if (true) {
                compressedTexSubImage2D3Method(info);
                return;
            }
            break;
        case 9:
            if (info[7]->IsArrayBufferView()) {
                compressedTexSubImage2D1Method(info);
                return;
            }
            if (true) {
                compressedTexSubImage2D2Method(info);
                return;
            }
            break;
        case 10:
            if (true) {
                compressedTexSubImage2D1Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "compressedTexSubImage2D");

        if (isArityError) {
            if (info.Length() < 8) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(8, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void compressedTexSubImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::compressedTexSubImage2DMethod(info);
    }

    static void copyTexImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "copyTexImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 8)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(8, info.Length()));
            return;
        }

        unsigned target;
        int level;
        unsigned internalformat;
        int x;
        int y;
        int width;
        int height;
        int border;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->copyTexImage2D(target, level, internalformat, x, y, width, height, border);
    }

    MODULES_EXPORT void copyTexImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::copyTexImage2DMethod(info);
    }

    static void copyTexSubImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "copyTexSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 8)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(8, info.Length()));
            return;
        }

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int x;
        int y;
        int width;
        int height;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    }

    MODULES_EXPORT void copyTexSubImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::copyTexSubImage2DMethod(info);
    }

    static void createBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createBuffer());
    }

    MODULES_EXPORT void createBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createBufferMethod(info);
    }

    static void createFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createFramebuffer());
    }

    MODULES_EXPORT void createFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createFramebufferMethod(info);
    }

    static void createProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createProgram());
    }

    MODULES_EXPORT void createProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createProgramMethod(info);
    }

    static void createRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createRenderbuffer());
    }

    MODULES_EXPORT void createRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createRenderbufferMethod(info);
    }

    static void createShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "createShader");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned type;
        type = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->createShader(type));
    }

    MODULES_EXPORT void createShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createShaderMethod(info);
    }

    static void createTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValue(info, impl->createTexture());
    }

    MODULES_EXPORT void createTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::createTextureMethod(info);
    }

    static void cullFaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "cullFace");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned mode;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->cullFace(mode);
    }

    MODULES_EXPORT void cullFaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::cullFaceMethod(info);
    }

    static void deleteBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteBuffer", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLBuffer* buffer;
        buffer = V8WebGLBuffer::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!buffer && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteBuffer", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLBuffer'."));

            return;
        }

        impl->deleteBuffer(buffer);
    }

    MODULES_EXPORT void deleteBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteBufferMethod(info);
    }

    static void deleteFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteFramebuffer", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLFramebuffer* framebuffer;
        framebuffer = V8WebGLFramebuffer::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!framebuffer && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteFramebuffer", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLFramebuffer'."));

            return;
        }

        impl->deleteFramebuffer(framebuffer);
    }

    MODULES_EXPORT void deleteFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteFramebufferMethod(info);
    }

    static void deleteProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteProgram", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLProgram* program;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteProgram", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        impl->deleteProgram(program);
    }

    MODULES_EXPORT void deleteProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteProgramMethod(info);
    }

    static void deleteRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteRenderbuffer", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLRenderbuffer* renderbuffer;
        renderbuffer = V8WebGLRenderbuffer::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!renderbuffer && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteRenderbuffer", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLRenderbuffer'."));

            return;
        }

        impl->deleteRenderbuffer(renderbuffer);
    }

    MODULES_EXPORT void deleteRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteRenderbufferMethod(info);
    }

    static void deleteShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteShader", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLShader* shader;
        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!shader && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteShader", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLShader'."));

            return;
        }

        impl->deleteShader(shader);
    }

    MODULES_EXPORT void deleteShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteShaderMethod(info);
    }

    static void deleteTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteTexture", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLTexture* texture;
        texture = V8WebGLTexture::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!texture && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deleteTexture", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLTexture'."));

            return;
        }

        impl->deleteTexture(texture);
    }

    MODULES_EXPORT void deleteTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::deleteTextureMethod(info);
    }

    static void depthFuncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "depthFunc");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned func;
        func = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->depthFunc(func);
    }

    MODULES_EXPORT void depthFuncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::depthFuncMethod(info);
    }

    static void depthMaskMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "depthMask");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool flag;
        flag = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->depthMask(flag);
    }

    MODULES_EXPORT void depthMaskMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::depthMaskMethod(info);
    }

    static void depthRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "depthRange");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        float zNear;
        float zFar;
        zNear = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        zFar = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->depthRange(zNear, zFar);
    }

    MODULES_EXPORT void depthRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::depthRangeMethod(info);
    }

    static void detachShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("detachShader", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLProgram* program;
        WebGLShader* shader;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("detachShader", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!shader) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("detachShader", "WebGL2RenderingContext", "parameter 2 is not of type 'WebGLShader'."));

            return;
        }

        impl->detachShader(program, shader);
    }

    MODULES_EXPORT void detachShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::detachShaderMethod(info);
    }

    static void disableMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "disable");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned cap;
        cap = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->disable(cap);
    }

    MODULES_EXPORT void disableMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::disableMethod(info);
    }

    static void disableVertexAttribArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "disableVertexAttribArray");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned index;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->disableVertexAttribArray(index);
    }

    MODULES_EXPORT void disableVertexAttribArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::disableVertexAttribArrayMethod(info);
    }

    static void drawArraysMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "drawArrays");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned mode;
        int first;
        int count;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        first = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        count = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->drawArrays(mode, first, count);
    }

    MODULES_EXPORT void drawArraysMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawArraysMethod(info);
    }

    static void drawElementsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "drawElements");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned mode;
        int count;
        unsigned type;
        long long offset;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        count = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->drawElements(mode, count, type, offset);
    }

    MODULES_EXPORT void drawElementsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::drawElementsMethod(info);
    }

    static void enableMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "enable");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned cap;
        cap = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->enable(cap);
    }

    MODULES_EXPORT void enableMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::enableMethod(info);
    }

    static void enableVertexAttribArrayMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "enableVertexAttribArray");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned index;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->enableVertexAttribArray(index);
    }

    MODULES_EXPORT void enableVertexAttribArrayMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::enableVertexAttribArrayMethod(info);
    }

    static void finishMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        impl->finish();
    }

    MODULES_EXPORT void finishMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::finishMethod(info);
    }

    static void flushMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        impl->flush();
    }

    MODULES_EXPORT void flushMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::flushMethod(info);
    }

    static void framebufferRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "framebufferRenderbuffer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned target;
        unsigned attachment;
        unsigned renderbuffertarget;
        WebGLRenderbuffer* renderbuffer;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        attachment = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        renderbuffertarget = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        renderbuffer = V8WebGLRenderbuffer::toImplWithTypeCheck(info.GetIsolate(), info[3]);
        if (!renderbuffer && !isUndefinedOrNull(info[3])) {
            exceptionState.throwTypeError("parameter 4 is not of type 'WebGLRenderbuffer'.");

            return;
        }

        impl->framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    }

    MODULES_EXPORT void framebufferRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::framebufferRenderbufferMethod(info);
    }

    static void framebufferTexture2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "framebufferTexture2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned target;
        unsigned attachment;
        unsigned textarget;
        WebGLTexture* texture;
        int level;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        attachment = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        textarget = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        texture = V8WebGLTexture::toImplWithTypeCheck(info.GetIsolate(), info[3]);
        if (!texture && !isUndefinedOrNull(info[3])) {
            exceptionState.throwTypeError("parameter 4 is not of type 'WebGLTexture'.");

            return;
        }

        level = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->framebufferTexture2D(target, attachment, textarget, texture, level);
    }

    MODULES_EXPORT void framebufferTexture2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::framebufferTexture2DMethod(info);
    }

    static void frontFaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "frontFace");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned mode;
        mode = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->frontFace(mode);
    }

    MODULES_EXPORT void frontFaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::frontFaceMethod(info);
    }

    static void generateMipmapMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "generateMipmap");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned target;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->generateMipmap(target);
    }

    MODULES_EXPORT void generateMipmapMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::generateMipmapMethod(info);
    }

    static void getActiveAttribMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getActiveAttrib");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned index;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        index = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->getActiveAttrib(program, index));
    }

    MODULES_EXPORT void getActiveAttribMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getActiveAttribMethod(info);
    }

    static void getActiveUniformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getActiveUniform");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned index;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        index = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->getActiveUniform(program, index));
    }

    MODULES_EXPORT void getActiveUniformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getActiveUniformMethod(info);
    }

    static void getAttachedShadersMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttachedShaders", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLProgram* program;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttachedShaders", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        Nullable<HeapVector<Member<WebGLShader>>> result = impl->getAttachedShaders(program);
        if (result.isNull())
            v8SetReturnValueNull(info);
        else
            v8SetReturnValue(info, ToV8(result.get(), info.Holder(), info.GetIsolate()));
    }

    MODULES_EXPORT void getAttachedShadersMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getAttachedShadersMethod(info);
    }

    static void getAttribLocationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttribLocation", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLProgram* program;
        V8StringResource<> name;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttribLocation", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        name = info[1];
        if (!name.prepare())
            return;

        v8SetReturnValueInt(info, impl->getAttribLocation(program, name));
    }

    MODULES_EXPORT void getAttribLocationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getAttribLocationMethod(info);
    }

    static void getBufferParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getBufferParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        unsigned pname;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getBufferParameter(scriptState, target, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getBufferParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getBufferParameterMethod(info);
    }

    static void getContextAttributesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        Nullable<WebGLContextAttributes> result;
        impl->getContextAttributes(result);
        if (result.isNull())
            v8SetReturnValueNull(info);
        else
            v8SetReturnValue(info, result.get());
    }

    MODULES_EXPORT void getContextAttributesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getContextAttributesMethod(info);
    }

    static void getErrorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValueUnsigned(info, impl->getError());
    }

    MODULES_EXPORT void getErrorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getErrorMethod(info);
    }

    static void getExtensionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getExtension", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> name;
        name = info[0];
        if (!name.prepare())
            return;

        ScriptValue result = impl->getExtension(scriptState, name);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getExtensionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getExtensionMethod(info);
    }

    static void getFramebufferAttachmentParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getFramebufferAttachmentParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned target;
        unsigned attachment;
        unsigned pname;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        attachment = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getFramebufferAttachmentParameter(scriptState, target, attachment, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getFramebufferAttachmentParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getFramebufferAttachmentParameterMethod(info);
    }

    static void getParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned pname;
        pname = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getParameter(scriptState, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getParameterMethod(info);
    }

    static void getProgramParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getProgramParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLProgram* program;
        unsigned pname;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLProgram'.");

            return;
        }

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getProgramParameter(scriptState, program, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getProgramParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getProgramParameterMethod(info);
    }

    static void getProgramInfoLogMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getProgramInfoLog", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLProgram* program;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getProgramInfoLog", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        v8SetReturnValueStringOrNull(info, impl->getProgramInfoLog(program), info.GetIsolate());
    }

    MODULES_EXPORT void getProgramInfoLogMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getProgramInfoLogMethod(info);
    }

    static void getRenderbufferParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getRenderbufferParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        unsigned pname;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getRenderbufferParameter(scriptState, target, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getRenderbufferParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getRenderbufferParameterMethod(info);
    }

    static void getShaderParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getShaderParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLShader* shader;
        unsigned pname;
        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!shader) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLShader'.");

            return;
        }

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getShaderParameter(scriptState, shader, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getShaderParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getShaderParameterMethod(info);
    }

    static void getShaderInfoLogMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getShaderInfoLog", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLShader* shader;
        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!shader) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getShaderInfoLog", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLShader'."));

            return;
        }

        v8SetReturnValueStringOrNull(info, impl->getShaderInfoLog(shader), info.GetIsolate());
    }

    MODULES_EXPORT void getShaderInfoLogMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getShaderInfoLogMethod(info);
    }

    static void getShaderPrecisionFormatMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getShaderPrecisionFormat");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned shadertype;
        unsigned precisiontype;
        shadertype = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        precisiontype = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->getShaderPrecisionFormat(shadertype, precisiontype));
    }

    MODULES_EXPORT void getShaderPrecisionFormatMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getShaderPrecisionFormatMethod(info);
    }

    static void getShaderSourceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getShaderSource", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLShader* shader;
        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!shader) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getShaderSource", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLShader'."));

            return;
        }

        v8SetReturnValueStringOrNull(info, impl->getShaderSource(shader), info.GetIsolate());
    }

    MODULES_EXPORT void getShaderSourceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getShaderSourceMethod(info);
    }

    static void getSupportedExtensionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        Nullable<Vector<String>> result = impl->getSupportedExtensions();
        if (result.isNull())
            v8SetReturnValueNull(info);
        else
            v8SetReturnValue(info, ToV8(result.get(), info.Holder(), info.GetIsolate()));
    }

    MODULES_EXPORT void getSupportedExtensionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getSupportedExtensionsMethod(info);
    }

    static void getTexParameterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getTexParameter");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        unsigned pname;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getTexParameter(scriptState, target, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getTexParameterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getTexParameterMethod(info);
    }

    static void getUniformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getUniform", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLProgram* program;
        WebGLUniformLocation* location;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getUniform", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!location) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getUniform", "WebGL2RenderingContext", "parameter 2 is not of type 'WebGLUniformLocation'."));

            return;
        }

        ScriptValue result = impl->getUniform(scriptState, program, location);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getUniformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getUniformMethod(info);
    }

    static void getUniformLocationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getUniformLocation", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLProgram* program;
        V8StringResource<> name;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getUniformLocation", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        name = info[1];
        if (!name.prepare())
            return;

        v8SetReturnValue(info, impl->getUniformLocation(program, name));
    }

    MODULES_EXPORT void getUniformLocationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getUniformLocationMethod(info);
    }

    static void getVertexAttribMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getVertexAttrib");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned index;
        unsigned pname;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptValue result = impl->getVertexAttrib(scriptState, index, pname);
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void getVertexAttribMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getVertexAttribMethod(info);
    }

    static void getVertexAttribOffsetMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "getVertexAttribOffset");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned index;
        unsigned pname;
        index = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, static_cast<double>(impl->getVertexAttribOffset(index, pname)));
    }

    MODULES_EXPORT void getVertexAttribOffsetMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::getVertexAttribOffsetMethod(info);
    }

    static void hintMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "hint");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned target;
        unsigned mode;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        mode = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->hint(target, mode);
    }

    MODULES_EXPORT void hintMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::hintMethod(info);
    }

    static void isBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isBuffer", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLBuffer* buffer;
        buffer = V8WebGLBuffer::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!buffer && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isBuffer", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLBuffer'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isBuffer(buffer));
    }

    MODULES_EXPORT void isBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isBufferMethod(info);
    }

    static void isContextLostMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        v8SetReturnValueBool(info, impl->isContextLost());
    }

    MODULES_EXPORT void isContextLostMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isContextLostMethod(info);
    }

    static void isEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "isEnabled");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned cap;
        cap = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueBool(info, impl->isEnabled(cap));
    }

    MODULES_EXPORT void isEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isEnabledMethod(info);
    }

    static void isFramebufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isFramebuffer", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLFramebuffer* framebuffer;
        framebuffer = V8WebGLFramebuffer::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!framebuffer && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isFramebuffer", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLFramebuffer'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isFramebuffer(framebuffer));
    }

    MODULES_EXPORT void isFramebufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isFramebufferMethod(info);
    }

    static void isProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isProgram", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLProgram* program;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isProgram", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isProgram(program));
    }

    MODULES_EXPORT void isProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isProgramMethod(info);
    }

    static void isRenderbufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isRenderbuffer", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLRenderbuffer* renderbuffer;
        renderbuffer = V8WebGLRenderbuffer::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!renderbuffer && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isRenderbuffer", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLRenderbuffer'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isRenderbuffer(renderbuffer));
    }

    MODULES_EXPORT void isRenderbufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isRenderbufferMethod(info);
    }

    static void isShaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isShader", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLShader* shader;
        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!shader && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isShader", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLShader'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isShader(shader));
    }

    MODULES_EXPORT void isShaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isShaderMethod(info);
    }

    static void isTextureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isTexture", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLTexture* texture;
        texture = V8WebGLTexture::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!texture && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isTexture", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLTexture'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isTexture(texture));
    }

    MODULES_EXPORT void isTextureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::isTextureMethod(info);
    }

    static void lineWidthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "lineWidth");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        float width;
        width = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->lineWidth(width);
    }

    MODULES_EXPORT void lineWidthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::lineWidthMethod(info);
    }

    static void linkProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("linkProgram", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLProgram* program;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("linkProgram", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        impl->linkProgram(program);
    }

    MODULES_EXPORT void linkProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::linkProgramMethod(info);
    }

    static void pixelStoreiMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "pixelStorei");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned pname;
        int param;
        pname = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        param = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->pixelStorei(pname, param);
    }

    MODULES_EXPORT void pixelStoreiMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::pixelStoreiMethod(info);
    }

    static void polygonOffsetMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "polygonOffset");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        float factor;
        float units;
        factor = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        units = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->polygonOffset(factor, units);
    }

    MODULES_EXPORT void polygonOffsetMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::polygonOffsetMethod(info);
    }

    static void readPixels3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "readPixels");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        int x;
        int y;
        int width;
        int height;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* pixels;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = info[6]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[6])) : 0;
        if (!pixels && !isUndefinedOrNull(info[6])) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ArrayBufferView'.");

            return;
        }

        impl->readPixels(x, y, width, height, format, type, pixels);
    }

    static void readPixelsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(8, info.Length())) {
        case 7:
            if (isUndefinedOrNull(info[6])) {
                readPixels3Method(info);
                return;
            }
            if (info[6]->IsArrayBufferView()) {
                readPixels3Method(info);
                return;
            }
            if (true) {
                readPixels2Method(info);
                return;
            }
            break;
        case 8:
            if (true) {
                readPixels1Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "readPixels");

        if (isArityError) {
            if (info.Length() < 7) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(7, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void readPixelsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::readPixelsMethod(info);
    }

    static void renderbufferStorageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "renderbufferStorage");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned target;
        unsigned internalformat;
        int width;
        int height;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->renderbufferStorage(target, internalformat, width, height);
    }

    MODULES_EXPORT void renderbufferStorageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::renderbufferStorageMethod(info);
    }

    static void sampleCoverageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "sampleCoverage");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        float value;
        bool invert;
        value = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        invert = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->sampleCoverage(value, invert);
    }

    MODULES_EXPORT void sampleCoverageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::sampleCoverageMethod(info);
    }

    static void scissorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "scissor");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        int x;
        int y;
        int width;
        int height;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->scissor(x, y, width, height);
    }

    MODULES_EXPORT void scissorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::scissorMethod(info);
    }

    static void shaderSourceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shaderSource", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        WebGLShader* shader;
        V8StringResource<> string;
        shader = V8WebGLShader::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!shader) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shaderSource", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLShader'."));

            return;
        }

        string = info[1];
        if (!string.prepare())
            return;

        impl->shaderSource(shader, string);
    }

    MODULES_EXPORT void shaderSourceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::shaderSourceMethod(info);
    }

    static void stencilFuncMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "stencilFunc");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned func;
        int ref;
        unsigned mask;
        func = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ref = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        mask = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->stencilFunc(func, ref, mask);
    }

    MODULES_EXPORT void stencilFuncMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::stencilFuncMethod(info);
    }

    static void stencilFuncSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "stencilFuncSeparate");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned face;
        unsigned func;
        int ref;
        unsigned mask;
        face = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        func = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ref = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        mask = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->stencilFuncSeparate(face, func, ref, mask);
    }

    MODULES_EXPORT void stencilFuncSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::stencilFuncSeparateMethod(info);
    }

    static void stencilMaskMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "stencilMask");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned mask;
        mask = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->stencilMask(mask);
    }

    MODULES_EXPORT void stencilMaskMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::stencilMaskMethod(info);
    }

    static void stencilMaskSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "stencilMaskSeparate");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned face;
        unsigned mask;
        face = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        mask = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->stencilMaskSeparate(face, mask);
    }

    MODULES_EXPORT void stencilMaskSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::stencilMaskSeparateMethod(info);
    }

    static void stencilOpMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "stencilOp");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned fail;
        unsigned zfail;
        unsigned zpass;
        fail = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zfail = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zpass = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->stencilOp(fail, zfail, zpass);
    }

    MODULES_EXPORT void stencilOpMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::stencilOpMethod(info);
    }

    static void stencilOpSeparateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "stencilOpSeparate");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned face;
        unsigned fail;
        unsigned zfail;
        unsigned zpass;
        face = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        fail = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zfail = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        zpass = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->stencilOpSeparate(face, fail, zfail, zpass);
    }

    MODULES_EXPORT void stencilOpSeparateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::stencilOpSeparateMethod(info);
    }

    static void texParameterfMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texParameterf");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned target;
        unsigned pname;
        float param;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        param = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texParameterf(target, pname, param);
    }

    MODULES_EXPORT void texParameterfMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texParameterfMethod(info);
    }

    static void texParameteriMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texParameteri");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned target;
        unsigned pname;
        int param;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pname = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        param = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->texParameteri(target, pname, param);
    }

    MODULES_EXPORT void texParameteriMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texParameteriMethod(info);
    }

    static void texImage2D8Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        int width;
        int height;
        int border;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* pixels;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        border = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = info[8]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[8])) : 0;
        if (!pixels && !isUndefinedOrNull(info[8])) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ArrayBufferView'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
    }

    static void texImage2D9Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        unsigned format;
        unsigned type;
        ImageData* pixels;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[5]);
        if (!pixels) {
            exceptionState.throwTypeError("parameter 6 is not of type 'ImageData'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, format, type, pixels);
    }

    static void texImage2D10Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        unsigned format;
        unsigned type;
        HTMLImageElement* image;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        image = V8HTMLImageElement::toImplWithTypeCheck(info.GetIsolate(), info[5]);
        if (!image) {
            exceptionState.throwTypeError("parameter 6 is not of type 'HTMLImageElement'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, format, type, image, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2D11Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        unsigned format;
        unsigned type;
        HTMLCanvasElement* canvas;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        canvas = V8HTMLCanvasElement::toImplWithTypeCheck(info.GetIsolate(), info[5]);
        if (!canvas) {
            exceptionState.throwTypeError("parameter 6 is not of type 'HTMLCanvasElement'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, format, type, canvas, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2D12Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        unsigned format;
        unsigned type;
        HTMLVideoElement* video;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        video = V8HTMLVideoElement::toImplWithTypeCheck(info.GetIsolate(), info[5]);
        if (!video) {
            exceptionState.throwTypeError("parameter 6 is not of type 'HTMLVideoElement'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, format, type, video, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2D13Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int internalformat;
        unsigned format;
        unsigned type;
        ImageBitmap* bitmap;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        internalformat = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bitmap = V8ImageBitmap::toImplWithTypeCheck(info.GetIsolate(), info[5]);
        if (!bitmap) {
            exceptionState.throwTypeError("parameter 6 is not of type 'ImageBitmap'.");

            return;
        }

        impl->texImage2D(target, level, internalformat, format, type, bitmap, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(10, info.Length())) {
        case 6:
            if (V8ImageData::hasInstance(info[5], info.GetIsolate())) {
                texImage2D9Method(info);
                return;
            }
            if (V8HTMLImageElement::hasInstance(info[5], info.GetIsolate())) {
                texImage2D10Method(info);
                return;
            }
            if (V8HTMLCanvasElement::hasInstance(info[5], info.GetIsolate())) {
                texImage2D11Method(info);
                return;
            }
            if (V8HTMLVideoElement::hasInstance(info[5], info.GetIsolate())) {
                texImage2D12Method(info);
                return;
            }
            if (V8ImageBitmap::hasInstance(info[5], info.GetIsolate())) {
                texImage2D13Method(info);
                return;
            }
            break;
        case 9:
            if (isUndefinedOrNull(info[8])) {
                texImage2D8Method(info);
                return;
            }
            if (V8ImageData::hasInstance(info[8], info.GetIsolate())) {
                texImage2D2Method(info);
                return;
            }
            if (V8HTMLImageElement::hasInstance(info[8], info.GetIsolate())) {
                texImage2D3Method(info);
                return;
            }
            if (V8HTMLCanvasElement::hasInstance(info[8], info.GetIsolate())) {
                texImage2D4Method(info);
                return;
            }
            if (V8HTMLVideoElement::hasInstance(info[8], info.GetIsolate())) {
                texImage2D5Method(info);
                return;
            }
            if (V8ImageBitmap::hasInstance(info[8], info.GetIsolate())) {
                texImage2D6Method(info);
                return;
            }
            if (info[8]->IsArrayBufferView()) {
                texImage2D8Method(info);
                return;
            }
            if (true) {
                texImage2D1Method(info);
                return;
            }
            break;
        case 10:
            if (true) {
                texImage2D7Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texImage2D");

        if (isArityError) {
            if (info.Length() < 6) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(6, info.Length()));
                return;
            }
            if (info.Length() >= 6) {
                exceptionState.throwTypeError(ExceptionMessages::invalidArity("[6, 9, 10]", info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void texImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texImage2DMethod(info);
    }

    static void texSubImage2D8Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        int width;
        int height;
        unsigned format;
        unsigned type;
        DOMArrayBufferView* pixels;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[7], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = info[8]->IsArrayBufferView() ? V8ArrayBufferView::toImpl(v8::Local<v8::ArrayBufferView>::Cast(info[8])) : 0;
        if (!pixels && !isUndefinedOrNull(info[8])) {
            exceptionState.throwTypeError("parameter 9 is not of type 'ArrayBufferView'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
    }

    static void texSubImage2D9Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        unsigned format;
        unsigned type;
        ImageData* pixels;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        pixels = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[6]);
        if (!pixels) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ImageData'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, format, type, pixels);
    }

    static void texSubImage2D10Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        unsigned format;
        unsigned type;
        HTMLImageElement* image;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        image = V8HTMLImageElement::toImplWithTypeCheck(info.GetIsolate(), info[6]);
        if (!image) {
            exceptionState.throwTypeError("parameter 7 is not of type 'HTMLImageElement'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, format, type, image, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2D11Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        unsigned format;
        unsigned type;
        HTMLCanvasElement* canvas;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        canvas = V8HTMLCanvasElement::toImplWithTypeCheck(info.GetIsolate(), info[6]);
        if (!canvas) {
            exceptionState.throwTypeError("parameter 7 is not of type 'HTMLCanvasElement'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, format, type, canvas, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2D12Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        unsigned format;
        unsigned type;
        HTMLVideoElement* video;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        video = V8HTMLVideoElement::toImplWithTypeCheck(info.GetIsolate(), info[6]);
        if (!video) {
            exceptionState.throwTypeError("parameter 7 is not of type 'HTMLVideoElement'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, format, type, video, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2D13Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned target;
        int level;
        int xoffset;
        int yoffset;
        unsigned format;
        unsigned type;
        ImageBitmap* bitmap;
        target = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        level = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        xoffset = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        yoffset = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        format = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bitmap = V8ImageBitmap::toImplWithTypeCheck(info.GetIsolate(), info[6]);
        if (!bitmap) {
            exceptionState.throwTypeError("parameter 7 is not of type 'ImageBitmap'.");

            return;
        }

        impl->texSubImage2D(target, level, xoffset, yoffset, format, type, bitmap, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    static void texSubImage2DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(10, info.Length())) {
        case 7:
            if (V8ImageData::hasInstance(info[6], info.GetIsolate())) {
                texSubImage2D9Method(info);
                return;
            }
            if (V8HTMLImageElement::hasInstance(info[6], info.GetIsolate())) {
                texSubImage2D10Method(info);
                return;
            }
            if (V8HTMLCanvasElement::hasInstance(info[6], info.GetIsolate())) {
                texSubImage2D11Method(info);
                return;
            }
            if (V8HTMLVideoElement::hasInstance(info[6], info.GetIsolate())) {
                texSubImage2D12Method(info);
                return;
            }
            if (V8ImageBitmap::hasInstance(info[6], info.GetIsolate())) {
                texSubImage2D13Method(info);
                return;
            }
            break;
        case 9:
            if (isUndefinedOrNull(info[8])) {
                texSubImage2D8Method(info);
                return;
            }
            if (V8ImageData::hasInstance(info[8], info.GetIsolate())) {
                texSubImage2D2Method(info);
                return;
            }
            if (V8HTMLImageElement::hasInstance(info[8], info.GetIsolate())) {
                texSubImage2D3Method(info);
                return;
            }
            if (V8HTMLCanvasElement::hasInstance(info[8], info.GetIsolate())) {
                texSubImage2D4Method(info);
                return;
            }
            if (V8HTMLVideoElement::hasInstance(info[8], info.GetIsolate())) {
                texSubImage2D5Method(info);
                return;
            }
            if (V8ImageBitmap::hasInstance(info[8], info.GetIsolate())) {
                texSubImage2D6Method(info);
                return;
            }
            if (info[8]->IsArrayBufferView()) {
                texSubImage2D8Method(info);
                return;
            }
            if (true) {
                texSubImage2D1Method(info);
                return;
            }
            break;
        case 10:
            if (true) {
                texSubImage2D7Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "texSubImage2D");

        if (isArityError) {
            if (info.Length() < 7) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(7, info.Length()));
                return;
            }
            if (info.Length() >= 7) {
                exceptionState.throwTypeError(ExceptionMessages::invalidArity("[7, 9, 10]", info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void texSubImage2DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::texSubImage2DMethod(info);
    }

    static void uniform1fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        float x;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform1f(location, x);
    }

    MODULES_EXPORT void uniform1fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform1fMethod(info);
    }

    static void uniform1fv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform1fv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform1fv", "WebGL2RenderingContext", "parameter 2 is not of type 'Float32Array'."));

            return;
        }

        impl->uniform1fv(location, v);
    }

    static void uniform1fv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform1fv(location, v);
    }

    static void uniform1fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                uniform1fv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1fv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsFloat32Array()) {
                uniform1fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsFloat32Array()) {
                uniform1fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform1fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform1fvMethod(info);
    }

    static void uniform1iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1i");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        int x;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform1i(location, x);
    }

    MODULES_EXPORT void uniform1iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform1iMethod(info);
    }

    static void uniform1iv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform1iv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform1iv", "WebGL2RenderingContext", "parameter 2 is not of type 'Int32Array'."));

            return;
        }

        impl->uniform1iv(location, v);
    }

    static void uniform1iv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform1iv(location, v);
    }

    static void uniform1ivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsInt32Array()) {
                uniform1iv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1iv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsInt32Array()) {
                uniform1iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1iv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsInt32Array()) {
                uniform1iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform1iv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform1iv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform1ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform1ivMethod(info);
    }

    static void uniform2fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        float x;
        float y;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform2f(location, x, y);
    }

    MODULES_EXPORT void uniform2fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform2fMethod(info);
    }

    static void uniform2fv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform2fv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform2fv", "WebGL2RenderingContext", "parameter 2 is not of type 'Float32Array'."));

            return;
        }

        impl->uniform2fv(location, v);
    }

    static void uniform2fv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform2fv(location, v);
    }

    static void uniform2fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                uniform2fv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2fv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsFloat32Array()) {
                uniform2fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsFloat32Array()) {
                uniform2fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform2fvMethod(info);
    }

    static void uniform2iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2i");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        int x;
        int y;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform2i(location, x, y);
    }

    MODULES_EXPORT void uniform2iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform2iMethod(info);
    }

    static void uniform2iv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform2iv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform2iv", "WebGL2RenderingContext", "parameter 2 is not of type 'Int32Array'."));

            return;
        }

        impl->uniform2iv(location, v);
    }

    static void uniform2iv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform2iv(location, v);
    }

    static void uniform2ivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsInt32Array()) {
                uniform2iv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2iv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsInt32Array()) {
                uniform2iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2iv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsInt32Array()) {
                uniform2iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform2iv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform2iv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform2ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform2ivMethod(info);
    }

    static void uniform3fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        float x;
        float y;
        float z;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        z = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform3f(location, x, y, z);
    }

    MODULES_EXPORT void uniform3fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform3fMethod(info);
    }

    static void uniform3fv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform3fv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform3fv", "WebGL2RenderingContext", "parameter 2 is not of type 'Float32Array'."));

            return;
        }

        impl->uniform3fv(location, v);
    }

    static void uniform3fv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform3fv(location, v);
    }

    static void uniform3fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                uniform3fv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3fv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsFloat32Array()) {
                uniform3fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsFloat32Array()) {
                uniform3fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform3fvMethod(info);
    }

    static void uniform3iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3i");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        int x;
        int y;
        int z;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        z = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform3i(location, x, y, z);
    }

    MODULES_EXPORT void uniform3iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform3iMethod(info);
    }

    static void uniform3iv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform3iv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform3iv", "WebGL2RenderingContext", "parameter 2 is not of type 'Int32Array'."));

            return;
        }

        impl->uniform3iv(location, v);
    }

    static void uniform3iv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform3iv(location, v);
    }

    static void uniform3ivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsInt32Array()) {
                uniform3iv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3iv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsInt32Array()) {
                uniform3iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3iv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsInt32Array()) {
                uniform3iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform3iv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform3iv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform3ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform3ivMethod(info);
    }

    static void uniform4fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        float x;
        float y;
        float z;
        float w;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        z = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        w = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform4f(location, x, y, z, w);
    }

    MODULES_EXPORT void uniform4fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform4fMethod(info);
    }

    static void uniform4fv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleFloat32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform4fv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform4fv", "WebGL2RenderingContext", "parameter 2 is not of type 'Float32Array'."));

            return;
        }

        impl->uniform4fv(location, v);
    }

    static void uniform4fv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<float> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform4fv(location, v);
    }

    static void uniform4fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                uniform4fv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4fv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsFloat32Array()) {
                uniform4fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4fv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsFloat32Array()) {
                uniform4fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform4fvMethod(info);
    }

    static void uniform4iMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4i");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        WebGLUniformLocation* location;
        int x;
        int y;
        int z;
        int w;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        z = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        w = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform4i(location, x, y, z, w);
    }

    MODULES_EXPORT void uniform4iMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform4iMethod(info);
    }

    static void uniform4iv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        FlexibleInt32ArrayView v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform4iv", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLUniformLocation'."));

            return;
        }

        toFlexibleArrayBufferView(info.GetIsolate(), info[1], v, allocateFlexibleArrayBufferViewStorage(info[1]));
        if (!v) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("uniform4iv", "WebGL2RenderingContext", "parameter 2 is not of type 'Int32Array'."));

            return;
        }

        impl->uniform4iv(location, v);
    }

    static void uniform4iv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4iv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        Vector<int> v;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        v = toImplArray<Vector<int>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniform4iv(location, v);
    }

    static void uniform4ivMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(4, info.Length())) {
        case 2:
            if (info[1]->IsInt32Array()) {
                uniform4iv3Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4iv4Method(info);
                return;
            }
            break;
        case 3:
            if (info[1]->IsInt32Array()) {
                uniform4iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4iv2Method(info);
                return;
            }
            break;
        case 4:
            if (info[1]->IsInt32Array()) {
                uniform4iv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                uniform4iv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniform4iv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniform4ivMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniform4ivMethod(info);
    }

    static void uniformMatrix2fv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* array;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!array) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        impl->uniformMatrix2fv(location, transpose, array);
    }

    static void uniformMatrix2fv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> array;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniformMatrix2fv(location, transpose, array);
    }

    static void uniformMatrix2fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2fv3Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2fv4Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix2fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix2fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix2fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix2fvMethod(info);
    }

    static void uniformMatrix3fv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* array;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!array) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        impl->uniformMatrix3fv(location, transpose, array);
    }

    static void uniformMatrix3fv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> array;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniformMatrix3fv(location, transpose, array);
    }

    static void uniformMatrix3fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3fv3Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3fv4Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix3fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix3fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix3fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix3fvMethod(info);
    }

    static void uniformMatrix4fv3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        DOMFloat32Array* array;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = info[2]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[2])) : 0;
        if (!array) {
            exceptionState.throwTypeError("parameter 3 is not of type 'Float32Array'.");

            return;
        }

        impl->uniformMatrix4fv(location, transpose, array);
    }

    static void uniformMatrix4fv4Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        WebGLUniformLocation* location;
        bool transpose;
        Vector<float> array;
        location = V8WebGLUniformLocation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!location && !isUndefinedOrNull(info[0])) {
            exceptionState.throwTypeError("parameter 1 is not of type 'WebGLUniformLocation'.");

            return;
        }

        transpose = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        array = toImplArray<Vector<float>>(info[2], 3, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->uniformMatrix4fv(location, transpose, array);
    }

    static void uniformMatrix4fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(5, info.Length())) {
        case 3:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4fv3Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4fv4Method(info);
                return;
            }
            break;
        case 4:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4fv2Method(info);
                return;
            }
            break;
        case 5:
            if (info[2]->IsFloat32Array()) {
                uniformMatrix4fv1Method(info);
                return;
            }
            if (info[2]->IsArray()) {
                uniformMatrix4fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "uniformMatrix4fv");

        if (isArityError) {
            if (info.Length() < 3) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void uniformMatrix4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::uniformMatrix4fvMethod(info);
    }

    static void useProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("useProgram", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLProgram* program;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("useProgram", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        impl->useProgram(program);
    }

    MODULES_EXPORT void useProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::useProgramMethod(info);
    }

    static void validateProgramMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("validateProgram", "WebGL2RenderingContext", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        WebGLProgram* program;
        program = V8WebGLProgram::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!program) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("validateProgram", "WebGL2RenderingContext", "parameter 1 is not of type 'WebGLProgram'."));

            return;
        }

        impl->validateProgram(program);
    }

    MODULES_EXPORT void validateProgramMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::validateProgramMethod(info);
    }

    static void vertexAttrib1fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib1f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        unsigned indx;
        float x;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib1f(indx, x);
    }

    MODULES_EXPORT void vertexAttrib1fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib1fMethod(info);
    }

    static void vertexAttrib1fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib1fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        DOMFloat32Array* values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = info[1]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[1])) : 0;
        if (!values) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        impl->vertexAttrib1fv(indx, values);
    }

    static void vertexAttrib1fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib1fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        Vector<float> values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib1fv(indx, values);
    }

    static void vertexAttrib1fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(2, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                vertexAttrib1fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                vertexAttrib1fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib1fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void vertexAttrib1fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib1fvMethod(info);
    }

    static void vertexAttrib2fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib2f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        unsigned indx;
        float x;
        float y;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib2f(indx, x, y);
    }

    MODULES_EXPORT void vertexAttrib2fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib2fMethod(info);
    }

    static void vertexAttrib2fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        DOMFloat32Array* values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = info[1]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[1])) : 0;
        if (!values) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        impl->vertexAttrib2fv(indx, values);
    }

    static void vertexAttrib2fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib2fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        Vector<float> values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib2fv(indx, values);
    }

    static void vertexAttrib2fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(2, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                vertexAttrib2fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                vertexAttrib2fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib2fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void vertexAttrib2fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib2fvMethod(info);
    }

    static void vertexAttrib3fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib3f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        unsigned indx;
        float x;
        float y;
        float z;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        z = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib3f(indx, x, y, z);
    }

    MODULES_EXPORT void vertexAttrib3fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib3fMethod(info);
    }

    static void vertexAttrib3fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        DOMFloat32Array* values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = info[1]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[1])) : 0;
        if (!values) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        impl->vertexAttrib3fv(indx, values);
    }

    static void vertexAttrib3fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib3fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        Vector<float> values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib3fv(indx, values);
    }

    static void vertexAttrib3fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(2, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                vertexAttrib3fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                vertexAttrib3fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib3fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void vertexAttrib3fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib3fvMethod(info);
    }

    static void vertexAttrib4fMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib4f");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        unsigned indx;
        float x;
        float y;
        float z;
        float w;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        z = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        w = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib4f(indx, x, y, z, w);
    }

    MODULES_EXPORT void vertexAttrib4fMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib4fMethod(info);
    }

    static void vertexAttrib4fv1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        DOMFloat32Array* values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = info[1]->IsFloat32Array() ? V8Float32Array::toImpl(v8::Local<v8::Float32Array>::Cast(info[1])) : 0;
        if (!values) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Float32Array'.");

            return;
        }

        impl->vertexAttrib4fv(indx, values);
    }

    static void vertexAttrib4fv2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib4fv");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        unsigned indx;
        Vector<float> values;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        values = toImplArray<Vector<float>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttrib4fv(indx, values);
    }

    static void vertexAttrib4fvMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(2, info.Length())) {
        case 2:
            if (info[1]->IsFloat32Array()) {
                vertexAttrib4fv1Method(info);
                return;
            }
            if (info[1]->IsArray()) {
                vertexAttrib4fv2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttrib4fv");

        if (isArityError) {
            if (info.Length() < 2) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    MODULES_EXPORT void vertexAttrib4fvMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttrib4fvMethod(info);
    }

    static void vertexAttribPointerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "vertexAttribPointer");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 6)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(6, info.Length()));
            return;
        }

        unsigned indx;
        int size;
        unsigned type;
        bool normalized;
        int stride;
        long long offset;
        indx = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        size = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        type = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        normalized = toBoolean(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        stride = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        offset = toInt64(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->vertexAttribPointer(indx, size, type, normalized, stride, offset);
    }

    MODULES_EXPORT void vertexAttribPointerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::vertexAttribPointerMethod(info);
    }

    static void viewportMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "viewport");

        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        int x;
        int y;
        int width;
        int height;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->viewport(x, y, width, height);
    }

    MODULES_EXPORT void viewportMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::viewportMethod(info);
    }

    static void commitMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "WebGL2RenderingContext", "commit");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8WebGL2RenderingContext::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        WebGL2RenderingContext* impl = V8WebGL2RenderingContext::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        ScriptPromise result = impl->commit(scriptState, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result.v8Value());
    }

    MODULES_EXPORT void commitMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        WebGL2RenderingContextV8Internal::commitMethod(info);
    }

} // namespace WebGL2RenderingContextV8Internal

void V8WebGL2RenderingContext::visitDOMWrapper(v8::Isolate* isolate, ScriptWrappable* scriptWrappable, const v8::Persistent<v8::Object>& wrapper)
{
    V8WebGL2RenderingContext::visitDOMWrapperCustom(isolate, scriptWrappable, wrapper);
    WebGL2RenderingContext* impl = scriptWrappable->toImpl<WebGL2RenderingContext>();
    // The canvas() method may return a reference or a pointer.
    if (Node* owner = WTF::getPtr(impl->canvas())) {
        Node* root = V8GCController::opaqueRootForGC(isolate, owner);
        isolate->SetReferenceFromGroup(v8::UniqueId(reinterpret_cast<intptr_t>(root)), wrapper);
        return;
    }
}

const V8DOMConfiguration::AccessorConfiguration V8WebGL2RenderingContextAccessors[] = {
    { "canvas", WebGL2RenderingContextV8Internal::canvasAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawingBufferWidth", WebGL2RenderingContextV8Internal::drawingBufferWidthAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawingBufferHeight", WebGL2RenderingContextV8Internal::drawingBufferHeightAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
};

const V8DOMConfiguration::MethodConfiguration V8WebGL2RenderingContextMethods[] = {
    { "copyBufferSubData", WebGL2RenderingContextV8Internal::copyBufferSubDataMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getBufferSubData", WebGL2RenderingContextV8Internal::getBufferSubDataMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "blitFramebuffer", WebGL2RenderingContextV8Internal::blitFramebufferMethodCallback, 0, 10, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "framebufferTextureLayer", WebGL2RenderingContextV8Internal::framebufferTextureLayerMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getInternalformatParameter", WebGL2RenderingContextV8Internal::getInternalformatParameterMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "invalidateFramebuffer", WebGL2RenderingContextV8Internal::invalidateFramebufferMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "invalidateSubFramebuffer", WebGL2RenderingContextV8Internal::invalidateSubFramebufferMethodCallback, 0, 6, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "readBuffer", WebGL2RenderingContextV8Internal::readBufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "renderbufferStorageMultisample", WebGL2RenderingContextV8Internal::renderbufferStorageMultisampleMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texStorage2D", WebGL2RenderingContextV8Internal::texStorage2DMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texStorage3D", WebGL2RenderingContextV8Internal::texStorage3DMethodCallback, 0, 6, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texImage3D", WebGL2RenderingContextV8Internal::texImage3DMethodCallback, 0, 10, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texSubImage3D", WebGL2RenderingContextV8Internal::texSubImage3DMethodCallback, 0, 11, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "copyTexSubImage3D", WebGL2RenderingContextV8Internal::copyTexSubImage3DMethodCallback, 0, 9, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "compressedTexImage3D", WebGL2RenderingContextV8Internal::compressedTexImage3DMethodCallback, 0, 8, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "compressedTexSubImage3D", WebGL2RenderingContextV8Internal::compressedTexSubImage3DMethodCallback, 0, 10, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getFragDataLocation", WebGL2RenderingContextV8Internal::getFragDataLocationMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform1ui", WebGL2RenderingContextV8Internal::uniform1uiMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform2ui", WebGL2RenderingContextV8Internal::uniform2uiMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform3ui", WebGL2RenderingContextV8Internal::uniform3uiMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform4ui", WebGL2RenderingContextV8Internal::uniform4uiMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform1uiv", WebGL2RenderingContextV8Internal::uniform1uivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform2uiv", WebGL2RenderingContextV8Internal::uniform2uivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform3uiv", WebGL2RenderingContextV8Internal::uniform3uivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform4uiv", WebGL2RenderingContextV8Internal::uniform4uivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix2x3fv", WebGL2RenderingContextV8Internal::uniformMatrix2x3fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix3x2fv", WebGL2RenderingContextV8Internal::uniformMatrix3x2fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix2x4fv", WebGL2RenderingContextV8Internal::uniformMatrix2x4fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix4x2fv", WebGL2RenderingContextV8Internal::uniformMatrix4x2fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix3x4fv", WebGL2RenderingContextV8Internal::uniformMatrix3x4fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix4x3fv", WebGL2RenderingContextV8Internal::uniformMatrix4x3fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttribI4i", WebGL2RenderingContextV8Internal::vertexAttribI4iMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttribI4iv", WebGL2RenderingContextV8Internal::vertexAttribI4ivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttribI4ui", WebGL2RenderingContextV8Internal::vertexAttribI4uiMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttribI4uiv", WebGL2RenderingContextV8Internal::vertexAttribI4uivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttribIPointer", WebGL2RenderingContextV8Internal::vertexAttribIPointerMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttribDivisor", WebGL2RenderingContextV8Internal::vertexAttribDivisorMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawArraysInstanced", WebGL2RenderingContextV8Internal::drawArraysInstancedMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawElementsInstanced", WebGL2RenderingContextV8Internal::drawElementsInstancedMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawRangeElements", WebGL2RenderingContextV8Internal::drawRangeElementsMethodCallback, 0, 6, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawBuffers", WebGL2RenderingContextV8Internal::drawBuffersMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearBufferiv", WebGL2RenderingContextV8Internal::clearBufferivMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearBufferuiv", WebGL2RenderingContextV8Internal::clearBufferuivMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearBufferfv", WebGL2RenderingContextV8Internal::clearBufferfvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearBufferfi", WebGL2RenderingContextV8Internal::clearBufferfiMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createQuery", WebGL2RenderingContextV8Internal::createQueryMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteQuery", WebGL2RenderingContextV8Internal::deleteQueryMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isQuery", WebGL2RenderingContextV8Internal::isQueryMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "beginQuery", WebGL2RenderingContextV8Internal::beginQueryMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "endQuery", WebGL2RenderingContextV8Internal::endQueryMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getQuery", WebGL2RenderingContextV8Internal::getQueryMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getQueryParameter", WebGL2RenderingContextV8Internal::getQueryParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createSampler", WebGL2RenderingContextV8Internal::createSamplerMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteSampler", WebGL2RenderingContextV8Internal::deleteSamplerMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isSampler", WebGL2RenderingContextV8Internal::isSamplerMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindSampler", WebGL2RenderingContextV8Internal::bindSamplerMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "samplerParameteri", WebGL2RenderingContextV8Internal::samplerParameteriMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "samplerParameterf", WebGL2RenderingContextV8Internal::samplerParameterfMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getSamplerParameter", WebGL2RenderingContextV8Internal::getSamplerParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "fenceSync", WebGL2RenderingContextV8Internal::fenceSyncMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isSync", WebGL2RenderingContextV8Internal::isSyncMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteSync", WebGL2RenderingContextV8Internal::deleteSyncMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clientWaitSync", WebGL2RenderingContextV8Internal::clientWaitSyncMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "waitSync", WebGL2RenderingContextV8Internal::waitSyncMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getSyncParameter", WebGL2RenderingContextV8Internal::getSyncParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createTransformFeedback", WebGL2RenderingContextV8Internal::createTransformFeedbackMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteTransformFeedback", WebGL2RenderingContextV8Internal::deleteTransformFeedbackMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isTransformFeedback", WebGL2RenderingContextV8Internal::isTransformFeedbackMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindTransformFeedback", WebGL2RenderingContextV8Internal::bindTransformFeedbackMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "beginTransformFeedback", WebGL2RenderingContextV8Internal::beginTransformFeedbackMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "endTransformFeedback", WebGL2RenderingContextV8Internal::endTransformFeedbackMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "transformFeedbackVaryings", WebGL2RenderingContextV8Internal::transformFeedbackVaryingsMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getTransformFeedbackVarying", WebGL2RenderingContextV8Internal::getTransformFeedbackVaryingMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "pauseTransformFeedback", WebGL2RenderingContextV8Internal::pauseTransformFeedbackMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "resumeTransformFeedback", WebGL2RenderingContextV8Internal::resumeTransformFeedbackMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindBufferBase", WebGL2RenderingContextV8Internal::bindBufferBaseMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindBufferRange", WebGL2RenderingContextV8Internal::bindBufferRangeMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getIndexedParameter", WebGL2RenderingContextV8Internal::getIndexedParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getUniformIndices", WebGL2RenderingContextV8Internal::getUniformIndicesMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getActiveUniforms", WebGL2RenderingContextV8Internal::getActiveUniformsMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getUniformBlockIndex", WebGL2RenderingContextV8Internal::getUniformBlockIndexMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getActiveUniformBlockParameter", WebGL2RenderingContextV8Internal::getActiveUniformBlockParameterMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getActiveUniformBlockName", WebGL2RenderingContextV8Internal::getActiveUniformBlockNameMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformBlockBinding", WebGL2RenderingContextV8Internal::uniformBlockBindingMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createVertexArray", WebGL2RenderingContextV8Internal::createVertexArrayMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteVertexArray", WebGL2RenderingContextV8Internal::deleteVertexArrayMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isVertexArray", WebGL2RenderingContextV8Internal::isVertexArrayMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindVertexArray", WebGL2RenderingContextV8Internal::bindVertexArrayMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "activeTexture", WebGL2RenderingContextV8Internal::activeTextureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "attachShader", WebGL2RenderingContextV8Internal::attachShaderMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindAttribLocation", WebGL2RenderingContextV8Internal::bindAttribLocationMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindBuffer", WebGL2RenderingContextV8Internal::bindBufferMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindFramebuffer", WebGL2RenderingContextV8Internal::bindFramebufferMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindRenderbuffer", WebGL2RenderingContextV8Internal::bindRenderbufferMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bindTexture", WebGL2RenderingContextV8Internal::bindTextureMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "blendColor", WebGL2RenderingContextV8Internal::blendColorMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "blendEquation", WebGL2RenderingContextV8Internal::blendEquationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "blendEquationSeparate", WebGL2RenderingContextV8Internal::blendEquationSeparateMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "blendFunc", WebGL2RenderingContextV8Internal::blendFuncMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "blendFuncSeparate", WebGL2RenderingContextV8Internal::blendFuncSeparateMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bufferData", WebGL2RenderingContextV8Internal::bufferDataMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bufferSubData", WebGL2RenderingContextV8Internal::bufferSubDataMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "checkFramebufferStatus", WebGL2RenderingContextV8Internal::checkFramebufferStatusMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clear", WebGL2RenderingContextV8Internal::clearMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearColor", WebGL2RenderingContextV8Internal::clearColorMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearDepth", WebGL2RenderingContextV8Internal::clearDepthMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearStencil", WebGL2RenderingContextV8Internal::clearStencilMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "colorMask", WebGL2RenderingContextV8Internal::colorMaskMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "compileShader", WebGL2RenderingContextV8Internal::compileShaderMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "compressedTexImage2D", WebGL2RenderingContextV8Internal::compressedTexImage2DMethodCallback, 0, 7, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "compressedTexSubImage2D", WebGL2RenderingContextV8Internal::compressedTexSubImage2DMethodCallback, 0, 8, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "copyTexImage2D", WebGL2RenderingContextV8Internal::copyTexImage2DMethodCallback, 0, 8, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "copyTexSubImage2D", WebGL2RenderingContextV8Internal::copyTexSubImage2DMethodCallback, 0, 8, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createBuffer", WebGL2RenderingContextV8Internal::createBufferMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createFramebuffer", WebGL2RenderingContextV8Internal::createFramebufferMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createProgram", WebGL2RenderingContextV8Internal::createProgramMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createRenderbuffer", WebGL2RenderingContextV8Internal::createRenderbufferMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createShader", WebGL2RenderingContextV8Internal::createShaderMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createTexture", WebGL2RenderingContextV8Internal::createTextureMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "cullFace", WebGL2RenderingContextV8Internal::cullFaceMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteBuffer", WebGL2RenderingContextV8Internal::deleteBufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteFramebuffer", WebGL2RenderingContextV8Internal::deleteFramebufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteProgram", WebGL2RenderingContextV8Internal::deleteProgramMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteRenderbuffer", WebGL2RenderingContextV8Internal::deleteRenderbufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteShader", WebGL2RenderingContextV8Internal::deleteShaderMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deleteTexture", WebGL2RenderingContextV8Internal::deleteTextureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "depthFunc", WebGL2RenderingContextV8Internal::depthFuncMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "depthMask", WebGL2RenderingContextV8Internal::depthMaskMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "depthRange", WebGL2RenderingContextV8Internal::depthRangeMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "detachShader", WebGL2RenderingContextV8Internal::detachShaderMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "disable", WebGL2RenderingContextV8Internal::disableMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "disableVertexAttribArray", WebGL2RenderingContextV8Internal::disableVertexAttribArrayMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawArrays", WebGL2RenderingContextV8Internal::drawArraysMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "drawElements", WebGL2RenderingContextV8Internal::drawElementsMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "enable", WebGL2RenderingContextV8Internal::enableMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "enableVertexAttribArray", WebGL2RenderingContextV8Internal::enableVertexAttribArrayMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "finish", WebGL2RenderingContextV8Internal::finishMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "flush", WebGL2RenderingContextV8Internal::flushMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "framebufferRenderbuffer", WebGL2RenderingContextV8Internal::framebufferRenderbufferMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "framebufferTexture2D", WebGL2RenderingContextV8Internal::framebufferTexture2DMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "frontFace", WebGL2RenderingContextV8Internal::frontFaceMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "generateMipmap", WebGL2RenderingContextV8Internal::generateMipmapMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getActiveAttrib", WebGL2RenderingContextV8Internal::getActiveAttribMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getActiveUniform", WebGL2RenderingContextV8Internal::getActiveUniformMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getAttachedShaders", WebGL2RenderingContextV8Internal::getAttachedShadersMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getAttribLocation", WebGL2RenderingContextV8Internal::getAttribLocationMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getBufferParameter", WebGL2RenderingContextV8Internal::getBufferParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getContextAttributes", WebGL2RenderingContextV8Internal::getContextAttributesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getError", WebGL2RenderingContextV8Internal::getErrorMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getExtension", WebGL2RenderingContextV8Internal::getExtensionMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getFramebufferAttachmentParameter", WebGL2RenderingContextV8Internal::getFramebufferAttachmentParameterMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getParameter", WebGL2RenderingContextV8Internal::getParameterMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getProgramParameter", WebGL2RenderingContextV8Internal::getProgramParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getProgramInfoLog", WebGL2RenderingContextV8Internal::getProgramInfoLogMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getRenderbufferParameter", WebGL2RenderingContextV8Internal::getRenderbufferParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getShaderParameter", WebGL2RenderingContextV8Internal::getShaderParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getShaderInfoLog", WebGL2RenderingContextV8Internal::getShaderInfoLogMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getShaderPrecisionFormat", WebGL2RenderingContextV8Internal::getShaderPrecisionFormatMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getShaderSource", WebGL2RenderingContextV8Internal::getShaderSourceMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getSupportedExtensions", WebGL2RenderingContextV8Internal::getSupportedExtensionsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getTexParameter", WebGL2RenderingContextV8Internal::getTexParameterMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getUniform", WebGL2RenderingContextV8Internal::getUniformMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getUniformLocation", WebGL2RenderingContextV8Internal::getUniformLocationMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getVertexAttrib", WebGL2RenderingContextV8Internal::getVertexAttribMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getVertexAttribOffset", WebGL2RenderingContextV8Internal::getVertexAttribOffsetMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hint", WebGL2RenderingContextV8Internal::hintMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isBuffer", WebGL2RenderingContextV8Internal::isBufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isContextLost", WebGL2RenderingContextV8Internal::isContextLostMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isEnabled", WebGL2RenderingContextV8Internal::isEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isFramebuffer", WebGL2RenderingContextV8Internal::isFramebufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isProgram", WebGL2RenderingContextV8Internal::isProgramMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isRenderbuffer", WebGL2RenderingContextV8Internal::isRenderbufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isShader", WebGL2RenderingContextV8Internal::isShaderMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isTexture", WebGL2RenderingContextV8Internal::isTextureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "lineWidth", WebGL2RenderingContextV8Internal::lineWidthMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "linkProgram", WebGL2RenderingContextV8Internal::linkProgramMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "pixelStorei", WebGL2RenderingContextV8Internal::pixelStoreiMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "polygonOffset", WebGL2RenderingContextV8Internal::polygonOffsetMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "readPixels", WebGL2RenderingContextV8Internal::readPixelsMethodCallback, 0, 7, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "renderbufferStorage", WebGL2RenderingContextV8Internal::renderbufferStorageMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "sampleCoverage", WebGL2RenderingContextV8Internal::sampleCoverageMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "scissor", WebGL2RenderingContextV8Internal::scissorMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "shaderSource", WebGL2RenderingContextV8Internal::shaderSourceMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stencilFunc", WebGL2RenderingContextV8Internal::stencilFuncMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stencilFuncSeparate", WebGL2RenderingContextV8Internal::stencilFuncSeparateMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stencilMask", WebGL2RenderingContextV8Internal::stencilMaskMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stencilMaskSeparate", WebGL2RenderingContextV8Internal::stencilMaskSeparateMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stencilOp", WebGL2RenderingContextV8Internal::stencilOpMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stencilOpSeparate", WebGL2RenderingContextV8Internal::stencilOpSeparateMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texParameterf", WebGL2RenderingContextV8Internal::texParameterfMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texParameteri", WebGL2RenderingContextV8Internal::texParameteriMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texImage2D", WebGL2RenderingContextV8Internal::texImage2DMethodCallback, 0, 6, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "texSubImage2D", WebGL2RenderingContextV8Internal::texSubImage2DMethodCallback, 0, 7, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform1f", WebGL2RenderingContextV8Internal::uniform1fMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform1fv", WebGL2RenderingContextV8Internal::uniform1fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform1i", WebGL2RenderingContextV8Internal::uniform1iMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform1iv", WebGL2RenderingContextV8Internal::uniform1ivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform2f", WebGL2RenderingContextV8Internal::uniform2fMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform2fv", WebGL2RenderingContextV8Internal::uniform2fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform2i", WebGL2RenderingContextV8Internal::uniform2iMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform2iv", WebGL2RenderingContextV8Internal::uniform2ivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform3f", WebGL2RenderingContextV8Internal::uniform3fMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform3fv", WebGL2RenderingContextV8Internal::uniform3fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform3i", WebGL2RenderingContextV8Internal::uniform3iMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform3iv", WebGL2RenderingContextV8Internal::uniform3ivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform4f", WebGL2RenderingContextV8Internal::uniform4fMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform4fv", WebGL2RenderingContextV8Internal::uniform4fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform4i", WebGL2RenderingContextV8Internal::uniform4iMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniform4iv", WebGL2RenderingContextV8Internal::uniform4ivMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix2fv", WebGL2RenderingContextV8Internal::uniformMatrix2fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix3fv", WebGL2RenderingContextV8Internal::uniformMatrix3fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "uniformMatrix4fv", WebGL2RenderingContextV8Internal::uniformMatrix4fvMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "useProgram", WebGL2RenderingContextV8Internal::useProgramMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "validateProgram", WebGL2RenderingContextV8Internal::validateProgramMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib1f", WebGL2RenderingContextV8Internal::vertexAttrib1fMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib1fv", WebGL2RenderingContextV8Internal::vertexAttrib1fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib2f", WebGL2RenderingContextV8Internal::vertexAttrib2fMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib2fv", WebGL2RenderingContextV8Internal::vertexAttrib2fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib3f", WebGL2RenderingContextV8Internal::vertexAttrib3fMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib3fv", WebGL2RenderingContextV8Internal::vertexAttrib3fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib4f", WebGL2RenderingContextV8Internal::vertexAttrib4fMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttrib4fv", WebGL2RenderingContextV8Internal::vertexAttrib4fvMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "vertexAttribPointer", WebGL2RenderingContextV8Internal::vertexAttribPointerMethodCallback, 0, 6, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "viewport", WebGL2RenderingContextV8Internal::viewportMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
};

static void installV8WebGL2RenderingContextTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    // Initialize the interface object's template.
    V8DOMConfiguration::initializeDOMInterfaceTemplate(isolate, interfaceTemplate, V8WebGL2RenderingContext::wrapperTypeInfo.interfaceName, v8::Local<v8::FunctionTemplate>(), V8WebGL2RenderingContext::internalFieldCount);

    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interfaceTemplate);
    ALLOW_UNUSED_LOCAL(signature);
    v8::Local<v8::ObjectTemplate> instanceTemplate = interfaceTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = interfaceTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);

    // Register DOM constants, attributes and operations.
    const V8DOMConfiguration::ConstantConfiguration V8WebGL2RenderingContextConstants[] = {
        { "READ_BUFFER", 0x0C02, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_ROW_LENGTH", 0x0CF2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_SKIP_ROWS", 0x0CF3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_SKIP_PIXELS", 0x0CF4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PACK_ROW_LENGTH", 0x0D02, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PACK_SKIP_ROWS", 0x0D03, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PACK_SKIP_PIXELS", 0x0D04, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR", 0x1800, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH", 0x1801, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL", 0x1802, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RED", 0x1903, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB8", 0x8051, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA8", 0x8058, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB10_A2", 0x8059, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_BINDING_3D", 0x806A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_SKIP_IMAGES", 0x806D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_IMAGE_HEIGHT", 0x806E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_3D", 0x806F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_WRAP_R", 0x8072, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_3D_TEXTURE_SIZE", 0x8073, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_2_10_10_10_REV", 0x8368, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_ELEMENTS_VERTICES", 0x80E8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_ELEMENTS_INDICES", 0x80E9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_MIN_LOD", 0x813A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_MAX_LOD", 0x813B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_BASE_LEVEL", 0x813C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_MAX_LEVEL", 0x813D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MIN", 0x8007, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX", 0x8008, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_COMPONENT24", 0x81A6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_TEXTURE_LOD_BIAS", 0x84FD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_COMPARE_MODE", 0x884C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_COMPARE_FUNC", 0x884D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CURRENT_QUERY", 0x8865, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "QUERY_RESULT", 0x8866, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "QUERY_RESULT_AVAILABLE", 0x8867, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STREAM_READ", 0x88E1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STREAM_COPY", 0x88E2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STATIC_READ", 0x88E5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STATIC_COPY", 0x88E6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DYNAMIC_READ", 0x88E9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DYNAMIC_COPY", 0x88EA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_DRAW_BUFFERS", 0x8824, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER0", 0x8825, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER1", 0x8826, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER2", 0x8827, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER3", 0x8828, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER4", 0x8829, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER5", 0x882A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER6", 0x882B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER7", 0x882C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER8", 0x882D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER9", 0x882E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER10", 0x882F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER11", 0x8830, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER12", 0x8831, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER13", 0x8832, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER14", 0x8833, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_BUFFER15", 0x8834, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_FRAGMENT_UNIFORM_COMPONENTS", 0x8B49, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VERTEX_UNIFORM_COMPONENTS", 0x8B4A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_3D", 0x8B5F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_2D_SHADOW", 0x8B62, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAGMENT_SHADER_DERIVATIVE_HINT", 0x8B8B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PIXEL_PACK_BUFFER", 0x88EB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PIXEL_UNPACK_BUFFER", 0x88EC, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PIXEL_PACK_BUFFER_BINDING", 0x88ED, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PIXEL_UNPACK_BUFFER_BINDING", 0x88EF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT2x3", 0x8B65, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT2x4", 0x8B66, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT3x2", 0x8B67, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT3x4", 0x8B68, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT4x2", 0x8B69, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT4x3", 0x8B6A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SRGB", 0x8C40, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SRGB8", 0x8C41, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SRGB8_ALPHA8", 0x8C43, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COMPARE_REF_TO_TEXTURE", 0x884E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA32F", 0x8814, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB32F", 0x8815, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA16F", 0x881A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB16F", 0x881B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_INTEGER", 0x88FD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_ARRAY_TEXTURE_LAYERS", 0x88FF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MIN_PROGRAM_TEXEL_OFFSET", 0x8904, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_PROGRAM_TEXEL_OFFSET", 0x8905, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VARYING_COMPONENTS", 0x8B4B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_2D_ARRAY", 0x8C1A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_BINDING_2D_ARRAY", 0x8C1D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R11F_G11F_B10F", 0x8C3A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_10F_11F_11F_REV", 0x8C3B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB9_E5", 0x8C3D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_5_9_9_9_REV", 0x8C3E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_BUFFER_MODE", 0x8C7F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", 0x8C80, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_VARYINGS", 0x8C83, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_BUFFER_START", 0x8C84, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_BUFFER_SIZE", 0x8C85, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", 0x8C88, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RASTERIZER_DISCARD", 0x8C89, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", 0x8C8A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", 0x8C8B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INTERLEAVED_ATTRIBS", 0x8C8C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SEPARATE_ATTRIBS", 0x8C8D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_BUFFER", 0x8C8E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_BUFFER_BINDING", 0x8C8F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA32UI", 0x8D70, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB32UI", 0x8D71, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA16UI", 0x8D76, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB16UI", 0x8D77, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA8UI", 0x8D7C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB8UI", 0x8D7D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA32I", 0x8D82, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB32I", 0x8D83, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA16I", 0x8D88, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB16I", 0x8D89, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA8I", 0x8D8E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB8I", 0x8D8F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RED_INTEGER", 0x8D94, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB_INTEGER", 0x8D98, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA_INTEGER", 0x8D99, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_2D_ARRAY", 0x8DC1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_2D_ARRAY_SHADOW", 0x8DC4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_CUBE_SHADOW", 0x8DC5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_VEC2", 0x8DC6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_VEC3", 0x8DC7, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_VEC4", 0x8DC8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_SAMPLER_2D", 0x8DCA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_SAMPLER_3D", 0x8DCB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_SAMPLER_CUBE", 0x8DCC, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_SAMPLER_2D_ARRAY", 0x8DCF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_SAMPLER_2D", 0x8DD2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_SAMPLER_3D", 0x8DD3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_SAMPLER_CUBE", 0x8DD4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_SAMPLER_2D_ARRAY", 0x8DD7, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_COMPONENT32F", 0x8CAC, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH32F_STENCIL8", 0x8CAD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_32_UNSIGNED_INT_24_8_REV", 0x8DAD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", 0x8210, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", 0x8211, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_RED_SIZE", 0x8212, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", 0x8213, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", 0x8214, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", 0x8215, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", 0x8216, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", 0x8217, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_DEFAULT", 0x8218, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT_24_8", 0x84FA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH24_STENCIL8", 0x88F0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_NORMALIZED", 0x8C17, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_FRAMEBUFFER_BINDING", 0x8CA6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "READ_FRAMEBUFFER", 0x8CA8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DRAW_FRAMEBUFFER", 0x8CA9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "READ_FRAMEBUFFER_BINDING", 0x8CAA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_SAMPLES", 0x8CAB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", 0x8CD4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_COLOR_ATTACHMENTS", 0x8CDF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT1", 0x8CE1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT2", 0x8CE2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT3", 0x8CE3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT4", 0x8CE4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT5", 0x8CE5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT6", 0x8CE6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT7", 0x8CE7, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT8", 0x8CE8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT9", 0x8CE9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT10", 0x8CEA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT11", 0x8CEB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT12", 0x8CEC, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT13", 0x8CED, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT14", 0x8CEE, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT15", 0x8CEF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", 0x8D56, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_SAMPLES", 0x8D57, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "HALF_FLOAT", 0x140B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG", 0x8227, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG_INTEGER", 0x8228, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R8", 0x8229, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG8", 0x822B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R16F", 0x822D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R32F", 0x822E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG16F", 0x822F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG32F", 0x8230, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R8I", 0x8231, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R8UI", 0x8232, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R16I", 0x8233, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R16UI", 0x8234, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R32I", 0x8235, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R32UI", 0x8236, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG8I", 0x8237, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG8UI", 0x8238, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG16I", 0x8239, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG16UI", 0x823A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG32I", 0x823B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG32UI", 0x823C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ARRAY_BINDING", 0x85B5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "R8_SNORM", 0x8F94, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RG8_SNORM", 0x8F95, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB8_SNORM", 0x8F96, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA8_SNORM", 0x8F97, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SIGNED_NORMALIZED", 0x8F9C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COPY_READ_BUFFER", 0x8F36, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COPY_WRITE_BUFFER", 0x8F37, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COPY_READ_BUFFER_BINDING", 0x8F36, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COPY_WRITE_BUFFER_BINDING", 0x8F37, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BUFFER", 0x8A11, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BUFFER_BINDING", 0x8A28, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BUFFER_START", 0x8A29, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BUFFER_SIZE", 0x8A2A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VERTEX_UNIFORM_BLOCKS", 0x8A2B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_FRAGMENT_UNIFORM_BLOCKS", 0x8A2D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_COMBINED_UNIFORM_BLOCKS", 0x8A2E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_UNIFORM_BUFFER_BINDINGS", 0x8A2F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_UNIFORM_BLOCK_SIZE", 0x8A30, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", 0x8A31, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", 0x8A33, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BUFFER_OFFSET_ALIGNMENT", 0x8A34, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ACTIVE_UNIFORM_BLOCKS", 0x8A36, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_TYPE", 0x8A37, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_SIZE", 0x8A38, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BLOCK_INDEX", 0x8A3A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_OFFSET", 0x8A3B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_ARRAY_STRIDE", 0x8A3C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_MATRIX_STRIDE", 0x8A3D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_IS_ROW_MAJOR", 0x8A3E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BLOCK_BINDING", 0x8A3F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BLOCK_DATA_SIZE", 0x8A40, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BLOCK_ACTIVE_UNIFORMS", 0x8A42, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", 0x8A43, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", 0x8A44, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", 0x8A46, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INVALID_INDEX", 0xFFFFFFFF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VERTEX_OUTPUT_COMPONENTS", 0x9122, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_FRAGMENT_INPUT_COMPONENTS", 0x9125, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_SERVER_WAIT_TIMEOUT", 0x9111, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "OBJECT_TYPE", 0x9112, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SYNC_CONDITION", 0x9113, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SYNC_STATUS", 0x9114, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SYNC_FLAGS", 0x9115, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SYNC_FENCE", 0x9116, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SYNC_GPU_COMMANDS_COMPLETE", 0x9117, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNALED", 0x9118, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SIGNALED", 0x9119, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ALREADY_SIGNALED", 0x911A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TIMEOUT_EXPIRED", 0x911B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CONDITION_SATISFIED", 0x911C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "WAIT_FAILED", 0x911D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SYNC_FLUSH_COMMANDS_BIT", 0x00000001, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_DIVISOR", 0x88FE, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ANY_SAMPLES_PASSED", 0x8C2F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ANY_SAMPLES_PASSED_CONSERVATIVE", 0x8D6A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_BINDING", 0x8919, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB10_A2UI", 0x906F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_2_10_10_10_REV", 0x8D9F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK", 0x8E22, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_PAUSED", 0x8E23, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_ACTIVE", 0x8E24, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRANSFORM_FEEDBACK_BINDING", 0x8E25, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_IMMUTABLE_FORMAT", 0x912F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_ELEMENT_INDEX", 0x8D6B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_IMMUTABLE_LEVELS", 0x82DF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TIMEOUT_IGNORED", -1, 0, V8DOMConfiguration::ConstantTypeLong },
        { "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", 0x9247, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_BUFFER_BIT", 0x00000100, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BUFFER_BIT", 0x00000400, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_BUFFER_BIT", 0x00004000, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "POINTS", 0x0000, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINES", 0x0001, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINE_LOOP", 0x0002, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINE_STRIP", 0x0003, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRIANGLES", 0x0004, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRIANGLE_STRIP", 0x0005, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TRIANGLE_FAN", 0x0006, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ZERO", 0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ONE", 1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SRC_COLOR", 0x0300, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ONE_MINUS_SRC_COLOR", 0x0301, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SRC_ALPHA", 0x0302, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ONE_MINUS_SRC_ALPHA", 0x0303, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DST_ALPHA", 0x0304, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ONE_MINUS_DST_ALPHA", 0x0305, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DST_COLOR", 0x0306, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ONE_MINUS_DST_COLOR", 0x0307, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SRC_ALPHA_SATURATE", 0x0308, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FUNC_ADD", 0x8006, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_EQUATION", 0x8009, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_EQUATION_RGB", 0x8009, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_EQUATION_ALPHA", 0x883D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FUNC_SUBTRACT", 0x800A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FUNC_REVERSE_SUBTRACT", 0x800B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_DST_RGB", 0x80C8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_SRC_RGB", 0x80C9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_DST_ALPHA", 0x80CA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_SRC_ALPHA", 0x80CB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CONSTANT_COLOR", 0x8001, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ONE_MINUS_CONSTANT_COLOR", 0x8002, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CONSTANT_ALPHA", 0x8003, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ONE_MINUS_CONSTANT_ALPHA", 0x8004, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND_COLOR", 0x8005, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ARRAY_BUFFER", 0x8892, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ELEMENT_ARRAY_BUFFER", 0x8893, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ARRAY_BUFFER_BINDING", 0x8894, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ELEMENT_ARRAY_BUFFER_BINDING", 0x8895, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STREAM_DRAW", 0x88E0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STATIC_DRAW", 0x88E4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DYNAMIC_DRAW", 0x88E8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BUFFER_SIZE", 0x8764, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BUFFER_USAGE", 0x8765, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CURRENT_VERTEX_ATTRIB", 0x8626, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRONT", 0x0404, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BACK", 0x0405, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRONT_AND_BACK", 0x0408, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_2D", 0x0DE1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CULL_FACE", 0x0B44, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLEND", 0x0BE2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DITHER", 0x0BD0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_TEST", 0x0B90, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_TEST", 0x0B71, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SCISSOR_TEST", 0x0C11, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "POLYGON_OFFSET_FILL", 0x8037, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLE_ALPHA_TO_COVERAGE", 0x809E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLE_COVERAGE", 0x80A0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NO_ERROR", 0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INVALID_ENUM", 0x0500, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INVALID_VALUE", 0x0501, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INVALID_OPERATION", 0x0502, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "OUT_OF_MEMORY", 0x0505, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CW", 0x0900, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CCW", 0x0901, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINE_WIDTH", 0x0B21, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ALIASED_POINT_SIZE_RANGE", 0x846D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ALIASED_LINE_WIDTH_RANGE", 0x846E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CULL_FACE_MODE", 0x0B45, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRONT_FACE", 0x0B46, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_RANGE", 0x0B70, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_WRITEMASK", 0x0B72, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_CLEAR_VALUE", 0x0B73, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_FUNC", 0x0B74, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_CLEAR_VALUE", 0x0B91, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_FUNC", 0x0B92, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_FAIL", 0x0B94, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_PASS_DEPTH_FAIL", 0x0B95, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_PASS_DEPTH_PASS", 0x0B96, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_REF", 0x0B97, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_VALUE_MASK", 0x0B93, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_WRITEMASK", 0x0B98, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BACK_FUNC", 0x8800, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BACK_FAIL", 0x8801, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BACK_PASS_DEPTH_FAIL", 0x8802, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BACK_PASS_DEPTH_PASS", 0x8803, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BACK_REF", 0x8CA3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BACK_VALUE_MASK", 0x8CA4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BACK_WRITEMASK", 0x8CA5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VIEWPORT", 0x0BA2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SCISSOR_BOX", 0x0C10, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_CLEAR_VALUE", 0x0C22, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_WRITEMASK", 0x0C23, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_ALIGNMENT", 0x0CF5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "PACK_ALIGNMENT", 0x0D05, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_TEXTURE_SIZE", 0x0D33, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VIEWPORT_DIMS", 0x0D3A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SUBPIXEL_BITS", 0x0D50, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RED_BITS", 0x0D52, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "GREEN_BITS", 0x0D53, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BLUE_BITS", 0x0D54, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ALPHA_BITS", 0x0D55, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_BITS", 0x0D56, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_BITS", 0x0D57, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "POLYGON_OFFSET_UNITS", 0x2A00, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "POLYGON_OFFSET_FACTOR", 0x8038, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_BINDING_2D", 0x8069, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLE_BUFFERS", 0x80A8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLES", 0x80A9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLE_COVERAGE_VALUE", 0x80AA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLE_COVERAGE_INVERT", 0x80AB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COMPRESSED_TEXTURE_FORMATS", 0x86A3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DONT_CARE", 0x1100, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FASTEST", 0x1101, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NICEST", 0x1102, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "GENERATE_MIPMAP_HINT", 0x8192, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BYTE", 0x1400, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_BYTE", 0x1401, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SHORT", 0x1402, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_SHORT", 0x1403, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT", 0x1404, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_INT", 0x1405, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT", 0x1406, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_COMPONENT", 0x1902, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ALPHA", 0x1906, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB", 0x1907, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA", 0x1908, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LUMINANCE", 0x1909, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LUMINANCE_ALPHA", 0x190A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_SHORT_4_4_4_4", 0x8033, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_SHORT_5_5_5_1", 0x8034, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNSIGNED_SHORT_5_6_5", 0x8363, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAGMENT_SHADER", 0x8B30, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_SHADER", 0x8B31, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VERTEX_ATTRIBS", 0x8869, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VERTEX_UNIFORM_VECTORS", 0x8DFB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VARYING_VECTORS", 0x8DFC, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_COMBINED_TEXTURE_IMAGE_UNITS", 0x8B4D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_VERTEX_TEXTURE_IMAGE_UNITS", 0x8B4C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_TEXTURE_IMAGE_UNITS", 0x8872, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_FRAGMENT_UNIFORM_VECTORS", 0x8DFD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SHADER_TYPE", 0x8B4F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DELETE_STATUS", 0x8B80, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINK_STATUS", 0x8B82, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VALIDATE_STATUS", 0x8B83, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ATTACHED_SHADERS", 0x8B85, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ACTIVE_UNIFORMS", 0x8B86, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ACTIVE_ATTRIBUTES", 0x8B89, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SHADING_LANGUAGE_VERSION", 0x8B8C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CURRENT_PROGRAM", 0x8B8D, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NEVER", 0x0200, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LESS", 0x0201, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "EQUAL", 0x0202, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LEQUAL", 0x0203, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "GREATER", 0x0204, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NOTEQUAL", 0x0205, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "GEQUAL", 0x0206, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ALWAYS", 0x0207, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "KEEP", 0x1E00, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "REPLACE", 0x1E01, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INCR", 0x1E02, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DECR", 0x1E03, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INVERT", 0x150A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INCR_WRAP", 0x8507, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DECR_WRAP", 0x8508, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VENDOR", 0x1F00, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERER", 0x1F01, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERSION", 0x1F02, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NEAREST", 0x2600, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINEAR", 0x2601, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NEAREST_MIPMAP_NEAREST", 0x2700, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINEAR_MIPMAP_NEAREST", 0x2701, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NEAREST_MIPMAP_LINEAR", 0x2702, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LINEAR_MIPMAP_LINEAR", 0x2703, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_MAG_FILTER", 0x2800, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_MIN_FILTER", 0x2801, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_WRAP_S", 0x2802, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_WRAP_T", 0x2803, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE", 0x1702, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_CUBE_MAP", 0x8513, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_BINDING_CUBE_MAP", 0x8514, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_CUBE_MAP_POSITIVE_X", 0x8515, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_CUBE_MAP_NEGATIVE_X", 0x8516, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_CUBE_MAP_POSITIVE_Y", 0x8517, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_CUBE_MAP_NEGATIVE_Y", 0x8518, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_CUBE_MAP_POSITIVE_Z", 0x8519, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE_CUBE_MAP_NEGATIVE_Z", 0x851A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_CUBE_MAP_TEXTURE_SIZE", 0x851C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE0", 0x84C0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE1", 0x84C1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE2", 0x84C2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE3", 0x84C3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE4", 0x84C4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE5", 0x84C5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE6", 0x84C6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE7", 0x84C7, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE8", 0x84C8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE9", 0x84C9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE10", 0x84CA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE11", 0x84CB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE12", 0x84CC, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE13", 0x84CD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE14", 0x84CE, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE15", 0x84CF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE16", 0x84D0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE17", 0x84D1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE18", 0x84D2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE19", 0x84D3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE20", 0x84D4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE21", 0x84D5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE22", 0x84D6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE23", 0x84D7, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE24", 0x84D8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE25", 0x84D9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE26", 0x84DA, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE27", 0x84DB, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE28", 0x84DC, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE29", 0x84DD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE30", 0x84DE, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "TEXTURE31", 0x84DF, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "ACTIVE_TEXTURE", 0x84E0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "REPEAT", 0x2901, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CLAMP_TO_EDGE", 0x812F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MIRRORED_REPEAT", 0x8370, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_VEC2", 0x8B50, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_VEC3", 0x8B51, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_VEC4", 0x8B52, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_VEC2", 0x8B53, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_VEC3", 0x8B54, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INT_VEC4", 0x8B55, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BOOL", 0x8B56, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BOOL_VEC2", 0x8B57, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BOOL_VEC3", 0x8B58, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BOOL_VEC4", 0x8B59, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT2", 0x8B5A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT3", 0x8B5B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FLOAT_MAT4", 0x8B5C, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_2D", 0x8B5E, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "SAMPLER_CUBE", 0x8B60, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_ENABLED", 0x8622, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_SIZE", 0x8623, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_STRIDE", 0x8624, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_TYPE", 0x8625, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_NORMALIZED", 0x886A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_POINTER", 0x8645, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", 0x889F, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "IMPLEMENTATION_COLOR_READ_TYPE", 0x8B9A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "IMPLEMENTATION_COLOR_READ_FORMAT", 0x8B9B, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COMPILE_STATUS", 0x8B81, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LOW_FLOAT", 0x8DF0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MEDIUM_FLOAT", 0x8DF1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "HIGH_FLOAT", 0x8DF2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "LOW_INT", 0x8DF3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MEDIUM_INT", 0x8DF4, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "HIGH_INT", 0x8DF5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER", 0x8D40, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER", 0x8D41, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGBA4", 0x8056, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB5_A1", 0x8057, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RGB565", 0x8D62, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_COMPONENT16", 0x81A5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_INDEX", 0x1901, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_INDEX8", 0x8D48, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_STENCIL", 0x84F9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_WIDTH", 0x8D42, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_HEIGHT", 0x8D43, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_INTERNAL_FORMAT", 0x8D44, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_RED_SIZE", 0x8D50, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_GREEN_SIZE", 0x8D51, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_BLUE_SIZE", 0x8D52, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_ALPHA_SIZE", 0x8D53, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_DEPTH_SIZE", 0x8D54, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_STENCIL_SIZE", 0x8D55, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", 0x8CD0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", 0x8CD1, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", 0x8CD2, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", 0x8CD3, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "COLOR_ATTACHMENT0", 0x8CE0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_ATTACHMENT", 0x8D00, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "STENCIL_ATTACHMENT", 0x8D20, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "DEPTH_STENCIL_ATTACHMENT", 0x821A, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "NONE", 0, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_COMPLETE", 0x8CD5, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", 0x8CD6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", 0x8CD7, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", 0x8CD9, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_UNSUPPORTED", 0x8CDD, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "FRAMEBUFFER_BINDING", 0x8CA6, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "RENDERBUFFER_BINDING", 0x8CA7, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "MAX_RENDERBUFFER_SIZE", 0x84E8, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "INVALID_FRAMEBUFFER_OPERATION", 0x0506, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_FLIP_Y_WEBGL", 0x9240, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_PREMULTIPLY_ALPHA_WEBGL", 0x9241, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "CONTEXT_LOST_WEBGL", 0x9242, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "UNPACK_COLORSPACE_CONVERSION_WEBGL", 0x9243, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
        { "BROWSER_DEFAULT_WEBGL", 0x9244, 0, V8DOMConfiguration::ConstantTypeUnsignedLong },
    };
    V8DOMConfiguration::installConstants(isolate, interfaceTemplate, prototypeTemplate, V8WebGL2RenderingContextConstants, WTF_ARRAY_LENGTH(V8WebGL2RenderingContextConstants));
    V8DOMConfiguration::installAccessors(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8WebGL2RenderingContextAccessors, WTF_ARRAY_LENGTH(V8WebGL2RenderingContextAccessors));
    V8DOMConfiguration::installMethods(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8WebGL2RenderingContextMethods, WTF_ARRAY_LENGTH(V8WebGL2RenderingContextMethods));

    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        const V8DOMConfiguration::MethodConfiguration commitMethodConfiguration = { "commit", WebGL2RenderingContextV8Internal::commitMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder };
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, commitMethodConfiguration);
    }
}

v8::Local<v8::FunctionTemplate> V8WebGL2RenderingContext::domTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world)
{
    return V8DOMConfiguration::domClassTemplate(isolate, world, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), installV8WebGL2RenderingContextTemplate);
}

bool V8WebGL2RenderingContext::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8WebGL2RenderingContext::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

WebGL2RenderingContext* V8WebGL2RenderingContext::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value)
{
    return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : nullptr;
}

} // namespace blink
