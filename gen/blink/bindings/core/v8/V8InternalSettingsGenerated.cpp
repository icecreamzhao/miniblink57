// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/interface.cpp.tmpl

// clang-format on
#include "V8InternalSettingsGenerated.h"

#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/GeneratedCodeHelper.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "core/dom/Document.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
const WrapperTypeInfo V8InternalSettingsGenerated::wrapperTypeInfo = { gin::kEmbedderBlink, V8InternalSettingsGenerated::domTemplate, V8InternalSettingsGenerated::trace, V8InternalSettingsGenerated::traceWrappers, 0, nullptr, "InternalSettingsGenerated", 0, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::ObjectClassId, WrapperTypeInfo::NotInheritFromActiveScriptWrappable, WrapperTypeInfo::NotInheritFromEventTarget, WrapperTypeInfo::Independent };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in InternalSettingsGenerated.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& InternalSettingsGenerated::s_wrapperTypeInfo = V8InternalSettingsGenerated::wrapperTypeInfo;

// not [ActiveScriptWrappable]
static_assert(
    !std::is_base_of<ActiveScriptWrappableBase, InternalSettingsGenerated>::value,
    "InternalSettingsGenerated inherits from ActiveScriptWrappable<>, but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");
static_assert(
    std::is_same<decltype(&InternalSettingsGenerated::hasPendingActivity),
        decltype(&ScriptWrappable::hasPendingActivity)>::value,
    "InternalSettingsGenerated is overriding hasPendingActivity(), but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");

namespace InternalSettingsGeneratedV8Internal {

    static void setDOMPasteAllowedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDOMPasteAllowed");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool DOMPasteAllowed;
        DOMPasteAllowed = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDOMPasteAllowed(DOMPasteAllowed);
    }

    void setDOMPasteAllowedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDOMPasteAllowedMethod(info);
    }

    static void setAccelerated2dCanvasMSAASampleCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAccelerated2dCanvasMSAASampleCount");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int accelerated2dCanvasMSAASampleCount;
        accelerated2dCanvasMSAASampleCount = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAccelerated2dCanvasMSAASampleCount(accelerated2dCanvasMSAASampleCount);
    }

    void setAccelerated2dCanvasMSAASampleCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAccelerated2dCanvasMSAASampleCountMethod(info);
    }

    static void setAcceleratedCompositingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAcceleratedCompositingEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool acceleratedCompositingEnabled;
        acceleratedCompositingEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAcceleratedCompositingEnabled(acceleratedCompositingEnabled);
    }

    void setAcceleratedCompositingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAcceleratedCompositingEnabledMethod(info);
    }

    static void setAccessibilityEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAccessibilityEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool accessibilityEnabled;
        accessibilityEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAccessibilityEnabled(accessibilityEnabled);
    }

    void setAccessibilityEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAccessibilityEnabledMethod(info);
    }

    static void setAccessibilityFontScaleFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAccessibilityFontScaleFactor");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        double accessibilityFontScaleFactor;
        accessibilityFontScaleFactor = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAccessibilityFontScaleFactor(accessibilityFontScaleFactor);
    }

    void setAccessibilityFontScaleFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAccessibilityFontScaleFactorMethod(info);
    }

    static void setAccessibilityPasswordValuesEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAccessibilityPasswordValuesEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool accessibilityPasswordValuesEnabled;
        accessibilityPasswordValuesEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAccessibilityPasswordValuesEnabled(accessibilityPasswordValuesEnabled);
    }

    void setAccessibilityPasswordValuesEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAccessibilityPasswordValuesEnabledMethod(info);
    }

    static void setAllowCustomScrollbarInMainFrameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAllowCustomScrollbarInMainFrame");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool allowCustomScrollbarInMainFrame;
        allowCustomScrollbarInMainFrame = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAllowCustomScrollbarInMainFrame(allowCustomScrollbarInMainFrame);
    }

    void setAllowCustomScrollbarInMainFrameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAllowCustomScrollbarInMainFrameMethod(info);
    }

    static void setAllowFileAccessFromFileURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAllowFileAccessFromFileURLs");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool allowFileAccessFromFileURLs;
        allowFileAccessFromFileURLs = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAllowFileAccessFromFileURLs(allowFileAccessFromFileURLs);
    }

    void setAllowFileAccessFromFileURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAllowFileAccessFromFileURLsMethod(info);
    }

    static void setAllowGeolocationOnInsecureOriginsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAllowGeolocationOnInsecureOrigins");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool allowGeolocationOnInsecureOrigins;
        allowGeolocationOnInsecureOrigins = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAllowGeolocationOnInsecureOrigins(allowGeolocationOnInsecureOrigins);
    }

    void setAllowGeolocationOnInsecureOriginsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAllowGeolocationOnInsecureOriginsMethod(info);
    }

    static void setAllowRunningOfInsecureContentMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAllowRunningOfInsecureContent");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool allowRunningOfInsecureContent;
        allowRunningOfInsecureContent = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAllowRunningOfInsecureContent(allowRunningOfInsecureContent);
    }

    void setAllowRunningOfInsecureContentMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAllowRunningOfInsecureContentMethod(info);
    }

    static void setAllowScriptsToCloseWindowsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAllowScriptsToCloseWindows");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool allowScriptsToCloseWindows;
        allowScriptsToCloseWindows = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAllowScriptsToCloseWindows(allowScriptsToCloseWindows);
    }

    void setAllowScriptsToCloseWindowsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAllowScriptsToCloseWindowsMethod(info);
    }

    static void setAllowUniversalAccessFromFileURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAllowUniversalAccessFromFileURLs");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool allowUniversalAccessFromFileURLs;
        allowUniversalAccessFromFileURLs = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAllowUniversalAccessFromFileURLs(allowUniversalAccessFromFileURLs);
    }

    void setAllowUniversalAccessFromFileURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAllowUniversalAccessFromFileURLsMethod(info);
    }

    static void setAlwaysShowContextMenuOnTouchMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAlwaysShowContextMenuOnTouch");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool alwaysShowContextMenuOnTouch;
        alwaysShowContextMenuOnTouch = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAlwaysShowContextMenuOnTouch(alwaysShowContextMenuOnTouch);
    }

    void setAlwaysShowContextMenuOnTouchMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAlwaysShowContextMenuOnTouchMethod(info);
    }

    static void setAntialiased2dCanvasEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAntialiased2dCanvasEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool antialiased2dCanvasEnabled;
        antialiased2dCanvasEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAntialiased2dCanvasEnabled(antialiased2dCanvasEnabled);
    }

    void setAntialiased2dCanvasEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAntialiased2dCanvasEnabledMethod(info);
    }

    static void setAntialiasedClips2dCanvasEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAntialiasedClips2dCanvasEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool antialiasedClips2dCanvasEnabled;
        antialiasedClips2dCanvasEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAntialiasedClips2dCanvasEnabled(antialiasedClips2dCanvasEnabled);
    }

    void setAntialiasedClips2dCanvasEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAntialiasedClips2dCanvasEnabledMethod(info);
    }

    static void setAvailableHoverTypesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAvailableHoverTypes");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int availableHoverTypes;
        availableHoverTypes = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAvailableHoverTypes(availableHoverTypes);
    }

    void setAvailableHoverTypesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAvailableHoverTypesMethod(info);
    }

    static void setAvailablePointerTypesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setAvailablePointerTypes");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int availablePointerTypes;
        availablePointerTypes = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAvailablePointerTypes(availablePointerTypes);
    }

    void setAvailablePointerTypesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setAvailablePointerTypesMethod(info);
    }

    static void setBackgroundHtmlParserOutstandingTokenLimitMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setBackgroundHtmlParserOutstandingTokenLimit");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned backgroundHtmlParserOutstandingTokenLimit;
        backgroundHtmlParserOutstandingTokenLimit = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setBackgroundHtmlParserOutstandingTokenLimit(backgroundHtmlParserOutstandingTokenLimit);
    }

    void setBackgroundHtmlParserOutstandingTokenLimitMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setBackgroundHtmlParserOutstandingTokenLimitMethod(info);
    }

    static void setBackgroundHtmlParserPendingTokenLimitMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setBackgroundHtmlParserPendingTokenLimit");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned backgroundHtmlParserPendingTokenLimit;
        backgroundHtmlParserPendingTokenLimit = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setBackgroundHtmlParserPendingTokenLimit(backgroundHtmlParserPendingTokenLimit);
    }

    void setBackgroundHtmlParserPendingTokenLimitMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setBackgroundHtmlParserPendingTokenLimitMethod(info);
    }

    static void setBrowserSideNavigationEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setBrowserSideNavigationEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool browserSideNavigationEnabled;
        browserSideNavigationEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setBrowserSideNavigationEnabled(browserSideNavigationEnabled);
    }

    void setBrowserSideNavigationEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setBrowserSideNavigationEnabledMethod(info);
    }

    static void setCookieEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setCookieEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool cookieEnabled;
        cookieEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setCookieEnabled(cookieEnabled);
    }

    void setCookieEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setCookieEnabledMethod(info);
    }

    static void setCrossOriginMediaPlaybackRequiresUserGestureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setCrossOriginMediaPlaybackRequiresUserGesture");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool crossOriginMediaPlaybackRequiresUserGesture;
        crossOriginMediaPlaybackRequiresUserGesture = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setCrossOriginMediaPlaybackRequiresUserGesture(crossOriginMediaPlaybackRequiresUserGesture);
    }

    void setCrossOriginMediaPlaybackRequiresUserGestureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setCrossOriginMediaPlaybackRequiresUserGestureMethod(info);
    }

    static void setCSSExternalScannerNoPreloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setCSSExternalScannerNoPreload");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool cssExternalScannerNoPreload;
        cssExternalScannerNoPreload = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setCSSExternalScannerNoPreload(cssExternalScannerNoPreload);
    }

    void setCSSExternalScannerNoPreloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setCSSExternalScannerNoPreloadMethod(info);
    }

    static void setCSSExternalScannerPreloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setCSSExternalScannerPreload");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool cssExternalScannerPreload;
        cssExternalScannerPreload = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setCSSExternalScannerPreload(cssExternalScannerPreload);
    }

    void setCSSExternalScannerPreloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setCSSExternalScannerPreloadMethod(info);
    }

    static void setDataSaverEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDataSaverEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool dataSaverEnabled;
        dataSaverEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDataSaverEnabled(dataSaverEnabled);
    }

    void setDataSaverEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDataSaverEnabledMethod(info);
    }

    static void setDefaultFixedFontSizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDefaultFixedFontSize");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int defaultFixedFontSize;
        defaultFixedFontSize = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDefaultFixedFontSize(defaultFixedFontSize);
    }

    void setDefaultFixedFontSizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDefaultFixedFontSizeMethod(info);
    }

    static void setDefaultFontSizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDefaultFontSize");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int defaultFontSize;
        defaultFontSize = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDefaultFontSize(defaultFontSize);
    }

    void setDefaultFontSizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDefaultFontSizeMethod(info);
    }

    static void setDefaultTextEncodingNameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setDefaultTextEncodingName", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> defaultTextEncodingName;
        defaultTextEncodingName = info[0];
        if (!defaultTextEncodingName.prepare())
            return;

        impl->setDefaultTextEncodingName(defaultTextEncodingName);
    }

    void setDefaultTextEncodingNameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDefaultTextEncodingNameMethod(info);
    }

    static void setDefaultVideoPosterURLMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setDefaultVideoPosterURL", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> defaultVideoPosterURL;
        defaultVideoPosterURL = info[0];
        if (!defaultVideoPosterURL.prepare())
            return;

        impl->setDefaultVideoPosterURL(defaultVideoPosterURL);
    }

    void setDefaultVideoPosterURLMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDefaultVideoPosterURLMethod(info);
    }

    static void setDeviceScaleAdjustmentMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDeviceScaleAdjustment");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        double deviceScaleAdjustment;
        deviceScaleAdjustment = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDeviceScaleAdjustment(deviceScaleAdjustment);
    }

    void setDeviceScaleAdjustmentMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDeviceScaleAdjustmentMethod(info);
    }

    static void setDeviceSupportsTouchMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDeviceSupportsTouch");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool deviceSupportsTouch;
        deviceSupportsTouch = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDeviceSupportsTouch(deviceSupportsTouch);
    }

    void setDeviceSupportsTouchMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDeviceSupportsTouchMethod(info);
    }

    static void setDisableReadingFromCanvasMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDisableReadingFromCanvas");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool disableReadingFromCanvas;
        disableReadingFromCanvas = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDisableReadingFromCanvas(disableReadingFromCanvas);
    }

    void setDisableReadingFromCanvasMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDisableReadingFromCanvasMethod(info);
    }

    static void setDisallowFetchForDocWrittenScriptsInMainFrameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDisallowFetchForDocWrittenScriptsInMainFrame");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool disallowFetchForDocWrittenScriptsInMainFrame;
        disallowFetchForDocWrittenScriptsInMainFrame = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDisallowFetchForDocWrittenScriptsInMainFrame(disallowFetchForDocWrittenScriptsInMainFrame);
    }

    void setDisallowFetchForDocWrittenScriptsInMainFrameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDisallowFetchForDocWrittenScriptsInMainFrameMethod(info);
    }

    static void setDisallowFetchForDocWrittenScriptsInMainFrameIfEffectively2GMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDisallowFetchForDocWrittenScriptsInMainFrameIfEffectively2G");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool disallowFetchForDocWrittenScriptsInMainFrameIfEffectively2G;
        disallowFetchForDocWrittenScriptsInMainFrameIfEffectively2G = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDisallowFetchForDocWrittenScriptsInMainFrameIfEffectively2G(disallowFetchForDocWrittenScriptsInMainFrameIfEffectively2G);
    }

    void setDisallowFetchForDocWrittenScriptsInMainFrameIfEffectively2GMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDisallowFetchForDocWrittenScriptsInMainFrameIfEffectively2GMethod(info);
    }

    static void setDisallowFetchForDocWrittenScriptsInMainFrameOnSlowConnectionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDisallowFetchForDocWrittenScriptsInMainFrameOnSlowConnections");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool disallowFetchForDocWrittenScriptsInMainFrameOnSlowConnections;
        disallowFetchForDocWrittenScriptsInMainFrameOnSlowConnections = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDisallowFetchForDocWrittenScriptsInMainFrameOnSlowConnections(disallowFetchForDocWrittenScriptsInMainFrameOnSlowConnections);
    }

    void setDisallowFetchForDocWrittenScriptsInMainFrameOnSlowConnectionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDisallowFetchForDocWrittenScriptsInMainFrameOnSlowConnectionsMethod(info);
    }

    static void setDNSPrefetchingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDNSPrefetchingEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool dnsPrefetchingEnabled;
        dnsPrefetchingEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDNSPrefetchingEnabled(dnsPrefetchingEnabled);
    }

    void setDNSPrefetchingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDNSPrefetchingEnabledMethod(info);
    }

    static void setDoHtmlPreloadScanningMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDoHtmlPreloadScanning");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool doHtmlPreloadScanning;
        doHtmlPreloadScanning = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDoHtmlPreloadScanning(doHtmlPreloadScanning);
    }

    void setDoHtmlPreloadScanningMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDoHtmlPreloadScanningMethod(info);
    }

    static void setDownloadableBinaryFontsEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setDownloadableBinaryFontsEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool downloadableBinaryFontsEnabled;
        downloadableBinaryFontsEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setDownloadableBinaryFontsEnabled(downloadableBinaryFontsEnabled);
    }

    void setDownloadableBinaryFontsEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setDownloadableBinaryFontsEnabledMethod(info);
    }

    static void setEncryptedMediaEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setEncryptedMediaEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool encryptedMediaEnabled;
        encryptedMediaEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setEncryptedMediaEnabled(encryptedMediaEnabled);
    }

    void setEncryptedMediaEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setEncryptedMediaEnabledMethod(info);
    }

    static void setFetchImagePlaceholdersMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setFetchImagePlaceholders");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool fetchImagePlaceholders;
        fetchImagePlaceholders = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setFetchImagePlaceholders(fetchImagePlaceholders);
    }

    void setFetchImagePlaceholdersMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setFetchImagePlaceholdersMethod(info);
    }

    static void setForceMainWorldInitializationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setForceMainWorldInitialization");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool forceMainWorldInitialization;
        forceMainWorldInitialization = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setForceMainWorldInitialization(forceMainWorldInitialization);
    }

    void setForceMainWorldInitializationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setForceMainWorldInitializationMethod(info);
    }

    static void setForcePreloadNoneForMediaElementsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setForcePreloadNoneForMediaElements");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool forcePreloadNoneForMediaElements;
        forcePreloadNoneForMediaElements = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setForcePreloadNoneForMediaElements(forcePreloadNoneForMediaElements);
    }

    void setForcePreloadNoneForMediaElementsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setForcePreloadNoneForMediaElementsMethod(info);
    }

    static void setForceZeroLayoutHeightMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setForceZeroLayoutHeight");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool forceZeroLayoutHeight;
        forceZeroLayoutHeight = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setForceZeroLayoutHeight(forceZeroLayoutHeight);
    }

    void setForceZeroLayoutHeightMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setForceZeroLayoutHeightMethod(info);
    }

    static void setFullscreenSupportedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setFullscreenSupported");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool fullscreenSupported;
        fullscreenSupported = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setFullscreenSupported(fullscreenSupported);
    }

    void setFullscreenSupportedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setFullscreenSupportedMethod(info);
    }

    static void setHideDownloadUIMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setHideDownloadUI");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool hideDownloadUI;
        hideDownloadUI = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setHideDownloadUI(hideDownloadUI);
    }

    void setHideDownloadUIMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setHideDownloadUIMethod(info);
    }

    static void setHideScrollbarsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setHideScrollbars");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool hideScrollbars;
        hideScrollbars = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setHideScrollbars(hideScrollbars);
    }

    void setHideScrollbarsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setHideScrollbarsMethod(info);
    }

    static void setHistoryEntryRequiresUserGestureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setHistoryEntryRequiresUserGesture");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool historyEntryRequiresUserGesture;
        historyEntryRequiresUserGesture = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setHistoryEntryRequiresUserGesture(historyEntryRequiresUserGesture);
    }

    void setHistoryEntryRequiresUserGestureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setHistoryEntryRequiresUserGestureMethod(info);
    }

    static void setHyperlinkAuditingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setHyperlinkAuditingEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool hyperlinkAuditingEnabled;
        hyperlinkAuditingEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setHyperlinkAuditingEnabled(hyperlinkAuditingEnabled);
    }

    void setHyperlinkAuditingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setHyperlinkAuditingEnabledMethod(info);
    }

    static void setIgnoreMainFrameOverflowHiddenQuirkMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setIgnoreMainFrameOverflowHiddenQuirk");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool ignoreMainFrameOverflowHiddenQuirk;
        ignoreMainFrameOverflowHiddenQuirk = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setIgnoreMainFrameOverflowHiddenQuirk(ignoreMainFrameOverflowHiddenQuirk);
    }

    void setIgnoreMainFrameOverflowHiddenQuirkMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setIgnoreMainFrameOverflowHiddenQuirkMethod(info);
    }

    static void setImagesEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setImagesEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool imagesEnabled;
        imagesEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setImagesEnabled(imagesEnabled);
    }

    void setImagesEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setImagesEnabledMethod(info);
    }

    static void setInertVisualViewportMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setInertVisualViewport");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool inertVisualViewport;
        inertVisualViewport = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setInertVisualViewport(inertVisualViewport);
    }

    void setInertVisualViewportMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setInertVisualViewportMethod(info);
    }

    static void setInlineTextBoxAccessibilityEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setInlineTextBoxAccessibilityEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool inlineTextBoxAccessibilityEnabled;
        inlineTextBoxAccessibilityEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setInlineTextBoxAccessibilityEnabled(inlineTextBoxAccessibilityEnabled);
    }

    void setInlineTextBoxAccessibilityEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setInlineTextBoxAccessibilityEnabledMethod(info);
    }

    static void setJavaScriptCanAccessClipboardMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setJavaScriptCanAccessClipboard");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool javaScriptCanAccessClipboard;
        javaScriptCanAccessClipboard = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setJavaScriptCanAccessClipboard(javaScriptCanAccessClipboard);
    }

    void setJavaScriptCanAccessClipboardMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setJavaScriptCanAccessClipboardMethod(info);
    }

    static void setJavaScriptCanOpenWindowsAutomaticallyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setJavaScriptCanOpenWindowsAutomatically");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool javaScriptCanOpenWindowsAutomatically;
        javaScriptCanOpenWindowsAutomatically = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setJavaScriptCanOpenWindowsAutomatically(javaScriptCanOpenWindowsAutomatically);
    }

    void setJavaScriptCanOpenWindowsAutomaticallyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setJavaScriptCanOpenWindowsAutomaticallyMethod(info);
    }

    static void setLayerSquashingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setLayerSquashingEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool layerSquashingEnabled;
        layerSquashingEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setLayerSquashingEnabled(layerSquashingEnabled);
    }

    void setLayerSquashingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setLayerSquashingEnabledMethod(info);
    }

    static void setLoadWithOverviewModeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setLoadWithOverviewMode");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool loadWithOverviewMode;
        loadWithOverviewMode = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setLoadWithOverviewMode(loadWithOverviewMode);
    }

    void setLoadWithOverviewModeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setLoadWithOverviewModeMethod(info);
    }

    static void setLoadsImagesAutomaticallyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setLoadsImagesAutomatically");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool loadsImagesAutomatically;
        loadsImagesAutomatically = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setLoadsImagesAutomatically(loadsImagesAutomatically);
    }

    void setLoadsImagesAutomaticallyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setLoadsImagesAutomaticallyMethod(info);
    }

    static void setLocalStorageEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setLocalStorageEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool localStorageEnabled;
        localStorageEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setLocalStorageEnabled(localStorageEnabled);
    }

    void setLocalStorageEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setLocalStorageEnabledMethod(info);
    }

    static void setLogDnsPrefetchAndPreconnectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setLogDnsPrefetchAndPreconnect");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool logDnsPrefetchAndPreconnect;
        logDnsPrefetchAndPreconnect = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setLogDnsPrefetchAndPreconnect(logDnsPrefetchAndPreconnect);
    }

    void setLogDnsPrefetchAndPreconnectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setLogDnsPrefetchAndPreconnectMethod(info);
    }

    static void setLogPreloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setLogPreload");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool logPreload;
        logPreload = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setLogPreload(logPreload);
    }

    void setLogPreloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setLogPreloadMethod(info);
    }

    static void setLowPriorityIframesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setLowPriorityIframes");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool lowPriorityIframes;
        lowPriorityIframes = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setLowPriorityIframes(lowPriorityIframes);
    }

    void setLowPriorityIframesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setLowPriorityIframesMethod(info);
    }

    static void setMainFrameClipsContentMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMainFrameClipsContent");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool mainFrameClipsContent;
        mainFrameClipsContent = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMainFrameClipsContent(mainFrameClipsContent);
    }

    void setMainFrameClipsContentMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMainFrameClipsContentMethod(info);
    }

    static void setMainFrameResizesAreOrientationChangesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMainFrameResizesAreOrientationChanges");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool mainFrameResizesAreOrientationChanges;
        mainFrameResizesAreOrientationChanges = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMainFrameResizesAreOrientationChanges(mainFrameResizesAreOrientationChanges);
    }

    void setMainFrameResizesAreOrientationChangesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMainFrameResizesAreOrientationChangesMethod(info);
    }

    static void setMaxBeaconTransmissionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMaxBeaconTransmission");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int maxBeaconTransmission;
        maxBeaconTransmission = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMaxBeaconTransmission(maxBeaconTransmission);
    }

    void setMaxBeaconTransmissionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMaxBeaconTransmissionMethod(info);
    }

    static void setMaxTouchPointsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMaxTouchPoints");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int maxTouchPoints;
        maxTouchPoints = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMaxTouchPoints(maxTouchPoints);
    }

    void setMaxTouchPointsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMaxTouchPointsMethod(info);
    }

    static void setMediaControlsOverlayPlayButtonEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMediaControlsOverlayPlayButtonEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool mediaControlsOverlayPlayButtonEnabled;
        mediaControlsOverlayPlayButtonEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMediaControlsOverlayPlayButtonEnabled(mediaControlsOverlayPlayButtonEnabled);
    }

    void setMediaControlsOverlayPlayButtonEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMediaControlsOverlayPlayButtonEnabledMethod(info);
    }

    static void setMediaPlaybackRequiresUserGestureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMediaPlaybackRequiresUserGesture");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool mediaPlaybackRequiresUserGesture;
        mediaPlaybackRequiresUserGesture = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMediaPlaybackRequiresUserGesture(mediaPlaybackRequiresUserGesture);
    }

    void setMediaPlaybackRequiresUserGestureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMediaPlaybackRequiresUserGestureMethod(info);
    }

    static void setMediaTypeOverrideMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setMediaTypeOverride", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> mediaTypeOverride;
        mediaTypeOverride = info[0];
        if (!mediaTypeOverride.prepare())
            return;

        impl->setMediaTypeOverride(mediaTypeOverride);
    }

    void setMediaTypeOverrideMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMediaTypeOverrideMethod(info);
    }

    static void setMinimumAccelerated2dCanvasSizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMinimumAccelerated2dCanvasSize");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int minimumAccelerated2dCanvasSize;
        minimumAccelerated2dCanvasSize = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMinimumAccelerated2dCanvasSize(minimumAccelerated2dCanvasSize);
    }

    void setMinimumAccelerated2dCanvasSizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMinimumAccelerated2dCanvasSizeMethod(info);
    }

    static void setMinimumFontSizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMinimumFontSize");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int minimumFontSize;
        minimumFontSize = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMinimumFontSize(minimumFontSize);
    }

    void setMinimumFontSizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMinimumFontSizeMethod(info);
    }

    static void setMinimumLogicalFontSizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMinimumLogicalFontSize");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int minimumLogicalFontSize;
        minimumLogicalFontSize = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMinimumLogicalFontSize(minimumLogicalFontSize);
    }

    void setMinimumLogicalFontSizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMinimumLogicalFontSizeMethod(info);
    }

    static void setMockGestureTapHighlightsEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMockGestureTapHighlightsEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool mockGestureTapHighlightsEnabled;
        mockGestureTapHighlightsEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMockGestureTapHighlightsEnabled(mockGestureTapHighlightsEnabled);
    }

    void setMockGestureTapHighlightsEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMockGestureTapHighlightsEnabledMethod(info);
    }

    static void setMultiTargetTapNotificationEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setMultiTargetTapNotificationEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool multiTargetTapNotificationEnabled;
        multiTargetTapNotificationEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMultiTargetTapNotificationEnabled(multiTargetTapNotificationEnabled);
    }

    void setMultiTargetTapNotificationEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setMultiTargetTapNotificationEnabledMethod(info);
    }

    static void setNavigateOnDragDropMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setNavigateOnDragDrop");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool navigateOnDragDrop;
        navigateOnDragDrop = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setNavigateOnDragDrop(navigateOnDragDrop);
    }

    void setNavigateOnDragDropMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setNavigateOnDragDropMethod(info);
    }

    static void setOfflineWebApplicationCacheEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setOfflineWebApplicationCacheEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool offlineWebApplicationCacheEnabled;
        offlineWebApplicationCacheEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setOfflineWebApplicationCacheEnabled(offlineWebApplicationCacheEnabled);
    }

    void setOfflineWebApplicationCacheEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setOfflineWebApplicationCacheEnabledMethod(info);
    }

    static void setParseHTMLOnMainThreadCoalesceChunksMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setParseHTMLOnMainThreadCoalesceChunks");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool parseHTMLOnMainThreadCoalesceChunks;
        parseHTMLOnMainThreadCoalesceChunks = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setParseHTMLOnMainThreadCoalesceChunks(parseHTMLOnMainThreadCoalesceChunks);
    }

    void setParseHTMLOnMainThreadCoalesceChunksMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setParseHTMLOnMainThreadCoalesceChunksMethod(info);
    }

    static void setParseHTMLOnMainThreadSyncTokenizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setParseHTMLOnMainThreadSyncTokenize");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool parseHTMLOnMainThreadSyncTokenize;
        parseHTMLOnMainThreadSyncTokenize = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setParseHTMLOnMainThreadSyncTokenize(parseHTMLOnMainThreadSyncTokenize);
    }

    void setParseHTMLOnMainThreadSyncTokenizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setParseHTMLOnMainThreadSyncTokenizeMethod(info);
    }

    static void setPasswordEchoDurationInSecondsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setPasswordEchoDurationInSeconds");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        double passwordEchoDurationInSeconds;
        passwordEchoDurationInSeconds = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPasswordEchoDurationInSeconds(passwordEchoDurationInSeconds);
    }

    void setPasswordEchoDurationInSecondsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setPasswordEchoDurationInSecondsMethod(info);
    }

    static void setPasswordEchoEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setPasswordEchoEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool passwordEchoEnabled;
        passwordEchoEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPasswordEchoEnabled(passwordEchoEnabled);
    }

    void setPasswordEchoEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setPasswordEchoEnabledMethod(info);
    }

    static void setPluginsEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setPluginsEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool pluginsEnabled;
        pluginsEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPluginsEnabled(pluginsEnabled);
    }

    void setPluginsEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setPluginsEnabledMethod(info);
    }

    static void setPreferCompositingToLCDTextEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setPreferCompositingToLCDTextEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool preferCompositingToLCDTextEnabled;
        preferCompositingToLCDTextEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPreferCompositingToLCDTextEnabled(preferCompositingToLCDTextEnabled);
    }

    void setPreferCompositingToLCDTextEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setPreferCompositingToLCDTextEnabledMethod(info);
    }

    static void setPreferHiddenVolumeControlsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setPreferHiddenVolumeControls");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool preferHiddenVolumeControls;
        preferHiddenVolumeControls = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPreferHiddenVolumeControls(preferHiddenVolumeControls);
    }

    void setPreferHiddenVolumeControlsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setPreferHiddenVolumeControlsMethod(info);
    }

    static void setPresentationReceiverMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setPresentationReceiver");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool presentationReceiver;
        presentationReceiver = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPresentationReceiver(presentationReceiver);
    }

    void setPresentationReceiverMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setPresentationReceiverMethod(info);
    }

    static void setPresentationRequiresUserGestureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setPresentationRequiresUserGesture");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool presentationRequiresUserGesture;
        presentationRequiresUserGesture = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPresentationRequiresUserGesture(presentationRequiresUserGesture);
    }

    void setPresentationRequiresUserGestureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setPresentationRequiresUserGestureMethod(info);
    }

    static void setReportScreenSizeInPhysicalPixelsQuirkMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setReportScreenSizeInPhysicalPixelsQuirk");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool reportScreenSizeInPhysicalPixelsQuirk;
        reportScreenSizeInPhysicalPixelsQuirk = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setReportScreenSizeInPhysicalPixelsQuirk(reportScreenSizeInPhysicalPixelsQuirk);
    }

    void setReportScreenSizeInPhysicalPixelsQuirkMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setReportScreenSizeInPhysicalPixelsQuirkMethod(info);
    }

    static void setRubberBandingOnCompositorThreadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setRubberBandingOnCompositorThread");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool rubberBandingOnCompositorThread;
        rubberBandingOnCompositorThread = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setRubberBandingOnCompositorThread(rubberBandingOnCompositorThread);
    }

    void setRubberBandingOnCompositorThreadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setRubberBandingOnCompositorThreadMethod(info);
    }

    static void setScriptEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setScriptEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool scriptEnabled;
        scriptEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setScriptEnabled(scriptEnabled);
    }

    void setScriptEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setScriptEnabledMethod(info);
    }

    static void setScrollAnimatorEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setScrollAnimatorEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool scrollAnimatorEnabled;
        scrollAnimatorEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setScrollAnimatorEnabled(scrollAnimatorEnabled);
    }

    void setScrollAnimatorEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setScrollAnimatorEnabledMethod(info);
    }

    static void setSelectTrailingWhitespaceEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setSelectTrailingWhitespaceEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool selectTrailingWhitespaceEnabled;
        selectTrailingWhitespaceEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSelectTrailingWhitespaceEnabled(selectTrailingWhitespaceEnabled);
    }

    void setSelectTrailingWhitespaceEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setSelectTrailingWhitespaceEnabledMethod(info);
    }

    static void setSelectionIncludesAltImageTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setSelectionIncludesAltImageText");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool selectionIncludesAltImageText;
        selectionIncludesAltImageText = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSelectionIncludesAltImageText(selectionIncludesAltImageText);
    }

    void setSelectionIncludesAltImageTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setSelectionIncludesAltImageTextMethod(info);
    }

    static void setShouldClearDocumentBackgroundMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setShouldClearDocumentBackground");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool shouldClearDocumentBackground;
        shouldClearDocumentBackground = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setShouldClearDocumentBackground(shouldClearDocumentBackground);
    }

    void setShouldClearDocumentBackgroundMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setShouldClearDocumentBackgroundMethod(info);
    }

    static void setShouldPrintBackgroundsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setShouldPrintBackgrounds");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool shouldPrintBackgrounds;
        shouldPrintBackgrounds = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setShouldPrintBackgrounds(shouldPrintBackgrounds);
    }

    void setShouldPrintBackgroundsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setShouldPrintBackgroundsMethod(info);
    }

    static void setShouldRespectImageOrientationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setShouldRespectImageOrientation");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool shouldRespectImageOrientation;
        shouldRespectImageOrientation = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setShouldRespectImageOrientation(shouldRespectImageOrientation);
    }

    void setShouldRespectImageOrientationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setShouldRespectImageOrientationMethod(info);
    }

    static void setShouldReuseGlobalForUnownedMainFrameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setShouldReuseGlobalForUnownedMainFrame");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool shouldReuseGlobalForUnownedMainFrame;
        shouldReuseGlobalForUnownedMainFrame = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setShouldReuseGlobalForUnownedMainFrame(shouldReuseGlobalForUnownedMainFrame);
    }

    void setShouldReuseGlobalForUnownedMainFrameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setShouldReuseGlobalForUnownedMainFrameMethod(info);
    }

    static void setShowContextMenuOnMouseUpMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setShowContextMenuOnMouseUp");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool showContextMenuOnMouseUp;
        showContextMenuOnMouseUp = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setShowContextMenuOnMouseUp(showContextMenuOnMouseUp);
    }

    void setShowContextMenuOnMouseUpMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setShowContextMenuOnMouseUpMethod(info);
    }

    static void setSmartInsertDeleteEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setSmartInsertDeleteEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool smartInsertDeleteEnabled;
        smartInsertDeleteEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSmartInsertDeleteEnabled(smartInsertDeleteEnabled);
    }

    void setSmartInsertDeleteEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setSmartInsertDeleteEnabledMethod(info);
    }

    static void setSpatialNavigationEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setSpatialNavigationEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool spatialNavigationEnabled;
        spatialNavigationEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSpatialNavigationEnabled(spatialNavigationEnabled);
    }

    void setSpatialNavigationEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setSpatialNavigationEnabledMethod(info);
    }

    static void setSpellCheckEnabledByDefaultMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setSpellCheckEnabledByDefault");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool spellCheckEnabledByDefault;
        spellCheckEnabledByDefault = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSpellCheckEnabledByDefault(spellCheckEnabledByDefault);
    }

    void setSpellCheckEnabledByDefaultMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setSpellCheckEnabledByDefaultMethod(info);
    }

    static void setStrictMixedContentCheckingMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setStrictMixedContentChecking");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool strictMixedContentChecking;
        strictMixedContentChecking = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setStrictMixedContentChecking(strictMixedContentChecking);
    }

    void setStrictMixedContentCheckingMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setStrictMixedContentCheckingMethod(info);
    }

    static void setStrictMixedContentCheckingForPluginMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setStrictMixedContentCheckingForPlugin");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool strictMixedContentCheckingForPlugin;
        strictMixedContentCheckingForPlugin = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setStrictMixedContentCheckingForPlugin(strictMixedContentCheckingForPlugin);
    }

    void setStrictMixedContentCheckingForPluginMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setStrictMixedContentCheckingForPluginMethod(info);
    }

    static void setStrictPowerfulFeatureRestrictionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setStrictPowerfulFeatureRestrictions");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool strictPowerfulFeatureRestrictions;
        strictPowerfulFeatureRestrictions = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setStrictPowerfulFeatureRestrictions(strictPowerfulFeatureRestrictions);
    }

    void setStrictPowerfulFeatureRestrictionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setStrictPowerfulFeatureRestrictionsMethod(info);
    }

    static void setStrictlyBlockBlockableMixedContentMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setStrictlyBlockBlockableMixedContent");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool strictlyBlockBlockableMixedContent;
        strictlyBlockBlockableMixedContent = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setStrictlyBlockBlockableMixedContent(strictlyBlockBlockableMixedContent);
    }

    void setStrictlyBlockBlockableMixedContentMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setStrictlyBlockBlockableMixedContentMethod(info);
    }

    static void setSupportsMultipleWindowsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setSupportsMultipleWindows");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool supportsMultipleWindows;
        supportsMultipleWindows = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSupportsMultipleWindows(supportsMultipleWindows);
    }

    void setSupportsMultipleWindowsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setSupportsMultipleWindowsMethod(info);
    }

    static void setSyncXHRInDocumentsEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setSyncXHRInDocumentsEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool syncXHRInDocumentsEnabled;
        syncXHRInDocumentsEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSyncXHRInDocumentsEnabled(syncXHRInDocumentsEnabled);
    }

    void setSyncXHRInDocumentsEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setSyncXHRInDocumentsEnabledMethod(info);
    }

    static void setTextAreasAreResizableMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setTextAreasAreResizable");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool textAreasAreResizable;
        textAreasAreResizable = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setTextAreasAreResizable(textAreasAreResizable);
    }

    void setTextAreasAreResizableMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextAreasAreResizableMethod(info);
    }

    static void setTextTrackBackgroundColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setTextTrackBackgroundColor", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> textTrackBackgroundColor;
        textTrackBackgroundColor = info[0];
        if (!textTrackBackgroundColor.prepare())
            return;

        impl->setTextTrackBackgroundColor(textTrackBackgroundColor);
    }

    void setTextTrackBackgroundColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackBackgroundColorMethod(info);
    }

    static void setTextTrackFontFamilyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setTextTrackFontFamily", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> textTrackFontFamily;
        textTrackFontFamily = info[0];
        if (!textTrackFontFamily.prepare())
            return;

        impl->setTextTrackFontFamily(textTrackFontFamily);
    }

    void setTextTrackFontFamilyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackFontFamilyMethod(info);
    }

    static void setTextTrackFontStyleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setTextTrackFontStyle", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> textTrackFontStyle;
        textTrackFontStyle = info[0];
        if (!textTrackFontStyle.prepare())
            return;

        impl->setTextTrackFontStyle(textTrackFontStyle);
    }

    void setTextTrackFontStyleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackFontStyleMethod(info);
    }

    static void setTextTrackFontVariantMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setTextTrackFontVariant", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> textTrackFontVariant;
        textTrackFontVariant = info[0];
        if (!textTrackFontVariant.prepare())
            return;

        impl->setTextTrackFontVariant(textTrackFontVariant);
    }

    void setTextTrackFontVariantMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackFontVariantMethod(info);
    }

    static void setTextTrackMarginPercentageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setTextTrackMarginPercentage");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        double textTrackMarginPercentage;
        textTrackMarginPercentage = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setTextTrackMarginPercentage(textTrackMarginPercentage);
    }

    void setTextTrackMarginPercentageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackMarginPercentageMethod(info);
    }

    static void setTextTrackTextColorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setTextTrackTextColor", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> textTrackTextColor;
        textTrackTextColor = info[0];
        if (!textTrackTextColor.prepare())
            return;

        impl->setTextTrackTextColor(textTrackTextColor);
    }

    void setTextTrackTextColorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackTextColorMethod(info);
    }

    static void setTextTrackTextShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setTextTrackTextShadow", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> textTrackTextShadow;
        textTrackTextShadow = info[0];
        if (!textTrackTextShadow.prepare())
            return;

        impl->setTextTrackTextShadow(textTrackTextShadow);
    }

    void setTextTrackTextShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackTextShadowMethod(info);
    }

    static void setTextTrackTextSizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setTextTrackTextSize", "InternalSettingsGenerated", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> textTrackTextSize;
        textTrackTextSize = info[0];
        if (!textTrackTextSize.prepare())
            return;

        impl->setTextTrackTextSize(textTrackTextSize);
    }

    void setTextTrackTextSizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTextTrackTextSizeMethod(info);
    }

    static void setThreadedScrollingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setThreadedScrollingEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool threadedScrollingEnabled;
        threadedScrollingEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setThreadedScrollingEnabled(threadedScrollingEnabled);
    }

    void setThreadedScrollingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setThreadedScrollingEnabledMethod(info);
    }

    static void setTouchAdjustmentEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setTouchAdjustmentEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool touchAdjustmentEnabled;
        touchAdjustmentEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setTouchAdjustmentEnabled(touchAdjustmentEnabled);
    }

    void setTouchAdjustmentEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTouchAdjustmentEnabledMethod(info);
    }

    static void setTouchDragDropEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setTouchDragDropEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool touchDragDropEnabled;
        touchDragDropEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setTouchDragDropEnabled(touchDragDropEnabled);
    }

    void setTouchDragDropEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTouchDragDropEnabledMethod(info);
    }

    static void setTouchEditingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setTouchEditingEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool touchEditingEnabled;
        touchEditingEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setTouchEditingEnabled(touchEditingEnabled);
    }

    void setTouchEditingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setTouchEditingEnabledMethod(info);
    }

    static void setUseDefaultImageInterpolationQualityMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setUseDefaultImageInterpolationQuality");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool useDefaultImageInterpolationQuality;
        useDefaultImageInterpolationQuality = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setUseDefaultImageInterpolationQuality(useDefaultImageInterpolationQuality);
    }

    void setUseDefaultImageInterpolationQualityMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setUseDefaultImageInterpolationQualityMethod(info);
    }

    static void setUseLegacyBackgroundSizeShorthandBehaviorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setUseLegacyBackgroundSizeShorthandBehavior");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool useLegacyBackgroundSizeShorthandBehavior;
        useLegacyBackgroundSizeShorthandBehavior = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setUseLegacyBackgroundSizeShorthandBehavior(useLegacyBackgroundSizeShorthandBehavior);
    }

    void setUseLegacyBackgroundSizeShorthandBehaviorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setUseLegacyBackgroundSizeShorthandBehaviorMethod(info);
    }

    static void setUseSolidColorScrollbarsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setUseSolidColorScrollbars");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool useSolidColorScrollbars;
        useSolidColorScrollbars = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setUseSolidColorScrollbars(useSolidColorScrollbars);
    }

    void setUseSolidColorScrollbarsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setUseSolidColorScrollbarsMethod(info);
    }

    static void setUseWideViewportMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setUseWideViewport");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool useWideViewport;
        useWideViewport = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setUseWideViewport(useWideViewport);
    }

    void setUseWideViewportMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setUseWideViewportMethod(info);
    }

    static void setValidationMessageTimerMagnificationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setValidationMessageTimerMagnification");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        int validationMessageTimerMagnification;
        validationMessageTimerMagnification = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setValidationMessageTimerMagnification(validationMessageTimerMagnification);
    }

    void setValidationMessageTimerMagnificationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setValidationMessageTimerMagnificationMethod(info);
    }

    static void setViewportEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setViewportEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool viewportEnabled;
        viewportEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setViewportEnabled(viewportEnabled);
    }

    void setViewportEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setViewportEnabledMethod(info);
    }

    static void setViewportMetaEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setViewportMetaEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool viewportMetaEnabled;
        viewportMetaEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setViewportMetaEnabled(viewportMetaEnabled);
    }

    void setViewportMetaEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setViewportMetaEnabledMethod(info);
    }

    static void setViewportMetaMergeContentQuirkMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setViewportMetaMergeContentQuirk");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool viewportMetaMergeContentQuirk;
        viewportMetaMergeContentQuirk = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setViewportMetaMergeContentQuirk(viewportMetaMergeContentQuirk);
    }

    void setViewportMetaMergeContentQuirkMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setViewportMetaMergeContentQuirkMethod(info);
    }

    static void setViewportMetaZeroValuesQuirkMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setViewportMetaZeroValuesQuirk");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool viewportMetaZeroValuesQuirk;
        viewportMetaZeroValuesQuirk = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setViewportMetaZeroValuesQuirk(viewportMetaZeroValuesQuirk);
    }

    void setViewportMetaZeroValuesQuirkMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setViewportMetaZeroValuesQuirkMethod(info);
    }

    static void setWebGLEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setWebGLEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool webGLEnabled;
        webGLEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setWebGLEnabled(webGLEnabled);
    }

    void setWebGLEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setWebGLEnabledMethod(info);
    }

    static void setWebGLErrorsToConsoleEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setWebGLErrorsToConsoleEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool webGLErrorsToConsoleEnabled;
        webGLErrorsToConsoleEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setWebGLErrorsToConsoleEnabled(webGLErrorsToConsoleEnabled);
    }

    void setWebGLErrorsToConsoleEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setWebGLErrorsToConsoleEnabledMethod(info);
    }

    static void setWebSecurityEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setWebSecurityEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool webSecurityEnabled;
        webSecurityEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setWebSecurityEnabled(webSecurityEnabled);
    }

    void setWebSecurityEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setWebSecurityEnabledMethod(info);
    }

    static void setWideViewportQuirkEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setWideViewportQuirkEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool wideViewportQuirkEnabled;
        wideViewportQuirkEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setWideViewportQuirkEnabled(wideViewportQuirkEnabled);
    }

    void setWideViewportQuirkEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setWideViewportQuirkEnabledMethod(info);
    }

    static void setXSSAuditorEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "InternalSettingsGenerated", "setXSSAuditorEnabled");

        InternalSettingsGenerated* impl = V8InternalSettingsGenerated::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool xssAuditorEnabled;
        xssAuditorEnabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setXSSAuditorEnabled(xssAuditorEnabled);
    }

    void setXSSAuditorEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalSettingsGeneratedV8Internal::setXSSAuditorEnabledMethod(info);
    }

} // namespace InternalSettingsGeneratedV8Internal

const V8DOMConfiguration::MethodConfiguration V8InternalSettingsGeneratedMethods[] = {
    { "setDOMPasteAllowed", InternalSettingsGeneratedV8Internal::setDOMPasteAllowedMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAccelerated2dCanvasMSAASampleCount", InternalSettingsGeneratedV8Internal::setAccelerated2dCanvasMSAASampleCountMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAcceleratedCompositingEnabled", InternalSettingsGeneratedV8Internal::setAcceleratedCompositingEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAccessibilityEnabled", InternalSettingsGeneratedV8Internal::setAccessibilityEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAccessibilityFontScaleFactor", InternalSettingsGeneratedV8Internal::setAccessibilityFontScaleFactorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAccessibilityPasswordValuesEnabled", InternalSettingsGeneratedV8Internal::setAccessibilityPasswordValuesEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAllowCustomScrollbarInMainFrame", InternalSettingsGeneratedV8Internal::setAllowCustomScrollbarInMainFrameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAllowFileAccessFromFileURLs", InternalSettingsGeneratedV8Internal::setAllowFileAccessFromFileURLsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAllowGeolocationOnInsecureOrigins", InternalSettingsGeneratedV8Internal::setAllowGeolocationOnInsecureOriginsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAllowRunningOfInsecureContent", InternalSettingsGeneratedV8Internal::setAllowRunningOfInsecureContentMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAllowScriptsToCloseWindows", InternalSettingsGeneratedV8Internal::setAllowScriptsToCloseWindowsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAllowUniversalAccessFromFileURLs", InternalSettingsGeneratedV8Internal::setAllowUniversalAccessFromFileURLsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAlwaysShowContextMenuOnTouch", InternalSettingsGeneratedV8Internal::setAlwaysShowContextMenuOnTouchMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAntialiased2dCanvasEnabled", InternalSettingsGeneratedV8Internal::setAntialiased2dCanvasEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAntialiasedClips2dCanvasEnabled", InternalSettingsGeneratedV8Internal::setAntialiasedClips2dCanvasEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAvailableHoverTypes", InternalSettingsGeneratedV8Internal::setAvailableHoverTypesMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAvailablePointerTypes", InternalSettingsGeneratedV8Internal::setAvailablePointerTypesMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setBackgroundHtmlParserOutstandingTokenLimit", InternalSettingsGeneratedV8Internal::setBackgroundHtmlParserOutstandingTokenLimitMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setBackgroundHtmlParserPendingTokenLimit", InternalSettingsGeneratedV8Internal::setBackgroundHtmlParserPendingTokenLimitMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setBrowserSideNavigationEnabled", InternalSettingsGeneratedV8Internal::setBrowserSideNavigationEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setCookieEnabled", InternalSettingsGeneratedV8Internal::setCookieEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setCrossOriginMediaPlaybackRequiresUserGesture", InternalSettingsGeneratedV8Internal::setCrossOriginMediaPlaybackRequiresUserGestureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setCSSExternalScannerNoPreload", InternalSettingsGeneratedV8Internal::setCSSExternalScannerNoPreloadMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setCSSExternalScannerPreload", InternalSettingsGeneratedV8Internal::setCSSExternalScannerPreloadMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDataSaverEnabled", InternalSettingsGeneratedV8Internal::setDataSaverEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDefaultFixedFontSize", InternalSettingsGeneratedV8Internal::setDefaultFixedFontSizeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDefaultFontSize", InternalSettingsGeneratedV8Internal::setDefaultFontSizeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDefaultTextEncodingName", InternalSettingsGeneratedV8Internal::setDefaultTextEncodingNameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDefaultVideoPosterURL", InternalSettingsGeneratedV8Internal::setDefaultVideoPosterURLMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDeviceScaleAdjustment", InternalSettingsGeneratedV8Internal::setDeviceScaleAdjustmentMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDeviceSupportsTouch", InternalSettingsGeneratedV8Internal::setDeviceSupportsTouchMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDisableReadingFromCanvas", InternalSettingsGeneratedV8Internal::setDisableReadingFromCanvasMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDisallowFetchForDocWrittenScriptsInMainFrame", InternalSettingsGeneratedV8Internal::setDisallowFetchForDocWrittenScriptsInMainFrameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDisallowFetchForDocWrittenScriptsInMainFrameIfEffectively2G", InternalSettingsGeneratedV8Internal::setDisallowFetchForDocWrittenScriptsInMainFrameIfEffectively2GMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDisallowFetchForDocWrittenScriptsInMainFrameOnSlowConnections", InternalSettingsGeneratedV8Internal::setDisallowFetchForDocWrittenScriptsInMainFrameOnSlowConnectionsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDNSPrefetchingEnabled", InternalSettingsGeneratedV8Internal::setDNSPrefetchingEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDoHtmlPreloadScanning", InternalSettingsGeneratedV8Internal::setDoHtmlPreloadScanningMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setDownloadableBinaryFontsEnabled", InternalSettingsGeneratedV8Internal::setDownloadableBinaryFontsEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setEncryptedMediaEnabled", InternalSettingsGeneratedV8Internal::setEncryptedMediaEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setFetchImagePlaceholders", InternalSettingsGeneratedV8Internal::setFetchImagePlaceholdersMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setForceMainWorldInitialization", InternalSettingsGeneratedV8Internal::setForceMainWorldInitializationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setForcePreloadNoneForMediaElements", InternalSettingsGeneratedV8Internal::setForcePreloadNoneForMediaElementsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setForceZeroLayoutHeight", InternalSettingsGeneratedV8Internal::setForceZeroLayoutHeightMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setFullscreenSupported", InternalSettingsGeneratedV8Internal::setFullscreenSupportedMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setHideDownloadUI", InternalSettingsGeneratedV8Internal::setHideDownloadUIMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setHideScrollbars", InternalSettingsGeneratedV8Internal::setHideScrollbarsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setHistoryEntryRequiresUserGesture", InternalSettingsGeneratedV8Internal::setHistoryEntryRequiresUserGestureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setHyperlinkAuditingEnabled", InternalSettingsGeneratedV8Internal::setHyperlinkAuditingEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setIgnoreMainFrameOverflowHiddenQuirk", InternalSettingsGeneratedV8Internal::setIgnoreMainFrameOverflowHiddenQuirkMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setImagesEnabled", InternalSettingsGeneratedV8Internal::setImagesEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setInertVisualViewport", InternalSettingsGeneratedV8Internal::setInertVisualViewportMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setInlineTextBoxAccessibilityEnabled", InternalSettingsGeneratedV8Internal::setInlineTextBoxAccessibilityEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setJavaScriptCanAccessClipboard", InternalSettingsGeneratedV8Internal::setJavaScriptCanAccessClipboardMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setJavaScriptCanOpenWindowsAutomatically", InternalSettingsGeneratedV8Internal::setJavaScriptCanOpenWindowsAutomaticallyMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setLayerSquashingEnabled", InternalSettingsGeneratedV8Internal::setLayerSquashingEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setLoadWithOverviewMode", InternalSettingsGeneratedV8Internal::setLoadWithOverviewModeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setLoadsImagesAutomatically", InternalSettingsGeneratedV8Internal::setLoadsImagesAutomaticallyMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setLocalStorageEnabled", InternalSettingsGeneratedV8Internal::setLocalStorageEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setLogDnsPrefetchAndPreconnect", InternalSettingsGeneratedV8Internal::setLogDnsPrefetchAndPreconnectMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setLogPreload", InternalSettingsGeneratedV8Internal::setLogPreloadMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setLowPriorityIframes", InternalSettingsGeneratedV8Internal::setLowPriorityIframesMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMainFrameClipsContent", InternalSettingsGeneratedV8Internal::setMainFrameClipsContentMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMainFrameResizesAreOrientationChanges", InternalSettingsGeneratedV8Internal::setMainFrameResizesAreOrientationChangesMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMaxBeaconTransmission", InternalSettingsGeneratedV8Internal::setMaxBeaconTransmissionMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMaxTouchPoints", InternalSettingsGeneratedV8Internal::setMaxTouchPointsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMediaControlsOverlayPlayButtonEnabled", InternalSettingsGeneratedV8Internal::setMediaControlsOverlayPlayButtonEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMediaPlaybackRequiresUserGesture", InternalSettingsGeneratedV8Internal::setMediaPlaybackRequiresUserGestureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMediaTypeOverride", InternalSettingsGeneratedV8Internal::setMediaTypeOverrideMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMinimumAccelerated2dCanvasSize", InternalSettingsGeneratedV8Internal::setMinimumAccelerated2dCanvasSizeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMinimumFontSize", InternalSettingsGeneratedV8Internal::setMinimumFontSizeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMinimumLogicalFontSize", InternalSettingsGeneratedV8Internal::setMinimumLogicalFontSizeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMockGestureTapHighlightsEnabled", InternalSettingsGeneratedV8Internal::setMockGestureTapHighlightsEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMultiTargetTapNotificationEnabled", InternalSettingsGeneratedV8Internal::setMultiTargetTapNotificationEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setNavigateOnDragDrop", InternalSettingsGeneratedV8Internal::setNavigateOnDragDropMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setOfflineWebApplicationCacheEnabled", InternalSettingsGeneratedV8Internal::setOfflineWebApplicationCacheEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setParseHTMLOnMainThreadCoalesceChunks", InternalSettingsGeneratedV8Internal::setParseHTMLOnMainThreadCoalesceChunksMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setParseHTMLOnMainThreadSyncTokenize", InternalSettingsGeneratedV8Internal::setParseHTMLOnMainThreadSyncTokenizeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPasswordEchoDurationInSeconds", InternalSettingsGeneratedV8Internal::setPasswordEchoDurationInSecondsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPasswordEchoEnabled", InternalSettingsGeneratedV8Internal::setPasswordEchoEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPluginsEnabled", InternalSettingsGeneratedV8Internal::setPluginsEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPreferCompositingToLCDTextEnabled", InternalSettingsGeneratedV8Internal::setPreferCompositingToLCDTextEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPreferHiddenVolumeControls", InternalSettingsGeneratedV8Internal::setPreferHiddenVolumeControlsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPresentationReceiver", InternalSettingsGeneratedV8Internal::setPresentationReceiverMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPresentationRequiresUserGesture", InternalSettingsGeneratedV8Internal::setPresentationRequiresUserGestureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setReportScreenSizeInPhysicalPixelsQuirk", InternalSettingsGeneratedV8Internal::setReportScreenSizeInPhysicalPixelsQuirkMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setRubberBandingOnCompositorThread", InternalSettingsGeneratedV8Internal::setRubberBandingOnCompositorThreadMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setScriptEnabled", InternalSettingsGeneratedV8Internal::setScriptEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setScrollAnimatorEnabled", InternalSettingsGeneratedV8Internal::setScrollAnimatorEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSelectTrailingWhitespaceEnabled", InternalSettingsGeneratedV8Internal::setSelectTrailingWhitespaceEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSelectionIncludesAltImageText", InternalSettingsGeneratedV8Internal::setSelectionIncludesAltImageTextMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setShouldClearDocumentBackground", InternalSettingsGeneratedV8Internal::setShouldClearDocumentBackgroundMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setShouldPrintBackgrounds", InternalSettingsGeneratedV8Internal::setShouldPrintBackgroundsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setShouldRespectImageOrientation", InternalSettingsGeneratedV8Internal::setShouldRespectImageOrientationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setShouldReuseGlobalForUnownedMainFrame", InternalSettingsGeneratedV8Internal::setShouldReuseGlobalForUnownedMainFrameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setShowContextMenuOnMouseUp", InternalSettingsGeneratedV8Internal::setShowContextMenuOnMouseUpMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSmartInsertDeleteEnabled", InternalSettingsGeneratedV8Internal::setSmartInsertDeleteEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSpatialNavigationEnabled", InternalSettingsGeneratedV8Internal::setSpatialNavigationEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSpellCheckEnabledByDefault", InternalSettingsGeneratedV8Internal::setSpellCheckEnabledByDefaultMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setStrictMixedContentChecking", InternalSettingsGeneratedV8Internal::setStrictMixedContentCheckingMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setStrictMixedContentCheckingForPlugin", InternalSettingsGeneratedV8Internal::setStrictMixedContentCheckingForPluginMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setStrictPowerfulFeatureRestrictions", InternalSettingsGeneratedV8Internal::setStrictPowerfulFeatureRestrictionsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setStrictlyBlockBlockableMixedContent", InternalSettingsGeneratedV8Internal::setStrictlyBlockBlockableMixedContentMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSupportsMultipleWindows", InternalSettingsGeneratedV8Internal::setSupportsMultipleWindowsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSyncXHRInDocumentsEnabled", InternalSettingsGeneratedV8Internal::setSyncXHRInDocumentsEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextAreasAreResizable", InternalSettingsGeneratedV8Internal::setTextAreasAreResizableMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackBackgroundColor", InternalSettingsGeneratedV8Internal::setTextTrackBackgroundColorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackFontFamily", InternalSettingsGeneratedV8Internal::setTextTrackFontFamilyMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackFontStyle", InternalSettingsGeneratedV8Internal::setTextTrackFontStyleMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackFontVariant", InternalSettingsGeneratedV8Internal::setTextTrackFontVariantMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackMarginPercentage", InternalSettingsGeneratedV8Internal::setTextTrackMarginPercentageMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackTextColor", InternalSettingsGeneratedV8Internal::setTextTrackTextColorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackTextShadow", InternalSettingsGeneratedV8Internal::setTextTrackTextShadowMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTextTrackTextSize", InternalSettingsGeneratedV8Internal::setTextTrackTextSizeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setThreadedScrollingEnabled", InternalSettingsGeneratedV8Internal::setThreadedScrollingEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTouchAdjustmentEnabled", InternalSettingsGeneratedV8Internal::setTouchAdjustmentEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTouchDragDropEnabled", InternalSettingsGeneratedV8Internal::setTouchDragDropEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setTouchEditingEnabled", InternalSettingsGeneratedV8Internal::setTouchEditingEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setUseDefaultImageInterpolationQuality", InternalSettingsGeneratedV8Internal::setUseDefaultImageInterpolationQualityMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setUseLegacyBackgroundSizeShorthandBehavior", InternalSettingsGeneratedV8Internal::setUseLegacyBackgroundSizeShorthandBehaviorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setUseSolidColorScrollbars", InternalSettingsGeneratedV8Internal::setUseSolidColorScrollbarsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setUseWideViewport", InternalSettingsGeneratedV8Internal::setUseWideViewportMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setValidationMessageTimerMagnification", InternalSettingsGeneratedV8Internal::setValidationMessageTimerMagnificationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setViewportEnabled", InternalSettingsGeneratedV8Internal::setViewportEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setViewportMetaEnabled", InternalSettingsGeneratedV8Internal::setViewportMetaEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setViewportMetaMergeContentQuirk", InternalSettingsGeneratedV8Internal::setViewportMetaMergeContentQuirkMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setViewportMetaZeroValuesQuirk", InternalSettingsGeneratedV8Internal::setViewportMetaZeroValuesQuirkMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setWebGLEnabled", InternalSettingsGeneratedV8Internal::setWebGLEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setWebGLErrorsToConsoleEnabled", InternalSettingsGeneratedV8Internal::setWebGLErrorsToConsoleEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setWebSecurityEnabled", InternalSettingsGeneratedV8Internal::setWebSecurityEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setWideViewportQuirkEnabled", InternalSettingsGeneratedV8Internal::setWideViewportQuirkEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setXSSAuditorEnabled", InternalSettingsGeneratedV8Internal::setXSSAuditorEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
};

static void installV8InternalSettingsGeneratedTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    // Initialize the interface object's template.
    V8DOMConfiguration::initializeDOMInterfaceTemplate(isolate, interfaceTemplate, V8InternalSettingsGenerated::wrapperTypeInfo.interfaceName, v8::Local<v8::FunctionTemplate>(), V8InternalSettingsGenerated::internalFieldCount);

    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interfaceTemplate);
    ALLOW_UNUSED_LOCAL(signature);
    v8::Local<v8::ObjectTemplate> instanceTemplate = interfaceTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = interfaceTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);

    // Register DOM constants, attributes and operations.
    V8DOMConfiguration::installMethods(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8InternalSettingsGeneratedMethods, WTF_ARRAY_LENGTH(V8InternalSettingsGeneratedMethods));
}

v8::Local<v8::FunctionTemplate> V8InternalSettingsGenerated::domTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world)
{
    return V8DOMConfiguration::domClassTemplate(isolate, world, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), installV8InternalSettingsGeneratedTemplate);
}

bool V8InternalSettingsGenerated::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8InternalSettingsGenerated::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

InternalSettingsGenerated* V8InternalSettingsGenerated::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value)
{
    return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : nullptr;
}

} // namespace blink
