// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/interface.cpp.tmpl

// clang-format off
#include "V8Element.h"

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/DictionarySequenceOrDictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/GeneratedCodeHelper.h"
#include "bindings/core/v8/ScriptState.h"
#include "bindings/core/v8/V8AbstractEventListener.h"
#include "bindings/core/v8/V8Animation.h"
#include "bindings/core/v8/V8Attr.h"
#include "bindings/core/v8/V8ClientRect.h"
#include "bindings/core/v8/V8ClientRectList.h"
#include "bindings/core/v8/V8DOMActivityLogger.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8DOMTokenList.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8EventListenerHelper.h"
#include "bindings/core/v8/V8HTMLCollection.h"
#include "bindings/core/v8/V8HTMLSlotElement.h"
#include "bindings/core/v8/V8KeyframeEffectOptions.h"
#include "bindings/core/v8/V8NamedNodeMap.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "bindings/core/v8/V8ScrollStateCallback.h"
#include "bindings/core/v8/V8ScrollToOptions.h"
#include "bindings/core/v8/V8ShadowRoot.h"
#include "bindings/core/v8/V8ShadowRootInit.h"
#include "core/HTMLNames.h"
#include "core/animation/ElementAnimation.h"
#include "core/dom/ChildNode.h"
#include "core/dom/ClassCollection.h"
#include "core/dom/Document.h"
#include "core/dom/ElementFullscreen.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/NonDocumentTypeChildNode.h"
#include "core/dom/ParentNode.h"
#include "core/dom/StaticNodeList.h"
#include "core/dom/TagCollection.h"
#include "core/dom/custom/CEReactionsScope.h"
#include "core/dom/custom/V0CustomElementProcessingStack.h"
#include "core/frame/UseCounter.h"
#include "core/html/HTMLCollection.h"
#include "core/html/HTMLDataListOptionsCollection.h"
#include "core/html/HTMLFormControlsCollection.h"
#include "core/html/HTMLTableRowsCollection.h"
#include "core/html/LabelsNodeList.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
const WrapperTypeInfo V8Element::wrapperTypeInfo = { gin::kEmbedderBlink, V8Element::domTemplate, V8Element::trace, V8Element::traceWrappers, 0, V8Element::preparePrototypeAndInterfaceObject, "Element", &V8Node::wrapperTypeInfo, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::NodeClassId, WrapperTypeInfo::NotInheritFromActiveScriptWrappable, WrapperTypeInfo::InheritFromEventTarget, WrapperTypeInfo::Dependent };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in Element.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& Element::s_wrapperTypeInfo = V8Element::wrapperTypeInfo;

// not [ActiveScriptWrappable]
static_assert(
    !std::is_base_of<ActiveScriptWrappableBase, Element>::value,
    "Element inherits from ActiveScriptWrappable<>, but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");
static_assert(
    std::is_same<decltype(&Element::hasPendingActivity),
                 decltype(&ScriptWrappable::hasPendingActivity)>::value,
    "Element is overriding hasPendingActivity(), but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");

namespace ElementV8Internal {

static void namespaceURIAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {

  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueStringOrNull(info, impl->namespaceURI(), info.GetIsolate());
}

CORE_EXPORT void namespaceURIAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {

  ElementV8Internal::namespaceURIAttributeGetter(info);
}

static void prefixAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueStringOrNull(info, impl->prefix(), info.GetIsolate());
}

CORE_EXPORT void prefixAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::prefixAttributeGetter(info);
}

static void localNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueString(info, impl->localName(), info.GetIsolate());
}

CORE_EXPORT void localNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::localNameAttributeGetter(info);
}

static void tagNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueString(info, impl->tagName(), info.GetIsolate());
}

CORE_EXPORT void tagNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::tagNameAttributeGetter(info);
}

static void idAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueString(info, impl->getIdAttribute(), info.GetIsolate());
}

CORE_EXPORT void idAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::idAttributeGetter(info);
}

static void idAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.
  V8StringResource<> cppValue = v8Value;
  if (!cppValue.prepare())
    return;

  impl->setAttribute(HTMLNames::idAttr, cppValue);
}

CORE_EXPORT void idAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  CEReactionsScope ceReactionsScope;

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ElementV8Internal::idAttributeSetter(v8Value, info);
}

static void classNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueString(info, impl->getClassAttribute(), info.GetIsolate());
}

CORE_EXPORT void classNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::classNameAttributeGetter(info);
}

static void classNameAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.
  V8StringResource<> cppValue = v8Value;
  if (!cppValue.prepare())
    return;

  impl->setAttribute(HTMLNames::classAttr, cppValue);
}

CORE_EXPORT void classNameAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  CEReactionsScope ceReactionsScope;

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ElementV8Internal::classNameAttributeSetter(v8Value, info);
}

static void classListAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, WTF::getPtr(impl->classList()), impl);
}

CORE_EXPORT void classListAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::classListAttributeGetter(info);
}

static void classListAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* proxyImpl = V8Element::toImpl(holder);
  DOMTokenList* impl = WTF::getPtr(proxyImpl->classList());
  if (!impl)
    return;

  // Prepare the value to be set.
  V8StringResource<> cppValue = v8Value;
  if (!cppValue.prepare())
    return;

  impl->setValue(cppValue);
}

CORE_EXPORT void classListAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  CEReactionsScope ceReactionsScope;

  ElementV8Internal::classListAttributeSetter(v8Value, info);
}

static void classListAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->classList()));
}

CORE_EXPORT void classListAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::classListAttributeGetterForMainWorld(info);
}

static void classListAttributeSetterForMainWorld(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* proxyImpl = V8Element::toImpl(holder);
  DOMTokenList* impl = WTF::getPtr(proxyImpl->classList());
  if (!impl)
    return;

  // Prepare the value to be set.
  V8StringResource<> cppValue = v8Value;
  if (!cppValue.prepare())
    return;

  impl->setValue(cppValue);
}

CORE_EXPORT void classListAttributeSetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  CEReactionsScope ceReactionsScope;

  ElementV8Internal::classListAttributeSetterForMainWorld(v8Value, info);
}

static void slotAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueString(info, impl->fastGetAttribute(HTMLNames::slotAttr), info.GetIsolate());
}

CORE_EXPORT void slotAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::slotAttributeGetter(info);
}

static void slotAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.
  V8StringResource<> cppValue = v8Value;
  if (!cppValue.prepare())
    return;

  impl->setAttribute(HTMLNames::slotAttr, cppValue);
}

CORE_EXPORT void slotAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  CEReactionsScope ceReactionsScope;

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ElementV8Internal::slotAttributeSetter(v8Value, info);
}

static void attributesAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, WTF::getPtr(impl->attributesForBindings()), impl);
}

CORE_EXPORT void attributesAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::attributesAttributeGetter(info);
}

static void attributesAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->attributesForBindings()));
}

CORE_EXPORT void attributesAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::attributesAttributeGetterForMainWorld(info);
}

static void shadowRootAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, WTF::getPtr(impl->openShadowRoot()), impl);
}

CORE_EXPORT void shadowRootAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::shadowRootAttributeGetter(info);
}

static void shadowRootAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->openShadowRoot()));
}

CORE_EXPORT void shadowRootAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::shadowRootAttributeGetterForMainWorld(info);
}

static void assignedSlotAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, WTF::getPtr(impl->assignedSlotForBinding()), impl);
}

CORE_EXPORT void assignedSlotAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::assignedSlotAttributeGetter(info);
}

static void innerHTMLAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueString(info, impl->innerHTML(), info.GetIsolate());
}

CORE_EXPORT void innerHTMLAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::innerHTMLAttributeGetter(info);
}

static void innerHTMLAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Skip on compact node DOMString getters.
  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::SetterContext, "Element", "innerHTML");

  // Prepare the value to be set.
  V8StringResource<TreatNullAsNullString> cppValue = v8Value;
  if (!cppValue.prepare())
    return;

  impl->setInnerHTML(cppValue, exceptionState);
}

CORE_EXPORT void innerHTMLAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  CEReactionsScope ceReactionsScope;

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ElementV8Internal::innerHTMLAttributeSetter(v8Value, info);
}

static void outerHTMLAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueString(info, impl->outerHTML(), info.GetIsolate());
}

CORE_EXPORT void outerHTMLAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::outerHTMLAttributeGetter(info);
}

static void outerHTMLAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Skip on compact node DOMString getters.
  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::SetterContext, "Element", "outerHTML");

  // Prepare the value to be set.
  V8StringResource<TreatNullAsNullString> cppValue = v8Value;
  if (!cppValue.prepare())
    return;

  impl->setOuterHTML(cppValue, exceptionState);
}

CORE_EXPORT void outerHTMLAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  CEReactionsScope ceReactionsScope;

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ElementV8Internal::outerHTMLAttributeSetter(v8Value, info);
}

static void scrollTopAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValue(info, impl->scrollTop());
}

CORE_EXPORT void scrollTopAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollTopAttributeGetter(info);
}

static void scrollTopAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::SetterContext, "Element", "scrollTop");

  // Prepare the value to be set.
  double cppValue = toDouble(info.GetIsolate(), v8Value, exceptionState);
  if (exceptionState.hadException())
    return;

  impl->setScrollTop(cppValue);
}

CORE_EXPORT void scrollTopAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::scrollTopAttributeSetter(v8Value, info);
}

static void scrollLeftAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValue(info, impl->scrollLeft());
}

CORE_EXPORT void scrollLeftAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollLeftAttributeGetter(info);
}

static void scrollLeftAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::SetterContext, "Element", "scrollLeft");

  // Prepare the value to be set.
  double cppValue = toDouble(info.GetIsolate(), v8Value, exceptionState);
  if (exceptionState.hadException())
    return;

  impl->setScrollLeft(cppValue);
}

CORE_EXPORT void scrollLeftAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::scrollLeftAttributeSetter(v8Value, info);
}

static void scrollWidthAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueInt(info, impl->scrollWidth());
}

CORE_EXPORT void scrollWidthAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollWidthAttributeGetter(info);
}

static void scrollHeightAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueInt(info, impl->scrollHeight());
}

CORE_EXPORT void scrollHeightAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollHeightAttributeGetter(info);
}

static void clientTopAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueInt(info, impl->clientTop());
}

CORE_EXPORT void clientTopAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::clientTopAttributeGetter(info);
}

static void clientLeftAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueInt(info, impl->clientLeft());
}

CORE_EXPORT void clientLeftAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::clientLeftAttributeGetter(info);
}

static void clientWidthAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueInt(info, impl->clientWidth());
}

CORE_EXPORT void clientWidthAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::clientWidthAttributeGetter(info);
}

static void clientHeightAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueInt(info, impl->clientHeight());
}

CORE_EXPORT void clientHeightAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::clientHeightAttributeGetter(info);
}

static void computedRoleAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueStringOrNull(info, impl->computedRole(), info.GetIsolate());
}

CORE_EXPORT void computedRoleAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::computedRoleAttributeGetter(info);
}

static void computedNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueStringOrNull(info, impl->computedName(), info.GetIsolate());
}

CORE_EXPORT void computedNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::computedNameAttributeGetter(info);
}

static void onbeforecopyAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->onbeforecopy()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onbeforecopyAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onbeforecopyAttributeGetter(info);
}

static void onbeforecopyAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOnbeforecopy(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onbeforecopyAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onbeforecopyAttributeSetter(v8Value, info);
}

static void onbeforecutAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->onbeforecut()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onbeforecutAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onbeforecutAttributeGetter(info);
}

static void onbeforecutAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOnbeforecut(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onbeforecutAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onbeforecutAttributeSetter(v8Value, info);
}

static void onbeforepasteAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->onbeforepaste()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onbeforepasteAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onbeforepasteAttributeGetter(info);
}

static void onbeforepasteAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOnbeforepaste(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onbeforepasteAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onbeforepasteAttributeSetter(v8Value, info);
}

static void oncopyAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->oncopy()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void oncopyAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::oncopyAttributeGetter(info);
}

static void oncopyAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOncopy(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void oncopyAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::oncopyAttributeSetter(v8Value, info);
}

static void oncutAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->oncut()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void oncutAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::oncutAttributeGetter(info);
}

static void oncutAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOncut(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void oncutAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::oncutAttributeSetter(v8Value, info);
}

static void onpasteAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->onpaste()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onpasteAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onpasteAttributeGetter(info);
}

static void onpasteAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOnpaste(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onpasteAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onpasteAttributeSetter(v8Value, info);
}

static void onsearchAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->onsearch()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onsearchAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onsearchAttributeGetter(info);
}

static void onsearchAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOnsearch(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onsearchAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onsearchAttributeSetter(v8Value, info);
}

static void onselectstartAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->onselectstart()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onselectstartAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onselectstartAttributeGetter(info);
}

static void onselectstartAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOnselectstart(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onselectstartAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onselectstartAttributeSetter(v8Value, info);
}

static void onwheelAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(WTF::getPtr(impl->onwheel()));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onwheelAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onwheelAttributeGetter(info);
}

static void onwheelAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  impl->setOnwheel(V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onwheelAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onwheelAttributeSetter(v8Value, info);
}

static void onwebkitfullscreenchangeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(ElementFullscreen::onwebkitfullscreenchange(*impl));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onwebkitfullscreenchangeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onwebkitfullscreenchangeAttributeGetter(info);
}

static void onwebkitfullscreenchangeAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  ElementFullscreen::setOnwebkitfullscreenchange(*impl, V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onwebkitfullscreenchangeAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onwebkitfullscreenchangeAttributeSetter(v8Value, info);
}

static void onwebkitfullscreenerrorAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  EventListener* cppValue(ElementFullscreen::onwebkitfullscreenerror(*impl));

  v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

CORE_EXPORT void onwebkitfullscreenerrorAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::onwebkitfullscreenerrorAttributeGetter(info);
}

static void onwebkitfullscreenerrorAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();
  Element* impl = V8Element::toImpl(holder);

  // Prepare the value to be set.

  ElementFullscreen::setOnwebkitfullscreenerror(*impl, V8EventListenerHelper::getEventListener(ScriptState::forReceiverObject(info), v8Value, true, ListenerFindOrCreate));
}

CORE_EXPORT void onwebkitfullscreenerrorAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Value> v8Value = info[0];

  ElementV8Internal::onwebkitfullscreenerrorAttributeSetter(v8Value, info);
}

static void previousElementSiblingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, NonDocumentTypeChildNode::previousElementSibling(*impl), impl);
}

CORE_EXPORT void previousElementSiblingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::previousElementSiblingAttributeGetter(info);
}

static void previousElementSiblingAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, NonDocumentTypeChildNode::previousElementSibling(*impl));
}

CORE_EXPORT void previousElementSiblingAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::previousElementSiblingAttributeGetterForMainWorld(info);
}

static void nextElementSiblingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, NonDocumentTypeChildNode::nextElementSibling(*impl), impl);
}

CORE_EXPORT void nextElementSiblingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::nextElementSiblingAttributeGetter(info);
}

static void nextElementSiblingAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, NonDocumentTypeChildNode::nextElementSibling(*impl));
}

CORE_EXPORT void nextElementSiblingAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::nextElementSiblingAttributeGetterForMainWorld(info);
}

static void childrenAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, ParentNode::children(*impl), impl);
}

CORE_EXPORT void childrenAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::childrenAttributeGetter(info);
}

static void childrenAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, ParentNode::children(*impl));
}

CORE_EXPORT void childrenAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::childrenAttributeGetterForMainWorld(info);
}

static void firstElementChildAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, ParentNode::firstElementChild(*impl), impl);
}

CORE_EXPORT void firstElementChildAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::firstElementChildAttributeGetter(info);
}

static void firstElementChildAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, ParentNode::firstElementChild(*impl));
}

CORE_EXPORT void firstElementChildAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::firstElementChildAttributeGetterForMainWorld(info);
}

static void lastElementChildAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueFast(info, ParentNode::lastElementChild(*impl), impl);
}

CORE_EXPORT void lastElementChildAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::lastElementChildAttributeGetter(info);
}

static void lastElementChildAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueForMainWorld(info, ParentNode::lastElementChild(*impl));
}

CORE_EXPORT void lastElementChildAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::lastElementChildAttributeGetterForMainWorld(info);
}

static void childElementCountAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Local<v8::Object> holder = info.Holder();

  Element* impl = V8Element::toImpl(holder);

  v8SetReturnValueUnsigned(info, ParentNode::childElementCount(*impl));
}

CORE_EXPORT void childElementCountAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::childElementCountAttributeGetter(info);
}

static void setPointerCaptureMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "setPointerCapture");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  int pointerId;
  pointerId = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
  if (exceptionState.hadException())
    return;

  impl->setPointerCapture(pointerId, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void setPointerCaptureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::setPointerCaptureMethod(info);
}

static void releasePointerCaptureMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "releasePointerCapture");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  int pointerId;
  pointerId = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
  if (exceptionState.hadException())
    return;

  impl->releasePointerCapture(pointerId, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void releasePointerCaptureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::releasePointerCaptureMethod(info);
}

static void hasPointerCaptureMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "hasPointerCapture");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  int pointerId;
  pointerId = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
  if (exceptionState.hadException())
    return;

  v8SetReturnValueBool(info, impl->hasPointerCapture(pointerId));
}

CORE_EXPORT  void hasPointerCaptureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::hasPointerCaptureMethod(info);
}

static void hasAttributesMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  v8SetReturnValueBool(info, impl->hasAttributes());
}

CORE_EXPORT  void hasAttributesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::hasAttributesMethod(info);
}

static void getAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttribute", "Element", ExceptionMessages::notEnoughArguments(1, info.Length())));
    return;
  }

  V8StringResource<> name;
  name = info[0];
  if (!name.prepare())
    return;

  v8SetReturnValueStringOrNull(info, impl->getAttribute(name), info.GetIsolate());
}

CORE_EXPORT  void getAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getAttributeMethod(info);
}

static void getAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 2)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttributeNS", "Element", ExceptionMessages::notEnoughArguments(2, info.Length())));
    return;
  }

  V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
  V8StringResource<> localName;
  namespaceURI = info[0];
  if (!namespaceURI.prepare())
    return;

  localName = info[1];
  if (!localName.prepare())
    return;

  v8SetReturnValueStringOrNull(info, impl->getAttributeNS(namespaceURI, localName), info.GetIsolate());
}

CORE_EXPORT  void getAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getAttributeNSMethod(info);
}

static void setAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "setAttribute");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 2)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
    return;
  }

  V8StringResource<> name;
  V8StringResource<> value;
  name = info[0];
  if (!name.prepare())
    return;

  value = info[1];
  if (!value.prepare())
    return;

  impl->setAttribute(name, value, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void setAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::setAttributeMethod(info);
}

static void setAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "setAttributeNS");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 3)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
    return;
  }

  V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
  V8StringResource<> name;
  V8StringResource<> value;
  namespaceURI = info[0];
  if (!namespaceURI.prepare())
    return;

  name = info[1];
  if (!name.prepare())
    return;

  value = info[2];
  if (!value.prepare())
    return;

  impl->setAttributeNS(namespaceURI, name, value, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void setAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::setAttributeNSMethod(info);
}

static void removeAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 1)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("removeAttribute", "Element", ExceptionMessages::notEnoughArguments(1, info.Length())));
    return;
  }

  V8StringResource<> name;
  name = info[0];
  if (!name.prepare())
    return;

  impl->removeAttribute(name);
}

CORE_EXPORT  void removeAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::removeAttributeMethod(info);
}

static void removeAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 2)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("removeAttributeNS", "Element", ExceptionMessages::notEnoughArguments(2, info.Length())));
    return;
  }

  V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
  V8StringResource<> localName;
  namespaceURI = info[0];
  if (!namespaceURI.prepare())
    return;

  localName = info[1];
  if (!localName.prepare())
    return;

  impl->removeAttributeNS(namespaceURI, localName);
}

CORE_EXPORT  void removeAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::removeAttributeNSMethod(info);
}

static void hasAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("hasAttribute", "Element", ExceptionMessages::notEnoughArguments(1, info.Length())));
    return;
  }

  V8StringResource<> name;
  name = info[0];
  if (!name.prepare())
    return;

  v8SetReturnValueBool(info, impl->hasAttribute(name));
}

CORE_EXPORT  void hasAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::hasAttributeMethod(info);
}

static void hasAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 2)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("hasAttributeNS", "Element", ExceptionMessages::notEnoughArguments(2, info.Length())));
    return;
  }

  V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
  V8StringResource<> localName;
  namespaceURI = info[0];
  if (!namespaceURI.prepare())
    return;

  localName = info[1];
  if (!localName.prepare())
    return;

  v8SetReturnValueBool(info, impl->hasAttributeNS(namespaceURI, localName));
}

CORE_EXPORT  void hasAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::hasAttributeNSMethod(info);
}

static void getAttributeNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttributeNode", "Element", ExceptionMessages::notEnoughArguments(1, info.Length())));
    return;
  }

  V8StringResource<> name;
  name = info[0];
  if (!name.prepare())
    return;

  v8SetReturnValueFast(info, impl->getAttributeNode(name), impl);
}

CORE_EXPORT  void getAttributeNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getAttributeNodeMethod(info);
}

static void getAttributeNodeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 2)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getAttributeNodeNS", "Element", ExceptionMessages::notEnoughArguments(2, info.Length())));
    return;
  }

  V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
  V8StringResource<> localName;
  namespaceURI = info[0];
  if (!namespaceURI.prepare())
    return;

  localName = info[1];
  if (!localName.prepare())
    return;

  v8SetReturnValueFast(info, impl->getAttributeNodeNS(namespaceURI, localName), impl);
}

CORE_EXPORT  void getAttributeNodeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getAttributeNodeNSMethod(info);
}

static void setAttributeNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "setAttributeNode");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  Attr* attr;
  attr = V8Attr::toImplWithTypeCheck(info.GetIsolate(), info[0]);
  if (!attr) {
    exceptionState.throwTypeError("parameter 1 is not of type 'Attr'.");

    return;
  }

  Attr* result = impl->setAttributeNode(attr, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void setAttributeNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::setAttributeNodeMethod(info);
}

static void setAttributeNodeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "setAttributeNodeNS");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  Attr* attr;
  attr = V8Attr::toImplWithTypeCheck(info.GetIsolate(), info[0]);
  if (!attr) {
    exceptionState.throwTypeError("parameter 1 is not of type 'Attr'.");

    return;
  }

  Attr* result = impl->setAttributeNodeNS(attr, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void setAttributeNodeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::setAttributeNodeNSMethod(info);
}

static void removeAttributeNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "removeAttributeNode");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  Attr* attr;
  attr = V8Attr::toImplWithTypeCheck(info.GetIsolate(), info[0]);
  if (!attr) {
    exceptionState.throwTypeError("parameter 1 is not of type 'Attr'.");

    return;
  }

  Attr* result = impl->removeAttributeNode(attr, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void removeAttributeNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::removeAttributeNodeMethod(info);
}

static void closestMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "closest");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  V8StringResource<> selectors;
  selectors = info[0];
  if (!selectors.prepare())
    return;

  Element* result = impl->closest(selectors, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void closestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::closestMethod(info);
}

static void matchesMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "matches");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  V8StringResource<> selectors;
  selectors = info[0];
  if (!selectors.prepare())
    return;

  bool result = impl->matches(selectors, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueBool(info, result);
}

CORE_EXPORT  void matchesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::matchesMethod(info);
}

static void webkitMatchesSelectorMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "webkitMatchesSelector");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  V8StringResource<> selectors;
  selectors = info[0];
  if (!selectors.prepare())
    return;

  bool result = impl->matches(selectors, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueBool(info, result);
}

CORE_EXPORT  void webkitMatchesSelectorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::ElementPrefixedMatchesSelector);
  ElementV8Internal::webkitMatchesSelectorMethod(info);
}

static void attachShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "attachShadow");

  Element* impl = V8Element::toImpl(info.Holder());

  ScriptState* scriptState = ScriptState::forReceiverObject(info);

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  ShadowRootInit shadowRootInitDict;
  if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
    exceptionState.throwTypeError("parameter 1 ('shadowRootInitDict') is not an object.");

    return;
  }
  V8ShadowRootInit::toImpl(info.GetIsolate(), info[0], shadowRootInitDict, exceptionState);
  if (exceptionState.hadException())
    return;

  ShadowRoot* result = impl->attachShadow(scriptState, shadowRootInitDict, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void attachShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::ElementAttachShadow);
  ElementV8Internal::attachShadowMethod(info);
}

static void getElementsByTagNameMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getElementsByTagName", "Element", ExceptionMessages::notEnoughArguments(1, info.Length())));
    return;
  }

  V8StringResource<> localName;
  localName = info[0];
  if (!localName.prepare())
    return;

  v8SetReturnValueFast(info, impl->getElementsByTagName(localName), impl);
}

CORE_EXPORT  void getElementsByTagNameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getElementsByTagNameMethod(info);
}

static void getElementsByTagNameNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 2)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getElementsByTagNameNS", "Element", ExceptionMessages::notEnoughArguments(2, info.Length())));
    return;
  }

  V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
  V8StringResource<> localName;
  namespaceURI = info[0];
  if (!namespaceURI.prepare())
    return;

  localName = info[1];
  if (!localName.prepare())
    return;

  v8SetReturnValueFast(info, impl->getElementsByTagNameNS(namespaceURI, localName), impl);
}

CORE_EXPORT  void getElementsByTagNameNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getElementsByTagNameNSMethod(info);
}

static void getElementsByClassNameMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getElementsByClassName", "Element", ExceptionMessages::notEnoughArguments(1, info.Length())));
    return;
  }

  V8StringResource<> classNames;
  classNames = info[0];
  if (!classNames.prepare())
    return;

  v8SetReturnValueFast(info, impl->getElementsByClassName(classNames), impl);
}

CORE_EXPORT  void getElementsByClassNameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getElementsByClassNameMethod(info);
}

static void insertAdjacentElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "insertAdjacentElement");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 2)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
    return;
  }

  V8StringResource<> where;
  Element* element;
  where = info[0];
  if (!where.prepare())
    return;

  element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[1]);
  if (!element) {
    exceptionState.throwTypeError("parameter 2 is not of type 'Element'.");

    return;
  }

  Element* result = impl->insertAdjacentElement(where, element, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void insertAdjacentElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::insertAdjacentElementMethod(info);
}

static void insertAdjacentTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "insertAdjacentText");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 2)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
    return;
  }

  V8StringResource<> where;
  V8StringResource<> data;
  where = info[0];
  if (!where.prepare())
    return;

  data = info[1];
  if (!data.prepare())
    return;

  impl->insertAdjacentText(where, data, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void insertAdjacentTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::insertAdjacentTextMethod(info);
}

static void insertAdjacentHTMLMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "insertAdjacentHTML");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  if (UNLIKELY(info.Length() < 2)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
    return;
  }

  V8StringResource<> position;
  V8StringResource<> text;
  position = info[0];
  if (!position.prepare())
    return;

  text = info[1];
  if (!text.prepare())
    return;

  impl->insertAdjacentHTML(position, text, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void insertAdjacentHTMLMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::insertAdjacentHTMLMethod(info);
}

static void requestPointerLockMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  impl->requestPointerLock();
}

CORE_EXPORT  void requestPointerLockMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::ElementRequestPointerLock);
  ElementV8Internal::requestPointerLockMethod(info);
}

static void getClientRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  v8SetReturnValueFast(info, impl->getClientRects(), impl);
}

CORE_EXPORT  void getClientRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getClientRectsMethod(info);
}

static void getBoundingClientRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  v8SetReturnValueFast(info, impl->getBoundingClientRect(), impl);
}

CORE_EXPORT  void getBoundingClientRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getBoundingClientRectMethod(info);
}

static void scrollIntoViewMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollIntoView");

  Element* impl = V8Element::toImpl(info.Holder());

  bool alignWithTop;
  int numArgsPassed = info.Length();
  while (numArgsPassed > 0) {
    if (!info[numArgsPassed - 1]->IsUndefined())
      break;
    --numArgsPassed;
  }
  if (UNLIKELY(numArgsPassed <= 0)) {
    impl->scrollIntoView();
    return;
  }
  alignWithTop = toBoolean(info.GetIsolate(), info[0], exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollIntoView(alignWithTop);
}

CORE_EXPORT  void scrollIntoViewMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollIntoViewMethod(info);
}

static void scroll1Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scroll");

  Element* impl = V8Element::toImpl(info.Holder());

  ScrollToOptions options;
  if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
    exceptionState.throwTypeError("parameter 1 ('options') is not an object.");

    return;
  }
  V8ScrollToOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollTo(options);
}

static void scroll2Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scroll");

  Element* impl = V8Element::toImpl(info.Holder());

  double x;
  double y;
  x = toDouble(info.GetIsolate(), info[0], exceptionState);
  if (exceptionState.hadException())
    return;

  y = toDouble(info.GetIsolate(), info[1], exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollTo(x, y);
}

static void scrollMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  bool isArityError = false;
  switch (std::min(2, info.Length())) {
    case 0:
      if (true) {
        scroll1Method(info);
        return;
      }
      break;
    case 1:
      if (true) {
        scroll1Method(info);
        return;
      }
      break;
    case 2:
      if (true) {
        scroll2Method(info);
        return;
      }
      break;
    default:
      isArityError = true;
  }

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scroll");

  if (isArityError) {
  }
  exceptionState.throwTypeError("No function was found that matched the signature provided.");
}

CORE_EXPORT  void scrollMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollMethod(info);
}

static void scrollTo1Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollTo");

  Element* impl = V8Element::toImpl(info.Holder());

  ScrollToOptions options;
  if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
    exceptionState.throwTypeError("parameter 1 ('options') is not an object.");

    return;
  }
  V8ScrollToOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollTo(options);
}

static void scrollTo2Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollTo");

  Element* impl = V8Element::toImpl(info.Holder());

  double x;
  double y;
  x = toDouble(info.GetIsolate(), info[0], exceptionState);
  if (exceptionState.hadException())
    return;

  y = toDouble(info.GetIsolate(), info[1], exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollTo(x, y);
}

static void scrollToMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  bool isArityError = false;
  switch (std::min(2, info.Length())) {
    case 0:
      if (true) {
        scrollTo1Method(info);
        return;
      }
      break;
    case 1:
      if (true) {
        scrollTo1Method(info);
        return;
      }
      break;
    case 2:
      if (true) {
        scrollTo2Method(info);
        return;
      }
      break;
    default:
      isArityError = true;
  }

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollTo");

  if (isArityError) {
  }
  exceptionState.throwTypeError("No function was found that matched the signature provided.");
}

CORE_EXPORT  void scrollToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollToMethod(info);
}

static void scrollBy1Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollBy");

  Element* impl = V8Element::toImpl(info.Holder());

  ScrollToOptions options;
  if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
    exceptionState.throwTypeError("parameter 1 ('options') is not an object.");

    return;
  }
  V8ScrollToOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollBy(options);
}

static void scrollBy2Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollBy");

  Element* impl = V8Element::toImpl(info.Holder());

  double x;
  double y;
  x = toDouble(info.GetIsolate(), info[0], exceptionState);
  if (exceptionState.hadException())
    return;

  y = toDouble(info.GetIsolate(), info[1], exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollBy(x, y);
}

static void scrollByMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  bool isArityError = false;
  switch (std::min(2, info.Length())) {
    case 0:
      if (true) {
        scrollBy1Method(info);
        return;
      }
      break;
    case 1:
      if (true) {
        scrollBy1Method(info);
        return;
      }
      break;
    case 2:
      if (true) {
        scrollBy2Method(info);
        return;
      }
      break;
    default:
      isArityError = true;
  }

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollBy");

  if (isArityError) {
  }
  exceptionState.throwTypeError("No function was found that matched the signature provided.");
}

CORE_EXPORT  void scrollByMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::scrollByMethod(info);
}

static void setApplyScrollMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "setApplyScroll");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 2)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
    return;
  }

  ScrollStateCallback* scrollStateCallback;
  V8StringResource<> nativeScrollBehavior;
  if (info.Length() <= 0 || !info[0]->IsFunction()) {
    exceptionState.throwTypeError("The callback provided as parameter 1 is not a function.");

    return;
  }
  scrollStateCallback = V8ScrollStateCallback::create(v8::Local<v8::Function>::Cast(info[0]), ScriptState::current(info.GetIsolate()));

  nativeScrollBehavior = info[1];
  if (!nativeScrollBehavior.prepare())
    return;
  const char* validNativeScrollBehaviorValues[] = {
      "disable-native-scroll",
      "perform-before-native-scroll",
      "perform-after-native-scroll",
  };
  if (!isValidEnum(nativeScrollBehavior, validNativeScrollBehaviorValues, WTF_ARRAY_LENGTH(validNativeScrollBehaviorValues), "NativeScrollBehavior", exceptionState)) {
    return;
  }

  impl->setApplyScroll(scrollStateCallback, nativeScrollBehavior);
}

CORE_EXPORT  void setApplyScrollMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::setApplyScrollMethod(info);
}

static void setDistributeScrollMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "setDistributeScroll");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 2)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
    return;
  }

  ScrollStateCallback* scrollStateCallback;
  V8StringResource<> nativeScrollBehavior;
  if (info.Length() <= 0 || !info[0]->IsFunction()) {
    exceptionState.throwTypeError("The callback provided as parameter 1 is not a function.");

    return;
  }
  scrollStateCallback = V8ScrollStateCallback::create(v8::Local<v8::Function>::Cast(info[0]), ScriptState::current(info.GetIsolate()));

  nativeScrollBehavior = info[1];
  if (!nativeScrollBehavior.prepare())
    return;
  const char* validNativeScrollBehaviorValues[] = {
      "disable-native-scroll",
      "perform-before-native-scroll",
      "perform-after-native-scroll",
  };
  if (!isValidEnum(nativeScrollBehavior, validNativeScrollBehaviorValues, WTF_ARRAY_LENGTH(validNativeScrollBehaviorValues), "NativeScrollBehavior", exceptionState)) {
    return;
  }

  impl->setDistributeScroll(scrollStateCallback, nativeScrollBehavior);
}

CORE_EXPORT  void setDistributeScrollMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::setDistributeScrollMethod(info);
}

static void scrollIntoViewIfNeededMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "scrollIntoViewIfNeeded");

  Element* impl = V8Element::toImpl(info.Holder());

  bool centerIfNeeded;
  int numArgsPassed = info.Length();
  while (numArgsPassed > 0) {
    if (!info[numArgsPassed - 1]->IsUndefined())
      break;
    --numArgsPassed;
  }
  if (UNLIKELY(numArgsPassed <= 0)) {
    impl->scrollIntoViewIfNeeded();
    return;
  }
  centerIfNeeded = toBoolean(info.GetIsolate(), info[0], exceptionState);
  if (exceptionState.hadException())
    return;

  impl->scrollIntoViewIfNeeded(centerIfNeeded);
}

CORE_EXPORT  void scrollIntoViewIfNeededMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::ElementScrollIntoViewIfNeeded);
  ElementV8Internal::scrollIntoViewIfNeededMethod(info);
}

static void createShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "createShadowRoot");

  Element* impl = V8Element::toImpl(info.Holder());

  ScriptState* scriptState = ScriptState::forReceiverObject(info);

  ShadowRoot* result = impl->createShadowRoot(scriptState, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void createShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::ElementCreateShadowRoot);
  ElementV8Internal::createShadowRootMethod(info);
}

static void getDestinationInsertionPointsMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  v8SetReturnValueFast(info, impl->getDestinationInsertionPoints(), impl);
}

CORE_EXPORT  void getDestinationInsertionPointsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getDestinationInsertionPointsMethod(info);
}

static void animate1Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "animate");

  Element* impl = V8Element::toImpl(info.Holder());

  ScriptState* scriptState = ScriptState::forReceiverObject(info);

  DictionarySequenceOrDictionary effect;
  double timing;
  int numArgsPassed = info.Length();
  while (numArgsPassed > 0) {
    if (!info[numArgsPassed - 1]->IsUndefined())
      break;
    --numArgsPassed;
  }
  V8DictionarySequenceOrDictionary::toImpl(info.GetIsolate(), info[0], effect, UnionTypeConversionMode::Nullable, exceptionState);
  if (exceptionState.hadException())
    return;

  if (UNLIKELY(numArgsPassed <= 1)) {
    Animation* result = ElementAnimation::animate(scriptState, *impl, effect, exceptionState);
    if (exceptionState.hadException()) {
      return;
    }
    v8SetReturnValueFast(info, result, impl);
    return;
  }
  timing = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
  if (exceptionState.hadException())
    return;

  Animation* result = ElementAnimation::animate(scriptState, *impl, effect, timing, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

static void animate2Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "animate");

  Element* impl = V8Element::toImpl(info.Holder());

  ScriptState* scriptState = ScriptState::forReceiverObject(info);

  DictionarySequenceOrDictionary effect;
  KeyframeEffectOptions timing;
  V8DictionarySequenceOrDictionary::toImpl(info.GetIsolate(), info[0], effect, UnionTypeConversionMode::Nullable, exceptionState);
  if (exceptionState.hadException())
    return;

  if (!isUndefinedOrNull(info[1]) && !info[1]->IsObject()) {
    exceptionState.throwTypeError("parameter 2 ('timing') is not an object.");

    return;
  }
  V8KeyframeEffectOptions::toImpl(info.GetIsolate(), info[1], timing, exceptionState);
  if (exceptionState.hadException())
    return;

  Animation* result = ElementAnimation::animate(scriptState, *impl, effect, timing, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

static void animateMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  bool isArityError = false;
  switch (std::min(2, info.Length())) {
    case 1:
      if (true) {
        UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
        animate1Method(info);
        return;
      }
      break;
    case 2:
      if (info[1]->IsUndefined()) {
        UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
        animate1Method(info);
        return;
      }
      if (info[1]->IsObject()) {
        UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
        animate2Method(info);
        return;
      }
      if (true) {
        UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
        animate1Method(info);
        return;
      }
      break;
    default:
      isArityError = true;
  }

  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "animate");

  if (isArityError) {
    if (info.Length() < 1) {
      exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
      return;
    }
  }
  exceptionState.throwTypeError("No function was found that matched the signature provided.");
}

CORE_EXPORT  void animateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::animateMethod(info);
}

static void getAnimationsMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  v8SetReturnValue(info, ToV8(ElementAnimation::getAnimations(*impl), info.Holder(), info.GetIsolate()));
}

CORE_EXPORT  void getAnimationsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::getAnimationsMethod(info);
}

static void beforeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "before");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  HeapVector<NodeOrString> nodes;
  nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
  if (exceptionState.hadException())
    return;

  ChildNode::before(*impl, nodes, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void beforeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::beforeMethod(info);
}

static void afterMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "after");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  HeapVector<NodeOrString> nodes;
  nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
  if (exceptionState.hadException())
    return;

  ChildNode::after(*impl, nodes, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void afterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::afterMethod(info);
}

static void replaceWithMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "replaceWith");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  HeapVector<NodeOrString> nodes;
  nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
  if (exceptionState.hadException())
    return;

  ChildNode::replaceWith(*impl, nodes, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void replaceWithMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::replaceWithMethod(info);
}

static void removeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "remove");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  ChildNode::remove(*impl, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void removeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::removeMethod(info);
}

static void requestFullscreenMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  ElementFullscreen::requestFullscreen(*impl);
}

CORE_EXPORT  void requestFullscreenMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::requestFullscreenMethod(info);
}

static void webkitRequestFullScreenMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  ElementFullscreen::webkitRequestFullscreen(*impl);
}

CORE_EXPORT  void webkitRequestFullScreenMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::PrefixedElementRequestFullScreen);
  ScriptState* scriptState = ScriptState::forReceiverObject(info);
  V8PerContextData* contextData = scriptState->perContextData();
  if (contextData && contextData->activityLogger()) {
    ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "webkitRequestFullScreen");
    Vector<v8::Local<v8::Value>> loggerArgs = toImplArguments<Vector<v8::Local<v8::Value>>>(info, 0, exceptionState);
    contextData->activityLogger()->logMethod("Element.webkitRequestFullScreen", info.Length(), loggerArgs.data());
  }
  ElementV8Internal::webkitRequestFullScreenMethod(info);
}

static void webkitRequestFullscreenMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Element* impl = V8Element::toImpl(info.Holder());

  ElementFullscreen::webkitRequestFullscreen(*impl);
}

CORE_EXPORT  void webkitRequestFullscreenMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  UseCounter::count(currentExecutionContext(info.GetIsolate()), UseCounter::PrefixedElementRequestFullscreen);
  ScriptState* scriptState = ScriptState::forReceiverObject(info);
  V8PerContextData* contextData = scriptState->perContextData();
  if (contextData && contextData->activityLogger()) {
    ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "webkitRequestFullscreen");
    Vector<v8::Local<v8::Value>> loggerArgs = toImplArguments<Vector<v8::Local<v8::Value>>>(info, 0, exceptionState);
    contextData->activityLogger()->logMethod("Element.webkitRequestFullscreen", info.Length(), loggerArgs.data());
  }
  ElementV8Internal::webkitRequestFullscreenMethod(info);
}

static void prependMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "prepend");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  HeapVector<NodeOrString> nodes;
  nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
  if (exceptionState.hadException())
    return;

  ParentNode::prepend(*impl, nodes, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void prependMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::prependMethod(info);
}

static void appendMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "append");

  Element* impl = V8Element::toImpl(info.Holder());

  V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;

  HeapVector<NodeOrString> nodes;
  nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
  if (exceptionState.hadException())
    return;

  ParentNode::append(*impl, nodes, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
}

CORE_EXPORT  void appendMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  CEReactionsScope ceReactionsScope;
  ElementV8Internal::appendMethod(info);
}

static void querySelectorMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "querySelector");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  V8StringResource<> selectors;
  selectors = info[0];
  if (!selectors.prepare())
    return;

  Element* result = ParentNode::querySelector(*impl, selectors, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void querySelectorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::querySelectorMethod(info);
}

static void querySelectorAllMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Element", "querySelectorAll");

  Element* impl = V8Element::toImpl(info.Holder());

  if (UNLIKELY(info.Length() < 1)) {
    exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
    return;
  }

  V8StringResource<> selectors;
  selectors = info[0];
  if (!selectors.prepare())
    return;

  NodeList* result = ParentNode::querySelectorAll(*impl, selectors, exceptionState);
  if (exceptionState.hadException()) {
    return;
  }
  // [NewObject] must always create a new wrapper.  Check that a wrapper
  // does not exist yet.
  DCHECK(!result || DOMDataStore::getWrapper(result, info.GetIsolate()).IsEmpty());
  v8SetReturnValueFast(info, result, impl);
}

CORE_EXPORT  void querySelectorAllMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  ElementV8Internal::querySelectorAllMethod(info);
}

} // namespace ElementV8Internal

const V8DOMConfiguration::AccessorConfiguration V8ElementAccessors[] = {
    {"namespaceURI", ElementV8Internal::namespaceURIAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"prefix", ElementV8Internal::prefixAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"localName", ElementV8Internal::localNameAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"tagName", ElementV8Internal::tagNameAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"id", ElementV8Internal::idAttributeGetterCallback, ElementV8Internal::idAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"className", ElementV8Internal::classNameAttributeGetterCallback, ElementV8Internal::classNameAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"classList", ElementV8Internal::classListAttributeGetterCallback, ElementV8Internal::classListAttributeSetterCallback, ElementV8Internal::classListAttributeGetterCallbackForMainWorld, ElementV8Internal::classListAttributeSetterCallbackForMainWorld, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"slot", ElementV8Internal::slotAttributeGetterCallback, ElementV8Internal::slotAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"attributes", ElementV8Internal::attributesAttributeGetterCallback, 0, ElementV8Internal::attributesAttributeGetterCallbackForMainWorld, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"shadowRoot", ElementV8Internal::shadowRootAttributeGetterCallback, 0, ElementV8Internal::shadowRootAttributeGetterCallbackForMainWorld, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"assignedSlot", ElementV8Internal::assignedSlotAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"innerHTML", ElementV8Internal::innerHTMLAttributeGetterCallback, ElementV8Internal::innerHTMLAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"outerHTML", ElementV8Internal::outerHTMLAttributeGetterCallback, ElementV8Internal::outerHTMLAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollTop", ElementV8Internal::scrollTopAttributeGetterCallback, ElementV8Internal::scrollTopAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollLeft", ElementV8Internal::scrollLeftAttributeGetterCallback, ElementV8Internal::scrollLeftAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollWidth", ElementV8Internal::scrollWidthAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollHeight", ElementV8Internal::scrollHeightAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientTop", ElementV8Internal::clientTopAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientLeft", ElementV8Internal::clientLeftAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientWidth", ElementV8Internal::clientWidthAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientHeight", ElementV8Internal::clientHeightAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onbeforecopy", ElementV8Internal::onbeforecopyAttributeGetterCallback, ElementV8Internal::onbeforecopyAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onbeforecut", ElementV8Internal::onbeforecutAttributeGetterCallback, ElementV8Internal::onbeforecutAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onbeforepaste", ElementV8Internal::onbeforepasteAttributeGetterCallback, ElementV8Internal::onbeforepasteAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"oncopy", ElementV8Internal::oncopyAttributeGetterCallback, ElementV8Internal::oncopyAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"oncut", ElementV8Internal::oncutAttributeGetterCallback, ElementV8Internal::oncutAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onpaste", ElementV8Internal::onpasteAttributeGetterCallback, ElementV8Internal::onpasteAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onsearch", ElementV8Internal::onsearchAttributeGetterCallback, ElementV8Internal::onsearchAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onselectstart", ElementV8Internal::onselectstartAttributeGetterCallback, ElementV8Internal::onselectstartAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onwheel", ElementV8Internal::onwheelAttributeGetterCallback, ElementV8Internal::onwheelAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onwebkitfullscreenchange", ElementV8Internal::onwebkitfullscreenchangeAttributeGetterCallback, ElementV8Internal::onwebkitfullscreenchangeAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onwebkitfullscreenerror", ElementV8Internal::onwebkitfullscreenerrorAttributeGetterCallback, ElementV8Internal::onwebkitfullscreenerrorAttributeSetterCallback, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"previousElementSibling", ElementV8Internal::previousElementSiblingAttributeGetterCallback, 0, ElementV8Internal::previousElementSiblingAttributeGetterCallbackForMainWorld, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"nextElementSibling", ElementV8Internal::nextElementSiblingAttributeGetterCallback, 0, ElementV8Internal::nextElementSiblingAttributeGetterCallbackForMainWorld, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"children", ElementV8Internal::childrenAttributeGetterCallback, 0, ElementV8Internal::childrenAttributeGetterCallbackForMainWorld, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"firstElementChild", ElementV8Internal::firstElementChildAttributeGetterCallback, 0, ElementV8Internal::firstElementChildAttributeGetterCallbackForMainWorld, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"lastElementChild", ElementV8Internal::lastElementChildAttributeGetterCallback, 0, ElementV8Internal::lastElementChildAttributeGetterCallbackForMainWorld, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"childElementCount", ElementV8Internal::childElementCountAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
};

const V8DOMConfiguration::MethodConfiguration V8ElementMethods[] = {
    {"hasAttributes", ElementV8Internal::hasAttributesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getAttribute", ElementV8Internal::getAttributeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getAttributeNS", ElementV8Internal::getAttributeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"setAttribute", ElementV8Internal::setAttributeMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"setAttributeNS", ElementV8Internal::setAttributeNSMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"removeAttribute", ElementV8Internal::removeAttributeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"removeAttributeNS", ElementV8Internal::removeAttributeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"hasAttribute", ElementV8Internal::hasAttributeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"hasAttributeNS", ElementV8Internal::hasAttributeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getAttributeNode", ElementV8Internal::getAttributeNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getAttributeNodeNS", ElementV8Internal::getAttributeNodeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"setAttributeNode", ElementV8Internal::setAttributeNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"setAttributeNodeNS", ElementV8Internal::setAttributeNodeNSMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"removeAttributeNode", ElementV8Internal::removeAttributeNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"closest", ElementV8Internal::closestMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"matches", ElementV8Internal::matchesMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"webkitMatchesSelector", ElementV8Internal::webkitMatchesSelectorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"attachShadow", ElementV8Internal::attachShadowMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getElementsByTagName", ElementV8Internal::getElementsByTagNameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getElementsByTagNameNS", ElementV8Internal::getElementsByTagNameNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getElementsByClassName", ElementV8Internal::getElementsByClassNameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"insertAdjacentElement", ElementV8Internal::insertAdjacentElementMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"insertAdjacentText", ElementV8Internal::insertAdjacentTextMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"insertAdjacentHTML", ElementV8Internal::insertAdjacentHTMLMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"requestPointerLock", ElementV8Internal::requestPointerLockMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getClientRects", ElementV8Internal::getClientRectsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getBoundingClientRect", ElementV8Internal::getBoundingClientRectMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollIntoView", ElementV8Internal::scrollIntoViewMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollIntoViewIfNeeded", ElementV8Internal::scrollIntoViewIfNeededMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"createShadowRoot", ElementV8Internal::createShadowRootMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"getDestinationInsertionPoints", ElementV8Internal::getDestinationInsertionPointsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"animate", ElementV8Internal::animateMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"remove", ElementV8Internal::removeMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"webkitRequestFullScreen", ElementV8Internal::webkitRequestFullScreenMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"webkitRequestFullscreen", ElementV8Internal::webkitRequestFullscreenMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"querySelector", ElementV8Internal::querySelectorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"querySelectorAll", ElementV8Internal::querySelectorAllMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
};

static void installV8ElementTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::FunctionTemplate> interfaceTemplate) {
  // Initialize the interface object's template.
  V8DOMConfiguration::initializeDOMInterfaceTemplate(isolate, interfaceTemplate, V8Element::wrapperTypeInfo.interfaceName, V8Node::domTemplate(isolate, world), V8Element::internalFieldCount);

  v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interfaceTemplate);
  ALLOW_UNUSED_LOCAL(signature);
  v8::Local<v8::ObjectTemplate> instanceTemplate = interfaceTemplate->InstanceTemplate();
  ALLOW_UNUSED_LOCAL(instanceTemplate);
  v8::Local<v8::ObjectTemplate> prototypeTemplate = interfaceTemplate->PrototypeTemplate();
  ALLOW_UNUSED_LOCAL(prototypeTemplate);

  // Register DOM constants, attributes and operations.
  V8DOMConfiguration::installAccessors(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8ElementAccessors, WTF_ARRAY_LENGTH(V8ElementAccessors));
  V8DOMConfiguration::installMethods(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8ElementMethods, WTF_ARRAY_LENGTH(V8ElementMethods));

  if (RuntimeEnabledFeatures::computedAccessibilityInfoEnabled()) {
    const V8DOMConfiguration::AccessorConfiguration accessorcomputedNameConfiguration = {"computedName", ElementV8Internal::computedNameAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessorcomputedNameConfiguration);
    const V8DOMConfiguration::AccessorConfiguration accessorcomputedRoleConfiguration = {"computedRole", ElementV8Internal::computedRoleAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessorcomputedRoleConfiguration);
  }

  if (RuntimeEnabledFeatures::pointerEventEnabled()) {
    const V8DOMConfiguration::MethodConfiguration setPointerCaptureMethodConfiguration = {"setPointerCapture", ElementV8Internal::setPointerCaptureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, setPointerCaptureMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::pointerEventEnabled()) {
    const V8DOMConfiguration::MethodConfiguration releasePointerCaptureMethodConfiguration = {"releasePointerCapture", ElementV8Internal::releasePointerCaptureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, releasePointerCaptureMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::pointerEventEnabled()) {
    const V8DOMConfiguration::MethodConfiguration hasPointerCaptureMethodConfiguration = {"hasPointerCapture", ElementV8Internal::hasPointerCaptureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, hasPointerCaptureMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::cssomSmoothScrollEnabled()) {
    const V8DOMConfiguration::MethodConfiguration scrollMethodConfiguration = {"scroll", ElementV8Internal::scrollMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, scrollMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::cssomSmoothScrollEnabled()) {
    const V8DOMConfiguration::MethodConfiguration scrollToMethodConfiguration = {"scrollTo", ElementV8Internal::scrollToMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, scrollToMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::cssomSmoothScrollEnabled()) {
    const V8DOMConfiguration::MethodConfiguration scrollByMethodConfiguration = {"scrollBy", ElementV8Internal::scrollByMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, scrollByMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::scrollCustomizationEnabled()) {
    const V8DOMConfiguration::MethodConfiguration setApplyScrollMethodConfiguration = {"setApplyScroll", ElementV8Internal::setApplyScrollMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, setApplyScrollMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::scrollCustomizationEnabled()) {
    const V8DOMConfiguration::MethodConfiguration setDistributeScrollMethodConfiguration = {"setDistributeScroll", ElementV8Internal::setDistributeScrollMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, setDistributeScrollMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::webAnimationsAPIEnabled()) {
    const V8DOMConfiguration::MethodConfiguration getAnimationsMethodConfiguration = {"getAnimations", ElementV8Internal::getAnimationsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, getAnimationsMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    const V8DOMConfiguration::MethodConfiguration beforeMethodConfiguration = {"before", ElementV8Internal::beforeMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, beforeMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    const V8DOMConfiguration::MethodConfiguration afterMethodConfiguration = {"after", ElementV8Internal::afterMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, afterMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    const V8DOMConfiguration::MethodConfiguration replaceWithMethodConfiguration = {"replaceWith", ElementV8Internal::replaceWithMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, replaceWithMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::fullscreenUnprefixedEnabled()) {
    const V8DOMConfiguration::MethodConfiguration requestFullscreenMethodConfiguration = {"requestFullscreen", ElementV8Internal::requestFullscreenMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, requestFullscreenMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    const V8DOMConfiguration::MethodConfiguration prependMethodConfiguration = {"prepend", ElementV8Internal::prependMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, prependMethodConfiguration);
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    const V8DOMConfiguration::MethodConfiguration appendMethodConfiguration = {"append", ElementV8Internal::appendMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
    V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, appendMethodConfiguration);
  }
}

v8::Local<v8::FunctionTemplate> V8Element::domTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world) {
  return V8DOMConfiguration::domClassTemplate(isolate, world, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), installV8ElementTemplate);
}

bool V8Element::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate) {
  return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8Element::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate) {
  return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

Element* V8Element::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value) {
  return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : nullptr;
}

void V8Element::preparePrototypeAndInterfaceObject(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> prototypeObject, v8::Local<v8::Function> interfaceObject, v8::Local<v8::FunctionTemplate> interfaceTemplate) {
  v8::Isolate* isolate = context->GetIsolate();
  v8::Local<v8::Name> unscopablesSymbol(v8::Symbol::GetUnscopables(isolate));
  v8::Local<v8::Object> unscopables;
  if (v8CallBoolean(prototypeObject->HasOwnProperty(context, unscopablesSymbol)))
    unscopables = prototypeObject->Get(context, unscopablesSymbol).ToLocalChecked().As<v8::Object>();
  else
    unscopables = v8::Object::New(isolate);
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    unscopables->CreateDataProperty(context, v8AtomicString(isolate, "after"), v8::True(isolate)).FromJust();
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    unscopables->CreateDataProperty(context, v8AtomicString(isolate, "append"), v8::True(isolate)).FromJust();
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    unscopables->CreateDataProperty(context, v8AtomicString(isolate, "before"), v8::True(isolate)).FromJust();
  }
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    unscopables->CreateDataProperty(context, v8AtomicString(isolate, "prepend"), v8::True(isolate)).FromJust();
  }
  unscopables->CreateDataProperty(context, v8AtomicString(isolate, "remove"), v8::True(isolate)).FromJust();
  if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
    unscopables->CreateDataProperty(context, v8AtomicString(isolate, "replaceWith"), v8::True(isolate)).FromJust();
  }
  unscopables->CreateDataProperty(context, v8AtomicString(isolate, "slot"), v8::True(isolate)).FromJust();
  prototypeObject->CreateDataProperty(context, unscopablesSymbol, unscopables).FromJust();
}

}  // namespace blink
