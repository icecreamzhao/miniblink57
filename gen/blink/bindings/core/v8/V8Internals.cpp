// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/interface.cpp.tmpl

// clang-format on
#include "V8Internals.h"

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/GeneratedCodeHelper.h"
#include "bindings/core/v8/ScriptPromise.h"
#include "bindings/core/v8/ScriptState.h"
#include "bindings/core/v8/ScriptValue.h"
#include "bindings/core/v8/SerializedScriptValue.h"
#include "bindings/core/v8/SerializedScriptValueFactory.h"
#include "bindings/core/v8/V8Animation.h"
#include "bindings/core/v8/V8ArrayBuffer.h"
#include "bindings/core/v8/V8CSSStyleDeclaration.h"
#include "bindings/core/v8/V8CallbackFunctionTest.h"
#include "bindings/core/v8/V8ClientRect.h"
#include "bindings/core/v8/V8ClientRectList.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8DOMPoint.h"
#include "bindings/core/v8/V8DictionaryTest.h"
#include "bindings/core/v8/V8Document.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8GCObservation.h"
#include "bindings/core/v8/V8HTMLInputElement.h"
#include "bindings/core/v8/V8HTMLMediaElement.h"
#include "bindings/core/v8/V8HTMLSelectElement.h"
#include "bindings/core/v8/V8HiddenValue.h"
#include "bindings/core/v8/V8InternalRuntimeFlags.h"
#include "bindings/core/v8/V8InternalSettings.h"
#include "bindings/core/v8/V8Iterator.h"
#include "bindings/core/v8/V8LayerRectList.h"
#include "bindings/core/v8/V8Location.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "bindings/core/v8/V8OriginTrialsTest.h"
#include "bindings/core/v8/V8Range.h"
#include "bindings/core/v8/V8ScrollState.h"
#include "bindings/core/v8/V8ShadowRoot.h"
#include "bindings/core/v8/V8TypeConversions.h"
#include "bindings/core/v8/V8UnionTypesTest.h"
#include "bindings/core/v8/V8Window.h"
#include "bindings/modules/v8/V8CanvasRenderingContext2D.h"
#include "core/dom/Document.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/StaticNodeList.h"
#include "core/html/LabelsNodeList.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
WrapperTypeInfo V8Internals::wrapperTypeInfo = { gin::kEmbedderBlink, V8Internals::domTemplate, V8Internals::trace, V8Internals::traceWrappers, 0, V8Internals::preparePrototypeAndInterfaceObject, "Internals", 0, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::ObjectClassId, WrapperTypeInfo::NotInheritFromActiveScriptWrappable, WrapperTypeInfo::NotInheritFromEventTarget, WrapperTypeInfo::Independent };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in Internals.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& Internals::s_wrapperTypeInfo = V8Internals::wrapperTypeInfo;

// not [ActiveScriptWrappable]
static_assert(
    !std::is_base_of<ActiveScriptWrappableBase, Internals>::value,
    "Internals inherits from ActiveScriptWrappable<>, but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");
static_assert(
    std::is_same<decltype(&Internals::hasPendingActivity),
        decltype(&ScriptWrappable::hasPendingActivity)>::value,
    "Internals is overriding hasPendingActivity(), but is not specifying "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");

namespace InternalsV8Internal {

    static void pagePopupWindowAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        Internals* impl = V8Internals::toImpl(holder);

        v8SetReturnValueFast(info, WTF::getPtr(impl->pagePopupWindow()), impl);
    }

    void pagePopupWindowAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::pagePopupWindowAttributeGetter(info);
    }

    static void settingsAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        Internals* impl = V8Internals::toImpl(holder);

        InternalSettings* cppValue(WTF::getPtr(impl->settings()));

        // Keep the wrapper object for the return value alive as long as |this|
        // object is alive in order to save creation time of the wrapper object.
        if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue))
            return;
        v8::Local<v8::Value> v8Value(ToV8(cppValue, holder, info.GetIsolate()));
        const char kKeepAliveKey[] = "KeepAlive#Internals#settings";
        V8HiddenValue::setHiddenValue(ScriptState::current(info.GetIsolate()), holder, v8AtomicString(info.GetIsolate(), StringView(kKeepAliveKey, sizeof kKeepAliveKey)), v8Value);

        v8SetReturnValue(info, v8Value);
    }

    void settingsAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::settingsAttributeGetter(info);
    }

    static void runtimeFlagsAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        Internals* impl = V8Internals::toImpl(holder);

        InternalRuntimeFlags* cppValue(WTF::getPtr(impl->runtimeFlags()));

        // Keep the wrapper object for the return value alive as long as |this|
        // object is alive in order to save creation time of the wrapper object.
        if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue))
            return;
        v8::Local<v8::Value> v8Value(ToV8(cppValue, holder, info.GetIsolate()));
        const char kKeepAliveKey[] = "KeepAlive#Internals#runtimeFlags";
        V8HiddenValue::setHiddenValue(ScriptState::current(info.GetIsolate()), holder, v8AtomicString(info.GetIsolate(), StringView(kKeepAliveKey, sizeof kKeepAliveKey)), v8Value);

        v8SetReturnValue(info, v8Value);
    }

    void runtimeFlagsAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::runtimeFlagsAttributeGetter(info);
    }

    static void workerThreadCountAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        Internals* impl = V8Internals::toImpl(holder);

        v8SetReturnValueUnsigned(info, impl->workerThreadCount());
    }

    void workerThreadCountAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::workerThreadCountAttributeGetter(info);
    }

    static void cursorUpdatePendingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        Internals* impl = V8Internals::toImpl(holder);

        v8SetReturnValueBool(info, impl->cursorUpdatePending());
    }

    void cursorUpdatePendingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::cursorUpdatePendingAttributeGetter(info);
    }

    static void unscopableAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        v8::Local<v8::Object> holder = info.Holder();

        Internals* impl = V8Internals::toImpl(holder);

        v8SetReturnValueString(info, impl->unscopableAttribute(), info.GetIsolate());
    }

    void unscopableAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::unscopableAttributeAttributeGetter(info);
    }

    static void addressMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("address", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("address", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValueString(info, impl->address(node), info.GetIsolate());
    }

    void addressMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::addressMethod(info);
    }

    static void observeGCMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("observeGC", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        ScriptValue observed;
        observed = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);

        v8SetReturnValue(info, impl->observeGC(observed));
    }

    void observeGCMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::observeGCMethod(info);
    }

    static void elementLayoutTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "elementLayoutTreeAsText");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        String result = impl->elementLayoutTreeAsText(element, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void elementLayoutTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::elementLayoutTreeAsTextMethod(info);
    }

    static void isPreloadedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isPreloaded", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> url;
        url = info[0];
        if (!url.prepare())
            return;

        v8SetReturnValueBool(info, impl->isPreloaded(url));
    }

    void isPreloadedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isPreloadedMethod(info);
    }

    static void isPreloadedByMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isPreloadedBy", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        V8StringResource<> url;
        Document* document;
        url = info[0];
        if (!url.prepare())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isPreloadedBy", "Internals", "parameter 2 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isPreloadedBy(url, document));
    }

    void isPreloadedByMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isPreloadedByMethod(info);
    }

    static void isLoadingMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isLoading", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> url;
        url = info[0];
        if (!url.prepare())
            return;

        v8SetReturnValueBool(info, impl->isLoading(url));
    }

    void isLoadingMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isLoadingMethod(info);
    }

    static void isLoadingFromMemoryCacheMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isLoadingFromMemoryCache", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> url;
        url = info[0];
        if (!url.prepare())
            return;

        v8SetReturnValueBool(info, impl->isLoadingFromMemoryCache(url));
    }

    void isLoadingFromMemoryCacheMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isLoadingFromMemoryCacheMethod(info);
    }

    static void getResourcePriorityMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getResourcePriority", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        V8StringResource<> url;
        Document* document;
        url = info[0];
        if (!url.prepare())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getResourcePriority", "Internals", "parameter 2 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->getResourcePriority(url, document));
    }

    void getResourcePriorityMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::getResourcePriorityMethod(info);
    }

    static void getResourceHeaderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getResourceHeader", "Internals", ExceptionMessages::notEnoughArguments(3, info.Length())));
            return;
        }

        V8StringResource<> url;
        V8StringResource<> header;
        Document* document;
        url = info[0];
        if (!url.prepare())
            return;

        header = info[1];
        if (!header.prepare())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[2]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getResourceHeader", "Internals", "parameter 3 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueString(info, impl->getResourceHeader(url, header, document), info.GetIsolate());
    }

    void getResourceHeaderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::getResourceHeaderMethod(info);
    }

    static void isSharingStyleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSharingStyle", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        Element* element1;
        Element* element2;
        element1 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element1) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSharingStyle", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        element2 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!element2) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSharingStyle", "Internals", "parameter 2 is not of type 'Element'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isSharingStyle(element1, element2));
    }

    void isSharingStyleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isSharingStyleMethod(info);
    }

    static void computedStyleIncludingVisitedInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("computedStyleIncludingVisitedInfo", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("computedStyleIncludingVisitedInfo", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValue(info, impl->computedStyleIncludingVisitedInfo(node));
    }

    void computedStyleIncludingVisitedInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::computedStyleIncludingVisitedInfoMethod(info);
    }

    static void createUserAgentShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("createUserAgentShadowRoot", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* host;
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("createUserAgentShadowRoot", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValue(info, impl->createUserAgentShadowRoot(host));
    }

    void createUserAgentShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::createUserAgentShadowRootMethod(info);
    }

    static void shadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shadowRoot", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* host;
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shadowRoot", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValue(info, impl->shadowRoot(host));
    }

    void shadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::shadowRootMethod(info);
    }

    static void youngestShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("youngestShadowRoot", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* host;
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("youngestShadowRoot", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValue(info, impl->youngestShadowRoot(host));
    }

    void youngestShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::youngestShadowRootMethod(info);
    }

    static void oldestShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("oldestShadowRoot", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* host;
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("oldestShadowRoot", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValue(info, impl->oldestShadowRoot(host));
    }

    void oldestShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::oldestShadowRootMethod(info);
    }

    static void youngerShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "youngerShadowRoot");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* root;
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        ShadowRoot* result = impl->youngerShadowRoot(root, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void youngerShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::youngerShadowRootMethod(info);
    }

    static void shadowRootTypeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "shadowRootType");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* root;
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        String result = impl->shadowRootType(root, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void shadowRootTypeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::shadowRootTypeMethod(info);
    }

    static void hasShadowInsertionPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hasShadowInsertionPoint");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* root;
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        bool result = impl->hasShadowInsertionPoint(root, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void hasShadowInsertionPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasShadowInsertionPointMethod(info);
    }

    static void hasContentElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hasContentElement");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* root;
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        bool result = impl->hasContentElement(root, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void hasContentElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasContentElementMethod(info);
    }

    static void countElementShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "countElementShadow");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* Root;
        Root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!Root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        unsigned result = impl->countElementShadow(Root, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueUnsigned(info, result);
    }

    void countElementShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::countElementShadowMethod(info);
    }

    static void shadowPseudoIdMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shadowPseudoId", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shadowPseudoId", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValueString(info, impl->shadowPseudoId(element), info.GetIsolate());
    }

    void shadowPseudoIdMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::shadowPseudoIdMethod(info);
    }

    static void isValidContentSelectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "isValidContentSelect");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Element* contentElement;
        contentElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!contentElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        bool result = impl->isValidContentSelect(contentElement, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void isValidContentSelectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isValidContentSelectMethod(info);
    }

    static void treeScopeRootNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("treeScopeRootNode", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("treeScopeRootNode", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValue(info, impl->treeScopeRootNode(node));
    }

    void treeScopeRootNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::treeScopeRootNodeMethod(info);
    }

    static void parentTreeScopeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("parentTreeScope", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("parentTreeScope", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValue(info, impl->parentTreeScope(node));
    }

    void parentTreeScopeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::parentTreeScopeMethod(info);
    }

    static void hasSelectorForIdInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hasSelectorForIdInShadow");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* host;
        V8StringResource<> id;
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        id = info[1];
        if (!id.prepare())
            return;

        bool result = impl->hasSelectorForIdInShadow(host, id, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void hasSelectorForIdInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasSelectorForIdInShadowMethod(info);
    }

    static void hasSelectorForClassInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hasSelectorForClassInShadow");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* host;
        V8StringResource<> className;
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        className = info[1];
        if (!className.prepare())
            return;

        bool result = impl->hasSelectorForClassInShadow(host, className, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void hasSelectorForClassInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasSelectorForClassInShadowMethod(info);
    }

    static void hasSelectorForAttributeInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hasSelectorForAttributeInShadow");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* host;
        V8StringResource<> attributeName;
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        attributeName = info[1];
        if (!attributeName.prepare())
            return;

        bool result = impl->hasSelectorForAttributeInShadow(host, attributeName, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void hasSelectorForAttributeInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasSelectorForAttributeInShadowMethod(info);
    }

    static void compareTreeScopePositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "compareTreeScopePosition");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Node* treeScope1;
        Node* treeScope2;
        treeScope1 = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!treeScope1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        treeScope2 = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!treeScope2) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Node'.");

            return;
        }

        unsigned result = impl->compareTreeScopePosition(treeScope1, treeScope2, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueUnsigned(info, result);
    }

    void compareTreeScopePositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::compareTreeScopePositionMethod(info);
    }

    static void updateStyleAndReturnAffectedElementCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "updateStyleAndReturnAffectedElementCount");

        Internals* impl = V8Internals::toImpl(info.Holder());

        unsigned result = impl->updateStyleAndReturnAffectedElementCount(exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueUnsigned(info, result);
    }

    void updateStyleAndReturnAffectedElementCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::updateStyleAndReturnAffectedElementCountMethod(info);
    }

    static void needsLayoutCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "needsLayoutCount");

        Internals* impl = V8Internals::toImpl(info.Holder());

        unsigned result = impl->needsLayoutCount(exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueUnsigned(info, result);
    }

    void needsLayoutCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::needsLayoutCountMethod(info);
    }

    static void hitTestCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hitTestCount");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        unsigned result = impl->hitTestCount(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueUnsigned(info, result);
    }

    void hitTestCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hitTestCountMethod(info);
    }

    static void hitTestCacheHitsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hitTestCacheHits");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        unsigned result = impl->hitTestCacheHits(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueUnsigned(info, result);
    }

    void hitTestCacheHitsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hitTestCacheHitsMethod(info);
    }

    static void elementFromPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "elementFromPoint");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        Document* document;
        double x;
        double y;
        bool ignoreClipping;
        bool allowChildFrameContent;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        x = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toRestrictedDouble(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        ignoreClipping = toBoolean(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        allowChildFrameContent = toBoolean(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.hadException())
            return;

        Element* result = impl->elementFromPoint(document, x, y, ignoreClipping, allowChildFrameContent, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void elementFromPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::elementFromPointMethod(info);
    }

    static void clearHitTestCacheMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "clearHitTestCache");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        impl->clearHitTestCache(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void clearHitTestCacheMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::clearHitTestCacheMethod(info);
    }

    static void pauseAnimationsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "pauseAnimations");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        double pauseTime;
        pauseTime = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->pauseAnimations(pauseTime, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void pauseAnimationsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::pauseAnimationsMethod(info);
    }

    static void isCompositedAnimationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isCompositedAnimation", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Animation* animation;
        animation = V8Animation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!animation) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isCompositedAnimation", "Internals", "parameter 1 is not of type 'Animation'."));

            return;
        }

        v8SetReturnValue(info, impl->isCompositedAnimation(animation));
    }

    void isCompositedAnimationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isCompositedAnimationMethod(info);
    }

    static void disableCompositedAnimationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("disableCompositedAnimation", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Animation* animation;
        animation = V8Animation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!animation) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("disableCompositedAnimation", "Internals", "parameter 1 is not of type 'Animation'."));

            return;
        }

        impl->disableCompositedAnimation(animation);
    }

    void disableCompositedAnimationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::disableCompositedAnimationMethod(info);
    }

    static void disableCSSAdditiveAnimationsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        impl->disableCSSAdditiveAnimations();
    }

    void disableCSSAdditiveAnimationsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::disableCSSAdditiveAnimationsMethod(info);
    }

    static void advanceTimeForImageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "advanceTimeForImage");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* image;
        double deltaTimeInSeconds;
        image = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!image) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        deltaTimeInSeconds = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->advanceTimeForImage(image, deltaTimeInSeconds, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void advanceTimeForImageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::advanceTimeForImageMethod(info);
    }

    static void advanceImageAnimationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "advanceImageAnimation");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Element* image;
        image = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!image) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        impl->advanceImageAnimation(image, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void advanceImageAnimationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::advanceImageAnimationMethod(info);
    }

    static void nextSiblingInFlatTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "nextSiblingInFlatTree");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        Node* result = impl->nextSiblingInFlatTree(node, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void nextSiblingInFlatTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::nextSiblingInFlatTreeMethod(info);
    }

    static void firstChildInFlatTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "firstChildInFlatTree");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        Node* result = impl->firstChildInFlatTree(node, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void firstChildInFlatTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::firstChildInFlatTreeMethod(info);
    }

    static void lastChildInFlatTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "lastChildInFlatTree");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        Node* result = impl->lastChildInFlatTree(node, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void lastChildInFlatTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::lastChildInFlatTreeMethod(info);
    }

    static void nextInFlatTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "nextInFlatTree");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        Node* result = impl->nextInFlatTree(node, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void nextInFlatTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::nextInFlatTreeMethod(info);
    }

    static void previousInFlatTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "previousInFlatTree");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        Node* result = impl->previousInFlatTree(node, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void previousInFlatTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::previousInFlatTreeMethod(info);
    }

    static void visiblePlaceholderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("visiblePlaceholder", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("visiblePlaceholder", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValueString(info, impl->visiblePlaceholder(element), info.GetIsolate());
    }

    void visiblePlaceholderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::visiblePlaceholderMethod(info);
    }

    static void selectColorInColorChooserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("selectColorInColorChooser", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        Element* element;
        V8StringResource<> colorValue;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("selectColorInColorChooser", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        colorValue = info[1];
        if (!colorValue.prepare())
            return;

        impl->selectColorInColorChooser(element, colorValue);
    }

    void selectColorInColorChooserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::selectColorInColorChooserMethod(info);
    }

    static void endColorChooserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("endColorChooser", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("endColorChooser", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        impl->endColorChooser(element);
    }

    void endColorChooserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::endColorChooserMethod(info);
    }

    static void hasAutofocusRequestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        Document* document;
        int numArgsPassed = info.Length();
        while (numArgsPassed > 0) {
            if (!info[numArgsPassed - 1]->IsUndefined())
                break;
            --numArgsPassed;
        }
        if (UNLIKELY(numArgsPassed <= 0)) {
            v8SetReturnValueBool(info, impl->hasAutofocusRequest());
            return;
        }
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("hasAutofocusRequest", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueBool(info, impl->hasAutofocusRequest(document));
    }

    void hasAutofocusRequestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasAutofocusRequestMethod(info);
    }

    static void formControlStateOfHistoryItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "formControlStateOfHistoryItem");

        Internals* impl = V8Internals::toImpl(info.Holder());

        Vector<String> result = impl->formControlStateOfHistoryItem(exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, ToV8(result, info.Holder(), info.GetIsolate()));
    }

    void formControlStateOfHistoryItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::formControlStateOfHistoryItemMethod(info);
    }

    static void setFormControlStateOfHistoryItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setFormControlStateOfHistoryItem");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Vector<String> values;
        values = toImplArray<Vector<String>>(info[0], 1, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setFormControlStateOfHistoryItem(values, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setFormControlStateOfHistoryItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setFormControlStateOfHistoryItemMethod(info);
    }

    static void absoluteCaretBoundsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "absoluteCaretBounds");

        Internals* impl = V8Internals::toImpl(info.Holder());

        ClientRect* result = impl->absoluteCaretBounds(exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void absoluteCaretBoundsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::absoluteCaretBoundsMethod(info);
    }

    static void boundingBoxMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("boundingBox", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("boundingBox", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValue(info, impl->boundingBox(element));
    }

    void boundingBoxMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::boundingBoxMethod(info);
    }

    static void setMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setMarker");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Document* document;
        Range* range;
        V8StringResource<> markerType;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!range) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Range'.");

            return;
        }

        markerType = info[2];
        if (!markerType.prepare())
            return;

        impl->setMarker(document, range, markerType, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setMarkerMethod(info);
    }

    static void markerCountForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "markerCountForNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Node* node;
        V8StringResource<> markerType;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        markerType = info[1];
        if (!markerType.prepare())
            return;

        unsigned result = impl->markerCountForNode(node, markerType, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueUnsigned(info, result);
    }

    void markerCountForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::markerCountForNodeMethod(info);
    }

    static void activeMarkerCountForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("activeMarkerCountForNode", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("activeMarkerCountForNode", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->activeMarkerCountForNode(node));
    }

    void activeMarkerCountForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::activeMarkerCountForNodeMethod(info);
    }

    static void markerRangeForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "markerRangeForNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Node* node;
        V8StringResource<> markerType;
        unsigned index;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        markerType = info[1];
        if (!markerType.prepare())
            return;

        index = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        Range* result = impl->markerRangeForNode(node, markerType, index, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void markerRangeForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::markerRangeForNodeMethod(info);
    }

    static void markerDescriptionForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "markerDescriptionForNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Node* node;
        V8StringResource<> markerType;
        unsigned index;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        markerType = info[1];
        if (!markerType.prepare())
            return;

        index = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        String result = impl->markerDescriptionForNode(node, markerType, index, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void markerDescriptionForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::markerDescriptionForNodeMethod(info);
    }

    static void addTextMatchMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "addTextMatchMarker");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Range* range;
        bool isActive;
        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!range) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Range'.");

            return;
        }

        isActive = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->addTextMatchMarker(range, isActive);
    }

    void addTextMatchMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::addTextMatchMarkerMethod(info);
    }

    static void addCompositionMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "addCompositionMarker");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        Range* range;
        V8StringResource<> underlineColorValue;
        bool thick;
        V8StringResource<> backgroundColorValue;
        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!range) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Range'.");

            return;
        }

        underlineColorValue = info[1];
        if (!underlineColorValue.prepare())
            return;

        thick = toBoolean(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        backgroundColorValue = info[3];
        if (!backgroundColorValue.prepare())
            return;

        impl->addCompositionMarker(range, underlineColorValue, thick, backgroundColorValue, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void addCompositionMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::addCompositionMarkerMethod(info);
    }

    static void setMarkersActiveMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setMarkersActive");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        Node* node;
        unsigned startOffset;
        unsigned endOffset;
        bool active;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        startOffset = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        endOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        active = toBoolean(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMarkersActive(node, startOffset, endOffset, active);
    }

    void setMarkersActiveMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setMarkersActiveMethod(info);
    }

    static void setMarkedTextMatchesAreHighlightedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setMarkedTextMatchesAreHighlighted");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Document* document;
        bool highlight;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        highlight = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMarkedTextMatchesAreHighlighted(document, highlight);
    }

    void setMarkedTextMatchesAreHighlightedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setMarkedTextMatchesAreHighlightedMethod(info);
    }

    static void setFrameViewPositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setFrameViewPosition");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Document* document;
        int x;
        int y;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setFrameViewPosition(document, x, y, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setFrameViewPositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setFrameViewPositionMethod(info);
    }

    static void viewportAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "viewportAsText");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        Document* document;
        float devicePixelRatio;
        int availableWidth;
        int availableHeight;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        devicePixelRatio = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        availableWidth = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        availableHeight = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        String result = impl->viewportAsText(document, devicePixelRatio, availableWidth, availableHeight, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void viewportAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::viewportAsTextMethod(info);
    }

    static void elementShouldAutoCompleteMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "elementShouldAutoComplete");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Element* inputElement;
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        bool result = impl->elementShouldAutoComplete(inputElement, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void elementShouldAutoCompleteMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::elementShouldAutoCompleteMethod(info);
    }

    static void suggestedValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "suggestedValue");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Element* inputElement;
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        String result = impl->suggestedValue(inputElement, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void suggestedValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::suggestedValueMethod(info);
    }

    static void setSuggestedValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setSuggestedValue");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* inputElement;
        V8StringResource<> value;
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        value = info[1];
        if (!value.prepare())
            return;

        impl->setSuggestedValue(inputElement, value, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setSuggestedValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setSuggestedValueMethod(info);
    }

    static void setEditingValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setEditingValue");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* inputElement;
        V8StringResource<> value;
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        value = info[1];
        if (!value.prepare())
            return;

        impl->setEditingValue(inputElement, value, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setEditingValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setEditingValueMethod(info);
    }

    static void setAutofilledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setAutofilled");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* inputElement;
        bool enabled;
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        enabled = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setAutofilled(inputElement, enabled, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setAutofilledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setAutofilledMethod(info);
    }

    static void rangeFromLocationAndLengthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "rangeFromLocationAndLength");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Element* scope;
        int rangeLocation;
        int rangeLength;
        scope = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!scope) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        rangeLocation = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        rangeLength = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->rangeFromLocationAndLength(scope, rangeLocation, rangeLength));
    }

    void rangeFromLocationAndLengthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::rangeFromLocationAndLengthMethod(info);
    }

    static void locationFromRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("locationFromRange", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        Element* scope;
        Range* range;
        scope = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!scope) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("locationFromRange", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!range) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("locationFromRange", "Internals", "parameter 2 is not of type 'Range'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->locationFromRange(scope, range));
    }

    void locationFromRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::locationFromRangeMethod(info);
    }

    static void lengthFromRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("lengthFromRange", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        Element* scope;
        Range* range;
        scope = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!scope) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("lengthFromRange", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!range) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("lengthFromRange", "Internals", "parameter 2 is not of type 'Range'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->lengthFromRange(scope, range));
    }

    void lengthFromRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::lengthFromRangeMethod(info);
    }

    static void rangeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("rangeAsText", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Range* range;
        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!range) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("rangeAsText", "Internals", "parameter 1 is not of type 'Range'."));

            return;
        }

        v8SetReturnValueString(info, impl->rangeAsText(range), info.GetIsolate());
    }

    void rangeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::rangeAsTextMethod(info);
    }

    static void touchPositionAdjustedToBestClickableNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "touchPositionAdjustedToBestClickableNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        int x;
        int y;
        int width;
        int height;
        Document* document;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");

            return;
        }

        DOMPoint* result = impl->touchPositionAdjustedToBestClickableNode(x, y, width, height, document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void touchPositionAdjustedToBestClickableNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::touchPositionAdjustedToBestClickableNodeMethod(info);
    }

    static void touchNodeAdjustedToBestClickableNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "touchNodeAdjustedToBestClickableNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        int x;
        int y;
        int width;
        int height;
        Document* document;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");

            return;
        }

        Node* result = impl->touchNodeAdjustedToBestClickableNode(x, y, width, height, document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void touchNodeAdjustedToBestClickableNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::touchNodeAdjustedToBestClickableNodeMethod(info);
    }

    static void touchPositionAdjustedToBestContextMenuNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "touchPositionAdjustedToBestContextMenuNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        int x;
        int y;
        int width;
        int height;
        Document* document;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");

            return;
        }

        DOMPoint* result = impl->touchPositionAdjustedToBestContextMenuNode(x, y, width, height, document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void touchPositionAdjustedToBestContextMenuNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::touchPositionAdjustedToBestContextMenuNodeMethod(info);
    }

    static void touchNodeAdjustedToBestContextMenuNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "touchNodeAdjustedToBestContextMenuNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        int x;
        int y;
        int width;
        int height;
        Document* document;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");

            return;
        }

        Node* result = impl->touchNodeAdjustedToBestContextMenuNode(x, y, width, height, document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void touchNodeAdjustedToBestContextMenuNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::touchNodeAdjustedToBestContextMenuNodeMethod(info);
    }

    static void bestZoomableAreaForTouchPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "bestZoomableAreaForTouchPoint");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        int x;
        int y;
        int width;
        int height;
        Document* document;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");

            return;
        }

        ClientRect* result = impl->bestZoomableAreaForTouchPoint(x, y, width, height, document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void bestZoomableAreaForTouchPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::bestZoomableAreaForTouchPointMethod(info);
    }

    static void lastSpellCheckRequestSequenceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "lastSpellCheckRequestSequence");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        int result = impl->lastSpellCheckRequestSequence(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueInt(info, result);
    }

    void lastSpellCheckRequestSequenceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::lastSpellCheckRequestSequenceMethod(info);
    }

    static void lastSpellCheckProcessedSequenceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "lastSpellCheckProcessedSequence");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        int result = impl->lastSpellCheckProcessedSequence(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueInt(info, result);
    }

    void lastSpellCheckProcessedSequenceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::lastSpellCheckProcessedSequenceMethod(info);
    }

    static void userPreferredLanguagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, ToV8(impl->userPreferredLanguages(), info.Holder(), info.GetIsolate()));
    }

    void userPreferredLanguagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::userPreferredLanguagesMethod(info);
    }

    static void setUserPreferredLanguagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setUserPreferredLanguages");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Vector<String> languages;
        languages = toImplArray<Vector<String>>(info[0], 1, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setUserPreferredLanguages(languages);
    }

    void setUserPreferredLanguagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setUserPreferredLanguagesMethod(info);
    }

    static void mediaKeysCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueUnsigned(info, impl->mediaKeysCount());
    }

    void mediaKeysCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::mediaKeysCountMethod(info);
    }

    static void mediaKeySessionCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueUnsigned(info, impl->mediaKeySessionCount());
    }

    void mediaKeySessionCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::mediaKeySessionCountMethod(info);
    }

    static void suspendableObjectCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("suspendableObjectCount", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("suspendableObjectCount", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->suspendableObjectCount(document));
    }

    void suspendableObjectCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::suspendableObjectCountMethod(info);
    }

    static void wheelEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("wheelEventHandlerCount", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("wheelEventHandlerCount", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->wheelEventHandlerCount(document));
    }

    void wheelEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::wheelEventHandlerCountMethod(info);
    }

    static void scrollEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("scrollEventHandlerCount", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("scrollEventHandlerCount", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->scrollEventHandlerCount(document));
    }

    void scrollEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::scrollEventHandlerCountMethod(info);
    }

    static void touchStartOrMoveEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("touchStartOrMoveEventHandlerCount", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("touchStartOrMoveEventHandlerCount", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->touchStartOrMoveEventHandlerCount(document));
    }

    void touchStartOrMoveEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::touchStartOrMoveEventHandlerCountMethod(info);
    }

    static void touchEndOrCancelEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("touchEndOrCancelEventHandlerCount", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("touchEndOrCancelEventHandlerCount", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->touchEndOrCancelEventHandlerCount(document));
    }

    void touchEndOrCancelEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::touchEndOrCancelEventHandlerCountMethod(info);
    }

    static void touchEventTargetLayerRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "touchEventTargetLayerRects");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        LayerRectList* result = impl->touchEventTargetLayerRects(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void touchEventTargetLayerRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::touchEventTargetLayerRectsMethod(info);
    }

    static void executeCommandMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "executeCommand");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Document* document;
        V8StringResource<> name;
        V8StringResource<> value;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        name = info[1];
        if (!name.prepare())
            return;

        value = info[2];
        if (!value.prepare())
            return;

        bool result = impl->executeCommand(document, name, value, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void executeCommandMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::executeCommandMethod(info);
    }

    static void htmlNamespaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueString(info, impl->htmlNamespace(), info.GetIsolate());
    }

    void htmlNamespaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::htmlNamespaceMethod(info);
    }

    static void htmlTagsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, ToV8(impl->htmlTags(), info.Holder(), info.GetIsolate()));
    }

    void htmlTagsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::htmlTagsMethod(info);
    }

    static void svgNamespaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueString(info, impl->svgNamespace(), info.GetIsolate());
    }

    void svgNamespaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::svgNamespaceMethod(info);
    }

    static void svgTagsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, ToV8(impl->svgTags(), info.Holder(), info.GetIsolate()));
    }

    void svgTagsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::svgTagsMethod(info);
    }

    static void nodesFromRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "nodesFromRect");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 9)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(9, info.Length()));
            return;
        }

        Document* document;
        int x;
        int y;
        unsigned topPadding;
        unsigned rightPadding;
        unsigned bottomPadding;
        unsigned leftPadding;
        bool ignoreClipping;
        bool allowChildFrameContent;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        topPadding = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        rightPadding = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bottomPadding = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        leftPadding = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ignoreClipping = toBoolean(info.GetIsolate(), info[7], exceptionState);
        if (exceptionState.hadException())
            return;

        allowChildFrameContent = toBoolean(info.GetIsolate(), info[8], exceptionState);
        if (exceptionState.hadException())
            return;

        NodeList* result = impl->nodesFromRect(document, x, y, topPadding, rightPadding, bottomPadding, leftPadding, ignoreClipping, allowChildFrameContent, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void nodesFromRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::nodesFromRectMethod(info);
    }

    static void hasSpellingMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hasSpellingMarker");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Document* document;
        int from;
        int length;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        from = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        length = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bool result = impl->hasSpellingMarker(document, from, length, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void hasSpellingMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasSpellingMarkerMethod(info);
    }

    static void hasGrammarMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "hasGrammarMarker");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        Document* document;
        int from;
        int length;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        from = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        length = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        bool result = impl->hasGrammarMarker(document, from, length, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void hasGrammarMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::hasGrammarMarkerMethod(info);
    }

    static void setSpellCheckingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setSpellCheckingEnabled");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool enabled;
        enabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setSpellCheckingEnabled(enabled, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setSpellCheckingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setSpellCheckingEnabledMethod(info);
    }

    static void replaceMisspelledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "replaceMisspelled");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Document* document;
        V8StringResource<> replacement;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        replacement = info[1];
        if (!replacement.prepare())
            return;

        impl->replaceMisspelled(document, replacement, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void replaceMisspelledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::replaceMisspelledMethod(info);
    }

    static void canHyphenateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("canHyphenate", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> locale;
        locale = info[0];
        if (!locale.prepare())
            return;

        v8SetReturnValue(info, impl->canHyphenate(locale));
    }

    void canHyphenateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::canHyphenateMethod(info);
    }

    static void setMockHyphenationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setMockHyphenation", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> locale;
        locale = info[0];
        if (!locale.prepare())
            return;

        impl->setMockHyphenation(locale);
    }

    void setMockHyphenationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setMockHyphenationMethod(info);
    }

    static void isOverwriteModeEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isOverwriteModeEnabled", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isOverwriteModeEnabled", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isOverwriteModeEnabled(document));
    }

    void isOverwriteModeEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isOverwriteModeEnabledMethod(info);
    }

    static void toggleOverwriteModeEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("toggleOverwriteModeEnabled", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("toggleOverwriteModeEnabled", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        impl->toggleOverwriteModeEnabled(document);
    }

    void toggleOverwriteModeEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::toggleOverwriteModeEnabledMethod(info);
    }

    static void numberOfScrollableAreasMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("numberOfScrollableAreas", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("numberOfScrollableAreas", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->numberOfScrollableAreas(document));
    }

    void numberOfScrollableAreasMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::numberOfScrollableAreasMethod(info);
    }

    static void isPageBoxVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "isPageBoxVisible");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Document* document;
        int pageNumber;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        pageNumber = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueBool(info, impl->isPageBoxVisible(document, pageNumber));
    }

    void isPageBoxVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isPageBoxVisibleMethod(info);
    }

    static void layerTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "layerTreeAsText");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        unsigned flags;
        int numArgsPassed = info.Length();
        while (numArgsPassed > 0) {
            if (!info[numArgsPassed - 1]->IsUndefined())
                break;
            --numArgsPassed;
        }
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        if (UNLIKELY(numArgsPassed <= 1)) {
            String result = impl->layerTreeAsText(document, exceptionState);
            if (exceptionState.hadException()) {
                return;
            }
            v8SetReturnValueString(info, result, info.GetIsolate());
            return;
        }
        flags = toUInt16(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        String result = impl->layerTreeAsText(document, flags, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void layerTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::layerTreeAsTextMethod(info);
    }

    static void elementLayerTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "elementLayerTreeAsText");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Element* element;
        unsigned flags;
        int numArgsPassed = info.Length();
        while (numArgsPassed > 0) {
            if (!info[numArgsPassed - 1]->IsUndefined())
                break;
            --numArgsPassed;
        }
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        if (UNLIKELY(numArgsPassed <= 1)) {
            String result = impl->elementLayerTreeAsText(element, exceptionState);
            if (exceptionState.hadException()) {
                return;
            }
            v8SetReturnValueString(info, result, info.GetIsolate());
            return;
        }
        flags = toUInt16(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        String result = impl->elementLayerTreeAsText(element, flags, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void elementLayerTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::elementLayerTreeAsTextMethod(info);
    }

    static void scrollsWithRespectToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "scrollsWithRespectTo");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* element1;
        Element* element2;
        element1 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        element2 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!element2) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Element'.");

            return;
        }

        bool result = impl->scrollsWithRespectTo(element1, element2, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueBool(info, result);
    }

    void scrollsWithRespectToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::scrollsWithRespectToMethod(info);
    }

    static void scrollingStateTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("scrollingStateTreeAsText", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("scrollingStateTreeAsText", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueString(info, impl->scrollingStateTreeAsText(document), info.GetIsolate());
    }

    void scrollingStateTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::scrollingStateTreeAsTextMethod(info);
    }

    static void mainThreadScrollingReasonsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "mainThreadScrollingReasons");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        String result = impl->mainThreadScrollingReasons(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void mainThreadScrollingReasonsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::mainThreadScrollingReasonsMethod(info);
    }

    static void nonFastScrollableRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "nonFastScrollableRects");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        ClientRectList* result = impl->nonFastScrollableRects(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void nonFastScrollableRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::nonFastScrollableRectsMethod(info);
    }

    static void evictAllResourcesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        impl->evictAllResources();
    }

    void evictAllResourcesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::evictAllResourcesMethod(info);
    }

    static void numberOfLiveNodesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueUnsigned(info, impl->numberOfLiveNodes());
    }

    void numberOfLiveNodesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::numberOfLiveNodesMethod(info);
    }

    static void numberOfLiveDocumentsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueUnsigned(info, impl->numberOfLiveDocuments());
    }

    void numberOfLiveDocumentsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::numberOfLiveDocumentsMethod(info);
    }

    static void dumpRefCountedInstanceCountsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueString(info, impl->dumpRefCountedInstanceCounts(), info.GetIsolate());
    }

    void dumpRefCountedInstanceCountsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::dumpRefCountedInstanceCountsMethod(info);
    }

    static void counterValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("counterValue", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("counterValue", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValueString(info, impl->counterValue(element), info.GetIsolate());
    }

    void counterValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::counterValueMethod(info);
    }

    static void pageNumberMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "pageNumber");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Element* element;
        float pageWidth;
        float pageHeight;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        if (!info[1]->IsUndefined()) {
            pageWidth = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            pageWidth = 800;
        }
        if (!info[2]->IsUndefined()) {
            pageHeight = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            pageHeight = 600;
        }

        int result = impl->pageNumber(element, pageWidth, pageHeight, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueInt(info, result);
    }

    void pageNumberMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::pageNumberMethod(info);
    }

    static void shortcutIconURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shortcutIconURLs", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shortcutIconURLs", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValue(info, ToV8(impl->shortcutIconURLs(document), info.Holder(), info.GetIsolate()));
    }

    void shortcutIconURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::shortcutIconURLsMethod(info);
    }

    static void allIconURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("allIconURLs", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("allIconURLs", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValue(info, ToV8(impl->allIconURLs(document), info.Holder(), info.GetIsolate()));
    }

    void allIconURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::allIconURLsMethod(info);
    }

    static void numberOfPagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "numberOfPages");

        Internals* impl = V8Internals::toImpl(info.Holder());

        double pageWidthInPixels;
        double pageHeightInPixels;
        if (!info[0]->IsUndefined()) {
            pageWidthInPixels = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            pageWidthInPixels = 800;
        }
        if (!info[1]->IsUndefined()) {
            pageHeightInPixels = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
            if (exceptionState.hadException())
                return;
        } else {
            pageHeightInPixels = 600;
        }

        int result = impl->numberOfPages(pageWidthInPixels, pageHeightInPixels, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueInt(info, result);
    }

    void numberOfPagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::numberOfPagesMethod(info);
    }

    static void pagePropertyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "pageProperty");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        V8StringResource<> propertyName;
        int pageNumber;
        propertyName = info[0];
        if (!propertyName.prepare())
            return;

        pageNumber = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        String result = impl->pageProperty(propertyName, pageNumber, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void pagePropertyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::pagePropertyMethod(info);
    }

    static void pageSizeAndMarginsInPixelsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "pageSizeAndMarginsInPixels");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 7)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(7, info.Length()));
            return;
        }

        int pageIndex;
        int width;
        int height;
        int marginTop;
        int marginRight;
        int marginBottom;
        int marginLeft;
        pageIndex = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        width = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        height = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        marginTop = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        marginRight = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        marginBottom = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        marginLeft = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        String result = impl->pageSizeAndMarginsInPixels(pageIndex, width, height, marginTop, marginRight, marginBottom, marginLeft, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValueString(info, result, info.GetIsolate());
    }

    void pageSizeAndMarginsInPixelsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::pageSizeAndMarginsInPixelsMethod(info);
    }

    static void pageScaleFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "pageScaleFactor");

        Internals* impl = V8Internals::toImpl(info.Holder());

        float result = impl->pageScaleFactor(exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void pageScaleFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::pageScaleFactorMethod(info);
    }

    static void setPageScaleFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setPageScaleFactor");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        float scaleFactor;
        scaleFactor = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPageScaleFactor(scaleFactor, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setPageScaleFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setPageScaleFactorMethod(info);
    }

    static void setPageScaleFactorLimitsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setPageScaleFactorLimits");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        float minScaleFactor;
        float maxScaleFactor;
        minScaleFactor = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        maxScaleFactor = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setPageScaleFactorLimits(minScaleFactor, maxScaleFactor, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setPageScaleFactorLimitsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setPageScaleFactorLimitsMethod(info);
    }

    static void setIsCursorVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setIsCursorVisible");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Document* document;
        bool isVisible;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        isVisible = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setIsCursorVisible(document, isVisible, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setIsCursorVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setIsCursorVisibleMethod(info);
    }

    static void effectivePreloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("effectivePreload", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        HTMLMediaElement* mediaElement;
        mediaElement = V8HTMLMediaElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!mediaElement) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("effectivePreload", "Internals", "parameter 1 is not of type 'HTMLMediaElement'."));

            return;
        }

        v8SetReturnValueString(info, impl->effectivePreload(mediaElement), info.GetIsolate());
    }

    void effectivePreloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::effectivePreloadMethod(info);
    }

    static void mediaPlayerRemoteRouteAvailabilityChangedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "mediaPlayerRemoteRouteAvailabilityChanged");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        HTMLMediaElement* mediaElement;
        bool available;
        mediaElement = V8HTMLMediaElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!mediaElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLMediaElement'.");

            return;
        }

        available = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->mediaPlayerRemoteRouteAvailabilityChanged(mediaElement, available);
    }

    void mediaPlayerRemoteRouteAvailabilityChangedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::mediaPlayerRemoteRouteAvailabilityChangedMethod(info);
    }

    static void mediaPlayerPlayingRemotelyChangedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "mediaPlayerPlayingRemotelyChanged");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        HTMLMediaElement* mediaElement;
        bool remote;
        mediaElement = V8HTMLMediaElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!mediaElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLMediaElement'.");

            return;
        }

        remote = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->mediaPlayerPlayingRemotelyChanged(mediaElement, remote);
    }

    void mediaPlayerPlayingRemotelyChangedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::mediaPlayerPlayingRemotelyChangedMethod(info);
    }

    static void registerURLSchemeAsBypassingContentSecurityPolicy1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        V8StringResource<> scheme;
        scheme = info[0];
        if (!scheme.prepare())
            return;

        impl->registerURLSchemeAsBypassingContentSecurityPolicy(scheme);
    }

    static void registerURLSchemeAsBypassingContentSecurityPolicy2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "registerURLSchemeAsBypassingContentSecurityPolicy");

        Internals* impl = V8Internals::toImpl(info.Holder());

        V8StringResource<> scheme;
        Vector<String> policyAreas;
        scheme = info[0];
        if (!scheme.prepare())
            return;

        policyAreas = toImplArray<Vector<String>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        impl->registerURLSchemeAsBypassingContentSecurityPolicy(scheme, policyAreas);
    }

    static void registerURLSchemeAsBypassingContentSecurityPolicyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(2, info.Length())) {
        case 1:
            if (true) {
                registerURLSchemeAsBypassingContentSecurityPolicy1Method(info);
                return;
            }
            break;
        case 2:
            if (true) {
                registerURLSchemeAsBypassingContentSecurityPolicy2Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "registerURLSchemeAsBypassingContentSecurityPolicy");

        if (isArityError) {
            if (info.Length() < 1) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    void registerURLSchemeAsBypassingContentSecurityPolicyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::registerURLSchemeAsBypassingContentSecurityPolicyMethod(info);
    }

    static void removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        V8StringResource<> scheme;
        scheme = info[0];
        if (!scheme.prepare())
            return;

        impl->removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);
    }

    void removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethod(info);
    }

    static void typeConversionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, impl->typeConversions());
    }

    void typeConversionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::typeConversionsMethod(info);
    }

    static void getReferencedFilePathsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, ToV8(impl->getReferencedFilePaths(), info.Holder(), info.GetIsolate()));
    }

    void getReferencedFilePathsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::getReferencedFilePathsMethod(info);
    }

    static void startStoringCompositedLayerDebugInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "startStoringCompositedLayerDebugInfo");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        impl->startStoringCompositedLayerDebugInfo(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void startStoringCompositedLayerDebugInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::startStoringCompositedLayerDebugInfoMethod(info);
    }

    static void stopStoringCompositedLayerDebugInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "stopStoringCompositedLayerDebugInfo");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        impl->stopStoringCompositedLayerDebugInfo(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void stopStoringCompositedLayerDebugInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::stopStoringCompositedLayerDebugInfoMethod(info);
    }

    static void startTrackingRepaintsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "startTrackingRepaints");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        impl->startTrackingRepaints(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void startTrackingRepaintsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::startTrackingRepaintsMethod(info);
    }

    static void stopTrackingRepaintsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "stopTrackingRepaints");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        impl->stopTrackingRepaints(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void stopTrackingRepaintsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::stopTrackingRepaintsMethod(info);
    }

    static void updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks");

        Internals* impl = V8Internals::toImpl(info.Holder());

        Node* node;
        if (!info[0]->IsUndefined()) {
            node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
            if (!node && !isUndefinedOrNull(info[0])) {
                exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

                return;
            }
        } else {
            node = nullptr;
        }

        impl->updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(node, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethod(info);
    }

    static void forceFullRepaintMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "forceFullRepaint");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        impl->forceFullRepaint(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void forceFullRepaintMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::forceFullRepaintMethod(info);
    }

    static void draggableRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "draggableRegions");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        ClientRectList* result = impl->draggableRegions(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void draggableRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::draggableRegionsMethod(info);
    }

    static void nonDraggableRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "nonDraggableRegions");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        ClientRectList* result = impl->nonDraggableRegions(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void nonDraggableRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::nonDraggableRegionsMethod(info);
    }

    static void getCurrentCursorInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueString(info, impl->getCurrentCursorInfo(), info.GetIsolate());
    }

    void getCurrentCursorInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::getCurrentCursorInfoMethod(info);
    }

    static void markerTextForListItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("markerTextForListItem", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("markerTextForListItem", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValueString(info, impl->markerTextForListItem(element), info.GetIsolate());
    }

    void markerTextForListItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::markerTextForListItemMethod(info);
    }

    static void deserializeBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deserializeBuffer", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        DOMArrayBuffer* buffer;
        buffer = info[0]->IsArrayBuffer() ? V8ArrayBuffer::toImpl(v8::Local<v8::ArrayBuffer>::Cast(info[0])) : 0;
        if (!buffer) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deserializeBuffer", "Internals", "parameter 1 is not of type 'ArrayBuffer'."));

            return;
        }

        v8SetReturnValue(info, v8Deserialize(info.GetIsolate(), impl->deserializeBuffer(buffer)));
    }

    void deserializeBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::deserializeBufferMethod(info);
    }

    static void serializeObjectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "serializeObject");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        RefPtr<SerializedScriptValue> obj;
        obj = SerializedScriptValue::serialize(info.GetIsolate(), info[0], nullptr, nullptr, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->serializeObject(obj));
    }

    void serializeObjectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::serializeObjectMethod(info);
    }

    static void forceReloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "forceReload");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool endToEnd;
        endToEnd = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->forceReload(endToEnd);
    }

    void forceReloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::forceReloadMethod(info);
    }

    static void getImageSourceURLMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getImageSourceURL", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getImageSourceURL", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValueString(info, impl->getImageSourceURL(element), info.GetIsolate());
    }

    void getImageSourceURLMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::getImageSourceURLMethod(info);
    }

    static void selectMenuListTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("selectMenuListText", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        HTMLSelectElement* select;
        select = V8HTMLSelectElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!select) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("selectMenuListText", "Internals", "parameter 1 is not of type 'HTMLSelectElement'."));

            return;
        }

        v8SetReturnValueString(info, impl->selectMenuListText(select), info.GetIsolate());
    }

    void selectMenuListTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::selectMenuListTextMethod(info);
    }

    static void isSelectPopupVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSelectPopupVisible", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSelectPopupVisible", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValueBool(info, impl->isSelectPopupVisible(node));
    }

    void isSelectPopupVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isSelectPopupVisibleMethod(info);
    }

    static void selectPopupItemStyleIsRtlMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "selectPopupItemStyleIsRtl");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Node* select;
        int itemIndex;
        select = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!select) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        itemIndex = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueBool(info, impl->selectPopupItemStyleIsRtl(select, itemIndex));
    }

    void selectPopupItemStyleIsRtlMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::selectPopupItemStyleIsRtlMethod(info);
    }

    static void selectPopupItemStyleFontHeightMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "selectPopupItemStyleFontHeight");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Node* select;
        int itemIndex;
        select = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!select) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        itemIndex = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueInt(info, impl->selectPopupItemStyleFontHeight(select, itemIndex));
    }

    void selectPopupItemStyleFontHeightMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::selectPopupItemStyleFontHeightMethod(info);
    }

    static void resetTypeAheadSessionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("resetTypeAheadSession", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        HTMLSelectElement* select;
        select = V8HTMLSelectElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!select) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("resetTypeAheadSession", "Internals", "parameter 1 is not of type 'HTMLSelectElement'."));

            return;
        }

        impl->resetTypeAheadSession(select);
    }

    void resetTypeAheadSessionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::resetTypeAheadSessionMethod(info);
    }

    static void selectionBoundsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "selectionBounds");

        Internals* impl = V8Internals::toImpl(info.Holder());

        ClientRect* result = impl->selectionBounds(exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void selectionBoundsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::selectionBoundsMethod(info);
    }

    static void loseSharedGraphicsContext3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueBool(info, impl->loseSharedGraphicsContext3D());
    }

    void loseSharedGraphicsContext3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::loseSharedGraphicsContext3DMethod(info);
    }

    static void forceCompositingUpdateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "forceCompositingUpdate");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        impl->forceCompositingUpdate(document, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void forceCompositingUpdateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::forceCompositingUpdateMethod(info);
    }

    static void setZoomFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setZoomFactor");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        float factor;
        factor = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setZoomFactor(factor);
    }

    void setZoomFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setZoomFactorMethod(info);
    }

    static void setShouldRevealPasswordMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setShouldRevealPassword");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Element* element;
        bool reveal;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");

            return;
        }

        reveal = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setShouldRevealPassword(element, reveal, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setShouldRevealPasswordMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setShouldRevealPasswordMethod(info);
    }

    static void createResolvedPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "createResolvedPromise");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        ScriptValue value;
        value = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);

        ScriptPromise result = impl->createResolvedPromise(scriptState, value);
        v8SetReturnValue(info, result.v8Value());
    }

    void createResolvedPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::createResolvedPromiseMethod(info);
    }

    static void createRejectedPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "createRejectedPromise");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        ScriptValue reason;
        reason = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);

        ScriptPromise result = impl->createRejectedPromise(scriptState, reason);
        v8SetReturnValue(info, result.v8Value());
    }

    void createRejectedPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::createRejectedPromiseMethod(info);
    }

    static void addOneToPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "addOneToPromise");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        ScriptPromise promise;
        promise = ScriptPromise::cast(ScriptState::current(info.GetIsolate()), info[0]);
        if (!promise.isUndefinedOrNull() && !promise.isObject()) {
            exceptionState.throwTypeError("parameter 1 ('promise') is not an object.");

            return;
        }

        ScriptPromise result = impl->addOneToPromise(scriptState, promise);
        v8SetReturnValue(info, result.v8Value());
    }

    void addOneToPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::addOneToPromiseMethod(info);
    }

    static void promiseCheckMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "promiseCheck");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 5)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(5, info.Length()));
            return;
        }

        int arg1;
        bool arg2;
        Dictionary arg3;
        V8StringResource<> arg4;
        Vector<String> arg5;
        arg1 = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        arg2 = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        if (!isUndefinedOrNull(info[2]) && !info[2]->IsObject()) {
            exceptionState.throwTypeError("parameter 3 ('arg3') is not an object.");

            return;
        }
        arg3 = Dictionary(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        arg4 = info[3];
        if (!arg4.prepare(exceptionState))
            return;

        arg5 = toImplArray<Vector<String>>(info[4], 5, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptPromise result = impl->promiseCheck(scriptState, arg1, arg2, arg3, arg4, arg5, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result.v8Value());
    }

    void promiseCheckMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::promiseCheckMethod(info);
    }

    static void promiseCheckWithoutExceptionStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "promiseCheckWithoutExceptionState");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Dictionary arg1;
        V8StringResource<> arg2;
        Vector<String> variadic;
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('arg1') is not an object.");

            return;
        }
        arg1 = Dictionary(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        arg2 = info[1];
        if (!arg2.prepare(exceptionState))
            return;

        variadic = toImplArguments<Vector<String>>(info, 2, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptPromise result = impl->promiseCheckWithoutExceptionState(scriptState, arg1, arg2, variadic);
        v8SetReturnValue(info, result.v8Value());
    }

    void promiseCheckWithoutExceptionStateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::promiseCheckWithoutExceptionStateMethod(info);
    }

    static void promiseCheckRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "promiseCheckRange");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        unsigned arg1;
        arg1 = toUInt8(info.GetIsolate(), info[0], EnforceRange, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptPromise result = impl->promiseCheckRange(scriptState, arg1);
        v8SetReturnValue(info, result.v8Value());
    }

    void promiseCheckRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::promiseCheckRangeMethod(info);
    }

    static void promiseCheckOverload1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "promiseCheckOverload");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        Location* arg1;
        arg1 = V8Location::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!arg1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Location'.");

            return;
        }

        ScriptPromise result = impl->promiseCheckOverload(scriptState, arg1);
        v8SetReturnValue(info, result.v8Value());
    }

    static void promiseCheckOverload2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "promiseCheckOverload");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        Document* arg1;
        arg1 = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!arg1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        ScriptPromise result = impl->promiseCheckOverload(scriptState, arg1);
        v8SetReturnValue(info, result.v8Value());
    }

    static void promiseCheckOverload3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "promiseCheckOverload");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        // V8DOMConfiguration::DoNotCheckHolder
        // Make sure that info.Holder() really points to an instance of the type.
        if (!V8Internals::hasInstance(info.Holder(), info.GetIsolate())) {
            exceptionState.throwTypeError("Illegal invocation");
            return;
        }
        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        Location* arg1;
        int arg2;
        int arg3;
        arg1 = V8Location::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!arg1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Location'.");

            return;
        }

        arg2 = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        arg3 = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        ScriptPromise result = impl->promiseCheckOverload(scriptState, arg1, arg2, arg3);
        v8SetReturnValue(info, result.v8Value());
    }

    static void promiseCheckOverloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        bool isArityError = false;
        switch (std::min(3, info.Length())) {
        case 1:
            if (V8Location::hasInstance(info[0], info.GetIsolate())) {
                promiseCheckOverload1Method(info);
                return;
            }
            if (V8Document::hasInstance(info[0], info.GetIsolate())) {
                promiseCheckOverload2Method(info);
                return;
            }
            break;
        case 3:
            if (true) {
                promiseCheckOverload3Method(info);
                return;
            }
            break;
        default:
            isArityError = true;
        }

        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "promiseCheckOverload");
        ExceptionToRejectPromiseScope rejectPromiseScope(info, exceptionState);

        if (isArityError) {
            if (info.Length() < 1) {
                exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
                return;
            }
            if (info.Length() >= 1) {
                exceptionState.throwTypeError(ExceptionMessages::invalidArity("[1, 3]", info.Length()));
                return;
            }
        }
        exceptionState.throwTypeError("No function was found that matched the signature provided.");
    }

    void promiseCheckOverloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::promiseCheckOverloadMethod(info);
    }

    static void setValueForUserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setValueForUser", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        HTMLInputElement* element;
        V8StringResource<> value;
        element = V8HTMLInputElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setValueForUser", "Internals", "parameter 1 is not of type 'HTMLInputElement'."));

            return;
        }

        value = info[1];
        if (!value.prepare())
            return;

        impl->setValueForUser(element, value);
    }

    void setValueForUserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setValueForUserMethod(info);
    }

    static void textSurroundingNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "textSurroundingNode");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 4)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(4, info.Length()));
            return;
        }

        Node* node;
        int x;
        int y;
        unsigned maxLength;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        maxLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueString(info, impl->textSurroundingNode(node, x, y, maxLength), info.GetIsolate());
    }

    void textSurroundingNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::textSurroundingNodeMethod(info);
    }

    static void setFocusedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setFocused");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool focused;
        focused = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setFocused(focused);
    }

    void setFocusedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setFocusedMethod(info);
    }

    static void setInitialFocusMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setInitialFocus");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool reverse;
        reverse = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setInitialFocus(reverse);
    }

    void setInitialFocusMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setInitialFocusMethod(info);
    }

    static void ignoreLayoutWithPendingStylesheetsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("ignoreLayoutWithPendingStylesheets", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Document* document;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("ignoreLayoutWithPendingStylesheets", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        v8SetReturnValueBool(info, impl->ignoreLayoutWithPendingStylesheets(document));
    }

    void ignoreLayoutWithPendingStylesheetsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::ignoreLayoutWithPendingStylesheetsMethod(info);
    }

    static void setNetworkConnectionInfoOverrideMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setNetworkConnectionInfoOverride");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        bool onLine;
        V8StringResource<> type;
        double downlinkMaxMbps;
        onLine = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        type = info[1];
        if (!type.prepare())
            return;

        downlinkMaxMbps = toRestrictedDouble(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setNetworkConnectionInfoOverride(onLine, type, downlinkMaxMbps, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setNetworkConnectionInfoOverrideMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setNetworkConnectionInfoOverrideMethod(info);
    }

    static void clearNetworkConnectionInfoOverrideMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        impl->clearNetworkConnectionInfoOverride();
    }

    void clearNetworkConnectionInfoOverrideMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::clearNetworkConnectionInfoOverrideMethod(info);
    }

    static void countHitRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("countHitRegions", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        CanvasRenderingContext2D* context;
        context = V8CanvasRenderingContext2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!context) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("countHitRegions", "Internals", "parameter 1 is not of type 'CanvasRenderingContext2D'."));

            return;
        }

        v8SetReturnValueUnsigned(info, impl->countHitRegions(context));
    }

    void countHitRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::countHitRegionsMethod(info);
    }

    static void isInCanvasFontCacheMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isInCanvasFontCache", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        Document* document;
        V8StringResource<> fontString;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isInCanvasFontCache", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        fontString = info[1];
        if (!fontString.prepare())
            return;

        v8SetReturnValueBool(info, impl->isInCanvasFontCache(document, fontString));
    }

    void isInCanvasFontCacheMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isInCanvasFontCacheMethod(info);
    }

    static void canvasFontCacheMaxFontsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueUnsigned(info, impl->canvasFontCacheMaxFonts());
    }

    void canvasFontCacheMaxFontsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::canvasFontCacheMaxFontsMethod(info);
    }

    static void dictionaryTestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, impl->dictionaryTest());
    }

    void dictionaryTestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::dictionaryTestMethod(info);
    }

    static void unionTypesTestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, impl->unionTypesTest());
    }

    void unionTypesTestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::unionTypesTestMethod(info);
    }

    static void callbackFunctionTestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, impl->callbackFunctionTest());
    }

    void callbackFunctionTestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::callbackFunctionTestMethod(info);
    }

    static void setScrollChainMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setScrollChain");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        ScrollState* scrollState;
        HeapVector<Member<Element>> elements;
        scrollState = V8ScrollState::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!scrollState) {
            exceptionState.throwTypeError("parameter 1 is not of type 'ScrollState'.");

            return;
        }

        elements = (toMemberNativeArray<Element>(info[1], 2, info.GetIsolate(), exceptionState));
        if (exceptionState.hadException())
            return;

        impl->setScrollChain(scrollState, elements, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void setScrollChainMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setScrollChainMethod(info);
    }

    static void forceBlinkGCWithoutV8GCMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        impl->forceBlinkGCWithoutV8GC();
    }

    void forceBlinkGCWithoutV8GCMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::forceBlinkGCWithoutV8GCMethod(info);
    }

    static void selectedHTMLForClipboardMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueString(info, impl->selectedHTMLForClipboard(), info.GetIsolate());
    }

    void selectedHTMLForClipboardMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::selectedHTMLForClipboardMethod(info);
    }

    static void selectedTextForClipboardMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueString(info, impl->selectedTextForClipboard(), info.GetIsolate());
    }

    void selectedTextForClipboardMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::selectedTextForClipboardMethod(info);
    }

    static void setVisualViewportOffsetMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setVisualViewportOffset");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        int x;
        int y;
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setVisualViewportOffset(x, y);
    }

    void setVisualViewportOffsetMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setVisualViewportOffsetMethod(info);
    }

    static void visualViewportHeightMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueInt(info, impl->visualViewportHeight());
    }

    void visualViewportHeightMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::visualViewportHeightMethod(info);
    }

    static void visualViewportWidthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueInt(info, impl->visualViewportWidth());
    }

    void visualViewportWidthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::visualViewportWidthMethod(info);
    }

    static void visualViewportScrollXMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, impl->visualViewportScrollX());
    }

    void visualViewportScrollXMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::visualViewportScrollXMethod(info);
    }

    static void visualViewportScrollYMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, impl->visualViewportScrollY());
    }

    void visualViewportScrollYMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::visualViewportScrollYMethod(info);
    }

    static void magnifyScaleAroundAnchorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "magnifyScaleAroundAnchor");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 3)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
            return;
        }

        float offset;
        float x;
        float y;
        offset = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        x = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        y = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->magnifyScaleAroundAnchor(offset, x, y));
    }

    void magnifyScaleAroundAnchorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::magnifyScaleAroundAnchorMethod(info);
    }

    static void isUseCountedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "isUseCounted");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Document* document;
        int useCounterId;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");

            return;
        }

        useCounterId = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValueBool(info, impl->isUseCounted(document, useCounterId));
    }

    void isUseCountedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isUseCountedMethod(info);
    }

    static void isCSSPropertyUseCountedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isCSSPropertyUseCounted", "Internals", ExceptionMessages::notEnoughArguments(2, info.Length())));
            return;
        }

        Document* document;
        V8StringResource<> propertyName;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isCSSPropertyUseCounted", "Internals", "parameter 1 is not of type 'Document'."));

            return;
        }

        propertyName = info[1];
        if (!propertyName.prepare())
            return;

        v8SetReturnValueBool(info, impl->isCSSPropertyUseCounted(document, propertyName));
    }

    void isCSSPropertyUseCountedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::isCSSPropertyUseCountedMethod(info);
    }

    static void unscopableMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValueString(info, impl->unscopableMethod(), info.GetIsolate());
    }

    void unscopableMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::unscopableMethodMethod(info);
    }

    static void focusRingRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("focusRingRects", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("focusRingRects", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValue(info, impl->focusRingRects(element));
    }

    void focusRingRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::focusRingRectsMethod(info);
    }

    static void outlineRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("outlineRects", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Element* element;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("outlineRects", "Internals", "parameter 1 is not of type 'Element'."));

            return;
        }

        v8SetReturnValue(info, impl->outlineRects(element));
    }

    void outlineRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::outlineRectsMethod(info);
    }

    static void setCapsLockStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setCapsLockState");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool enabled;
        enabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setCapsLockState(enabled);
    }

    void setCapsLockStateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setCapsLockStateMethod(info);
    }

    static void setScrollbarVisibilityInScrollableAreaMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setScrollbarVisibilityInScrollableArea");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        Node* node;
        bool visible;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");

            return;
        }

        visible = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;

        v8SetReturnValue(info, impl->setScrollbarVisibilityInScrollableArea(node, visible));
    }

    void setScrollbarVisibilityInScrollableAreaMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setScrollbarVisibilityInScrollableAreaMethod(info);
    }

    static void monotonicTimeToZeroBasedDocumentTimeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "monotonicTimeToZeroBasedDocumentTime");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        double platformTime;
        platformTime = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        double result = impl->monotonicTimeToZeroBasedDocumentTime(platformTime, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void monotonicTimeToZeroBasedDocumentTimeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::monotonicTimeToZeroBasedDocumentTimeMethod(info);
    }

    static void setMediaElementNetworkStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setMediaElementNetworkState");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 2)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
            return;
        }

        HTMLMediaElement* element;
        int state;
        element = V8HTMLMediaElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLMediaElement'.");

            return;
        }

        state = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setMediaElementNetworkState(element, state);
    }

    void setMediaElementNetworkStateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setMediaElementNetworkStateMethod(info);
    }

    static void getScrollAnimationStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getScrollAnimationState", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getScrollAnimationState", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValueString(info, impl->getScrollAnimationState(node), info.GetIsolate());
    }

    void getScrollAnimationStateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::getScrollAnimationStateMethod(info);
    }

    static void getProgrammaticScrollAnimationStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getProgrammaticScrollAnimationState", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getProgrammaticScrollAnimationState", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValueString(info, impl->getProgrammaticScrollAnimationState(node), info.GetIsolate());
    }

    void getProgrammaticScrollAnimationStateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::getProgrammaticScrollAnimationStateMethod(info);
    }

    static void visualRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("visualRect", "Internals", ExceptionMessages::notEnoughArguments(1, info.Length())));
            return;
        }

        Node* node;
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("visualRect", "Internals", "parameter 1 is not of type 'Node'."));

            return;
        }

        v8SetReturnValue(info, impl->visualRect(node));
    }

    void visualRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::visualRectMethod(info);
    }

    static void originTrialsTestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        v8SetReturnValue(info, impl->originTrialsTest());
    }

    void originTrialsTestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::originTrialsTestMethod(info);
    }

    static void crashMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        Internals* impl = V8Internals::toImpl(info.Holder());

        impl->crash();
    }

    void crashMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::crashMethod(info);
    }

    static void setIsLowEndDeviceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "setIsLowEndDevice");

        Internals* impl = V8Internals::toImpl(info.Holder());

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        bool isLowEndDevice;
        isLowEndDevice = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.hadException())
            return;

        impl->setIsLowEndDevice(isLowEndDevice);
    }

    void setIsLowEndDeviceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::setIsLowEndDeviceMethod(info);
    }

    static void keysMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "keys");

        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        Iterator* result = impl->keysForBinding(scriptState, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void keysMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::keysMethod(info);
    }

    static void valuesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "values");

        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        Iterator* result = impl->valuesForBinding(scriptState, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void valuesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::valuesMethod(info);
    }

    static void entriesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "entries");

        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        Iterator* result = impl->entriesForBinding(scriptState, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void entriesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::entriesMethod(info);
    }

    static void forEachMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "forEach");

        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        if (UNLIKELY(info.Length() < 1)) {
            exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
            return;
        }

        ScriptValue callback;
        ScriptValue thisArg;
        if (!(info[0]->IsObject() && v8::Local<v8::Object>::Cast(info[0])->IsCallable())) {
            exceptionState.throwTypeError("The callback provided as parameter 1 is not a function.");

            return;
        }
        callback = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);

        thisArg = ScriptValue(ScriptState::current(info.GetIsolate()), info[1]);

        impl->forEachForBinding(scriptState, ScriptValue(scriptState, info.Holder()), callback, thisArg, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
    }

    void forEachMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::forEachMethod(info);
    }

    static void iteratorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        ExceptionState exceptionState(info.GetIsolate(), ExceptionState::ExecutionContext, "Internals", "iterator");

        Internals* impl = V8Internals::toImpl(info.Holder());

        ScriptState* scriptState = ScriptState::forReceiverObject(info);

        Iterator* result = impl->iterator(scriptState, exceptionState);
        if (exceptionState.hadException()) {
            return;
        }
        v8SetReturnValue(info, result);
    }

    void iteratorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
    {
        InternalsV8Internal::iteratorMethod(info);
    }

} // namespace InternalsV8Internal

const V8DOMConfiguration::AccessorConfiguration V8InternalsAccessors[] = {
    { "pagePopupWindow", InternalsV8Internal::pagePopupWindowAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "settings", InternalsV8Internal::settingsAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "runtimeFlags", InternalsV8Internal::runtimeFlagsAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "workerThreadCount", InternalsV8Internal::workerThreadCountAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "cursorUpdatePending", InternalsV8Internal::cursorUpdatePendingAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "unscopableAttribute", InternalsV8Internal::unscopableAttributeAttributeGetterCallback, 0, 0, 0, nullptr, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
};

const V8DOMConfiguration::MethodConfiguration V8InternalsMethods[] = {
    { "address", InternalsV8Internal::addressMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "observeGC", InternalsV8Internal::observeGCMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "elementLayoutTreeAsText", InternalsV8Internal::elementLayoutTreeAsTextMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isPreloaded", InternalsV8Internal::isPreloadedMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isPreloadedBy", InternalsV8Internal::isPreloadedByMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isLoading", InternalsV8Internal::isLoadingMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isLoadingFromMemoryCache", InternalsV8Internal::isLoadingFromMemoryCacheMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getResourcePriority", InternalsV8Internal::getResourcePriorityMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getResourceHeader", InternalsV8Internal::getResourceHeaderMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isSharingStyle", InternalsV8Internal::isSharingStyleMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "computedStyleIncludingVisitedInfo", InternalsV8Internal::computedStyleIncludingVisitedInfoMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createUserAgentShadowRoot", InternalsV8Internal::createUserAgentShadowRootMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "shadowRoot", InternalsV8Internal::shadowRootMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "youngestShadowRoot", InternalsV8Internal::youngestShadowRootMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "oldestShadowRoot", InternalsV8Internal::oldestShadowRootMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "youngerShadowRoot", InternalsV8Internal::youngerShadowRootMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "shadowRootType", InternalsV8Internal::shadowRootTypeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasShadowInsertionPoint", InternalsV8Internal::hasShadowInsertionPointMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasContentElement", InternalsV8Internal::hasContentElementMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "countElementShadow", InternalsV8Internal::countElementShadowMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "shadowPseudoId", InternalsV8Internal::shadowPseudoIdMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isValidContentSelect", InternalsV8Internal::isValidContentSelectMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "treeScopeRootNode", InternalsV8Internal::treeScopeRootNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "parentTreeScope", InternalsV8Internal::parentTreeScopeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasSelectorForIdInShadow", InternalsV8Internal::hasSelectorForIdInShadowMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasSelectorForClassInShadow", InternalsV8Internal::hasSelectorForClassInShadowMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasSelectorForAttributeInShadow", InternalsV8Internal::hasSelectorForAttributeInShadowMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "compareTreeScopePosition", InternalsV8Internal::compareTreeScopePositionMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "updateStyleAndReturnAffectedElementCount", InternalsV8Internal::updateStyleAndReturnAffectedElementCountMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "needsLayoutCount", InternalsV8Internal::needsLayoutCountMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hitTestCount", InternalsV8Internal::hitTestCountMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hitTestCacheHits", InternalsV8Internal::hitTestCacheHitsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "elementFromPoint", InternalsV8Internal::elementFromPointMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearHitTestCache", InternalsV8Internal::clearHitTestCacheMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "pauseAnimations", InternalsV8Internal::pauseAnimationsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isCompositedAnimation", InternalsV8Internal::isCompositedAnimationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "disableCompositedAnimation", InternalsV8Internal::disableCompositedAnimationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "disableCSSAdditiveAnimations", InternalsV8Internal::disableCSSAdditiveAnimationsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "advanceTimeForImage", InternalsV8Internal::advanceTimeForImageMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "advanceImageAnimation", InternalsV8Internal::advanceImageAnimationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "nextSiblingInFlatTree", InternalsV8Internal::nextSiblingInFlatTreeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "firstChildInFlatTree", InternalsV8Internal::firstChildInFlatTreeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "lastChildInFlatTree", InternalsV8Internal::lastChildInFlatTreeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "nextInFlatTree", InternalsV8Internal::nextInFlatTreeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "previousInFlatTree", InternalsV8Internal::previousInFlatTreeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "visiblePlaceholder", InternalsV8Internal::visiblePlaceholderMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "selectColorInColorChooser", InternalsV8Internal::selectColorInColorChooserMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "endColorChooser", InternalsV8Internal::endColorChooserMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasAutofocusRequest", InternalsV8Internal::hasAutofocusRequestMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "formControlStateOfHistoryItem", InternalsV8Internal::formControlStateOfHistoryItemMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setFormControlStateOfHistoryItem", InternalsV8Internal::setFormControlStateOfHistoryItemMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "absoluteCaretBounds", InternalsV8Internal::absoluteCaretBoundsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "boundingBox", InternalsV8Internal::boundingBoxMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMarker", InternalsV8Internal::setMarkerMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "markerCountForNode", InternalsV8Internal::markerCountForNodeMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "activeMarkerCountForNode", InternalsV8Internal::activeMarkerCountForNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "markerRangeForNode", InternalsV8Internal::markerRangeForNodeMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "markerDescriptionForNode", InternalsV8Internal::markerDescriptionForNodeMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "addTextMatchMarker", InternalsV8Internal::addTextMatchMarkerMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "addCompositionMarker", InternalsV8Internal::addCompositionMarkerMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMarkersActive", InternalsV8Internal::setMarkersActiveMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMarkedTextMatchesAreHighlighted", InternalsV8Internal::setMarkedTextMatchesAreHighlightedMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setFrameViewPosition", InternalsV8Internal::setFrameViewPositionMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "viewportAsText", InternalsV8Internal::viewportAsTextMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "elementShouldAutoComplete", InternalsV8Internal::elementShouldAutoCompleteMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "suggestedValue", InternalsV8Internal::suggestedValueMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSuggestedValue", InternalsV8Internal::setSuggestedValueMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setEditingValue", InternalsV8Internal::setEditingValueMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setAutofilled", InternalsV8Internal::setAutofilledMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "rangeFromLocationAndLength", InternalsV8Internal::rangeFromLocationAndLengthMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "locationFromRange", InternalsV8Internal::locationFromRangeMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "lengthFromRange", InternalsV8Internal::lengthFromRangeMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "rangeAsText", InternalsV8Internal::rangeAsTextMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "touchPositionAdjustedToBestClickableNode", InternalsV8Internal::touchPositionAdjustedToBestClickableNodeMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "touchNodeAdjustedToBestClickableNode", InternalsV8Internal::touchNodeAdjustedToBestClickableNodeMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "touchPositionAdjustedToBestContextMenuNode", InternalsV8Internal::touchPositionAdjustedToBestContextMenuNodeMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "touchNodeAdjustedToBestContextMenuNode", InternalsV8Internal::touchNodeAdjustedToBestContextMenuNodeMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "bestZoomableAreaForTouchPoint", InternalsV8Internal::bestZoomableAreaForTouchPointMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "lastSpellCheckRequestSequence", InternalsV8Internal::lastSpellCheckRequestSequenceMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "lastSpellCheckProcessedSequence", InternalsV8Internal::lastSpellCheckProcessedSequenceMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "userPreferredLanguages", InternalsV8Internal::userPreferredLanguagesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setUserPreferredLanguages", InternalsV8Internal::setUserPreferredLanguagesMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "mediaKeysCount", InternalsV8Internal::mediaKeysCountMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "mediaKeySessionCount", InternalsV8Internal::mediaKeySessionCountMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "suspendableObjectCount", InternalsV8Internal::suspendableObjectCountMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "wheelEventHandlerCount", InternalsV8Internal::wheelEventHandlerCountMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "scrollEventHandlerCount", InternalsV8Internal::scrollEventHandlerCountMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "touchStartOrMoveEventHandlerCount", InternalsV8Internal::touchStartOrMoveEventHandlerCountMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "touchEndOrCancelEventHandlerCount", InternalsV8Internal::touchEndOrCancelEventHandlerCountMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "touchEventTargetLayerRects", InternalsV8Internal::touchEventTargetLayerRectsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "executeCommand", InternalsV8Internal::executeCommandMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "htmlNamespace", InternalsV8Internal::htmlNamespaceMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "htmlTags", InternalsV8Internal::htmlTagsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "svgNamespace", InternalsV8Internal::svgNamespaceMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "svgTags", InternalsV8Internal::svgTagsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "nodesFromRect", InternalsV8Internal::nodesFromRectMethodCallback, 0, 9, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasSpellingMarker", InternalsV8Internal::hasSpellingMarkerMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "hasGrammarMarker", InternalsV8Internal::hasGrammarMarkerMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setSpellCheckingEnabled", InternalsV8Internal::setSpellCheckingEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "replaceMisspelled", InternalsV8Internal::replaceMisspelledMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "canHyphenate", InternalsV8Internal::canHyphenateMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMockHyphenation", InternalsV8Internal::setMockHyphenationMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isOverwriteModeEnabled", InternalsV8Internal::isOverwriteModeEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "toggleOverwriteModeEnabled", InternalsV8Internal::toggleOverwriteModeEnabledMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "numberOfScrollableAreas", InternalsV8Internal::numberOfScrollableAreasMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isPageBoxVisible", InternalsV8Internal::isPageBoxVisibleMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "layerTreeAsText", InternalsV8Internal::layerTreeAsTextMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "elementLayerTreeAsText", InternalsV8Internal::elementLayerTreeAsTextMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "scrollsWithRespectTo", InternalsV8Internal::scrollsWithRespectToMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "scrollingStateTreeAsText", InternalsV8Internal::scrollingStateTreeAsTextMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "mainThreadScrollingReasons", InternalsV8Internal::mainThreadScrollingReasonsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "nonFastScrollableRects", InternalsV8Internal::nonFastScrollableRectsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "evictAllResources", InternalsV8Internal::evictAllResourcesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "numberOfLiveNodes", InternalsV8Internal::numberOfLiveNodesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "numberOfLiveDocuments", InternalsV8Internal::numberOfLiveDocumentsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "dumpRefCountedInstanceCounts", InternalsV8Internal::dumpRefCountedInstanceCountsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "counterValue", InternalsV8Internal::counterValueMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "pageNumber", InternalsV8Internal::pageNumberMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "shortcutIconURLs", InternalsV8Internal::shortcutIconURLsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "allIconURLs", InternalsV8Internal::allIconURLsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "numberOfPages", InternalsV8Internal::numberOfPagesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "pageProperty", InternalsV8Internal::pagePropertyMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "pageSizeAndMarginsInPixels", InternalsV8Internal::pageSizeAndMarginsInPixelsMethodCallback, 0, 7, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "pageScaleFactor", InternalsV8Internal::pageScaleFactorMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPageScaleFactor", InternalsV8Internal::setPageScaleFactorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setPageScaleFactorLimits", InternalsV8Internal::setPageScaleFactorLimitsMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setIsCursorVisible", InternalsV8Internal::setIsCursorVisibleMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "effectivePreload", InternalsV8Internal::effectivePreloadMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "mediaPlayerRemoteRouteAvailabilityChanged", InternalsV8Internal::mediaPlayerRemoteRouteAvailabilityChangedMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "mediaPlayerPlayingRemotelyChanged", InternalsV8Internal::mediaPlayerPlayingRemotelyChangedMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "registerURLSchemeAsBypassingContentSecurityPolicy", InternalsV8Internal::registerURLSchemeAsBypassingContentSecurityPolicyMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", InternalsV8Internal::removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "typeConversions", InternalsV8Internal::typeConversionsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getReferencedFilePaths", InternalsV8Internal::getReferencedFilePathsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "startStoringCompositedLayerDebugInfo", InternalsV8Internal::startStoringCompositedLayerDebugInfoMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stopStoringCompositedLayerDebugInfo", InternalsV8Internal::stopStoringCompositedLayerDebugInfoMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "startTrackingRepaints", InternalsV8Internal::startTrackingRepaintsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "stopTrackingRepaints", InternalsV8Internal::stopTrackingRepaintsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks", InternalsV8Internal::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "forceFullRepaint", InternalsV8Internal::forceFullRepaintMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "draggableRegions", InternalsV8Internal::draggableRegionsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "nonDraggableRegions", InternalsV8Internal::nonDraggableRegionsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getCurrentCursorInfo", InternalsV8Internal::getCurrentCursorInfoMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "markerTextForListItem", InternalsV8Internal::markerTextForListItemMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "deserializeBuffer", InternalsV8Internal::deserializeBufferMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "serializeObject", InternalsV8Internal::serializeObjectMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "forceReload", InternalsV8Internal::forceReloadMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getImageSourceURL", InternalsV8Internal::getImageSourceURLMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "selectMenuListText", InternalsV8Internal::selectMenuListTextMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isSelectPopupVisible", InternalsV8Internal::isSelectPopupVisibleMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "selectPopupItemStyleIsRtl", InternalsV8Internal::selectPopupItemStyleIsRtlMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "selectPopupItemStyleFontHeight", InternalsV8Internal::selectPopupItemStyleFontHeightMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "resetTypeAheadSession", InternalsV8Internal::resetTypeAheadSessionMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "selectionBounds", InternalsV8Internal::selectionBoundsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "loseSharedGraphicsContext3D", InternalsV8Internal::loseSharedGraphicsContext3DMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "forceCompositingUpdate", InternalsV8Internal::forceCompositingUpdateMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setZoomFactor", InternalsV8Internal::setZoomFactorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setShouldRevealPassword", InternalsV8Internal::setShouldRevealPasswordMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "createResolvedPromise", InternalsV8Internal::createResolvedPromiseMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder },
    { "createRejectedPromise", InternalsV8Internal::createRejectedPromiseMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder },
    { "addOneToPromise", InternalsV8Internal::addOneToPromiseMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder },
    { "promiseCheck", InternalsV8Internal::promiseCheckMethodCallback, 0, 5, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder },
    { "promiseCheckWithoutExceptionState", InternalsV8Internal::promiseCheckWithoutExceptionStateMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder },
    { "promiseCheckRange", InternalsV8Internal::promiseCheckRangeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder },
    { "promiseCheckOverload", InternalsV8Internal::promiseCheckOverloadMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::DoNotCheckHolder },
    { "setValueForUser", InternalsV8Internal::setValueForUserMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "textSurroundingNode", InternalsV8Internal::textSurroundingNodeMethodCallback, 0, 4, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setFocused", InternalsV8Internal::setFocusedMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setInitialFocus", InternalsV8Internal::setInitialFocusMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "ignoreLayoutWithPendingStylesheets", InternalsV8Internal::ignoreLayoutWithPendingStylesheetsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setNetworkConnectionInfoOverride", InternalsV8Internal::setNetworkConnectionInfoOverrideMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "clearNetworkConnectionInfoOverride", InternalsV8Internal::clearNetworkConnectionInfoOverrideMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "countHitRegions", InternalsV8Internal::countHitRegionsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isInCanvasFontCache", InternalsV8Internal::isInCanvasFontCacheMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "canvasFontCacheMaxFonts", InternalsV8Internal::canvasFontCacheMaxFontsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "dictionaryTest", InternalsV8Internal::dictionaryTestMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "unionTypesTest", InternalsV8Internal::unionTypesTestMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "callbackFunctionTest", InternalsV8Internal::callbackFunctionTestMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setScrollChain", InternalsV8Internal::setScrollChainMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "forceBlinkGCWithoutV8GC", InternalsV8Internal::forceBlinkGCWithoutV8GCMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "selectedHTMLForClipboard", InternalsV8Internal::selectedHTMLForClipboardMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "selectedTextForClipboard", InternalsV8Internal::selectedTextForClipboardMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setVisualViewportOffset", InternalsV8Internal::setVisualViewportOffsetMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "visualViewportHeight", InternalsV8Internal::visualViewportHeightMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "visualViewportWidth", InternalsV8Internal::visualViewportWidthMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "visualViewportScrollX", InternalsV8Internal::visualViewportScrollXMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "visualViewportScrollY", InternalsV8Internal::visualViewportScrollYMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "magnifyScaleAroundAnchor", InternalsV8Internal::magnifyScaleAroundAnchorMethodCallback, 0, 3, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isUseCounted", InternalsV8Internal::isUseCountedMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "isCSSPropertyUseCounted", InternalsV8Internal::isCSSPropertyUseCountedMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "unscopableMethod", InternalsV8Internal::unscopableMethodMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "focusRingRects", InternalsV8Internal::focusRingRectsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "outlineRects", InternalsV8Internal::outlineRectsMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setCapsLockState", InternalsV8Internal::setCapsLockStateMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setScrollbarVisibilityInScrollableArea", InternalsV8Internal::setScrollbarVisibilityInScrollableAreaMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "monotonicTimeToZeroBasedDocumentTime", InternalsV8Internal::monotonicTimeToZeroBasedDocumentTimeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setMediaElementNetworkState", InternalsV8Internal::setMediaElementNetworkStateMethodCallback, 0, 2, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getScrollAnimationState", InternalsV8Internal::getScrollAnimationStateMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "getProgrammaticScrollAnimationState", InternalsV8Internal::getProgrammaticScrollAnimationStateMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "visualRect", InternalsV8Internal::visualRectMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "originTrialsTest", InternalsV8Internal::originTrialsTestMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "crash", InternalsV8Internal::crashMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "setIsLowEndDevice", InternalsV8Internal::setIsLowEndDeviceMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "keys", InternalsV8Internal::keysMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "values", InternalsV8Internal::valuesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "entries", InternalsV8Internal::entriesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
    { "forEach", InternalsV8Internal::forEachMethodCallback, 0, 1, v8::None, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder },
};

void V8Internals::installV8InternalsTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    // Initialize the interface object's template.
    V8DOMConfiguration::initializeDOMInterfaceTemplate(isolate, interfaceTemplate, V8Internals::wrapperTypeInfo.interfaceName, v8::Local<v8::FunctionTemplate>(), V8Internals::internalFieldCount);

    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interfaceTemplate);
    ALLOW_UNUSED_LOCAL(signature);
    v8::Local<v8::ObjectTemplate> instanceTemplate = interfaceTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = interfaceTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);

    // Register DOM constants, attributes and operations.
    const V8DOMConfiguration::ConstantConfiguration V8InternalsConstants[] = {
        { "LAYER_TREE_INCLUDES_DEBUG_INFO", 1, 0, V8DOMConfiguration::ConstantTypeUnsignedShort },
        { "LAYER_TREE_INCLUDES_PAINT_INVALIDATIONS", 2, 0, V8DOMConfiguration::ConstantTypeUnsignedShort },
        { "LAYER_TREE_INCLUDES_PAINTING_PHASES", 4, 0, V8DOMConfiguration::ConstantTypeUnsignedShort },
        { "LAYER_TREE_INCLUDES_ROOT_LAYER", 8, 0, V8DOMConfiguration::ConstantTypeUnsignedShort },
        { "LAYER_TREE_INCLUDES_CLIP_AND_SCROLL_PARENTS", 16, 0, V8DOMConfiguration::ConstantTypeUnsignedShort },
        { "LAYER_TREE_INCLUDES_COMPOSITING_REASONS", 32, 0, V8DOMConfiguration::ConstantTypeUnsignedShort },
        { "OUTPUT_AS_LAYER_TREE", 64, 0, V8DOMConfiguration::ConstantTypeUnsignedShort },
    };
    V8DOMConfiguration::installConstants(isolate, interfaceTemplate, prototypeTemplate, V8InternalsConstants, WTF_ARRAY_LENGTH(V8InternalsConstants));
    V8DOMConfiguration::installAccessors(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8InternalsAccessors, WTF_ARRAY_LENGTH(V8InternalsAccessors));
    V8DOMConfiguration::installMethods(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8InternalsMethods, WTF_ARRAY_LENGTH(V8InternalsMethods));

    // Iterator (@@iterator)
    const V8DOMConfiguration::SymbolKeyedMethodConfiguration symbolKeyedIteratorConfiguration = { v8::Symbol::GetIterator, InternalsV8Internal::iteratorMethodCallback, 0, v8::DontEnum, V8DOMConfiguration::OnPrototype };
    V8DOMConfiguration::installMethod(isolate, world, prototypeTemplate, signature, symbolKeyedIteratorConfiguration);
}

v8::Local<v8::FunctionTemplate> V8Internals::domTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world)
{
    return V8DOMConfiguration::domClassTemplate(isolate, world, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), V8Internals::installV8InternalsTemplateFunction);
}

bool V8Internals::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8Internals::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

Internals* V8Internals::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value)
{
    return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : nullptr;
}

void V8Internals::preparePrototypeAndInterfaceObject(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> prototypeObject, v8::Local<v8::Function> interfaceObject, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    v8::Isolate* isolate = context->GetIsolate();
    v8::Local<v8::Name> unscopablesSymbol(v8::Symbol::GetUnscopables(isolate));
    v8::Local<v8::Object> unscopables;
    if (v8CallBoolean(prototypeObject->HasOwnProperty(context, unscopablesSymbol)))
        unscopables = prototypeObject->Get(context, unscopablesSymbol).ToLocalChecked().As<v8::Object>();
    else
        unscopables = v8::Object::New(isolate);
    unscopables->CreateDataProperty(context, v8AtomicString(isolate, "unscopableAttribute"), v8::True(isolate)).FromJust();
    unscopables->CreateDataProperty(context, v8AtomicString(isolate, "unscopableMethod"), v8::True(isolate)).FromJust();
    prototypeObject->CreateDataProperty(context, unscopablesSymbol, unscopables).FromJust();
}

InstallTemplateFunction V8Internals::installV8InternalsTemplateFunction = (InstallTemplateFunction)&V8Internals::installV8InternalsTemplate;

void V8Internals::updateWrapperTypeInfo(InstallTemplateFunction installTemplateFunction, PreparePrototypeAndInterfaceObjectFunction preparePrototypeAndInterfaceObjectFunction)
{
    V8Internals::installV8InternalsTemplateFunction = installTemplateFunction;
    if (preparePrototypeAndInterfaceObjectFunction)
        V8Internals::wrapperTypeInfo.preparePrototypeAndInterfaceObjectFunction = preparePrototypeAndInterfaceObjectFunction;
}

} // namespace blink
