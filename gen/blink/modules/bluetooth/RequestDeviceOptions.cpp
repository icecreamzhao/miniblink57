// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/dictionary_impl.cpp.tmpl

// clang-format on
#include "RequestDeviceOptions.h"

namespace blink {

RequestDeviceOptions::RequestDeviceOptions()
{
    setAcceptAllDevices(false);
    setOptionalServices(HeapVector<StringOrUnsignedLong>());
}

RequestDeviceOptions::~RequestDeviceOptions() { }

RequestDeviceOptions::RequestDeviceOptions(const RequestDeviceOptions&) = default;

RequestDeviceOptions& RequestDeviceOptions::operator=(const RequestDeviceOptions&) = default;

bool RequestDeviceOptions::hasAcceptAllDevices() const
{
    return m_hasAcceptAllDevices;
}
bool RequestDeviceOptions::acceptAllDevices() const
{
    DCHECK(m_hasAcceptAllDevices);
    return m_acceptAllDevices;
}
void RequestDeviceOptions::setAcceptAllDevices(bool value)
{
    m_acceptAllDevices = value;
    m_hasAcceptAllDevices = true;
}
bool RequestDeviceOptions::hasFilters() const
{
    return m_hasFilters;
}
const HeapVector<BluetoothScanFilterInit>& RequestDeviceOptions::filters() const
{
    DCHECK(m_hasFilters);
    return m_filters;
}
void RequestDeviceOptions::setFilters(const HeapVector<BluetoothScanFilterInit>& value)
{
    m_filters = value;
    m_hasFilters = true;
}
bool RequestDeviceOptions::hasOptionalServices() const
{
    return m_hasOptionalServices;
}
const HeapVector<StringOrUnsignedLong>& RequestDeviceOptions::optionalServices() const
{
    DCHECK(m_hasOptionalServices);
    return m_optionalServices;
}
void RequestDeviceOptions::setOptionalServices(const HeapVector<StringOrUnsignedLong>& value)
{
    m_optionalServices = value;
    m_hasOptionalServices = true;
}

DEFINE_TRACE(RequestDeviceOptions)
{
    visitor->trace(m_filters);
    visitor->trace(m_optionalServices);
    IDLDictionaryBase::trace(visitor);
}

} // namespace blink
