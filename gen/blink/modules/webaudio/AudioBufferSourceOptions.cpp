// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/dictionary_impl.cpp.tmpl

// clang-format off
#include "AudioBufferSourceOptions.h"

#include "modules/webaudio/AudioBuffer.h"

namespace blink {

AudioBufferSourceOptions::AudioBufferSourceOptions() {
}

AudioBufferSourceOptions::~AudioBufferSourceOptions() {}

AudioBufferSourceOptions::AudioBufferSourceOptions(const AudioBufferSourceOptions&) = default;

AudioBufferSourceOptions& AudioBufferSourceOptions::operator=(const AudioBufferSourceOptions&) = default;

bool AudioBufferSourceOptions::hasBuffer() const {
  return m_buffer;
}
AudioBuffer* AudioBufferSourceOptions::buffer() const {
  return m_buffer;
}
void AudioBufferSourceOptions::setBuffer(AudioBuffer* value) {
  m_buffer = value;
}
void AudioBufferSourceOptions::setBufferToNull() {
  m_buffer = Member<AudioBuffer>();
}
bool AudioBufferSourceOptions::hasDetune() const {
  return m_hasDetune;
}
float AudioBufferSourceOptions::detune() const {
  DCHECK(m_hasDetune);
  return m_detune;
}
void AudioBufferSourceOptions::setDetune(float value) {
  m_detune = value;
  m_hasDetune = true;
}
bool AudioBufferSourceOptions::hasLoop() const {
  return m_hasLoop;
}
bool AudioBufferSourceOptions::loop() const {
  DCHECK(m_hasLoop);
  return m_loop;
}
void AudioBufferSourceOptions::setLoop(bool value) {
  m_loop = value;
  m_hasLoop = true;
}
bool AudioBufferSourceOptions::hasLoopEnd() const {
  return m_hasLoopEnd;
}
double AudioBufferSourceOptions::loopEnd() const {
  DCHECK(m_hasLoopEnd);
  return m_loopEnd;
}
void AudioBufferSourceOptions::setLoopEnd(double value) {
  m_loopEnd = value;
  m_hasLoopEnd = true;
}
bool AudioBufferSourceOptions::hasLoopStart() const {
  return m_hasLoopStart;
}
double AudioBufferSourceOptions::loopStart() const {
  DCHECK(m_hasLoopStart);
  return m_loopStart;
}
void AudioBufferSourceOptions::setLoopStart(double value) {
  m_loopStart = value;
  m_hasLoopStart = true;
}
bool AudioBufferSourceOptions::hasPlaybackRate() const {
  return m_hasPlaybackRate;
}
float AudioBufferSourceOptions::playbackRate() const {
  DCHECK(m_hasPlaybackRate);
  return m_playbackRate;
}
void AudioBufferSourceOptions::setPlaybackRate(float value) {
  m_playbackRate = value;
  m_hasPlaybackRate = true;
}

DEFINE_TRACE(AudioBufferSourceOptions) {
  visitor->trace(m_buffer);
  IDLDictionaryBase::trace(visitor);
}

}  // namespace blink
