// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/dictionary_impl.cpp.tmpl

// clang-format on
#include "AudioBufferSourceOptions.h"

#include "modules/webaudio/AudioBuffer.h"

namespace blink {

AudioBufferSourceOptions::AudioBufferSourceOptions()
{
}

AudioBufferSourceOptions::~AudioBufferSourceOptions() { }

AudioBufferSourceOptions::AudioBufferSourceOptions(const AudioBufferSourceOptions&) = default;

AudioBufferSourceOptions& AudioBufferSourceOptions::operator=(const AudioBufferSourceOptions&) = default;

bool AudioBufferSourceOptions::hasBuffer() const
{
    return m_buffer;
}
AudioBuffer* AudioBufferSourceOptions::buffer() const
{
    return m_buffer;
}
void AudioBufferSourceOptions::setBuffer(AudioBuffer* value)
{
    m_buffer = value;
}
void AudioBufferSourceOptions::setBufferToNull()
{
    m_buffer = Member<AudioBuffer>();
}
bool AudioBufferSourceOptions::hasDetune() const
{
    return m_hasDetune;
}
float AudioBufferSourceOptions::detune() const
{
    DCHECK(m_hasDetune);
    return m_detune;
}
void AudioBufferSourceOptions::setDetune(float value)
{
    m_detune = value;
    m_hasDetune = true;
}
bool AudioBufferSourceOptions::hasLoop() const
{
    return m_hasLoop;
}
bool AudioBufferSourceOptions::loop() const
{
    DCHECK(m_hasLoop);
    return m_loop;
}
void AudioBufferSourceOptions::setLoop(bool value)
{
    m_loop = value;
    m_hasLoop = true;
}
bool AudioBufferSourceOptions::hasLoopEnd() const
{
    return m_hasLoopEnd;
}
double AudioBufferSourceOptions::loopEnd() const
{
    DCHECK(m_hasLoopEnd);
    return m_loopEnd;
}
void AudioBufferSourceOptions::setLoopEnd(double value)
{
    m_loopEnd = value;
    m_hasLoopEnd = true;
}
bool AudioBufferSourceOptions::hasLoopStart() const
{
    return m_hasLoopStart;
}
double AudioBufferSourceOptions::loopStart() const
{
    DCHECK(m_hasLoopStart);
    return m_loopStart;
}
void AudioBufferSourceOptions::setLoopStart(double value)
{
    m_loopStart = value;
    m_hasLoopStart = true;
}
bool AudioBufferSourceOptions::hasPlaybackRate() const
{
    return m_hasPlaybackRate;
}
float AudioBufferSourceOptions::playbackRate() const
{
    DCHECK(m_hasPlaybackRate);
    return m_playbackRate;
}
void AudioBufferSourceOptions::setPlaybackRate(float value)
{
    m_playbackRate = value;
    m_hasPlaybackRate = true;
}

DEFINE_TRACE(AudioBufferSourceOptions)
{
    visitor->trace(m_buffer);
    IDLDictionaryBase::trace(visitor);
}

} // namespace blink
