// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_protocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "client_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace ipc {
namespace invalidation {

    void protobuf_ShutdownFile_client_5fprotocol_2eproto()
    {
        delete Version::default_instance_;
        delete ProtocolVersion::default_instance_;
        delete ClientVersion::default_instance_;
        delete StatusP::default_instance_;
        delete ObjectIdP::default_instance_;
        delete ApplicationClientIdP::default_instance_;
        delete InvalidationP::default_instance_;
        delete RegistrationP::default_instance_;
        delete RegistrationSummary::default_instance_;
        delete ClientHeader::default_instance_;
        delete ClientToServerMessage::default_instance_;
        delete InitializeMessage::default_instance_;
        delete RegistrationMessage::default_instance_;
        delete RegistrationSyncMessage::default_instance_;
        delete RegistrationSubtree::default_instance_;
        delete InfoMessage::default_instance_;
        delete PropertyRecord::default_instance_;
        delete ServerHeader::default_instance_;
        delete ServerToClientMessage::default_instance_;
        delete TokenControlMessage::default_instance_;
        delete RegistrationStatus::default_instance_;
        delete RegistrationStatusMessage::default_instance_;
        delete RegistrationSyncRequestMessage::default_instance_;
        delete InvalidationMessage::default_instance_;
        delete InfoRequestMessage::default_instance_;
        delete RateLimitP::default_instance_;
        delete ProtocolHandlerConfigP::default_instance_;
        delete ClientConfigP::default_instance_;
        delete ConfigChangeMessage::default_instance_;
        delete ErrorMessage::default_instance_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    void protobuf_AddDesc_client_5fprotocol_2eproto_impl()
    {
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
    void protobuf_AddDesc_client_5fprotocol_2eproto()
    {
        static bool already_here = false;
        if (already_here)
            return;
        already_here = true;
        GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
        Version::default_instance_ = new Version();
        ProtocolVersion::default_instance_ = new ProtocolVersion();
        ClientVersion::default_instance_ = new ClientVersion();
        StatusP::default_instance_ = new StatusP();
        ObjectIdP::default_instance_ = new ObjectIdP();
        ApplicationClientIdP::default_instance_ = new ApplicationClientIdP();
        InvalidationP::default_instance_ = new InvalidationP();
        RegistrationP::default_instance_ = new RegistrationP();
        RegistrationSummary::default_instance_ = new RegistrationSummary();
        ClientHeader::default_instance_ = new ClientHeader();
        ClientToServerMessage::default_instance_ = new ClientToServerMessage();
        InitializeMessage::default_instance_ = new InitializeMessage();
        RegistrationMessage::default_instance_ = new RegistrationMessage();
        RegistrationSyncMessage::default_instance_ = new RegistrationSyncMessage();
        RegistrationSubtree::default_instance_ = new RegistrationSubtree();
        InfoMessage::default_instance_ = new InfoMessage();
        PropertyRecord::default_instance_ = new PropertyRecord();
        ServerHeader::default_instance_ = new ServerHeader();
        ServerToClientMessage::default_instance_ = new ServerToClientMessage();
        TokenControlMessage::default_instance_ = new TokenControlMessage();
        RegistrationStatus::default_instance_ = new RegistrationStatus();
        RegistrationStatusMessage::default_instance_ = new RegistrationStatusMessage();
        RegistrationSyncRequestMessage::default_instance_ = new RegistrationSyncRequestMessage();
        InvalidationMessage::default_instance_ = new InvalidationMessage();
        InfoRequestMessage::default_instance_ = new InfoRequestMessage();
        RateLimitP::default_instance_ = new RateLimitP();
        ProtocolHandlerConfigP::default_instance_ = new ProtocolHandlerConfigP();
        ClientConfigP::default_instance_ = new ClientConfigP();
        ConfigChangeMessage::default_instance_ = new ConfigChangeMessage();
        ErrorMessage::default_instance_ = new ErrorMessage();
        Version::default_instance_->InitAsDefaultInstance();
        ProtocolVersion::default_instance_->InitAsDefaultInstance();
        ClientVersion::default_instance_->InitAsDefaultInstance();
        StatusP::default_instance_->InitAsDefaultInstance();
        ObjectIdP::default_instance_->InitAsDefaultInstance();
        ApplicationClientIdP::default_instance_->InitAsDefaultInstance();
        InvalidationP::default_instance_->InitAsDefaultInstance();
        RegistrationP::default_instance_->InitAsDefaultInstance();
        RegistrationSummary::default_instance_->InitAsDefaultInstance();
        ClientHeader::default_instance_->InitAsDefaultInstance();
        ClientToServerMessage::default_instance_->InitAsDefaultInstance();
        InitializeMessage::default_instance_->InitAsDefaultInstance();
        RegistrationMessage::default_instance_->InitAsDefaultInstance();
        RegistrationSyncMessage::default_instance_->InitAsDefaultInstance();
        RegistrationSubtree::default_instance_->InitAsDefaultInstance();
        InfoMessage::default_instance_->InitAsDefaultInstance();
        PropertyRecord::default_instance_->InitAsDefaultInstance();
        ServerHeader::default_instance_->InitAsDefaultInstance();
        ServerToClientMessage::default_instance_->InitAsDefaultInstance();
        TokenControlMessage::default_instance_->InitAsDefaultInstance();
        RegistrationStatus::default_instance_->InitAsDefaultInstance();
        RegistrationStatusMessage::default_instance_->InitAsDefaultInstance();
        RegistrationSyncRequestMessage::default_instance_->InitAsDefaultInstance();
        InvalidationMessage::default_instance_->InitAsDefaultInstance();
        InfoRequestMessage::default_instance_->InitAsDefaultInstance();
        RateLimitP::default_instance_->InitAsDefaultInstance();
        ProtocolHandlerConfigP::default_instance_->InitAsDefaultInstance();
        ClientConfigP::default_instance_->InitAsDefaultInstance();
        ConfigChangeMessage::default_instance_->InitAsDefaultInstance();
        ErrorMessage::default_instance_->InitAsDefaultInstance();
        ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_client_5fprotocol_2eproto);
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_client_5fprotocol_2eproto_once_);
    void protobuf_AddDesc_client_5fprotocol_2eproto()
    {
        ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_client_5fprotocol_2eproto_once_,
            &protobuf_AddDesc_client_5fprotocol_2eproto_impl);
    }
#else
    // Force AddDescriptors() to be called at static initialization time.
    struct StaticDescriptorInitializer_client_5fprotocol_2eproto {
        StaticDescriptorInitializer_client_5fprotocol_2eproto()
        {
            protobuf_AddDesc_client_5fprotocol_2eproto();
        }
    } static_descriptor_initializer_client_5fprotocol_2eproto_;
#endif

    namespace {

        static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
        GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line)
        {
            GOOGLE_CHECK(false) << __FILE__ << ":" << line;
        }

    } // namespace

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForVersion(
        Version* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int Version::kMajorVersionFieldNumber;
    const int Version::kMinorVersionFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    Version::Version()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.Version)
    }

    void Version::InitAsDefaultInstance()
    {
    }

    Version::Version(const Version& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.Version)
    }

    void Version::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        major_version_ = 0;
        minor_version_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    Version::~Version()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.Version)
        SharedDtor();
    }

    void Version::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void Version::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const Version& Version::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    Version* Version::default_instance_ = NULL;

    Version* Version::New(::google::protobuf::Arena* arena) const
    {
        Version* n = new Version;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void Version::Clear()
    {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.Version)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                             \
    _Pragma("clang diagnostic push")                                                              \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(Version, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<Version*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        ZR_(major_version_, minor_version_);

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool Version::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForVersion, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.Version)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 major_version = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &major_version_)));
                    set_has_major_version();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_minor_version;
                break;
            }

            // optional int32 minor_version = 2;
            case 2: {
                if (tag == 16) {
                parse_minor_version:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &minor_version_)));
                    set_has_minor_version();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.Version)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.Version)
        return false;
#undef DO_
    }

    void Version::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.Version)
        // optional int32 major_version = 1;
        if (has_major_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->major_version(), output);
        }

        // optional int32 minor_version = 2;
        if (has_minor_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->minor_version(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.Version)
    }

    int Version::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.Version)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional int32 major_version = 1;
            if (has_major_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->major_version());
            }

            // optional int32 minor_version = 2;
            if (has_minor_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->minor_version());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void Version::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const Version*>(&from));
    }

    void Version::MergeFrom(const Version& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.Version)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_major_version()) {
                set_major_version(from.major_version());
            }
            if (from.has_minor_version()) {
                set_minor_version(from.minor_version());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void Version::CopyFrom(const Version& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.Version)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool Version::IsInitialized() const
    {

        return true;
    }

    void Version::Swap(Version* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void Version::InternalSwap(Version* other)
    {
        std::swap(major_version_, other->major_version_);
        std::swap(minor_version_, other->minor_version_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string Version::GetTypeName() const
    {
        return "ipc.invalidation.Version";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // Version

    // optional int32 major_version = 1;
    bool Version::has_major_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void Version::set_has_major_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void Version::clear_has_major_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void Version::clear_major_version()
    {
        major_version_ = 0;
        clear_has_major_version();
    }
    ::google::protobuf::int32 Version::major_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.Version.major_version)
        return major_version_;
    }
    void Version::set_major_version(::google::protobuf::int32 value)
    {
        set_has_major_version();
        major_version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.Version.major_version)
    }

    // optional int32 minor_version = 2;
    bool Version::has_minor_version() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void Version::set_has_minor_version()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void Version::clear_has_minor_version()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void Version::clear_minor_version()
    {
        minor_version_ = 0;
        clear_has_minor_version();
    }
    ::google::protobuf::int32 Version::minor_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.Version.minor_version)
        return minor_version_;
    }
    void Version::set_minor_version(::google::protobuf::int32 value)
    {
        set_has_minor_version();
        minor_version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.Version.minor_version)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForProtocolVersion(
        ProtocolVersion* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ProtocolVersion::kVersionFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ProtocolVersion::ProtocolVersion()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ProtocolVersion)
    }

    void ProtocolVersion::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        version_ = const_cast<::ipc::invalidation::Version*>(
            ::ipc::invalidation::Version::internal_default_instance());
#else
        version_ = const_cast<::ipc::invalidation::Version*>(&::ipc::invalidation::Version::default_instance());
#endif
    }

    ProtocolVersion::ProtocolVersion(const ProtocolVersion& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ProtocolVersion)
    }

    void ProtocolVersion::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        version_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ProtocolVersion::~ProtocolVersion()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ProtocolVersion)
        SharedDtor();
    }

    void ProtocolVersion::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete version_;
        }
    }

    void ProtocolVersion::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ProtocolVersion& ProtocolVersion::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ProtocolVersion* ProtocolVersion::default_instance_ = NULL;

    ProtocolVersion* ProtocolVersion::New(::google::protobuf::Arena* arena) const
    {
        ProtocolVersion* n = new ProtocolVersion;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ProtocolVersion::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ProtocolVersion)
        if (has_version()) {
            if (version_ != NULL)
                version_->::ipc::invalidation::Version::Clear();
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ProtocolVersion::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForProtocolVersion, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ProtocolVersion)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.Version version = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_version()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ProtocolVersion)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ProtocolVersion)
        return false;
#undef DO_
    }

    void ProtocolVersion::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ProtocolVersion)
        // optional .ipc.invalidation.Version version = 1;
        if (has_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->version_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ProtocolVersion)
    }

    int ProtocolVersion::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ProtocolVersion)
        int total_size = 0;

        // optional .ipc.invalidation.Version version = 1;
        if (has_version()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->version_);
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ProtocolVersion::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ProtocolVersion*>(&from));
    }

    void ProtocolVersion::MergeFrom(const ProtocolVersion& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ProtocolVersion)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_version()) {
                mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ProtocolVersion::CopyFrom(const ProtocolVersion& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ProtocolVersion)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ProtocolVersion::IsInitialized() const
    {

        return true;
    }

    void ProtocolVersion::Swap(ProtocolVersion* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ProtocolVersion::InternalSwap(ProtocolVersion* other)
    {
        std::swap(version_, other->version_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ProtocolVersion::GetTypeName() const
    {
        return "ipc.invalidation.ProtocolVersion";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ProtocolVersion

    // optional .ipc.invalidation.Version version = 1;
    bool ProtocolVersion::has_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ProtocolVersion::set_has_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ProtocolVersion::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ProtocolVersion::clear_version()
    {
        if (version_ != NULL)
            version_->::ipc::invalidation::Version::Clear();
        clear_has_version();
    }
    const ::ipc::invalidation::Version& ProtocolVersion::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolVersion.version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return version_ != NULL ? *version_ : *default_instance().version_;
#else
        return version_ != NULL ? *version_ : *default_instance_->version_;
#endif
    }
    ::ipc::invalidation::Version* ProtocolVersion::mutable_version()
    {
        set_has_version();
        if (version_ == NULL) {
            version_ = new ::ipc::invalidation::Version;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolVersion.version)
        return version_;
    }
    ::ipc::invalidation::Version* ProtocolVersion::release_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ProtocolVersion.version)
        clear_has_version();
        ::ipc::invalidation::Version* temp = version_;
        version_ = NULL;
        return temp;
    }
    void ProtocolVersion::set_allocated_version(::ipc::invalidation::Version* version)
    {
        delete version_;
        version_ = version;
        if (version) {
            set_has_version();
        } else {
            clear_has_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ProtocolVersion.version)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForClientVersion(
        ClientVersion* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ClientVersion::kVersionFieldNumber;
    const int ClientVersion::kPlatformFieldNumber;
    const int ClientVersion::kLanguageFieldNumber;
    const int ClientVersion::kApplicationInfoFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ClientVersion::ClientVersion()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ClientVersion)
    }

    void ClientVersion::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        version_ = const_cast<::ipc::invalidation::Version*>(
            ::ipc::invalidation::Version::internal_default_instance());
#else
        version_ = const_cast<::ipc::invalidation::Version*>(&::ipc::invalidation::Version::default_instance());
#endif
    }

    ClientVersion::ClientVersion(const ClientVersion& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientVersion)
    }

    void ClientVersion::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        version_ = NULL;
        platform_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        application_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ClientVersion::~ClientVersion()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ClientVersion)
        SharedDtor();
    }

    void ClientVersion::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        platform_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        application_info_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete version_;
        }
    }

    void ClientVersion::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ClientVersion& ClientVersion::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ClientVersion* ClientVersion::default_instance_ = NULL;

    ClientVersion* ClientVersion::New(::google::protobuf::Arena* arena) const
    {
        ClientVersion* n = new ClientVersion;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ClientVersion::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientVersion)
        if (_has_bits_[0 / 32] & 15u) {
            if (has_version()) {
                if (version_ != NULL)
                    version_->::ipc::invalidation::Version::Clear();
            }
            if (has_platform()) {
                platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            if (has_language()) {
                language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            if (has_application_info()) {
                application_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ClientVersion::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForClientVersion, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientVersion)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.Version version = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_version()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_platform;
                break;
            }

            // optional string platform = 2;
            case 2: {
                if (tag == 18) {
                parse_platform:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_platform()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_language;
                break;
            }

            // optional string language = 3;
            case 3: {
                if (tag == 26) {
                parse_language:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_language()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_application_info;
                break;
            }

            // optional string application_info = 4;
            case 4: {
                if (tag == 34) {
                parse_application_info:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_application_info()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientVersion)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientVersion)
        return false;
#undef DO_
    }

    void ClientVersion::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientVersion)
        // optional .ipc.invalidation.Version version = 1;
        if (has_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->version_, output);
        }

        // optional string platform = 2;
        if (has_platform()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                2, this->platform(), output);
        }

        // optional string language = 3;
        if (has_language()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                3, this->language(), output);
        }

        // optional string application_info = 4;
        if (has_application_info()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                4, this->application_info(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientVersion)
    }

    int ClientVersion::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientVersion)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 15u) {
            // optional .ipc.invalidation.Version version = 1;
            if (has_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->version_);
            }

            // optional string platform = 2;
            if (has_platform()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->platform());
            }

            // optional string language = 3;
            if (has_language()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->language());
            }

            // optional string application_info = 4;
            if (has_application_info()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->application_info());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ClientVersion::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ClientVersion*>(&from));
    }

    void ClientVersion::MergeFrom(const ClientVersion& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientVersion)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_version()) {
                mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
            }
            if (from.has_platform()) {
                set_has_platform();
                platform_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.platform_);
            }
            if (from.has_language()) {
                set_has_language();
                language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
            }
            if (from.has_application_info()) {
                set_has_application_info();
                application_info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.application_info_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ClientVersion::CopyFrom(const ClientVersion& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientVersion)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ClientVersion::IsInitialized() const
    {

        return true;
    }

    void ClientVersion::Swap(ClientVersion* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ClientVersion::InternalSwap(ClientVersion* other)
    {
        std::swap(version_, other->version_);
        platform_.Swap(&other->platform_);
        language_.Swap(&other->language_);
        application_info_.Swap(&other->application_info_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ClientVersion::GetTypeName() const
    {
        return "ipc.invalidation.ClientVersion";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ClientVersion

    // optional .ipc.invalidation.Version version = 1;
    bool ClientVersion::has_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ClientVersion::set_has_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ClientVersion::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ClientVersion::clear_version()
    {
        if (version_ != NULL)
            version_->::ipc::invalidation::Version::Clear();
        clear_has_version();
    }
    const ::ipc::invalidation::Version& ClientVersion::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return version_ != NULL ? *version_ : *default_instance().version_;
#else
        return version_ != NULL ? *version_ : *default_instance_->version_;
#endif
    }
    ::ipc::invalidation::Version* ClientVersion::mutable_version()
    {
        set_has_version();
        if (version_ == NULL) {
            version_ = new ::ipc::invalidation::Version;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.version)
        return version_;
    }
    ::ipc::invalidation::Version* ClientVersion::release_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.version)
        clear_has_version();
        ::ipc::invalidation::Version* temp = version_;
        version_ = NULL;
        return temp;
    }
    void ClientVersion::set_allocated_version(::ipc::invalidation::Version* version)
    {
        delete version_;
        version_ = version;
        if (version) {
            set_has_version();
        } else {
            clear_has_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.version)
    }

    // optional string platform = 2;
    bool ClientVersion::has_platform() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ClientVersion::set_has_platform()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ClientVersion::clear_has_platform()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ClientVersion::clear_platform()
    {
        platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_platform();
    }
    const ::std::string& ClientVersion::platform() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.platform)
        return platform_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientVersion::set_platform(const ::std::string& value)
    {
        set_has_platform();
        platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.platform)
    }
    void ClientVersion::set_platform(const char* value)
    {
        set_has_platform();
        platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.platform)
    }
    void ClientVersion::set_platform(const char* value, size_t size)
    {
        set_has_platform();
        platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.platform)
    }
    ::std::string* ClientVersion::mutable_platform()
    {
        set_has_platform();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.platform)
        return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ClientVersion::release_platform()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.platform)
        clear_has_platform();
        return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientVersion::set_allocated_platform(::std::string* platform)
    {
        if (platform != NULL) {
            set_has_platform();
        } else {
            clear_has_platform();
        }
        platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.platform)
    }

    // optional string language = 3;
    bool ClientVersion::has_language() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ClientVersion::set_has_language()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ClientVersion::clear_has_language()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ClientVersion::clear_language()
    {
        language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_language();
    }
    const ::std::string& ClientVersion::language() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.language)
        return language_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientVersion::set_language(const ::std::string& value)
    {
        set_has_language();
        language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.language)
    }
    void ClientVersion::set_language(const char* value)
    {
        set_has_language();
        language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.language)
    }
    void ClientVersion::set_language(const char* value, size_t size)
    {
        set_has_language();
        language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.language)
    }
    ::std::string* ClientVersion::mutable_language()
    {
        set_has_language();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.language)
        return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ClientVersion::release_language()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.language)
        clear_has_language();
        return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientVersion::set_allocated_language(::std::string* language)
    {
        if (language != NULL) {
            set_has_language();
        } else {
            clear_has_language();
        }
        language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.language)
    }

    // optional string application_info = 4;
    bool ClientVersion::has_application_info() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void ClientVersion::set_has_application_info()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void ClientVersion::clear_has_application_info()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void ClientVersion::clear_application_info()
    {
        application_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_application_info();
    }
    const ::std::string& ClientVersion::application_info() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.application_info)
        return application_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientVersion::set_application_info(const ::std::string& value)
    {
        set_has_application_info();
        application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.application_info)
    }
    void ClientVersion::set_application_info(const char* value)
    {
        set_has_application_info();
        application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.application_info)
    }
    void ClientVersion::set_application_info(const char* value, size_t size)
    {
        set_has_application_info();
        application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.application_info)
    }
    ::std::string* ClientVersion::mutable_application_info()
    {
        set_has_application_info();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.application_info)
        return application_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ClientVersion::release_application_info()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.application_info)
        clear_has_application_info();
        return application_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientVersion::set_allocated_application_info(::std::string* application_info)
    {
        if (application_info != NULL) {
            set_has_application_info();
        } else {
            clear_has_application_info();
        }
        application_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_info);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.application_info)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForStatusP(
        StatusP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool StatusP_Code_IsValid(int value)
    {
        switch (value) {
        case 1:
        case 2:
        case 3:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const StatusP_Code StatusP::SUCCESS;
    const StatusP_Code StatusP::TRANSIENT_FAILURE;
    const StatusP_Code StatusP::PERMANENT_FAILURE;
    const StatusP_Code StatusP::Code_MIN;
    const StatusP_Code StatusP::Code_MAX;
    const int StatusP::Code_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int StatusP::kCodeFieldNumber;
    const int StatusP::kDescriptionFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    StatusP::StatusP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.StatusP)
    }

    void StatusP::InitAsDefaultInstance()
    {
    }

    StatusP::StatusP(const StatusP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.StatusP)
    }

    void StatusP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        code_ = 1;
        description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    StatusP::~StatusP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.StatusP)
        SharedDtor();
    }

    void StatusP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void StatusP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const StatusP& StatusP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    StatusP* StatusP::default_instance_ = NULL;

    StatusP* StatusP::New(::google::protobuf::Arena* arena) const
    {
        StatusP* n = new StatusP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void StatusP::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.StatusP)
        if (_has_bits_[0 / 32] & 3u) {
            code_ = 1;
            if (has_description()) {
                description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool StatusP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForStatusP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.StatusP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.StatusP.Code code = 1;
            case 1: {
                if (tag == 8) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::ipc::invalidation::StatusP_Code_IsValid(value)) {
                        set_code(static_cast<::ipc::invalidation::StatusP_Code>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(8);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_description;
                break;
            }

            // optional string description = 2;
            case 2: {
                if (tag == 18) {
                parse_description:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_description()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.StatusP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.StatusP)
        return false;
#undef DO_
    }

    void StatusP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.StatusP)
        // optional .ipc.invalidation.StatusP.Code code = 1;
        if (has_code()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                1, this->code(), output);
        }

        // optional string description = 2;
        if (has_description()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                2, this->description(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.StatusP)
    }

    int StatusP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.StatusP)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional .ipc.invalidation.StatusP.Code code = 1;
            if (has_code()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
            }

            // optional string description = 2;
            if (has_description()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->description());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void StatusP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const StatusP*>(&from));
    }

    void StatusP::MergeFrom(const StatusP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.StatusP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_code()) {
                set_code(from.code());
            }
            if (from.has_description()) {
                set_has_description();
                description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void StatusP::CopyFrom(const StatusP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.StatusP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool StatusP::IsInitialized() const
    {

        return true;
    }

    void StatusP::Swap(StatusP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void StatusP::InternalSwap(StatusP* other)
    {
        std::swap(code_, other->code_);
        description_.Swap(&other->description_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string StatusP::GetTypeName() const
    {
        return "ipc.invalidation.StatusP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // StatusP

    // optional .ipc.invalidation.StatusP.Code code = 1;
    bool StatusP::has_code() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void StatusP::set_has_code()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void StatusP::clear_has_code()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void StatusP::clear_code()
    {
        code_ = 1;
        clear_has_code();
    }
    ::ipc::invalidation::StatusP_Code StatusP::code() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.code)
        return static_cast<::ipc::invalidation::StatusP_Code>(code_);
    }
    void StatusP::set_code(::ipc::invalidation::StatusP_Code value)
    {
        assert(::ipc::invalidation::StatusP_Code_IsValid(value));
        set_has_code();
        code_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.code)
    }

    // optional string description = 2;
    bool StatusP::has_description() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void StatusP::set_has_description()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void StatusP::clear_has_description()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void StatusP::clear_description()
    {
        description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_description();
    }
    const ::std::string& StatusP::description() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.description)
        return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void StatusP::set_description(const ::std::string& value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.description)
    }
    void StatusP::set_description(const char* value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.StatusP.description)
    }
    void StatusP::set_description(const char* value, size_t size)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.StatusP.description)
    }
    ::std::string* StatusP::mutable_description()
    {
        set_has_description();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.StatusP.description)
        return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* StatusP::release_description()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.StatusP.description)
        clear_has_description();
        return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void StatusP::set_allocated_description(::std::string* description)
    {
        if (description != NULL) {
            set_has_description();
        } else {
            clear_has_description();
        }
        description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.StatusP.description)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForObjectIdP(
        ObjectIdP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ObjectIdP::kSourceFieldNumber;
    const int ObjectIdP::kNameFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ObjectIdP::ObjectIdP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ObjectIdP)
    }

    void ObjectIdP::InitAsDefaultInstance()
    {
    }

    ObjectIdP::ObjectIdP(const ObjectIdP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ObjectIdP)
    }

    void ObjectIdP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        source_ = 0;
        name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ObjectIdP::~ObjectIdP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ObjectIdP)
        SharedDtor();
    }

    void ObjectIdP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void ObjectIdP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ObjectIdP& ObjectIdP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ObjectIdP* ObjectIdP::default_instance_ = NULL;

    ObjectIdP* ObjectIdP::New(::google::protobuf::Arena* arena) const
    {
        ObjectIdP* n = new ObjectIdP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ObjectIdP::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ObjectIdP)
        if (_has_bits_[0 / 32] & 3u) {
            source_ = 0;
            if (has_name()) {
                name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ObjectIdP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForObjectIdP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ObjectIdP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 source = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &source_)));
                    set_has_source();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_name;
                break;
            }

            // optional bytes name = 2;
            case 2: {
                if (tag == 18) {
                parse_name:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_name()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ObjectIdP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ObjectIdP)
        return false;
#undef DO_
    }

    void ObjectIdP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ObjectIdP)
        // optional int32 source = 1;
        if (has_source()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->source(), output);
        }

        // optional bytes name = 2;
        if (has_name()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                2, this->name(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ObjectIdP)
    }

    int ObjectIdP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ObjectIdP)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional int32 source = 1;
            if (has_source()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->source());
            }

            // optional bytes name = 2;
            if (has_name()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->name());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ObjectIdP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ObjectIdP*>(&from));
    }

    void ObjectIdP::MergeFrom(const ObjectIdP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ObjectIdP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_source()) {
                set_source(from.source());
            }
            if (from.has_name()) {
                set_has_name();
                name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ObjectIdP::CopyFrom(const ObjectIdP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ObjectIdP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ObjectIdP::IsInitialized() const
    {

        return true;
    }

    void ObjectIdP::Swap(ObjectIdP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ObjectIdP::InternalSwap(ObjectIdP* other)
    {
        std::swap(source_, other->source_);
        name_.Swap(&other->name_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ObjectIdP::GetTypeName() const
    {
        return "ipc.invalidation.ObjectIdP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ObjectIdP

    // optional int32 source = 1;
    bool ObjectIdP::has_source() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ObjectIdP::set_has_source()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ObjectIdP::clear_has_source()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ObjectIdP::clear_source()
    {
        source_ = 0;
        clear_has_source();
    }
    ::google::protobuf::int32 ObjectIdP::source() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.source)
        return source_;
    }
    void ObjectIdP::set_source(::google::protobuf::int32 value)
    {
        set_has_source();
        source_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.source)
    }

    // optional bytes name = 2;
    bool ObjectIdP::has_name() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ObjectIdP::set_has_name()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ObjectIdP::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ObjectIdP::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    const ::std::string& ObjectIdP::name() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ObjectIdP::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.name)
    }
    void ObjectIdP::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ObjectIdP.name)
    }
    void ObjectIdP::set_name(const void* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ObjectIdP.name)
    }
    ::std::string* ObjectIdP::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ObjectIdP.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ObjectIdP::release_name()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ObjectIdP.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ObjectIdP::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ObjectIdP.name)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForApplicationClientIdP(
        ApplicationClientIdP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ApplicationClientIdP::kClientTypeFieldNumber;
    const int ApplicationClientIdP::kClientNameFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ApplicationClientIdP::ApplicationClientIdP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ApplicationClientIdP)
    }

    void ApplicationClientIdP::InitAsDefaultInstance()
    {
    }

    ApplicationClientIdP::ApplicationClientIdP(const ApplicationClientIdP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ApplicationClientIdP)
    }

    void ApplicationClientIdP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        client_type_ = 0;
        client_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ApplicationClientIdP::~ApplicationClientIdP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ApplicationClientIdP)
        SharedDtor();
    }

    void ApplicationClientIdP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        client_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void ApplicationClientIdP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ApplicationClientIdP& ApplicationClientIdP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ApplicationClientIdP* ApplicationClientIdP::default_instance_ = NULL;

    ApplicationClientIdP* ApplicationClientIdP::New(::google::protobuf::Arena* arena) const
    {
        ApplicationClientIdP* n = new ApplicationClientIdP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ApplicationClientIdP::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ApplicationClientIdP)
        if (_has_bits_[0 / 32] & 3u) {
            client_type_ = 0;
            if (has_client_name()) {
                client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ApplicationClientIdP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForApplicationClientIdP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ApplicationClientIdP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 client_type = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &client_type_)));
                    set_has_client_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_client_name;
                break;
            }

            // optional bytes client_name = 2;
            case 2: {
                if (tag == 18) {
                parse_client_name:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_client_name()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ApplicationClientIdP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ApplicationClientIdP)
        return false;
#undef DO_
    }

    void ApplicationClientIdP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ApplicationClientIdP)
        // optional int32 client_type = 1;
        if (has_client_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->client_type(), output);
        }

        // optional bytes client_name = 2;
        if (has_client_name()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                2, this->client_name(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ApplicationClientIdP)
    }

    int ApplicationClientIdP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ApplicationClientIdP)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional int32 client_type = 1;
            if (has_client_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->client_type());
            }

            // optional bytes client_name = 2;
            if (has_client_name()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->client_name());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ApplicationClientIdP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ApplicationClientIdP*>(&from));
    }

    void ApplicationClientIdP::MergeFrom(const ApplicationClientIdP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ApplicationClientIdP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_client_type()) {
                set_client_type(from.client_type());
            }
            if (from.has_client_name()) {
                set_has_client_name();
                client_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_name_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ApplicationClientIdP::CopyFrom(const ApplicationClientIdP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ApplicationClientIdP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ApplicationClientIdP::IsInitialized() const
    {

        return true;
    }

    void ApplicationClientIdP::Swap(ApplicationClientIdP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ApplicationClientIdP::InternalSwap(ApplicationClientIdP* other)
    {
        std::swap(client_type_, other->client_type_);
        client_name_.Swap(&other->client_name_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ApplicationClientIdP::GetTypeName() const
    {
        return "ipc.invalidation.ApplicationClientIdP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ApplicationClientIdP

    // optional int32 client_type = 1;
    bool ApplicationClientIdP::has_client_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ApplicationClientIdP::set_has_client_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ApplicationClientIdP::clear_has_client_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ApplicationClientIdP::clear_client_type()
    {
        client_type_ = 0;
        clear_has_client_type();
    }
    ::google::protobuf::int32 ApplicationClientIdP::client_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_type)
        return client_type_;
    }
    void ApplicationClientIdP::set_client_type(::google::protobuf::int32 value)
    {
        set_has_client_type();
        client_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_type)
    }

    // optional bytes client_name = 2;
    bool ApplicationClientIdP::has_client_name() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ApplicationClientIdP::set_has_client_name()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ApplicationClientIdP::clear_has_client_name()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ApplicationClientIdP::clear_client_name()
    {
        client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_client_name();
    }
    const ::std::string& ApplicationClientIdP::client_name() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_name)
        return client_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ApplicationClientIdP::set_client_name(const ::std::string& value)
    {
        set_has_client_name();
        client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_name)
    }
    void ApplicationClientIdP::set_client_name(const char* value)
    {
        set_has_client_name();
        client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ApplicationClientIdP.client_name)
    }
    void ApplicationClientIdP::set_client_name(const void* value, size_t size)
    {
        set_has_client_name();
        client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ApplicationClientIdP.client_name)
    }
    ::std::string* ApplicationClientIdP::mutable_client_name()
    {
        set_has_client_name();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ApplicationClientIdP.client_name)
        return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ApplicationClientIdP::release_client_name()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ApplicationClientIdP.client_name)
        clear_has_client_name();
        return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ApplicationClientIdP::set_allocated_client_name(::std::string* client_name)
    {
        if (client_name != NULL) {
            set_has_client_name();
        } else {
            clear_has_client_name();
        }
        client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ApplicationClientIdP.client_name)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForInvalidationP(
        InvalidationP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int InvalidationP::kObjectIdFieldNumber;
    const int InvalidationP::kIsKnownVersionFieldNumber;
    const int InvalidationP::kVersionFieldNumber;
    const int InvalidationP::kIsTrickleRestartFieldNumber;
    const int InvalidationP::kPayloadFieldNumber;
    const int InvalidationP::kBridgeArrivalTimeMsDeprecatedFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    InvalidationP::InvalidationP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.InvalidationP)
    }

    void InvalidationP::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        object_id_ = const_cast<::ipc::invalidation::ObjectIdP*>(
            ::ipc::invalidation::ObjectIdP::internal_default_instance());
#else
        object_id_ = const_cast<::ipc::invalidation::ObjectIdP*>(&::ipc::invalidation::ObjectIdP::default_instance());
#endif
    }

    InvalidationP::InvalidationP(const InvalidationP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InvalidationP)
    }

    void InvalidationP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        object_id_ = NULL;
        is_known_version_ = false;
        version_ = GOOGLE_LONGLONG(0);
        is_trickle_restart_ = false;
        payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        bridge_arrival_time_ms_deprecated_ = GOOGLE_LONGLONG(0);
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    InvalidationP::~InvalidationP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.InvalidationP)
        SharedDtor();
    }

    void InvalidationP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete object_id_;
        }
    }

    void InvalidationP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const InvalidationP& InvalidationP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    InvalidationP* InvalidationP::default_instance_ = NULL;

    InvalidationP* InvalidationP::New(::google::protobuf::Arena* arena) const
    {
        InvalidationP* n = new InvalidationP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void InvalidationP::Clear()
    {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InvalidationP)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                   \
    _Pragma("clang diagnostic push")                                                                    \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(InvalidationP, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<InvalidationP*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 63u) {
            ZR_(bridge_arrival_time_ms_deprecated_, is_trickle_restart_);
            if (has_object_id()) {
                if (object_id_ != NULL)
                    object_id_->::ipc::invalidation::ObjectIdP::Clear();
            }
            version_ = GOOGLE_LONGLONG(0);
            if (has_payload()) {
                payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool InvalidationP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForInvalidationP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.InvalidationP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ObjectIdP object_id = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_object_id()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_is_known_version;
                break;
            }

            // optional bool is_known_version = 2;
            case 2: {
                if (tag == 16) {
                parse_is_known_version:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &is_known_version_)));
                    set_has_is_known_version();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_version;
                break;
            }

            // optional int64 version = 3;
            case 3: {
                if (tag == 24) {
                parse_version:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                        input, &version_)));
                    set_has_version();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_payload;
                break;
            }

            // optional bytes payload = 4;
            case 4: {
                if (tag == 34) {
                parse_payload:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_payload()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(40))
                    goto parse_bridge_arrival_time_ms_deprecated;
                break;
            }

            // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
            case 5: {
                if (tag == 40) {
                parse_bridge_arrival_time_ms_deprecated:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                        input, &bridge_arrival_time_ms_deprecated_)));
                    set_has_bridge_arrival_time_ms_deprecated();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(48))
                    goto parse_is_trickle_restart;
                break;
            }

            // optional bool is_trickle_restart = 6 [default = false];
            case 6: {
                if (tag == 48) {
                parse_is_trickle_restart:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &is_trickle_restart_)));
                    set_has_is_trickle_restart();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.InvalidationP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.InvalidationP)
        return false;
#undef DO_
    }

    void InvalidationP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.InvalidationP)
        // optional .ipc.invalidation.ObjectIdP object_id = 1;
        if (has_object_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->object_id_, output);
        }

        // optional bool is_known_version = 2;
        if (has_is_known_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_known_version(), output);
        }

        // optional int64 version = 3;
        if (has_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->version(), output);
        }

        // optional bytes payload = 4;
        if (has_payload()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                4, this->payload(), output);
        }

        // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
        if (has_bridge_arrival_time_ms_deprecated()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->bridge_arrival_time_ms_deprecated(), output);
        }

        // optional bool is_trickle_restart = 6 [default = false];
        if (has_is_trickle_restart()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->is_trickle_restart(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.InvalidationP)
    }

    int InvalidationP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InvalidationP)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 63u) {
            // optional .ipc.invalidation.ObjectIdP object_id = 1;
            if (has_object_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->object_id_);
            }

            // optional bool is_known_version = 2;
            if (has_is_known_version()) {
                total_size += 1 + 1;
            }

            // optional int64 version = 3;
            if (has_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->version());
            }

            // optional bool is_trickle_restart = 6 [default = false];
            if (has_is_trickle_restart()) {
                total_size += 1 + 1;
            }

            // optional bytes payload = 4;
            if (has_payload()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->payload());
            }

            // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
            if (has_bridge_arrival_time_ms_deprecated()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->bridge_arrival_time_ms_deprecated());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void InvalidationP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const InvalidationP*>(&from));
    }

    void InvalidationP::MergeFrom(const InvalidationP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InvalidationP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_object_id()) {
                mutable_object_id()->::ipc::invalidation::ObjectIdP::MergeFrom(from.object_id());
            }
            if (from.has_is_known_version()) {
                set_is_known_version(from.is_known_version());
            }
            if (from.has_version()) {
                set_version(from.version());
            }
            if (from.has_is_trickle_restart()) {
                set_is_trickle_restart(from.is_trickle_restart());
            }
            if (from.has_payload()) {
                set_has_payload();
                payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
            }
            if (from.has_bridge_arrival_time_ms_deprecated()) {
                set_bridge_arrival_time_ms_deprecated(from.bridge_arrival_time_ms_deprecated());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void InvalidationP::CopyFrom(const InvalidationP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InvalidationP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool InvalidationP::IsInitialized() const
    {

        return true;
    }

    void InvalidationP::Swap(InvalidationP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void InvalidationP::InternalSwap(InvalidationP* other)
    {
        std::swap(object_id_, other->object_id_);
        std::swap(is_known_version_, other->is_known_version_);
        std::swap(version_, other->version_);
        std::swap(is_trickle_restart_, other->is_trickle_restart_);
        payload_.Swap(&other->payload_);
        std::swap(bridge_arrival_time_ms_deprecated_, other->bridge_arrival_time_ms_deprecated_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string InvalidationP::GetTypeName() const
    {
        return "ipc.invalidation.InvalidationP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // InvalidationP

    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    bool InvalidationP::has_object_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void InvalidationP::set_has_object_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void InvalidationP::clear_has_object_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void InvalidationP::clear_object_id()
    {
        if (object_id_ != NULL)
            object_id_->::ipc::invalidation::ObjectIdP::Clear();
        clear_has_object_id();
    }
    const ::ipc::invalidation::ObjectIdP& InvalidationP::object_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
        return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
    }
    ::ipc::invalidation::ObjectIdP* InvalidationP::mutable_object_id()
    {
        set_has_object_id();
        if (object_id_ == NULL) {
            object_id_ = new ::ipc::invalidation::ObjectIdP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.object_id)
        return object_id_;
    }
    ::ipc::invalidation::ObjectIdP* InvalidationP::release_object_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.object_id)
        clear_has_object_id();
        ::ipc::invalidation::ObjectIdP* temp = object_id_;
        object_id_ = NULL;
        return temp;
    }
    void InvalidationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id)
    {
        delete object_id_;
        object_id_ = object_id;
        if (object_id) {
            set_has_object_id();
        } else {
            clear_has_object_id();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.object_id)
    }

    // optional bool is_known_version = 2;
    bool InvalidationP::has_is_known_version() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void InvalidationP::set_has_is_known_version()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void InvalidationP::clear_has_is_known_version()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void InvalidationP::clear_is_known_version()
    {
        is_known_version_ = false;
        clear_has_is_known_version();
    }
    bool InvalidationP::is_known_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_known_version)
        return is_known_version_;
    }
    void InvalidationP::set_is_known_version(bool value)
    {
        set_has_is_known_version();
        is_known_version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_known_version)
    }

    // optional int64 version = 3;
    bool InvalidationP::has_version() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void InvalidationP::set_has_version()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void InvalidationP::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void InvalidationP::clear_version()
    {
        version_ = GOOGLE_LONGLONG(0);
        clear_has_version();
    }
    ::google::protobuf::int64 InvalidationP::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.version)
        return version_;
    }
    void InvalidationP::set_version(::google::protobuf::int64 value)
    {
        set_has_version();
        version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.version)
    }

    // optional bool is_trickle_restart = 6 [default = false];
    bool InvalidationP::has_is_trickle_restart() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void InvalidationP::set_has_is_trickle_restart()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void InvalidationP::clear_has_is_trickle_restart()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void InvalidationP::clear_is_trickle_restart()
    {
        is_trickle_restart_ = false;
        clear_has_is_trickle_restart();
    }
    bool InvalidationP::is_trickle_restart() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_trickle_restart)
        return is_trickle_restart_;
    }
    void InvalidationP::set_is_trickle_restart(bool value)
    {
        set_has_is_trickle_restart();
        is_trickle_restart_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_trickle_restart)
    }

    // optional bytes payload = 4;
    bool InvalidationP::has_payload() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void InvalidationP::set_has_payload()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void InvalidationP::clear_has_payload()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void InvalidationP::clear_payload()
    {
        payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_payload();
    }
    const ::std::string& InvalidationP::payload() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.payload)
        return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void InvalidationP::set_payload(const ::std::string& value)
    {
        set_has_payload();
        payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.payload)
    }
    void InvalidationP::set_payload(const char* value)
    {
        set_has_payload();
        payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.InvalidationP.payload)
    }
    void InvalidationP::set_payload(const void* value, size_t size)
    {
        set_has_payload();
        payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InvalidationP.payload)
    }
    ::std::string* InvalidationP::mutable_payload()
    {
        set_has_payload();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.payload)
        return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* InvalidationP::release_payload()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.payload)
        clear_has_payload();
        return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void InvalidationP::set_allocated_payload(::std::string* payload)
    {
        if (payload != NULL) {
            set_has_payload();
        } else {
            clear_has_payload();
        }
        payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.payload)
    }

    // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
    bool InvalidationP::has_bridge_arrival_time_ms_deprecated() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void InvalidationP::set_has_bridge_arrival_time_ms_deprecated()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void InvalidationP::clear_has_bridge_arrival_time_ms_deprecated()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void InvalidationP::clear_bridge_arrival_time_ms_deprecated()
    {
        bridge_arrival_time_ms_deprecated_ = GOOGLE_LONGLONG(0);
        clear_has_bridge_arrival_time_ms_deprecated();
    }
    ::google::protobuf::int64 InvalidationP::bridge_arrival_time_ms_deprecated() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
        return bridge_arrival_time_ms_deprecated_;
    }
    void InvalidationP::set_bridge_arrival_time_ms_deprecated(::google::protobuf::int64 value)
    {
        set_has_bridge_arrival_time_ms_deprecated();
        bridge_arrival_time_ms_deprecated_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationP(
        RegistrationP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool RegistrationP_OpType_IsValid(int value)
    {
        switch (value) {
        case 1:
        case 2:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const RegistrationP_OpType RegistrationP::REGISTER;
    const RegistrationP_OpType RegistrationP::UNREGISTER;
    const RegistrationP_OpType RegistrationP::OpType_MIN;
    const RegistrationP_OpType RegistrationP::OpType_MAX;
    const int RegistrationP::OpType_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RegistrationP::kObjectIdFieldNumber;
    const int RegistrationP::kOpTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationP::RegistrationP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationP)
    }

    void RegistrationP::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        object_id_ = const_cast<::ipc::invalidation::ObjectIdP*>(
            ::ipc::invalidation::ObjectIdP::internal_default_instance());
#else
        object_id_ = const_cast<::ipc::invalidation::ObjectIdP*>(&::ipc::invalidation::ObjectIdP::default_instance());
#endif
    }

    RegistrationP::RegistrationP(const RegistrationP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationP)
    }

    void RegistrationP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        object_id_ = NULL;
        op_type_ = 1;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationP::~RegistrationP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationP)
        SharedDtor();
    }

    void RegistrationP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete object_id_;
        }
    }

    void RegistrationP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationP& RegistrationP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationP* RegistrationP::default_instance_ = NULL;

    RegistrationP* RegistrationP::New(::google::protobuf::Arena* arena) const
    {
        RegistrationP* n = new RegistrationP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationP::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationP)
        if (_has_bits_[0 / 32] & 3u) {
            if (has_object_id()) {
                if (object_id_ != NULL)
                    object_id_->::ipc::invalidation::ObjectIdP::Clear();
            }
            op_type_ = 1;
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ObjectIdP object_id = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_object_id()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_op_type;
                break;
            }

            // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
            case 2: {
                if (tag == 16) {
                parse_op_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::ipc::invalidation::RegistrationP_OpType_IsValid(value)) {
                        set_op_type(static_cast<::ipc::invalidation::RegistrationP_OpType>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(16);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationP)
        return false;
#undef DO_
    }

    void RegistrationP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationP)
        // optional .ipc.invalidation.ObjectIdP object_id = 1;
        if (has_object_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->object_id_, output);
        }

        // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
        if (has_op_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                2, this->op_type(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationP)
    }

    int RegistrationP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationP)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional .ipc.invalidation.ObjectIdP object_id = 1;
            if (has_object_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->object_id_);
            }

            // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
            if (has_op_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->op_type());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationP*>(&from));
    }

    void RegistrationP::MergeFrom(const RegistrationP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_object_id()) {
                mutable_object_id()->::ipc::invalidation::ObjectIdP::MergeFrom(from.object_id());
            }
            if (from.has_op_type()) {
                set_op_type(from.op_type());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationP::CopyFrom(const RegistrationP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationP::IsInitialized() const
    {

        return true;
    }

    void RegistrationP::Swap(RegistrationP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationP::InternalSwap(RegistrationP* other)
    {
        std::swap(object_id_, other->object_id_);
        std::swap(op_type_, other->op_type_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationP::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationP

    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    bool RegistrationP::has_object_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RegistrationP::set_has_object_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RegistrationP::clear_has_object_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RegistrationP::clear_object_id()
    {
        if (object_id_ != NULL)
            object_id_->::ipc::invalidation::ObjectIdP::Clear();
        clear_has_object_id();
    }
    const ::ipc::invalidation::ObjectIdP& RegistrationP::object_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
        return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
    }
    ::ipc::invalidation::ObjectIdP* RegistrationP::mutable_object_id()
    {
        set_has_object_id();
        if (object_id_ == NULL) {
            object_id_ = new ::ipc::invalidation::ObjectIdP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationP.object_id)
        return object_id_;
    }
    ::ipc::invalidation::ObjectIdP* RegistrationP::release_object_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationP.object_id)
        clear_has_object_id();
        ::ipc::invalidation::ObjectIdP* temp = object_id_;
        object_id_ = NULL;
        return temp;
    }
    void RegistrationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id)
    {
        delete object_id_;
        object_id_ = object_id;
        if (object_id) {
            set_has_object_id();
        } else {
            clear_has_object_id();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationP.object_id)
    }

    // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
    bool RegistrationP::has_op_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RegistrationP::set_has_op_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RegistrationP::clear_has_op_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RegistrationP::clear_op_type()
    {
        op_type_ = 1;
        clear_has_op_type();
    }
    ::ipc::invalidation::RegistrationP_OpType RegistrationP::op_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.op_type)
        return static_cast<::ipc::invalidation::RegistrationP_OpType>(op_type_);
    }
    void RegistrationP::set_op_type(::ipc::invalidation::RegistrationP_OpType value)
    {
        assert(::ipc::invalidation::RegistrationP_OpType_IsValid(value));
        set_has_op_type();
        op_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationP.op_type)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationSummary(
        RegistrationSummary* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RegistrationSummary::kNumRegistrationsFieldNumber;
    const int RegistrationSummary::kRegistrationDigestFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationSummary::RegistrationSummary()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSummary)
    }

    void RegistrationSummary::InitAsDefaultInstance()
    {
    }

    RegistrationSummary::RegistrationSummary(const RegistrationSummary& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSummary)
    }

    void RegistrationSummary::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        num_registrations_ = 0;
        registration_digest_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationSummary::~RegistrationSummary()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSummary)
        SharedDtor();
    }

    void RegistrationSummary::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        registration_digest_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RegistrationSummary::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationSummary& RegistrationSummary::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationSummary* RegistrationSummary::default_instance_ = NULL;

    RegistrationSummary* RegistrationSummary::New(::google::protobuf::Arena* arena) const
    {
        RegistrationSummary* n = new RegistrationSummary;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationSummary::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSummary)
        if (_has_bits_[0 / 32] & 3u) {
            num_registrations_ = 0;
            if (has_registration_digest()) {
                registration_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationSummary::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationSummary, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSummary)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 num_registrations = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &num_registrations_)));
                    set_has_num_registrations();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_registration_digest;
                break;
            }

            // optional bytes registration_digest = 2;
            case 2: {
                if (tag == 18) {
                parse_registration_digest:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_registration_digest()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSummary)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSummary)
        return false;
#undef DO_
    }

    void RegistrationSummary::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSummary)
        // optional int32 num_registrations = 1;
        if (has_num_registrations()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num_registrations(), output);
        }

        // optional bytes registration_digest = 2;
        if (has_registration_digest()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                2, this->registration_digest(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSummary)
    }

    int RegistrationSummary::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSummary)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional int32 num_registrations = 1;
            if (has_num_registrations()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->num_registrations());
            }

            // optional bytes registration_digest = 2;
            if (has_registration_digest()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->registration_digest());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationSummary::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationSummary*>(&from));
    }

    void RegistrationSummary::MergeFrom(const RegistrationSummary& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSummary)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_num_registrations()) {
                set_num_registrations(from.num_registrations());
            }
            if (from.has_registration_digest()) {
                set_has_registration_digest();
                registration_digest_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.registration_digest_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationSummary::CopyFrom(const RegistrationSummary& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSummary)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationSummary::IsInitialized() const
    {

        return true;
    }

    void RegistrationSummary::Swap(RegistrationSummary* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationSummary::InternalSwap(RegistrationSummary* other)
    {
        std::swap(num_registrations_, other->num_registrations_);
        registration_digest_.Swap(&other->registration_digest_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationSummary::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationSummary";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationSummary

    // optional int32 num_registrations = 1;
    bool RegistrationSummary::has_num_registrations() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RegistrationSummary::set_has_num_registrations()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RegistrationSummary::clear_has_num_registrations()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RegistrationSummary::clear_num_registrations()
    {
        num_registrations_ = 0;
        clear_has_num_registrations();
    }
    ::google::protobuf::int32 RegistrationSummary::num_registrations() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.num_registrations)
        return num_registrations_;
    }
    void RegistrationSummary::set_num_registrations(::google::protobuf::int32 value)
    {
        set_has_num_registrations();
        num_registrations_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.num_registrations)
    }

    // optional bytes registration_digest = 2;
    bool RegistrationSummary::has_registration_digest() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RegistrationSummary::set_has_registration_digest()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RegistrationSummary::clear_has_registration_digest()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RegistrationSummary::clear_registration_digest()
    {
        registration_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_registration_digest();
    }
    const ::std::string& RegistrationSummary::registration_digest() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.registration_digest)
        return registration_digest_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RegistrationSummary::set_registration_digest(const ::std::string& value)
    {
        set_has_registration_digest();
        registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.registration_digest)
    }
    void RegistrationSummary::set_registration_digest(const char* value)
    {
        set_has_registration_digest();
        registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.RegistrationSummary.registration_digest)
    }
    void RegistrationSummary::set_registration_digest(const void* value, size_t size)
    {
        set_has_registration_digest();
        registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.RegistrationSummary.registration_digest)
    }
    ::std::string* RegistrationSummary::mutable_registration_digest()
    {
        set_has_registration_digest();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSummary.registration_digest)
        return registration_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* RegistrationSummary::release_registration_digest()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationSummary.registration_digest)
        clear_has_registration_digest();
        return registration_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void RegistrationSummary::set_allocated_registration_digest(::std::string* registration_digest)
    {
        if (registration_digest != NULL) {
            set_has_registration_digest();
        } else {
            clear_has_registration_digest();
        }
        registration_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), registration_digest);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationSummary.registration_digest)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForClientHeader(
        ClientHeader* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ClientHeader::kProtocolVersionFieldNumber;
    const int ClientHeader::kClientTokenFieldNumber;
    const int ClientHeader::kRegistrationSummaryFieldNumber;
    const int ClientHeader::kClientTimeMsFieldNumber;
    const int ClientHeader::kMaxKnownServerTimeMsFieldNumber;
    const int ClientHeader::kMessageIdFieldNumber;
    const int ClientHeader::kClientTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ClientHeader::ClientHeader()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ClientHeader)
    }

    void ClientHeader::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protocol_version_ = const_cast<::ipc::invalidation::ProtocolVersion*>(
            ::ipc::invalidation::ProtocolVersion::internal_default_instance());
#else
        protocol_version_ = const_cast<::ipc::invalidation::ProtocolVersion*>(&::ipc::invalidation::ProtocolVersion::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        registration_summary_ = const_cast<::ipc::invalidation::RegistrationSummary*>(
            ::ipc::invalidation::RegistrationSummary::internal_default_instance());
#else
        registration_summary_ = const_cast<::ipc::invalidation::RegistrationSummary*>(&::ipc::invalidation::RegistrationSummary::default_instance());
#endif
    }

    ClientHeader::ClientHeader(const ClientHeader& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientHeader)
    }

    void ClientHeader::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        protocol_version_ = NULL;
        client_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        registration_summary_ = NULL;
        client_time_ms_ = GOOGLE_LONGLONG(0);
        max_known_server_time_ms_ = GOOGLE_LONGLONG(0);
        message_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        client_type_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ClientHeader::~ClientHeader()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ClientHeader)
        SharedDtor();
    }

    void ClientHeader::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        client_token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        message_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete protocol_version_;
            delete registration_summary_;
        }
    }

    void ClientHeader::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ClientHeader& ClientHeader::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ClientHeader* ClientHeader::default_instance_ = NULL;

    ClientHeader* ClientHeader::New(::google::protobuf::Arena* arena) const
    {
        ClientHeader* n = new ClientHeader;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ClientHeader::Clear()
    {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientHeader)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                  \
    _Pragma("clang diagnostic push")                                                                   \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ClientHeader, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ClientHeader*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        if (_has_bits_[0 / 32] & 127u) {
            ZR_(client_time_ms_, max_known_server_time_ms_);
            if (has_protocol_version()) {
                if (protocol_version_ != NULL)
                    protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
            }
            if (has_client_token()) {
                client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            if (has_registration_summary()) {
                if (registration_summary_ != NULL)
                    registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
            }
            if (has_message_id()) {
                message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            client_type_ = 0;
        }

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ClientHeader::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForClientHeader, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientHeader)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_protocol_version()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_client_token;
                break;
            }

            // optional bytes client_token = 2;
            case 2: {
                if (tag == 18) {
                parse_client_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_client_token()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_registration_summary;
                break;
            }

            // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
            case 3: {
                if (tag == 26) {
                parse_registration_summary:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_registration_summary()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(32))
                    goto parse_client_time_ms;
                break;
            }

            // optional int64 client_time_ms = 4;
            case 4: {
                if (tag == 32) {
                parse_client_time_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                        input, &client_time_ms_)));
                    set_has_client_time_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(40))
                    goto parse_max_known_server_time_ms;
                break;
            }

            // optional int64 max_known_server_time_ms = 5;
            case 5: {
                if (tag == 40) {
                parse_max_known_server_time_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                        input, &max_known_server_time_ms_)));
                    set_has_max_known_server_time_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(50))
                    goto parse_message_id;
                break;
            }

            // optional string message_id = 6;
            case 6: {
                if (tag == 50) {
                parse_message_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_message_id()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(56))
                    goto parse_client_type;
                break;
            }

            // optional int32 client_type = 7;
            case 7: {
                if (tag == 56) {
                parse_client_type:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &client_type_)));
                    set_has_client_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientHeader)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientHeader)
        return false;
#undef DO_
    }

    void ClientHeader::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientHeader)
        // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
        if (has_protocol_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->protocol_version_, output);
        }

        // optional bytes client_token = 2;
        if (has_client_token()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                2, this->client_token(), output);
        }

        // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
        if (has_registration_summary()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->registration_summary_, output);
        }

        // optional int64 client_time_ms = 4;
        if (has_client_time_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->client_time_ms(), output);
        }

        // optional int64 max_known_server_time_ms = 5;
        if (has_max_known_server_time_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->max_known_server_time_ms(), output);
        }

        // optional string message_id = 6;
        if (has_message_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                6, this->message_id(), output);
        }

        // optional int32 client_type = 7;
        if (has_client_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->client_type(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientHeader)
    }

    int ClientHeader::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientHeader)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 127u) {
            // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
            if (has_protocol_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->protocol_version_);
            }

            // optional bytes client_token = 2;
            if (has_client_token()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->client_token());
            }

            // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
            if (has_registration_summary()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->registration_summary_);
            }

            // optional int64 client_time_ms = 4;
            if (has_client_time_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->client_time_ms());
            }

            // optional int64 max_known_server_time_ms = 5;
            if (has_max_known_server_time_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->max_known_server_time_ms());
            }

            // optional string message_id = 6;
            if (has_message_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->message_id());
            }

            // optional int32 client_type = 7;
            if (has_client_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->client_type());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ClientHeader::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ClientHeader*>(&from));
    }

    void ClientHeader::MergeFrom(const ClientHeader& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientHeader)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_protocol_version()) {
                mutable_protocol_version()->::ipc::invalidation::ProtocolVersion::MergeFrom(from.protocol_version());
            }
            if (from.has_client_token()) {
                set_has_client_token();
                client_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_token_);
            }
            if (from.has_registration_summary()) {
                mutable_registration_summary()->::ipc::invalidation::RegistrationSummary::MergeFrom(from.registration_summary());
            }
            if (from.has_client_time_ms()) {
                set_client_time_ms(from.client_time_ms());
            }
            if (from.has_max_known_server_time_ms()) {
                set_max_known_server_time_ms(from.max_known_server_time_ms());
            }
            if (from.has_message_id()) {
                set_has_message_id();
                message_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_id_);
            }
            if (from.has_client_type()) {
                set_client_type(from.client_type());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ClientHeader::CopyFrom(const ClientHeader& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientHeader)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ClientHeader::IsInitialized() const
    {

        return true;
    }

    void ClientHeader::Swap(ClientHeader* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ClientHeader::InternalSwap(ClientHeader* other)
    {
        std::swap(protocol_version_, other->protocol_version_);
        client_token_.Swap(&other->client_token_);
        std::swap(registration_summary_, other->registration_summary_);
        std::swap(client_time_ms_, other->client_time_ms_);
        std::swap(max_known_server_time_ms_, other->max_known_server_time_ms_);
        message_id_.Swap(&other->message_id_);
        std::swap(client_type_, other->client_type_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ClientHeader::GetTypeName() const
    {
        return "ipc.invalidation.ClientHeader";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ClientHeader

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    bool ClientHeader::has_protocol_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ClientHeader::set_has_protocol_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ClientHeader::clear_has_protocol_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ClientHeader::clear_protocol_version()
    {
        if (protocol_version_ != NULL)
            protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
        clear_has_protocol_version();
    }
    const ::ipc::invalidation::ProtocolVersion& ClientHeader::protocol_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.protocol_version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance().protocol_version_;
#else
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance_->protocol_version_;
#endif
    }
    ::ipc::invalidation::ProtocolVersion* ClientHeader::mutable_protocol_version()
    {
        set_has_protocol_version();
        if (protocol_version_ == NULL) {
            protocol_version_ = new ::ipc::invalidation::ProtocolVersion;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.protocol_version)
        return protocol_version_;
    }
    ::ipc::invalidation::ProtocolVersion* ClientHeader::release_protocol_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.protocol_version)
        clear_has_protocol_version();
        ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
        protocol_version_ = NULL;
        return temp;
    }
    void ClientHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version)
    {
        delete protocol_version_;
        protocol_version_ = protocol_version;
        if (protocol_version) {
            set_has_protocol_version();
        } else {
            clear_has_protocol_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.protocol_version)
    }

    // optional bytes client_token = 2;
    bool ClientHeader::has_client_token() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ClientHeader::set_has_client_token()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ClientHeader::clear_has_client_token()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ClientHeader::clear_client_token()
    {
        client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_client_token();
    }
    const ::std::string& ClientHeader::client_token() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_token)
        return client_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientHeader::set_client_token(const ::std::string& value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_token)
    }
    void ClientHeader::set_client_token(const char* value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.client_token)
    }
    void ClientHeader::set_client_token(const void* value, size_t size)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.client_token)
    }
    ::std::string* ClientHeader::mutable_client_token()
    {
        set_has_client_token();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.client_token)
        return client_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ClientHeader::release_client_token()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.client_token)
        clear_has_client_token();
        return client_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientHeader::set_allocated_client_token(::std::string* client_token)
    {
        if (client_token != NULL) {
            set_has_client_token();
        } else {
            clear_has_client_token();
        }
        client_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_token);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.client_token)
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    bool ClientHeader::has_registration_summary() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ClientHeader::set_has_registration_summary()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ClientHeader::clear_has_registration_summary()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ClientHeader::clear_registration_summary()
    {
        if (registration_summary_ != NULL)
            registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
        clear_has_registration_summary();
    }
    const ::ipc::invalidation::RegistrationSummary& ClientHeader::registration_summary() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.registration_summary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance().registration_summary_;
#else
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance_->registration_summary_;
#endif
    }
    ::ipc::invalidation::RegistrationSummary* ClientHeader::mutable_registration_summary()
    {
        set_has_registration_summary();
        if (registration_summary_ == NULL) {
            registration_summary_ = new ::ipc::invalidation::RegistrationSummary;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.registration_summary)
        return registration_summary_;
    }
    ::ipc::invalidation::RegistrationSummary* ClientHeader::release_registration_summary()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.registration_summary)
        clear_has_registration_summary();
        ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
        registration_summary_ = NULL;
        return temp;
    }
    void ClientHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary)
    {
        delete registration_summary_;
        registration_summary_ = registration_summary;
        if (registration_summary) {
            set_has_registration_summary();
        } else {
            clear_has_registration_summary();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.registration_summary)
    }

    // optional int64 client_time_ms = 4;
    bool ClientHeader::has_client_time_ms() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void ClientHeader::set_has_client_time_ms()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void ClientHeader::clear_has_client_time_ms()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void ClientHeader::clear_client_time_ms()
    {
        client_time_ms_ = GOOGLE_LONGLONG(0);
        clear_has_client_time_ms();
    }
    ::google::protobuf::int64 ClientHeader::client_time_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_time_ms)
        return client_time_ms_;
    }
    void ClientHeader::set_client_time_ms(::google::protobuf::int64 value)
    {
        set_has_client_time_ms();
        client_time_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_time_ms)
    }

    // optional int64 max_known_server_time_ms = 5;
    bool ClientHeader::has_max_known_server_time_ms() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void ClientHeader::set_has_max_known_server_time_ms()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void ClientHeader::clear_has_max_known_server_time_ms()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void ClientHeader::clear_max_known_server_time_ms()
    {
        max_known_server_time_ms_ = GOOGLE_LONGLONG(0);
        clear_has_max_known_server_time_ms();
    }
    ::google::protobuf::int64 ClientHeader::max_known_server_time_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.max_known_server_time_ms)
        return max_known_server_time_ms_;
    }
    void ClientHeader::set_max_known_server_time_ms(::google::protobuf::int64 value)
    {
        set_has_max_known_server_time_ms();
        max_known_server_time_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.max_known_server_time_ms)
    }

    // optional string message_id = 6;
    bool ClientHeader::has_message_id() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void ClientHeader::set_has_message_id()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void ClientHeader::clear_has_message_id()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void ClientHeader::clear_message_id()
    {
        message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_message_id();
    }
    const ::std::string& ClientHeader::message_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.message_id)
        return message_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientHeader::set_message_id(const ::std::string& value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.message_id)
    }
    void ClientHeader::set_message_id(const char* value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.message_id)
    }
    void ClientHeader::set_message_id(const char* value, size_t size)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.message_id)
    }
    ::std::string* ClientHeader::mutable_message_id()
    {
        set_has_message_id();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.message_id)
        return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ClientHeader::release_message_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.message_id)
        clear_has_message_id();
        return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ClientHeader::set_allocated_message_id(::std::string* message_id)
    {
        if (message_id != NULL) {
            set_has_message_id();
        } else {
            clear_has_message_id();
        }
        message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.message_id)
    }

    // optional int32 client_type = 7;
    bool ClientHeader::has_client_type() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    void ClientHeader::set_has_client_type()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    void ClientHeader::clear_has_client_type()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    void ClientHeader::clear_client_type()
    {
        client_type_ = 0;
        clear_has_client_type();
    }
    ::google::protobuf::int32 ClientHeader::client_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_type)
        return client_type_;
    }
    void ClientHeader::set_client_type(::google::protobuf::int32 value)
    {
        set_has_client_type();
        client_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_type)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForClientToServerMessage(
        ClientToServerMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ClientToServerMessage::kHeaderFieldNumber;
    const int ClientToServerMessage::kInitializeMessageFieldNumber;
    const int ClientToServerMessage::kRegistrationMessageFieldNumber;
    const int ClientToServerMessage::kRegistrationSyncMessageFieldNumber;
    const int ClientToServerMessage::kInvalidationAckMessageFieldNumber;
    const int ClientToServerMessage::kInfoMessageFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ClientToServerMessage::ClientToServerMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ClientToServerMessage)
    }

    void ClientToServerMessage::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        header_ = const_cast<::ipc::invalidation::ClientHeader*>(
            ::ipc::invalidation::ClientHeader::internal_default_instance());
#else
        header_ = const_cast<::ipc::invalidation::ClientHeader*>(&::ipc::invalidation::ClientHeader::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        initialize_message_ = const_cast<::ipc::invalidation::InitializeMessage*>(
            ::ipc::invalidation::InitializeMessage::internal_default_instance());
#else
        initialize_message_ = const_cast<::ipc::invalidation::InitializeMessage*>(&::ipc::invalidation::InitializeMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        registration_message_ = const_cast<::ipc::invalidation::RegistrationMessage*>(
            ::ipc::invalidation::RegistrationMessage::internal_default_instance());
#else
        registration_message_ = const_cast<::ipc::invalidation::RegistrationMessage*>(&::ipc::invalidation::RegistrationMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        registration_sync_message_ = const_cast<::ipc::invalidation::RegistrationSyncMessage*>(
            ::ipc::invalidation::RegistrationSyncMessage::internal_default_instance());
#else
        registration_sync_message_ = const_cast<::ipc::invalidation::RegistrationSyncMessage*>(&::ipc::invalidation::RegistrationSyncMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        invalidation_ack_message_ = const_cast<::ipc::invalidation::InvalidationMessage*>(
            ::ipc::invalidation::InvalidationMessage::internal_default_instance());
#else
        invalidation_ack_message_ = const_cast<::ipc::invalidation::InvalidationMessage*>(&::ipc::invalidation::InvalidationMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        info_message_ = const_cast<::ipc::invalidation::InfoMessage*>(
            ::ipc::invalidation::InfoMessage::internal_default_instance());
#else
        info_message_ = const_cast<::ipc::invalidation::InfoMessage*>(&::ipc::invalidation::InfoMessage::default_instance());
#endif
    }

    ClientToServerMessage::ClientToServerMessage(const ClientToServerMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientToServerMessage)
    }

    void ClientToServerMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        header_ = NULL;
        initialize_message_ = NULL;
        registration_message_ = NULL;
        registration_sync_message_ = NULL;
        invalidation_ack_message_ = NULL;
        info_message_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ClientToServerMessage::~ClientToServerMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ClientToServerMessage)
        SharedDtor();
    }

    void ClientToServerMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete header_;
            delete initialize_message_;
            delete registration_message_;
            delete registration_sync_message_;
            delete invalidation_ack_message_;
            delete info_message_;
        }
    }

    void ClientToServerMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ClientToServerMessage& ClientToServerMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ClientToServerMessage* ClientToServerMessage::default_instance_ = NULL;

    ClientToServerMessage* ClientToServerMessage::New(::google::protobuf::Arena* arena) const
    {
        ClientToServerMessage* n = new ClientToServerMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ClientToServerMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientToServerMessage)
        if (_has_bits_[0 / 32] & 63u) {
            if (has_header()) {
                if (header_ != NULL)
                    header_->::ipc::invalidation::ClientHeader::Clear();
            }
            if (has_initialize_message()) {
                if (initialize_message_ != NULL)
                    initialize_message_->::ipc::invalidation::InitializeMessage::Clear();
            }
            if (has_registration_message()) {
                if (registration_message_ != NULL)
                    registration_message_->::ipc::invalidation::RegistrationMessage::Clear();
            }
            if (has_registration_sync_message()) {
                if (registration_sync_message_ != NULL)
                    registration_sync_message_->::ipc::invalidation::RegistrationSyncMessage::Clear();
            }
            if (has_invalidation_ack_message()) {
                if (invalidation_ack_message_ != NULL)
                    invalidation_ack_message_->::ipc::invalidation::InvalidationMessage::Clear();
            }
            if (has_info_message()) {
                if (info_message_ != NULL)
                    info_message_->::ipc::invalidation::InfoMessage::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ClientToServerMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForClientToServerMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientToServerMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ClientHeader header = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_header()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_initialize_message;
                break;
            }

            // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
            case 2: {
                if (tag == 18) {
                parse_initialize_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_initialize_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_registration_message;
                break;
            }

            // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
            case 3: {
                if (tag == 26) {
                parse_registration_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_registration_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_registration_sync_message;
                break;
            }

            // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
            case 4: {
                if (tag == 34) {
                parse_registration_sync_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_registration_sync_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_invalidation_ack_message;
                break;
            }

            // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
            case 5: {
                if (tag == 42) {
                parse_invalidation_ack_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_invalidation_ack_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(50))
                    goto parse_info_message;
                break;
            }

            // optional .ipc.invalidation.InfoMessage info_message = 6;
            case 6: {
                if (tag == 50) {
                parse_info_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_info_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientToServerMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientToServerMessage)
        return false;
#undef DO_
    }

    void ClientToServerMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientToServerMessage)
        // optional .ipc.invalidation.ClientHeader header = 1;
        if (has_header()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->header_, output);
        }

        // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
        if (has_initialize_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, *this->initialize_message_, output);
        }

        // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
        if (has_registration_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->registration_message_, output);
        }

        // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
        if (has_registration_sync_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                4, *this->registration_sync_message_, output);
        }

        // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
        if (has_invalidation_ack_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, *this->invalidation_ack_message_, output);
        }

        // optional .ipc.invalidation.InfoMessage info_message = 6;
        if (has_info_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                6, *this->info_message_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientToServerMessage)
    }

    int ClientToServerMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientToServerMessage)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 63u) {
            // optional .ipc.invalidation.ClientHeader header = 1;
            if (has_header()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->header_);
            }

            // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
            if (has_initialize_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->initialize_message_);
            }

            // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
            if (has_registration_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->registration_message_);
            }

            // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
            if (has_registration_sync_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->registration_sync_message_);
            }

            // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
            if (has_invalidation_ack_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->invalidation_ack_message_);
            }

            // optional .ipc.invalidation.InfoMessage info_message = 6;
            if (has_info_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->info_message_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ClientToServerMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ClientToServerMessage*>(&from));
    }

    void ClientToServerMessage::MergeFrom(const ClientToServerMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientToServerMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_header()) {
                mutable_header()->::ipc::invalidation::ClientHeader::MergeFrom(from.header());
            }
            if (from.has_initialize_message()) {
                mutable_initialize_message()->::ipc::invalidation::InitializeMessage::MergeFrom(from.initialize_message());
            }
            if (from.has_registration_message()) {
                mutable_registration_message()->::ipc::invalidation::RegistrationMessage::MergeFrom(from.registration_message());
            }
            if (from.has_registration_sync_message()) {
                mutable_registration_sync_message()->::ipc::invalidation::RegistrationSyncMessage::MergeFrom(from.registration_sync_message());
            }
            if (from.has_invalidation_ack_message()) {
                mutable_invalidation_ack_message()->::ipc::invalidation::InvalidationMessage::MergeFrom(from.invalidation_ack_message());
            }
            if (from.has_info_message()) {
                mutable_info_message()->::ipc::invalidation::InfoMessage::MergeFrom(from.info_message());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ClientToServerMessage::CopyFrom(const ClientToServerMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientToServerMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ClientToServerMessage::IsInitialized() const
    {

        return true;
    }

    void ClientToServerMessage::Swap(ClientToServerMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ClientToServerMessage::InternalSwap(ClientToServerMessage* other)
    {
        std::swap(header_, other->header_);
        std::swap(initialize_message_, other->initialize_message_);
        std::swap(registration_message_, other->registration_message_);
        std::swap(registration_sync_message_, other->registration_sync_message_);
        std::swap(invalidation_ack_message_, other->invalidation_ack_message_);
        std::swap(info_message_, other->info_message_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ClientToServerMessage::GetTypeName() const
    {
        return "ipc.invalidation.ClientToServerMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ClientToServerMessage

    // optional .ipc.invalidation.ClientHeader header = 1;
    bool ClientToServerMessage::has_header() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ClientToServerMessage::set_has_header()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ClientToServerMessage::clear_has_header()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ClientToServerMessage::clear_header()
    {
        if (header_ != NULL)
            header_->::ipc::invalidation::ClientHeader::Clear();
        clear_has_header();
    }
    const ::ipc::invalidation::ClientHeader& ClientToServerMessage::header() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return header_ != NULL ? *header_ : *default_instance().header_;
#else
        return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
    }
    ::ipc::invalidation::ClientHeader* ClientToServerMessage::mutable_header()
    {
        set_has_header();
        if (header_ == NULL) {
            header_ = new ::ipc::invalidation::ClientHeader;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.header)
        return header_;
    }
    ::ipc::invalidation::ClientHeader* ClientToServerMessage::release_header()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.header)
        clear_has_header();
        ::ipc::invalidation::ClientHeader* temp = header_;
        header_ = NULL;
        return temp;
    }
    void ClientToServerMessage::set_allocated_header(::ipc::invalidation::ClientHeader* header)
    {
        delete header_;
        header_ = header;
        if (header) {
            set_has_header();
        } else {
            clear_has_header();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.header)
    }

    // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
    bool ClientToServerMessage::has_initialize_message() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ClientToServerMessage::set_has_initialize_message()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ClientToServerMessage::clear_has_initialize_message()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ClientToServerMessage::clear_initialize_message()
    {
        if (initialize_message_ != NULL)
            initialize_message_->::ipc::invalidation::InitializeMessage::Clear();
        clear_has_initialize_message();
    }
    const ::ipc::invalidation::InitializeMessage& ClientToServerMessage::initialize_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.initialize_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return initialize_message_ != NULL ? *initialize_message_ : *default_instance().initialize_message_;
#else
        return initialize_message_ != NULL ? *initialize_message_ : *default_instance_->initialize_message_;
#endif
    }
    ::ipc::invalidation::InitializeMessage* ClientToServerMessage::mutable_initialize_message()
    {
        set_has_initialize_message();
        if (initialize_message_ == NULL) {
            initialize_message_ = new ::ipc::invalidation::InitializeMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.initialize_message)
        return initialize_message_;
    }
    ::ipc::invalidation::InitializeMessage* ClientToServerMessage::release_initialize_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.initialize_message)
        clear_has_initialize_message();
        ::ipc::invalidation::InitializeMessage* temp = initialize_message_;
        initialize_message_ = NULL;
        return temp;
    }
    void ClientToServerMessage::set_allocated_initialize_message(::ipc::invalidation::InitializeMessage* initialize_message)
    {
        delete initialize_message_;
        initialize_message_ = initialize_message;
        if (initialize_message) {
            set_has_initialize_message();
        } else {
            clear_has_initialize_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.initialize_message)
    }

    // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
    bool ClientToServerMessage::has_registration_message() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ClientToServerMessage::set_has_registration_message()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ClientToServerMessage::clear_has_registration_message()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ClientToServerMessage::clear_registration_message()
    {
        if (registration_message_ != NULL)
            registration_message_->::ipc::invalidation::RegistrationMessage::Clear();
        clear_has_registration_message();
    }
    const ::ipc::invalidation::RegistrationMessage& ClientToServerMessage::registration_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_message_ != NULL ? *registration_message_ : *default_instance().registration_message_;
#else
        return registration_message_ != NULL ? *registration_message_ : *default_instance_->registration_message_;
#endif
    }
    ::ipc::invalidation::RegistrationMessage* ClientToServerMessage::mutable_registration_message()
    {
        set_has_registration_message();
        if (registration_message_ == NULL) {
            registration_message_ = new ::ipc::invalidation::RegistrationMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_message)
        return registration_message_;
    }
    ::ipc::invalidation::RegistrationMessage* ClientToServerMessage::release_registration_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_message)
        clear_has_registration_message();
        ::ipc::invalidation::RegistrationMessage* temp = registration_message_;
        registration_message_ = NULL;
        return temp;
    }
    void ClientToServerMessage::set_allocated_registration_message(::ipc::invalidation::RegistrationMessage* registration_message)
    {
        delete registration_message_;
        registration_message_ = registration_message;
        if (registration_message) {
            set_has_registration_message();
        } else {
            clear_has_registration_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_message)
    }

    // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
    bool ClientToServerMessage::has_registration_sync_message() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void ClientToServerMessage::set_has_registration_sync_message()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void ClientToServerMessage::clear_has_registration_sync_message()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void ClientToServerMessage::clear_registration_sync_message()
    {
        if (registration_sync_message_ != NULL)
            registration_sync_message_->::ipc::invalidation::RegistrationSyncMessage::Clear();
        clear_has_registration_sync_message();
    }
    const ::ipc::invalidation::RegistrationSyncMessage& ClientToServerMessage::registration_sync_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_sync_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_sync_message_ != NULL ? *registration_sync_message_ : *default_instance().registration_sync_message_;
#else
        return registration_sync_message_ != NULL ? *registration_sync_message_ : *default_instance_->registration_sync_message_;
#endif
    }
    ::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::mutable_registration_sync_message()
    {
        set_has_registration_sync_message();
        if (registration_sync_message_ == NULL) {
            registration_sync_message_ = new ::ipc::invalidation::RegistrationSyncMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_sync_message)
        return registration_sync_message_;
    }
    ::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::release_registration_sync_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_sync_message)
        clear_has_registration_sync_message();
        ::ipc::invalidation::RegistrationSyncMessage* temp = registration_sync_message_;
        registration_sync_message_ = NULL;
        return temp;
    }
    void ClientToServerMessage::set_allocated_registration_sync_message(::ipc::invalidation::RegistrationSyncMessage* registration_sync_message)
    {
        delete registration_sync_message_;
        registration_sync_message_ = registration_sync_message;
        if (registration_sync_message) {
            set_has_registration_sync_message();
        } else {
            clear_has_registration_sync_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_sync_message)
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
    bool ClientToServerMessage::has_invalidation_ack_message() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void ClientToServerMessage::set_has_invalidation_ack_message()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void ClientToServerMessage::clear_has_invalidation_ack_message()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void ClientToServerMessage::clear_invalidation_ack_message()
    {
        if (invalidation_ack_message_ != NULL)
            invalidation_ack_message_->::ipc::invalidation::InvalidationMessage::Clear();
        clear_has_invalidation_ack_message();
    }
    const ::ipc::invalidation::InvalidationMessage& ClientToServerMessage::invalidation_ack_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return invalidation_ack_message_ != NULL ? *invalidation_ack_message_ : *default_instance().invalidation_ack_message_;
#else
        return invalidation_ack_message_ != NULL ? *invalidation_ack_message_ : *default_instance_->invalidation_ack_message_;
#endif
    }
    ::ipc::invalidation::InvalidationMessage* ClientToServerMessage::mutable_invalidation_ack_message()
    {
        set_has_invalidation_ack_message();
        if (invalidation_ack_message_ == NULL) {
            invalidation_ack_message_ = new ::ipc::invalidation::InvalidationMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
        return invalidation_ack_message_;
    }
    ::ipc::invalidation::InvalidationMessage* ClientToServerMessage::release_invalidation_ack_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
        clear_has_invalidation_ack_message();
        ::ipc::invalidation::InvalidationMessage* temp = invalidation_ack_message_;
        invalidation_ack_message_ = NULL;
        return temp;
    }
    void ClientToServerMessage::set_allocated_invalidation_ack_message(::ipc::invalidation::InvalidationMessage* invalidation_ack_message)
    {
        delete invalidation_ack_message_;
        invalidation_ack_message_ = invalidation_ack_message;
        if (invalidation_ack_message) {
            set_has_invalidation_ack_message();
        } else {
            clear_has_invalidation_ack_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
    }

    // optional .ipc.invalidation.InfoMessage info_message = 6;
    bool ClientToServerMessage::has_info_message() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void ClientToServerMessage::set_has_info_message()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void ClientToServerMessage::clear_has_info_message()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void ClientToServerMessage::clear_info_message()
    {
        if (info_message_ != NULL)
            info_message_->::ipc::invalidation::InfoMessage::Clear();
        clear_has_info_message();
    }
    const ::ipc::invalidation::InfoMessage& ClientToServerMessage::info_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.info_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return info_message_ != NULL ? *info_message_ : *default_instance().info_message_;
#else
        return info_message_ != NULL ? *info_message_ : *default_instance_->info_message_;
#endif
    }
    ::ipc::invalidation::InfoMessage* ClientToServerMessage::mutable_info_message()
    {
        set_has_info_message();
        if (info_message_ == NULL) {
            info_message_ = new ::ipc::invalidation::InfoMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.info_message)
        return info_message_;
    }
    ::ipc::invalidation::InfoMessage* ClientToServerMessage::release_info_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.info_message)
        clear_has_info_message();
        ::ipc::invalidation::InfoMessage* temp = info_message_;
        info_message_ = NULL;
        return temp;
    }
    void ClientToServerMessage::set_allocated_info_message(::ipc::invalidation::InfoMessage* info_message)
    {
        delete info_message_;
        info_message_ = info_message;
        if (info_message) {
            set_has_info_message();
        } else {
            clear_has_info_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.info_message)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForInitializeMessage(
        InitializeMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool InitializeMessage_DigestSerializationType_IsValid(int value)
    {
        switch (value) {
        case 1:
        case 2:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const InitializeMessage_DigestSerializationType InitializeMessage::BYTE_BASED;
    const InitializeMessage_DigestSerializationType InitializeMessage::NUMBER_BASED;
    const InitializeMessage_DigestSerializationType InitializeMessage::DigestSerializationType_MIN;
    const InitializeMessage_DigestSerializationType InitializeMessage::DigestSerializationType_MAX;
    const int InitializeMessage::DigestSerializationType_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int InitializeMessage::kClientTypeFieldNumber;
    const int InitializeMessage::kNonceFieldNumber;
    const int InitializeMessage::kApplicationClientIdFieldNumber;
    const int InitializeMessage::kDigestSerializationTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    InitializeMessage::InitializeMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.InitializeMessage)
    }

    void InitializeMessage::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        application_client_id_ = const_cast<::ipc::invalidation::ApplicationClientIdP*>(
            ::ipc::invalidation::ApplicationClientIdP::internal_default_instance());
#else
        application_client_id_ = const_cast<::ipc::invalidation::ApplicationClientIdP*>(&::ipc::invalidation::ApplicationClientIdP::default_instance());
#endif
    }

    InitializeMessage::InitializeMessage(const InitializeMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InitializeMessage)
    }

    void InitializeMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        client_type_ = 0;
        nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        application_client_id_ = NULL;
        digest_serialization_type_ = 1;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    InitializeMessage::~InitializeMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.InitializeMessage)
        SharedDtor();
    }

    void InitializeMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete application_client_id_;
        }
    }

    void InitializeMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const InitializeMessage& InitializeMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    InitializeMessage* InitializeMessage::default_instance_ = NULL;

    InitializeMessage* InitializeMessage::New(::google::protobuf::Arena* arena) const
    {
        InitializeMessage* n = new InitializeMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void InitializeMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.InitializeMessage)
        if (_has_bits_[0 / 32] & 15u) {
            client_type_ = 0;
            if (has_nonce()) {
                nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            if (has_application_client_id()) {
                if (application_client_id_ != NULL)
                    application_client_id_->::ipc::invalidation::ApplicationClientIdP::Clear();
            }
            digest_serialization_type_ = 1;
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool InitializeMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForInitializeMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.InitializeMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 client_type = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &client_type_)));
                    set_has_client_type();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_nonce;
                break;
            }

            // optional bytes nonce = 2;
            case 2: {
                if (tag == 18) {
                parse_nonce:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_nonce()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_application_client_id;
                break;
            }

            // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
            case 3: {
                if (tag == 26) {
                parse_application_client_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_application_client_id()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(32))
                    goto parse_digest_serialization_type;
                break;
            }

            // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
            case 4: {
                if (tag == 32) {
                parse_digest_serialization_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(value)) {
                        set_digest_serialization_type(static_cast<::ipc::invalidation::InitializeMessage_DigestSerializationType>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(32);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.InitializeMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.InitializeMessage)
        return false;
#undef DO_
    }

    void InitializeMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.InitializeMessage)
        // optional int32 client_type = 1;
        if (has_client_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->client_type(), output);
        }

        // optional bytes nonce = 2;
        if (has_nonce()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                2, this->nonce(), output);
        }

        // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
        if (has_application_client_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->application_client_id_, output);
        }

        // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
        if (has_digest_serialization_type()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                4, this->digest_serialization_type(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.InitializeMessage)
    }

    int InitializeMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InitializeMessage)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 15u) {
            // optional int32 client_type = 1;
            if (has_client_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->client_type());
            }

            // optional bytes nonce = 2;
            if (has_nonce()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->nonce());
            }

            // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
            if (has_application_client_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->application_client_id_);
            }

            // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
            if (has_digest_serialization_type()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->digest_serialization_type());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void InitializeMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const InitializeMessage*>(&from));
    }

    void InitializeMessage::MergeFrom(const InitializeMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InitializeMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_client_type()) {
                set_client_type(from.client_type());
            }
            if (from.has_nonce()) {
                set_has_nonce();
                nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
            }
            if (from.has_application_client_id()) {
                mutable_application_client_id()->::ipc::invalidation::ApplicationClientIdP::MergeFrom(from.application_client_id());
            }
            if (from.has_digest_serialization_type()) {
                set_digest_serialization_type(from.digest_serialization_type());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void InitializeMessage::CopyFrom(const InitializeMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InitializeMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool InitializeMessage::IsInitialized() const
    {

        return true;
    }

    void InitializeMessage::Swap(InitializeMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void InitializeMessage::InternalSwap(InitializeMessage* other)
    {
        std::swap(client_type_, other->client_type_);
        nonce_.Swap(&other->nonce_);
        std::swap(application_client_id_, other->application_client_id_);
        std::swap(digest_serialization_type_, other->digest_serialization_type_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string InitializeMessage::GetTypeName() const
    {
        return "ipc.invalidation.InitializeMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // InitializeMessage

    // optional int32 client_type = 1;
    bool InitializeMessage::has_client_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void InitializeMessage::set_has_client_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void InitializeMessage::clear_has_client_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void InitializeMessage::clear_client_type()
    {
        client_type_ = 0;
        clear_has_client_type();
    }
    ::google::protobuf::int32 InitializeMessage::client_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.client_type)
        return client_type_;
    }
    void InitializeMessage::set_client_type(::google::protobuf::int32 value)
    {
        set_has_client_type();
        client_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.client_type)
    }

    // optional bytes nonce = 2;
    bool InitializeMessage::has_nonce() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void InitializeMessage::set_has_nonce()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void InitializeMessage::clear_has_nonce()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void InitializeMessage::clear_nonce()
    {
        nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_nonce();
    }
    const ::std::string& InitializeMessage::nonce() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.nonce)
        return nonce_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void InitializeMessage::set_nonce(const ::std::string& value)
    {
        set_has_nonce();
        nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.nonce)
    }
    void InitializeMessage::set_nonce(const char* value)
    {
        set_has_nonce();
        nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.InitializeMessage.nonce)
    }
    void InitializeMessage::set_nonce(const void* value, size_t size)
    {
        set_has_nonce();
        nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InitializeMessage.nonce)
    }
    ::std::string* InitializeMessage::mutable_nonce()
    {
        set_has_nonce();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.nonce)
        return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* InitializeMessage::release_nonce()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.nonce)
        clear_has_nonce();
        return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void InitializeMessage::set_allocated_nonce(::std::string* nonce)
    {
        if (nonce != NULL) {
            set_has_nonce();
        } else {
            clear_has_nonce();
        }
        nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.nonce)
    }

    // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
    bool InitializeMessage::has_application_client_id() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void InitializeMessage::set_has_application_client_id()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void InitializeMessage::clear_has_application_client_id()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void InitializeMessage::clear_application_client_id()
    {
        if (application_client_id_ != NULL)
            application_client_id_->::ipc::invalidation::ApplicationClientIdP::Clear();
        clear_has_application_client_id();
    }
    const ::ipc::invalidation::ApplicationClientIdP& InitializeMessage::application_client_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.application_client_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return application_client_id_ != NULL ? *application_client_id_ : *default_instance().application_client_id_;
#else
        return application_client_id_ != NULL ? *application_client_id_ : *default_instance_->application_client_id_;
#endif
    }
    ::ipc::invalidation::ApplicationClientIdP* InitializeMessage::mutable_application_client_id()
    {
        set_has_application_client_id();
        if (application_client_id_ == NULL) {
            application_client_id_ = new ::ipc::invalidation::ApplicationClientIdP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.application_client_id)
        return application_client_id_;
    }
    ::ipc::invalidation::ApplicationClientIdP* InitializeMessage::release_application_client_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.application_client_id)
        clear_has_application_client_id();
        ::ipc::invalidation::ApplicationClientIdP* temp = application_client_id_;
        application_client_id_ = NULL;
        return temp;
    }
    void InitializeMessage::set_allocated_application_client_id(::ipc::invalidation::ApplicationClientIdP* application_client_id)
    {
        delete application_client_id_;
        application_client_id_ = application_client_id;
        if (application_client_id) {
            set_has_application_client_id();
        } else {
            clear_has_application_client_id();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.application_client_id)
    }

    // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
    bool InitializeMessage::has_digest_serialization_type() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void InitializeMessage::set_has_digest_serialization_type()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void InitializeMessage::clear_has_digest_serialization_type()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void InitializeMessage::clear_digest_serialization_type()
    {
        digest_serialization_type_ = 1;
        clear_has_digest_serialization_type();
    }
    ::ipc::invalidation::InitializeMessage_DigestSerializationType InitializeMessage::digest_serialization_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.digest_serialization_type)
        return static_cast<::ipc::invalidation::InitializeMessage_DigestSerializationType>(digest_serialization_type_);
    }
    void InitializeMessage::set_digest_serialization_type(::ipc::invalidation::InitializeMessage_DigestSerializationType value)
    {
        assert(::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(value));
        set_has_digest_serialization_type();
        digest_serialization_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.digest_serialization_type)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationMessage(
        RegistrationMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RegistrationMessage::kRegistrationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationMessage::RegistrationMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationMessage)
    }

    void RegistrationMessage::InitAsDefaultInstance()
    {
    }

    RegistrationMessage::RegistrationMessage(const RegistrationMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationMessage)
    }

    void RegistrationMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationMessage::~RegistrationMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationMessage)
        SharedDtor();
    }

    void RegistrationMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RegistrationMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationMessage& RegistrationMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationMessage* RegistrationMessage::default_instance_ = NULL;

    RegistrationMessage* RegistrationMessage::New(::google::protobuf::Arena* arena) const
    {
        RegistrationMessage* n = new RegistrationMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationMessage)
        registration_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .ipc.invalidation.RegistrationP registration = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_registration:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_registration()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_registration;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationMessage)
        return false;
#undef DO_
    }

    void RegistrationMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationMessage)
        // repeated .ipc.invalidation.RegistrationP registration = 1;
        for (unsigned int i = 0, n = this->registration_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->registration(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationMessage)
    }

    int RegistrationMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationMessage)
        int total_size = 0;

        // repeated .ipc.invalidation.RegistrationP registration = 1;
        total_size += 1 * this->registration_size();
        for (int i = 0; i < this->registration_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->registration(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationMessage*>(&from));
    }

    void RegistrationMessage::MergeFrom(const RegistrationMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        registration_.MergeFrom(from.registration_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationMessage::CopyFrom(const RegistrationMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationMessage::IsInitialized() const
    {

        return true;
    }

    void RegistrationMessage::Swap(RegistrationMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationMessage::InternalSwap(RegistrationMessage* other)
    {
        registration_.UnsafeArenaSwap(&other->registration_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationMessage::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationMessage

    // repeated .ipc.invalidation.RegistrationP registration = 1;
    int RegistrationMessage::registration_size() const
    {
        return registration_.size();
    }
    void RegistrationMessage::clear_registration()
    {
        registration_.Clear();
    }
    const ::ipc::invalidation::RegistrationP& RegistrationMessage::registration(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationMessage.registration)
        return registration_.Get(index);
    }
    ::ipc::invalidation::RegistrationP* RegistrationMessage::mutable_registration(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationMessage.registration)
        return registration_.Mutable(index);
    }
    ::ipc::invalidation::RegistrationP* RegistrationMessage::add_registration()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationMessage.registration)
        return registration_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationP>*
    RegistrationMessage::mutable_registration()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationMessage.registration)
        return &registration_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationP>&
    RegistrationMessage::registration() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationMessage.registration)
        return registration_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationSyncMessage(
        RegistrationSyncMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RegistrationSyncMessage::kSubtreeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationSyncMessage::RegistrationSyncMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSyncMessage)
    }

    void RegistrationSyncMessage::InitAsDefaultInstance()
    {
    }

    RegistrationSyncMessage::RegistrationSyncMessage(const RegistrationSyncMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSyncMessage)
    }

    void RegistrationSyncMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationSyncMessage::~RegistrationSyncMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSyncMessage)
        SharedDtor();
    }

    void RegistrationSyncMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RegistrationSyncMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationSyncMessage& RegistrationSyncMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationSyncMessage* RegistrationSyncMessage::default_instance_ = NULL;

    RegistrationSyncMessage* RegistrationSyncMessage::New(::google::protobuf::Arena* arena) const
    {
        RegistrationSyncMessage* n = new RegistrationSyncMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationSyncMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSyncMessage)
        subtree_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationSyncMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationSyncMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSyncMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_subtree:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_subtree()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_subtree;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSyncMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSyncMessage)
        return false;
#undef DO_
    }

    void RegistrationSyncMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSyncMessage)
        // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
        for (unsigned int i = 0, n = this->subtree_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->subtree(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSyncMessage)
    }

    int RegistrationSyncMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSyncMessage)
        int total_size = 0;

        // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
        total_size += 1 * this->subtree_size();
        for (int i = 0; i < this->subtree_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->subtree(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationSyncMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationSyncMessage*>(&from));
    }

    void RegistrationSyncMessage::MergeFrom(const RegistrationSyncMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSyncMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        subtree_.MergeFrom(from.subtree_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationSyncMessage::CopyFrom(const RegistrationSyncMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSyncMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationSyncMessage::IsInitialized() const
    {

        return true;
    }

    void RegistrationSyncMessage::Swap(RegistrationSyncMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationSyncMessage::InternalSwap(RegistrationSyncMessage* other)
    {
        subtree_.UnsafeArenaSwap(&other->subtree_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationSyncMessage::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationSyncMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationSyncMessage

    // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
    int RegistrationSyncMessage::subtree_size() const
    {
        return subtree_.size();
    }
    void RegistrationSyncMessage::clear_subtree()
    {
        subtree_.Clear();
    }
    const ::ipc::invalidation::RegistrationSubtree& RegistrationSyncMessage::subtree(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_.Get(index);
    }
    ::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::mutable_subtree(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_.Mutable(index);
    }
    ::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::add_subtree()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationSubtree>*
    RegistrationSyncMessage::mutable_subtree()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSyncMessage.subtree)
        return &subtree_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationSubtree>&
    RegistrationSyncMessage::subtree() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationSubtree(
        RegistrationSubtree* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RegistrationSubtree::kRegisteredObjectFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationSubtree::RegistrationSubtree()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSubtree)
    }

    void RegistrationSubtree::InitAsDefaultInstance()
    {
    }

    RegistrationSubtree::RegistrationSubtree(const RegistrationSubtree& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSubtree)
    }

    void RegistrationSubtree::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationSubtree::~RegistrationSubtree()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSubtree)
        SharedDtor();
    }

    void RegistrationSubtree::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RegistrationSubtree::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationSubtree& RegistrationSubtree::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationSubtree* RegistrationSubtree::default_instance_ = NULL;

    RegistrationSubtree* RegistrationSubtree::New(::google::protobuf::Arena* arena) const
    {
        RegistrationSubtree* n = new RegistrationSubtree;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationSubtree::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSubtree)
        registered_object_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationSubtree::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationSubtree, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSubtree)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_registered_object:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_registered_object()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_registered_object;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSubtree)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSubtree)
        return false;
#undef DO_
    }

    void RegistrationSubtree::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSubtree)
        // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
        for (unsigned int i = 0, n = this->registered_object_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->registered_object(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSubtree)
    }

    int RegistrationSubtree::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSubtree)
        int total_size = 0;

        // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
        total_size += 1 * this->registered_object_size();
        for (int i = 0; i < this->registered_object_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->registered_object(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationSubtree::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationSubtree*>(&from));
    }

    void RegistrationSubtree::MergeFrom(const RegistrationSubtree& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSubtree)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        registered_object_.MergeFrom(from.registered_object_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationSubtree::CopyFrom(const RegistrationSubtree& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSubtree)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationSubtree::IsInitialized() const
    {

        return true;
    }

    void RegistrationSubtree::Swap(RegistrationSubtree* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationSubtree::InternalSwap(RegistrationSubtree* other)
    {
        registered_object_.UnsafeArenaSwap(&other->registered_object_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationSubtree::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationSubtree";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationSubtree

    // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
    int RegistrationSubtree::registered_object_size() const
    {
        return registered_object_.size();
    }
    void RegistrationSubtree::clear_registered_object()
    {
        registered_object_.Clear();
    }
    const ::ipc::invalidation::ObjectIdP& RegistrationSubtree::registered_object(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_.Get(index);
    }
    ::ipc::invalidation::ObjectIdP* RegistrationSubtree::mutable_registered_object(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_.Mutable(index);
    }
    ::ipc::invalidation::ObjectIdP* RegistrationSubtree::add_registered_object()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::ObjectIdP>*
    RegistrationSubtree::mutable_registered_object()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSubtree.registered_object)
        return &registered_object_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::ObjectIdP>&
    RegistrationSubtree::registered_object() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForInfoMessage(
        InfoMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int InfoMessage::kClientVersionFieldNumber;
    const int InfoMessage::kConfigParameterFieldNumber;
    const int InfoMessage::kPerformanceCounterFieldNumber;
    const int InfoMessage::kServerRegistrationSummaryRequestedFieldNumber;
    const int InfoMessage::kClientConfigFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    InfoMessage::InfoMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.InfoMessage)
    }

    void InfoMessage::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        client_version_ = const_cast<::ipc::invalidation::ClientVersion*>(
            ::ipc::invalidation::ClientVersion::internal_default_instance());
#else
        client_version_ = const_cast<::ipc::invalidation::ClientVersion*>(&::ipc::invalidation::ClientVersion::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        client_config_ = const_cast<::ipc::invalidation::ClientConfigP*>(
            ::ipc::invalidation::ClientConfigP::internal_default_instance());
#else
        client_config_ = const_cast<::ipc::invalidation::ClientConfigP*>(&::ipc::invalidation::ClientConfigP::default_instance());
#endif
    }

    InfoMessage::InfoMessage(const InfoMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InfoMessage)
    }

    void InfoMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        client_version_ = NULL;
        server_registration_summary_requested_ = false;
        client_config_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    InfoMessage::~InfoMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.InfoMessage)
        SharedDtor();
    }

    void InfoMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete client_version_;
            delete client_config_;
        }
    }

    void InfoMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const InfoMessage& InfoMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    InfoMessage* InfoMessage::default_instance_ = NULL;

    InfoMessage* InfoMessage::New(::google::protobuf::Arena* arena) const
    {
        InfoMessage* n = new InfoMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void InfoMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.InfoMessage)
        if (_has_bits_[0 / 32] & 25u) {
            if (has_client_version()) {
                if (client_version_ != NULL)
                    client_version_->::ipc::invalidation::ClientVersion::Clear();
            }
            server_registration_summary_requested_ = false;
            if (has_client_config()) {
                if (client_config_ != NULL)
                    client_config_->::ipc::invalidation::ClientConfigP::Clear();
            }
        }
        config_parameter_.Clear();
        performance_counter_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool InfoMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForInfoMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.InfoMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ClientVersion client_version = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_client_version()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_config_parameter;
                break;
            }

            // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
            case 2: {
                if (tag == 18) {
                parse_config_parameter:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_config_parameter:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_config_parameter()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_loop_config_parameter;
                if (input->ExpectTag(26))
                    goto parse_loop_performance_counter;
                input->UnsafeDecrementRecursionDepth();
                break;
            }

            // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
            case 3: {
                if (tag == 26) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_performance_counter:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_performance_counter()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_loop_performance_counter;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectTag(32))
                    goto parse_server_registration_summary_requested;
                break;
            }

            // optional bool server_registration_summary_requested = 4;
            case 4: {
                if (tag == 32) {
                parse_server_registration_summary_requested:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &server_registration_summary_requested_)));
                    set_has_server_registration_summary_requested();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_client_config;
                break;
            }

            // optional .ipc.invalidation.ClientConfigP client_config = 5;
            case 5: {
                if (tag == 42) {
                parse_client_config:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_client_config()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.InfoMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.InfoMessage)
        return false;
#undef DO_
    }

    void InfoMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.InfoMessage)
        // optional .ipc.invalidation.ClientVersion client_version = 1;
        if (has_client_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->client_version_, output);
        }

        // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
        for (unsigned int i = 0, n = this->config_parameter_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, this->config_parameter(i), output);
        }

        // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
        for (unsigned int i = 0, n = this->performance_counter_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, this->performance_counter(i), output);
        }

        // optional bool server_registration_summary_requested = 4;
        if (has_server_registration_summary_requested()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->server_registration_summary_requested(), output);
        }

        // optional .ipc.invalidation.ClientConfigP client_config = 5;
        if (has_client_config()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, *this->client_config_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.InfoMessage)
    }

    int InfoMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InfoMessage)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 25u) {
            // optional .ipc.invalidation.ClientVersion client_version = 1;
            if (has_client_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->client_version_);
            }

            // optional bool server_registration_summary_requested = 4;
            if (has_server_registration_summary_requested()) {
                total_size += 1 + 1;
            }

            // optional .ipc.invalidation.ClientConfigP client_config = 5;
            if (has_client_config()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->client_config_);
            }
        }
        // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
        total_size += 1 * this->config_parameter_size();
        for (int i = 0; i < this->config_parameter_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->config_parameter(i));
        }

        // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
        total_size += 1 * this->performance_counter_size();
        for (int i = 0; i < this->performance_counter_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->performance_counter(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void InfoMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const InfoMessage*>(&from));
    }

    void InfoMessage::MergeFrom(const InfoMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InfoMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        config_parameter_.MergeFrom(from.config_parameter_);
        performance_counter_.MergeFrom(from.performance_counter_);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_client_version()) {
                mutable_client_version()->::ipc::invalidation::ClientVersion::MergeFrom(from.client_version());
            }
            if (from.has_server_registration_summary_requested()) {
                set_server_registration_summary_requested(from.server_registration_summary_requested());
            }
            if (from.has_client_config()) {
                mutable_client_config()->::ipc::invalidation::ClientConfigP::MergeFrom(from.client_config());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void InfoMessage::CopyFrom(const InfoMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InfoMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool InfoMessage::IsInitialized() const
    {

        return true;
    }

    void InfoMessage::Swap(InfoMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void InfoMessage::InternalSwap(InfoMessage* other)
    {
        std::swap(client_version_, other->client_version_);
        config_parameter_.UnsafeArenaSwap(&other->config_parameter_);
        performance_counter_.UnsafeArenaSwap(&other->performance_counter_);
        std::swap(server_registration_summary_requested_, other->server_registration_summary_requested_);
        std::swap(client_config_, other->client_config_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string InfoMessage::GetTypeName() const
    {
        return "ipc.invalidation.InfoMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // InfoMessage

    // optional .ipc.invalidation.ClientVersion client_version = 1;
    bool InfoMessage::has_client_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void InfoMessage::set_has_client_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void InfoMessage::clear_has_client_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void InfoMessage::clear_client_version()
    {
        if (client_version_ != NULL)
            client_version_->::ipc::invalidation::ClientVersion::Clear();
        clear_has_client_version();
    }
    const ::ipc::invalidation::ClientVersion& InfoMessage::client_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return client_version_ != NULL ? *client_version_ : *default_instance().client_version_;
#else
        return client_version_ != NULL ? *client_version_ : *default_instance_->client_version_;
#endif
    }
    ::ipc::invalidation::ClientVersion* InfoMessage::mutable_client_version()
    {
        set_has_client_version();
        if (client_version_ == NULL) {
            client_version_ = new ::ipc::invalidation::ClientVersion;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_version)
        return client_version_;
    }
    ::ipc::invalidation::ClientVersion* InfoMessage::release_client_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_version)
        clear_has_client_version();
        ::ipc::invalidation::ClientVersion* temp = client_version_;
        client_version_ = NULL;
        return temp;
    }
    void InfoMessage::set_allocated_client_version(::ipc::invalidation::ClientVersion* client_version)
    {
        delete client_version_;
        client_version_ = client_version;
        if (client_version) {
            set_has_client_version();
        } else {
            clear_has_client_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_version)
    }

    // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
    int InfoMessage::config_parameter_size() const
    {
        return config_parameter_.size();
    }
    void InfoMessage::clear_config_parameter()
    {
        config_parameter_.Clear();
    }
    const ::ipc::invalidation::PropertyRecord& InfoMessage::config_parameter(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_.Get(index);
    }
    ::ipc::invalidation::PropertyRecord* InfoMessage::mutable_config_parameter(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_.Mutable(index);
    }
    ::ipc::invalidation::PropertyRecord* InfoMessage::add_config_parameter()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>*
    InfoMessage::mutable_config_parameter()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.config_parameter)
        return &config_parameter_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>&
    InfoMessage::config_parameter() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_;
    }

    // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
    int InfoMessage::performance_counter_size() const
    {
        return performance_counter_.size();
    }
    void InfoMessage::clear_performance_counter()
    {
        performance_counter_.Clear();
    }
    const ::ipc::invalidation::PropertyRecord& InfoMessage::performance_counter(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_.Get(index);
    }
    ::ipc::invalidation::PropertyRecord* InfoMessage::mutable_performance_counter(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_.Mutable(index);
    }
    ::ipc::invalidation::PropertyRecord* InfoMessage::add_performance_counter()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>*
    InfoMessage::mutable_performance_counter()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.performance_counter)
        return &performance_counter_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>&
    InfoMessage::performance_counter() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_;
    }

    // optional bool server_registration_summary_requested = 4;
    bool InfoMessage::has_server_registration_summary_requested() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void InfoMessage::set_has_server_registration_summary_requested()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void InfoMessage::clear_has_server_registration_summary_requested()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void InfoMessage::clear_server_registration_summary_requested()
    {
        server_registration_summary_requested_ = false;
        clear_has_server_registration_summary_requested();
    }
    bool InfoMessage::server_registration_summary_requested() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.server_registration_summary_requested)
        return server_registration_summary_requested_;
    }
    void InfoMessage::set_server_registration_summary_requested(bool value)
    {
        set_has_server_registration_summary_requested();
        server_registration_summary_requested_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InfoMessage.server_registration_summary_requested)
    }

    // optional .ipc.invalidation.ClientConfigP client_config = 5;
    bool InfoMessage::has_client_config() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void InfoMessage::set_has_client_config()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void InfoMessage::clear_has_client_config()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void InfoMessage::clear_client_config()
    {
        if (client_config_ != NULL)
            client_config_->::ipc::invalidation::ClientConfigP::Clear();
        clear_has_client_config();
    }
    const ::ipc::invalidation::ClientConfigP& InfoMessage::client_config() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return client_config_ != NULL ? *client_config_ : *default_instance().client_config_;
#else
        return client_config_ != NULL ? *client_config_ : *default_instance_->client_config_;
#endif
    }
    ::ipc::invalidation::ClientConfigP* InfoMessage::mutable_client_config()
    {
        set_has_client_config();
        if (client_config_ == NULL) {
            client_config_ = new ::ipc::invalidation::ClientConfigP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_config)
        return client_config_;
    }
    ::ipc::invalidation::ClientConfigP* InfoMessage::release_client_config()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_config)
        clear_has_client_config();
        ::ipc::invalidation::ClientConfigP* temp = client_config_;
        client_config_ = NULL;
        return temp;
    }
    void InfoMessage::set_allocated_client_config(::ipc::invalidation::ClientConfigP* client_config)
    {
        delete client_config_;
        client_config_ = client_config;
        if (client_config) {
            set_has_client_config();
        } else {
            clear_has_client_config();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_config)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForPropertyRecord(
        PropertyRecord* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int PropertyRecord::kNameFieldNumber;
    const int PropertyRecord::kValueFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    PropertyRecord::PropertyRecord()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.PropertyRecord)
    }

    void PropertyRecord::InitAsDefaultInstance()
    {
    }

    PropertyRecord::PropertyRecord(const PropertyRecord& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.PropertyRecord)
    }

    void PropertyRecord::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        value_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    PropertyRecord::~PropertyRecord()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.PropertyRecord)
        SharedDtor();
    }

    void PropertyRecord::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void PropertyRecord::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const PropertyRecord& PropertyRecord::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    PropertyRecord* PropertyRecord::default_instance_ = NULL;

    PropertyRecord* PropertyRecord::New(::google::protobuf::Arena* arena) const
    {
        PropertyRecord* n = new PropertyRecord;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void PropertyRecord::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.PropertyRecord)
        if (_has_bits_[0 / 32] & 3u) {
            if (has_name()) {
                name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            value_ = 0;
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool PropertyRecord::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForPropertyRecord, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.PropertyRecord)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional string name = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_name()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_value;
                break;
            }

            // optional int32 value = 2;
            case 2: {
                if (tag == 16) {
                parse_value:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &value_)));
                    set_has_value();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.PropertyRecord)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.PropertyRecord)
        return false;
#undef DO_
    }

    void PropertyRecord::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.PropertyRecord)
        // optional string name = 1;
        if (has_name()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                1, this->name(), output);
        }

        // optional int32 value = 2;
        if (has_value()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->value(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.PropertyRecord)
    }

    int PropertyRecord::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.PropertyRecord)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional string name = 1;
            if (has_name()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->name());
            }

            // optional int32 value = 2;
            if (has_value()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->value());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void PropertyRecord::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const PropertyRecord*>(&from));
    }

    void PropertyRecord::MergeFrom(const PropertyRecord& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.PropertyRecord)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_name()) {
                set_has_name();
                name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
            }
            if (from.has_value()) {
                set_value(from.value());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void PropertyRecord::CopyFrom(const PropertyRecord& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.PropertyRecord)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool PropertyRecord::IsInitialized() const
    {

        return true;
    }

    void PropertyRecord::Swap(PropertyRecord* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void PropertyRecord::InternalSwap(PropertyRecord* other)
    {
        name_.Swap(&other->name_);
        std::swap(value_, other->value_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string PropertyRecord::GetTypeName() const
    {
        return "ipc.invalidation.PropertyRecord";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // PropertyRecord

    // optional string name = 1;
    bool PropertyRecord::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void PropertyRecord::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void PropertyRecord::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void PropertyRecord::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    const ::std::string& PropertyRecord::name() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void PropertyRecord::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.name)
    }
    void PropertyRecord::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.PropertyRecord.name)
    }
    void PropertyRecord::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.PropertyRecord.name)
    }
    ::std::string* PropertyRecord::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.PropertyRecord.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* PropertyRecord::release_name()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.PropertyRecord.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void PropertyRecord::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.PropertyRecord.name)
    }

    // optional int32 value = 2;
    bool PropertyRecord::has_value() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void PropertyRecord::set_has_value()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void PropertyRecord::clear_has_value()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void PropertyRecord::clear_value()
    {
        value_ = 0;
        clear_has_value();
    }
    ::google::protobuf::int32 PropertyRecord::value() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.value)
        return value_;
    }
    void PropertyRecord::set_value(::google::protobuf::int32 value)
    {
        set_has_value();
        value_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.value)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForServerHeader(
        ServerHeader* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ServerHeader::kProtocolVersionFieldNumber;
    const int ServerHeader::kClientTokenFieldNumber;
    const int ServerHeader::kRegistrationSummaryFieldNumber;
    const int ServerHeader::kServerTimeMsFieldNumber;
    const int ServerHeader::kMessageIdFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ServerHeader::ServerHeader()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ServerHeader)
    }

    void ServerHeader::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protocol_version_ = const_cast<::ipc::invalidation::ProtocolVersion*>(
            ::ipc::invalidation::ProtocolVersion::internal_default_instance());
#else
        protocol_version_ = const_cast<::ipc::invalidation::ProtocolVersion*>(&::ipc::invalidation::ProtocolVersion::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        registration_summary_ = const_cast<::ipc::invalidation::RegistrationSummary*>(
            ::ipc::invalidation::RegistrationSummary::internal_default_instance());
#else
        registration_summary_ = const_cast<::ipc::invalidation::RegistrationSummary*>(&::ipc::invalidation::RegistrationSummary::default_instance());
#endif
    }

    ServerHeader::ServerHeader(const ServerHeader& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ServerHeader)
    }

    void ServerHeader::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        protocol_version_ = NULL;
        client_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        registration_summary_ = NULL;
        server_time_ms_ = GOOGLE_LONGLONG(0);
        message_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ServerHeader::~ServerHeader()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ServerHeader)
        SharedDtor();
    }

    void ServerHeader::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        client_token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        message_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete protocol_version_;
            delete registration_summary_;
        }
    }

    void ServerHeader::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ServerHeader& ServerHeader::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ServerHeader* ServerHeader::default_instance_ = NULL;

    ServerHeader* ServerHeader::New(::google::protobuf::Arena* arena) const
    {
        ServerHeader* n = new ServerHeader;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ServerHeader::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ServerHeader)
        if (_has_bits_[0 / 32] & 31u) {
            if (has_protocol_version()) {
                if (protocol_version_ != NULL)
                    protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
            }
            if (has_client_token()) {
                client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            if (has_registration_summary()) {
                if (registration_summary_ != NULL)
                    registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
            }
            server_time_ms_ = GOOGLE_LONGLONG(0);
            if (has_message_id()) {
                message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ServerHeader::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForServerHeader, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ServerHeader)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_protocol_version()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_client_token;
                break;
            }

            // optional bytes client_token = 2;
            case 2: {
                if (tag == 18) {
                parse_client_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_client_token()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_registration_summary;
                break;
            }

            // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
            case 3: {
                if (tag == 26) {
                parse_registration_summary:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_registration_summary()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(32))
                    goto parse_server_time_ms;
                break;
            }

            // optional int64 server_time_ms = 4;
            case 4: {
                if (tag == 32) {
                parse_server_time_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                        input, &server_time_ms_)));
                    set_has_server_time_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_message_id;
                break;
            }

            // optional string message_id = 5;
            case 5: {
                if (tag == 42) {
                parse_message_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_message_id()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ServerHeader)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ServerHeader)
        return false;
#undef DO_
    }

    void ServerHeader::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ServerHeader)
        // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
        if (has_protocol_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->protocol_version_, output);
        }

        // optional bytes client_token = 2;
        if (has_client_token()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                2, this->client_token(), output);
        }

        // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
        if (has_registration_summary()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->registration_summary_, output);
        }

        // optional int64 server_time_ms = 4;
        if (has_server_time_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->server_time_ms(), output);
        }

        // optional string message_id = 5;
        if (has_message_id()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                5, this->message_id(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ServerHeader)
    }

    int ServerHeader::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ServerHeader)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 31u) {
            // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
            if (has_protocol_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->protocol_version_);
            }

            // optional bytes client_token = 2;
            if (has_client_token()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->client_token());
            }

            // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
            if (has_registration_summary()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->registration_summary_);
            }

            // optional int64 server_time_ms = 4;
            if (has_server_time_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->server_time_ms());
            }

            // optional string message_id = 5;
            if (has_message_id()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->message_id());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ServerHeader::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ServerHeader*>(&from));
    }

    void ServerHeader::MergeFrom(const ServerHeader& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ServerHeader)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_protocol_version()) {
                mutable_protocol_version()->::ipc::invalidation::ProtocolVersion::MergeFrom(from.protocol_version());
            }
            if (from.has_client_token()) {
                set_has_client_token();
                client_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_token_);
            }
            if (from.has_registration_summary()) {
                mutable_registration_summary()->::ipc::invalidation::RegistrationSummary::MergeFrom(from.registration_summary());
            }
            if (from.has_server_time_ms()) {
                set_server_time_ms(from.server_time_ms());
            }
            if (from.has_message_id()) {
                set_has_message_id();
                message_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_id_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ServerHeader::CopyFrom(const ServerHeader& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ServerHeader)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ServerHeader::IsInitialized() const
    {

        return true;
    }

    void ServerHeader::Swap(ServerHeader* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ServerHeader::InternalSwap(ServerHeader* other)
    {
        std::swap(protocol_version_, other->protocol_version_);
        client_token_.Swap(&other->client_token_);
        std::swap(registration_summary_, other->registration_summary_);
        std::swap(server_time_ms_, other->server_time_ms_);
        message_id_.Swap(&other->message_id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ServerHeader::GetTypeName() const
    {
        return "ipc.invalidation.ServerHeader";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ServerHeader

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    bool ServerHeader::has_protocol_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ServerHeader::set_has_protocol_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ServerHeader::clear_has_protocol_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ServerHeader::clear_protocol_version()
    {
        if (protocol_version_ != NULL)
            protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
        clear_has_protocol_version();
    }
    const ::ipc::invalidation::ProtocolVersion& ServerHeader::protocol_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.protocol_version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance().protocol_version_;
#else
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance_->protocol_version_;
#endif
    }
    ::ipc::invalidation::ProtocolVersion* ServerHeader::mutable_protocol_version()
    {
        set_has_protocol_version();
        if (protocol_version_ == NULL) {
            protocol_version_ = new ::ipc::invalidation::ProtocolVersion;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.protocol_version)
        return protocol_version_;
    }
    ::ipc::invalidation::ProtocolVersion* ServerHeader::release_protocol_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.protocol_version)
        clear_has_protocol_version();
        ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
        protocol_version_ = NULL;
        return temp;
    }
    void ServerHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version)
    {
        delete protocol_version_;
        protocol_version_ = protocol_version;
        if (protocol_version) {
            set_has_protocol_version();
        } else {
            clear_has_protocol_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.protocol_version)
    }

    // optional bytes client_token = 2;
    bool ServerHeader::has_client_token() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ServerHeader::set_has_client_token()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ServerHeader::clear_has_client_token()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ServerHeader::clear_client_token()
    {
        client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_client_token();
    }
    const ::std::string& ServerHeader::client_token() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.client_token)
        return client_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ServerHeader::set_client_token(const ::std::string& value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.client_token)
    }
    void ServerHeader::set_client_token(const char* value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.client_token)
    }
    void ServerHeader::set_client_token(const void* value, size_t size)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.client_token)
    }
    ::std::string* ServerHeader::mutable_client_token()
    {
        set_has_client_token();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.client_token)
        return client_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ServerHeader::release_client_token()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.client_token)
        clear_has_client_token();
        return client_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ServerHeader::set_allocated_client_token(::std::string* client_token)
    {
        if (client_token != NULL) {
            set_has_client_token();
        } else {
            clear_has_client_token();
        }
        client_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_token);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.client_token)
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    bool ServerHeader::has_registration_summary() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ServerHeader::set_has_registration_summary()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ServerHeader::clear_has_registration_summary()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ServerHeader::clear_registration_summary()
    {
        if (registration_summary_ != NULL)
            registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
        clear_has_registration_summary();
    }
    const ::ipc::invalidation::RegistrationSummary& ServerHeader::registration_summary() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.registration_summary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance().registration_summary_;
#else
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance_->registration_summary_;
#endif
    }
    ::ipc::invalidation::RegistrationSummary* ServerHeader::mutable_registration_summary()
    {
        set_has_registration_summary();
        if (registration_summary_ == NULL) {
            registration_summary_ = new ::ipc::invalidation::RegistrationSummary;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.registration_summary)
        return registration_summary_;
    }
    ::ipc::invalidation::RegistrationSummary* ServerHeader::release_registration_summary()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.registration_summary)
        clear_has_registration_summary();
        ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
        registration_summary_ = NULL;
        return temp;
    }
    void ServerHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary)
    {
        delete registration_summary_;
        registration_summary_ = registration_summary;
        if (registration_summary) {
            set_has_registration_summary();
        } else {
            clear_has_registration_summary();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.registration_summary)
    }

    // optional int64 server_time_ms = 4;
    bool ServerHeader::has_server_time_ms() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void ServerHeader::set_has_server_time_ms()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void ServerHeader::clear_has_server_time_ms()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void ServerHeader::clear_server_time_ms()
    {
        server_time_ms_ = GOOGLE_LONGLONG(0);
        clear_has_server_time_ms();
    }
    ::google::protobuf::int64 ServerHeader::server_time_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.server_time_ms)
        return server_time_ms_;
    }
    void ServerHeader::set_server_time_ms(::google::protobuf::int64 value)
    {
        set_has_server_time_ms();
        server_time_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.server_time_ms)
    }

    // optional string message_id = 5;
    bool ServerHeader::has_message_id() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void ServerHeader::set_has_message_id()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void ServerHeader::clear_has_message_id()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void ServerHeader::clear_message_id()
    {
        message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_message_id();
    }
    const ::std::string& ServerHeader::message_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.message_id)
        return message_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ServerHeader::set_message_id(const ::std::string& value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.message_id)
    }
    void ServerHeader::set_message_id(const char* value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.message_id)
    }
    void ServerHeader::set_message_id(const char* value, size_t size)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.message_id)
    }
    ::std::string* ServerHeader::mutable_message_id()
    {
        set_has_message_id();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.message_id)
        return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ServerHeader::release_message_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.message_id)
        clear_has_message_id();
        return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ServerHeader::set_allocated_message_id(::std::string* message_id)
    {
        if (message_id != NULL) {
            set_has_message_id();
        } else {
            clear_has_message_id();
        }
        message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.message_id)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForServerToClientMessage(
        ServerToClientMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ServerToClientMessage::kHeaderFieldNumber;
    const int ServerToClientMessage::kTokenControlMessageFieldNumber;
    const int ServerToClientMessage::kInvalidationMessageFieldNumber;
    const int ServerToClientMessage::kRegistrationStatusMessageFieldNumber;
    const int ServerToClientMessage::kRegistrationSyncRequestMessageFieldNumber;
    const int ServerToClientMessage::kConfigChangeMessageFieldNumber;
    const int ServerToClientMessage::kInfoRequestMessageFieldNumber;
    const int ServerToClientMessage::kErrorMessageFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ServerToClientMessage::ServerToClientMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ServerToClientMessage)
    }

    void ServerToClientMessage::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        header_ = const_cast<::ipc::invalidation::ServerHeader*>(
            ::ipc::invalidation::ServerHeader::internal_default_instance());
#else
        header_ = const_cast<::ipc::invalidation::ServerHeader*>(&::ipc::invalidation::ServerHeader::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        token_control_message_ = const_cast<::ipc::invalidation::TokenControlMessage*>(
            ::ipc::invalidation::TokenControlMessage::internal_default_instance());
#else
        token_control_message_ = const_cast<::ipc::invalidation::TokenControlMessage*>(&::ipc::invalidation::TokenControlMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        invalidation_message_ = const_cast<::ipc::invalidation::InvalidationMessage*>(
            ::ipc::invalidation::InvalidationMessage::internal_default_instance());
#else
        invalidation_message_ = const_cast<::ipc::invalidation::InvalidationMessage*>(&::ipc::invalidation::InvalidationMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        registration_status_message_ = const_cast<::ipc::invalidation::RegistrationStatusMessage*>(
            ::ipc::invalidation::RegistrationStatusMessage::internal_default_instance());
#else
        registration_status_message_ = const_cast<::ipc::invalidation::RegistrationStatusMessage*>(&::ipc::invalidation::RegistrationStatusMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        registration_sync_request_message_ = const_cast<::ipc::invalidation::RegistrationSyncRequestMessage*>(
            ::ipc::invalidation::RegistrationSyncRequestMessage::internal_default_instance());
#else
        registration_sync_request_message_ = const_cast<::ipc::invalidation::RegistrationSyncRequestMessage*>(&::ipc::invalidation::RegistrationSyncRequestMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        config_change_message_ = const_cast<::ipc::invalidation::ConfigChangeMessage*>(
            ::ipc::invalidation::ConfigChangeMessage::internal_default_instance());
#else
        config_change_message_ = const_cast<::ipc::invalidation::ConfigChangeMessage*>(&::ipc::invalidation::ConfigChangeMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        info_request_message_ = const_cast<::ipc::invalidation::InfoRequestMessage*>(
            ::ipc::invalidation::InfoRequestMessage::internal_default_instance());
#else
        info_request_message_ = const_cast<::ipc::invalidation::InfoRequestMessage*>(&::ipc::invalidation::InfoRequestMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        error_message_ = const_cast<::ipc::invalidation::ErrorMessage*>(
            ::ipc::invalidation::ErrorMessage::internal_default_instance());
#else
        error_message_ = const_cast<::ipc::invalidation::ErrorMessage*>(&::ipc::invalidation::ErrorMessage::default_instance());
#endif
    }

    ServerToClientMessage::ServerToClientMessage(const ServerToClientMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ServerToClientMessage)
    }

    void ServerToClientMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        header_ = NULL;
        token_control_message_ = NULL;
        invalidation_message_ = NULL;
        registration_status_message_ = NULL;
        registration_sync_request_message_ = NULL;
        config_change_message_ = NULL;
        info_request_message_ = NULL;
        error_message_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ServerToClientMessage::~ServerToClientMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ServerToClientMessage)
        SharedDtor();
    }

    void ServerToClientMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete header_;
            delete token_control_message_;
            delete invalidation_message_;
            delete registration_status_message_;
            delete registration_sync_request_message_;
            delete config_change_message_;
            delete info_request_message_;
            delete error_message_;
        }
    }

    void ServerToClientMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ServerToClientMessage& ServerToClientMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ServerToClientMessage* ServerToClientMessage::default_instance_ = NULL;

    ServerToClientMessage* ServerToClientMessage::New(::google::protobuf::Arena* arena) const
    {
        ServerToClientMessage* n = new ServerToClientMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ServerToClientMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ServerToClientMessage)
        if (_has_bits_[0 / 32] & 255u) {
            if (has_header()) {
                if (header_ != NULL)
                    header_->::ipc::invalidation::ServerHeader::Clear();
            }
            if (has_token_control_message()) {
                if (token_control_message_ != NULL)
                    token_control_message_->::ipc::invalidation::TokenControlMessage::Clear();
            }
            if (has_invalidation_message()) {
                if (invalidation_message_ != NULL)
                    invalidation_message_->::ipc::invalidation::InvalidationMessage::Clear();
            }
            if (has_registration_status_message()) {
                if (registration_status_message_ != NULL)
                    registration_status_message_->::ipc::invalidation::RegistrationStatusMessage::Clear();
            }
            if (has_registration_sync_request_message()) {
                if (registration_sync_request_message_ != NULL)
                    registration_sync_request_message_->::ipc::invalidation::RegistrationSyncRequestMessage::Clear();
            }
            if (has_config_change_message()) {
                if (config_change_message_ != NULL)
                    config_change_message_->::ipc::invalidation::ConfigChangeMessage::Clear();
            }
            if (has_info_request_message()) {
                if (info_request_message_ != NULL)
                    info_request_message_->::ipc::invalidation::InfoRequestMessage::Clear();
            }
            if (has_error_message()) {
                if (error_message_ != NULL)
                    error_message_->::ipc::invalidation::ErrorMessage::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ServerToClientMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForServerToClientMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ServerToClientMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ServerHeader header = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_header()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_token_control_message;
                break;
            }

            // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
            case 2: {
                if (tag == 18) {
                parse_token_control_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_token_control_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(26))
                    goto parse_invalidation_message;
                break;
            }

            // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
            case 3: {
                if (tag == 26) {
                parse_invalidation_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_invalidation_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(34))
                    goto parse_registration_status_message;
                break;
            }

            // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
            case 4: {
                if (tag == 34) {
                parse_registration_status_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_registration_status_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(42))
                    goto parse_registration_sync_request_message;
                break;
            }

            // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
            case 5: {
                if (tag == 42) {
                parse_registration_sync_request_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_registration_sync_request_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(50))
                    goto parse_config_change_message;
                break;
            }

            // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
            case 6: {
                if (tag == 50) {
                parse_config_change_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_config_change_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(58))
                    goto parse_info_request_message;
                break;
            }

            // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
            case 7: {
                if (tag == 58) {
                parse_info_request_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_info_request_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(66))
                    goto parse_error_message;
                break;
            }

            // optional .ipc.invalidation.ErrorMessage error_message = 8;
            case 8: {
                if (tag == 66) {
                parse_error_message:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_error_message()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ServerToClientMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ServerToClientMessage)
        return false;
#undef DO_
    }

    void ServerToClientMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ServerToClientMessage)
        // optional .ipc.invalidation.ServerHeader header = 1;
        if (has_header()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->header_, output);
        }

        // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
        if (has_token_control_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, *this->token_control_message_, output);
        }

        // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
        if (has_invalidation_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                3, *this->invalidation_message_, output);
        }

        // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
        if (has_registration_status_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                4, *this->registration_status_message_, output);
        }

        // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
        if (has_registration_sync_request_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                5, *this->registration_sync_request_message_, output);
        }

        // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
        if (has_config_change_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                6, *this->config_change_message_, output);
        }

        // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
        if (has_info_request_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                7, *this->info_request_message_, output);
        }

        // optional .ipc.invalidation.ErrorMessage error_message = 8;
        if (has_error_message()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                8, *this->error_message_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ServerToClientMessage)
    }

    int ServerToClientMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ServerToClientMessage)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 255u) {
            // optional .ipc.invalidation.ServerHeader header = 1;
            if (has_header()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->header_);
            }

            // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
            if (has_token_control_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->token_control_message_);
            }

            // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
            if (has_invalidation_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->invalidation_message_);
            }

            // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
            if (has_registration_status_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->registration_status_message_);
            }

            // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
            if (has_registration_sync_request_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->registration_sync_request_message_);
            }

            // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
            if (has_config_change_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->config_change_message_);
            }

            // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
            if (has_info_request_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->info_request_message_);
            }

            // optional .ipc.invalidation.ErrorMessage error_message = 8;
            if (has_error_message()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->error_message_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ServerToClientMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ServerToClientMessage*>(&from));
    }

    void ServerToClientMessage::MergeFrom(const ServerToClientMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ServerToClientMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_header()) {
                mutable_header()->::ipc::invalidation::ServerHeader::MergeFrom(from.header());
            }
            if (from.has_token_control_message()) {
                mutable_token_control_message()->::ipc::invalidation::TokenControlMessage::MergeFrom(from.token_control_message());
            }
            if (from.has_invalidation_message()) {
                mutable_invalidation_message()->::ipc::invalidation::InvalidationMessage::MergeFrom(from.invalidation_message());
            }
            if (from.has_registration_status_message()) {
                mutable_registration_status_message()->::ipc::invalidation::RegistrationStatusMessage::MergeFrom(from.registration_status_message());
            }
            if (from.has_registration_sync_request_message()) {
                mutable_registration_sync_request_message()->::ipc::invalidation::RegistrationSyncRequestMessage::MergeFrom(from.registration_sync_request_message());
            }
            if (from.has_config_change_message()) {
                mutable_config_change_message()->::ipc::invalidation::ConfigChangeMessage::MergeFrom(from.config_change_message());
            }
            if (from.has_info_request_message()) {
                mutable_info_request_message()->::ipc::invalidation::InfoRequestMessage::MergeFrom(from.info_request_message());
            }
            if (from.has_error_message()) {
                mutable_error_message()->::ipc::invalidation::ErrorMessage::MergeFrom(from.error_message());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ServerToClientMessage::CopyFrom(const ServerToClientMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ServerToClientMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ServerToClientMessage::IsInitialized() const
    {

        return true;
    }

    void ServerToClientMessage::Swap(ServerToClientMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ServerToClientMessage::InternalSwap(ServerToClientMessage* other)
    {
        std::swap(header_, other->header_);
        std::swap(token_control_message_, other->token_control_message_);
        std::swap(invalidation_message_, other->invalidation_message_);
        std::swap(registration_status_message_, other->registration_status_message_);
        std::swap(registration_sync_request_message_, other->registration_sync_request_message_);
        std::swap(config_change_message_, other->config_change_message_);
        std::swap(info_request_message_, other->info_request_message_);
        std::swap(error_message_, other->error_message_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ServerToClientMessage::GetTypeName() const
    {
        return "ipc.invalidation.ServerToClientMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ServerToClientMessage

    // optional .ipc.invalidation.ServerHeader header = 1;
    bool ServerToClientMessage::has_header() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ServerToClientMessage::set_has_header()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ServerToClientMessage::clear_has_header()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ServerToClientMessage::clear_header()
    {
        if (header_ != NULL)
            header_->::ipc::invalidation::ServerHeader::Clear();
        clear_has_header();
    }
    const ::ipc::invalidation::ServerHeader& ServerToClientMessage::header() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return header_ != NULL ? *header_ : *default_instance().header_;
#else
        return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
    }
    ::ipc::invalidation::ServerHeader* ServerToClientMessage::mutable_header()
    {
        set_has_header();
        if (header_ == NULL) {
            header_ = new ::ipc::invalidation::ServerHeader;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.header)
        return header_;
    }
    ::ipc::invalidation::ServerHeader* ServerToClientMessage::release_header()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.header)
        clear_has_header();
        ::ipc::invalidation::ServerHeader* temp = header_;
        header_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_header(::ipc::invalidation::ServerHeader* header)
    {
        delete header_;
        header_ = header;
        if (header) {
            set_has_header();
        } else {
            clear_has_header();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.header)
    }

    // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
    bool ServerToClientMessage::has_token_control_message() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ServerToClientMessage::set_has_token_control_message()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ServerToClientMessage::clear_has_token_control_message()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ServerToClientMessage::clear_token_control_message()
    {
        if (token_control_message_ != NULL)
            token_control_message_->::ipc::invalidation::TokenControlMessage::Clear();
        clear_has_token_control_message();
    }
    const ::ipc::invalidation::TokenControlMessage& ServerToClientMessage::token_control_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.token_control_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return token_control_message_ != NULL ? *token_control_message_ : *default_instance().token_control_message_;
#else
        return token_control_message_ != NULL ? *token_control_message_ : *default_instance_->token_control_message_;
#endif
    }
    ::ipc::invalidation::TokenControlMessage* ServerToClientMessage::mutable_token_control_message()
    {
        set_has_token_control_message();
        if (token_control_message_ == NULL) {
            token_control_message_ = new ::ipc::invalidation::TokenControlMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.token_control_message)
        return token_control_message_;
    }
    ::ipc::invalidation::TokenControlMessage* ServerToClientMessage::release_token_control_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.token_control_message)
        clear_has_token_control_message();
        ::ipc::invalidation::TokenControlMessage* temp = token_control_message_;
        token_control_message_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_token_control_message(::ipc::invalidation::TokenControlMessage* token_control_message)
    {
        delete token_control_message_;
        token_control_message_ = token_control_message;
        if (token_control_message) {
            set_has_token_control_message();
        } else {
            clear_has_token_control_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.token_control_message)
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
    bool ServerToClientMessage::has_invalidation_message() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ServerToClientMessage::set_has_invalidation_message()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ServerToClientMessage::clear_has_invalidation_message()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ServerToClientMessage::clear_invalidation_message()
    {
        if (invalidation_message_ != NULL)
            invalidation_message_->::ipc::invalidation::InvalidationMessage::Clear();
        clear_has_invalidation_message();
    }
    const ::ipc::invalidation::InvalidationMessage& ServerToClientMessage::invalidation_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.invalidation_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return invalidation_message_ != NULL ? *invalidation_message_ : *default_instance().invalidation_message_;
#else
        return invalidation_message_ != NULL ? *invalidation_message_ : *default_instance_->invalidation_message_;
#endif
    }
    ::ipc::invalidation::InvalidationMessage* ServerToClientMessage::mutable_invalidation_message()
    {
        set_has_invalidation_message();
        if (invalidation_message_ == NULL) {
            invalidation_message_ = new ::ipc::invalidation::InvalidationMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.invalidation_message)
        return invalidation_message_;
    }
    ::ipc::invalidation::InvalidationMessage* ServerToClientMessage::release_invalidation_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.invalidation_message)
        clear_has_invalidation_message();
        ::ipc::invalidation::InvalidationMessage* temp = invalidation_message_;
        invalidation_message_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_invalidation_message(::ipc::invalidation::InvalidationMessage* invalidation_message)
    {
        delete invalidation_message_;
        invalidation_message_ = invalidation_message;
        if (invalidation_message) {
            set_has_invalidation_message();
        } else {
            clear_has_invalidation_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.invalidation_message)
    }

    // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
    bool ServerToClientMessage::has_registration_status_message() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void ServerToClientMessage::set_has_registration_status_message()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void ServerToClientMessage::clear_has_registration_status_message()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void ServerToClientMessage::clear_registration_status_message()
    {
        if (registration_status_message_ != NULL)
            registration_status_message_->::ipc::invalidation::RegistrationStatusMessage::Clear();
        clear_has_registration_status_message();
    }
    const ::ipc::invalidation::RegistrationStatusMessage& ServerToClientMessage::registration_status_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_status_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_status_message_ != NULL ? *registration_status_message_ : *default_instance().registration_status_message_;
#else
        return registration_status_message_ != NULL ? *registration_status_message_ : *default_instance_->registration_status_message_;
#endif
    }
    ::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::mutable_registration_status_message()
    {
        set_has_registration_status_message();
        if (registration_status_message_ == NULL) {
            registration_status_message_ = new ::ipc::invalidation::RegistrationStatusMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_status_message)
        return registration_status_message_;
    }
    ::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::release_registration_status_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_status_message)
        clear_has_registration_status_message();
        ::ipc::invalidation::RegistrationStatusMessage* temp = registration_status_message_;
        registration_status_message_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_registration_status_message(::ipc::invalidation::RegistrationStatusMessage* registration_status_message)
    {
        delete registration_status_message_;
        registration_status_message_ = registration_status_message;
        if (registration_status_message) {
            set_has_registration_status_message();
        } else {
            clear_has_registration_status_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_status_message)
    }

    // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
    bool ServerToClientMessage::has_registration_sync_request_message() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void ServerToClientMessage::set_has_registration_sync_request_message()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void ServerToClientMessage::clear_has_registration_sync_request_message()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void ServerToClientMessage::clear_registration_sync_request_message()
    {
        if (registration_sync_request_message_ != NULL)
            registration_sync_request_message_->::ipc::invalidation::RegistrationSyncRequestMessage::Clear();
        clear_has_registration_sync_request_message();
    }
    const ::ipc::invalidation::RegistrationSyncRequestMessage& ServerToClientMessage::registration_sync_request_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_sync_request_message_ != NULL ? *registration_sync_request_message_ : *default_instance().registration_sync_request_message_;
#else
        return registration_sync_request_message_ != NULL ? *registration_sync_request_message_ : *default_instance_->registration_sync_request_message_;
#endif
    }
    ::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::mutable_registration_sync_request_message()
    {
        set_has_registration_sync_request_message();
        if (registration_sync_request_message_ == NULL) {
            registration_sync_request_message_ = new ::ipc::invalidation::RegistrationSyncRequestMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
        return registration_sync_request_message_;
    }
    ::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::release_registration_sync_request_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
        clear_has_registration_sync_request_message();
        ::ipc::invalidation::RegistrationSyncRequestMessage* temp = registration_sync_request_message_;
        registration_sync_request_message_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_registration_sync_request_message(::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message)
    {
        delete registration_sync_request_message_;
        registration_sync_request_message_ = registration_sync_request_message;
        if (registration_sync_request_message) {
            set_has_registration_sync_request_message();
        } else {
            clear_has_registration_sync_request_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
    }

    // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
    bool ServerToClientMessage::has_config_change_message() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void ServerToClientMessage::set_has_config_change_message()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void ServerToClientMessage::clear_has_config_change_message()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void ServerToClientMessage::clear_config_change_message()
    {
        if (config_change_message_ != NULL)
            config_change_message_->::ipc::invalidation::ConfigChangeMessage::Clear();
        clear_has_config_change_message();
    }
    const ::ipc::invalidation::ConfigChangeMessage& ServerToClientMessage::config_change_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.config_change_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return config_change_message_ != NULL ? *config_change_message_ : *default_instance().config_change_message_;
#else
        return config_change_message_ != NULL ? *config_change_message_ : *default_instance_->config_change_message_;
#endif
    }
    ::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::mutable_config_change_message()
    {
        set_has_config_change_message();
        if (config_change_message_ == NULL) {
            config_change_message_ = new ::ipc::invalidation::ConfigChangeMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.config_change_message)
        return config_change_message_;
    }
    ::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::release_config_change_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.config_change_message)
        clear_has_config_change_message();
        ::ipc::invalidation::ConfigChangeMessage* temp = config_change_message_;
        config_change_message_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_config_change_message(::ipc::invalidation::ConfigChangeMessage* config_change_message)
    {
        delete config_change_message_;
        config_change_message_ = config_change_message;
        if (config_change_message) {
            set_has_config_change_message();
        } else {
            clear_has_config_change_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.config_change_message)
    }

    // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
    bool ServerToClientMessage::has_info_request_message() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    void ServerToClientMessage::set_has_info_request_message()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    void ServerToClientMessage::clear_has_info_request_message()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    void ServerToClientMessage::clear_info_request_message()
    {
        if (info_request_message_ != NULL)
            info_request_message_->::ipc::invalidation::InfoRequestMessage::Clear();
        clear_has_info_request_message();
    }
    const ::ipc::invalidation::InfoRequestMessage& ServerToClientMessage::info_request_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.info_request_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return info_request_message_ != NULL ? *info_request_message_ : *default_instance().info_request_message_;
#else
        return info_request_message_ != NULL ? *info_request_message_ : *default_instance_->info_request_message_;
#endif
    }
    ::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::mutable_info_request_message()
    {
        set_has_info_request_message();
        if (info_request_message_ == NULL) {
            info_request_message_ = new ::ipc::invalidation::InfoRequestMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.info_request_message)
        return info_request_message_;
    }
    ::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::release_info_request_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.info_request_message)
        clear_has_info_request_message();
        ::ipc::invalidation::InfoRequestMessage* temp = info_request_message_;
        info_request_message_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_info_request_message(::ipc::invalidation::InfoRequestMessage* info_request_message)
    {
        delete info_request_message_;
        info_request_message_ = info_request_message;
        if (info_request_message) {
            set_has_info_request_message();
        } else {
            clear_has_info_request_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.info_request_message)
    }

    // optional .ipc.invalidation.ErrorMessage error_message = 8;
    bool ServerToClientMessage::has_error_message() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    void ServerToClientMessage::set_has_error_message()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    void ServerToClientMessage::clear_has_error_message()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    void ServerToClientMessage::clear_error_message()
    {
        if (error_message_ != NULL)
            error_message_->::ipc::invalidation::ErrorMessage::Clear();
        clear_has_error_message();
    }
    const ::ipc::invalidation::ErrorMessage& ServerToClientMessage::error_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.error_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return error_message_ != NULL ? *error_message_ : *default_instance().error_message_;
#else
        return error_message_ != NULL ? *error_message_ : *default_instance_->error_message_;
#endif
    }
    ::ipc::invalidation::ErrorMessage* ServerToClientMessage::mutable_error_message()
    {
        set_has_error_message();
        if (error_message_ == NULL) {
            error_message_ = new ::ipc::invalidation::ErrorMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.error_message)
        return error_message_;
    }
    ::ipc::invalidation::ErrorMessage* ServerToClientMessage::release_error_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.error_message)
        clear_has_error_message();
        ::ipc::invalidation::ErrorMessage* temp = error_message_;
        error_message_ = NULL;
        return temp;
    }
    void ServerToClientMessage::set_allocated_error_message(::ipc::invalidation::ErrorMessage* error_message)
    {
        delete error_message_;
        error_message_ = error_message;
        if (error_message) {
            set_has_error_message();
        } else {
            clear_has_error_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.error_message)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForTokenControlMessage(
        TokenControlMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int TokenControlMessage::kNewTokenFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    TokenControlMessage::TokenControlMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.TokenControlMessage)
    }

    void TokenControlMessage::InitAsDefaultInstance()
    {
    }

    TokenControlMessage::TokenControlMessage(const TokenControlMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.TokenControlMessage)
    }

    void TokenControlMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        new_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    TokenControlMessage::~TokenControlMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.TokenControlMessage)
        SharedDtor();
    }

    void TokenControlMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        new_token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void TokenControlMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const TokenControlMessage& TokenControlMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    TokenControlMessage* TokenControlMessage::default_instance_ = NULL;

    TokenControlMessage* TokenControlMessage::New(::google::protobuf::Arena* arena) const
    {
        TokenControlMessage* n = new TokenControlMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void TokenControlMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.TokenControlMessage)
        if (has_new_token()) {
            new_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool TokenControlMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForTokenControlMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.TokenControlMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional bytes new_token = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                        input, this->mutable_new_token()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.TokenControlMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.TokenControlMessage)
        return false;
#undef DO_
    }

    void TokenControlMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.TokenControlMessage)
        // optional bytes new_token = 1;
        if (has_new_token()) {
            ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
                1, this->new_token(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.TokenControlMessage)
    }

    int TokenControlMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.TokenControlMessage)
        int total_size = 0;

        // optional bytes new_token = 1;
        if (has_new_token()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->new_token());
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void TokenControlMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const TokenControlMessage*>(&from));
    }

    void TokenControlMessage::MergeFrom(const TokenControlMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.TokenControlMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_new_token()) {
                set_has_new_token();
                new_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.new_token_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void TokenControlMessage::CopyFrom(const TokenControlMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.TokenControlMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool TokenControlMessage::IsInitialized() const
    {

        return true;
    }

    void TokenControlMessage::Swap(TokenControlMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void TokenControlMessage::InternalSwap(TokenControlMessage* other)
    {
        new_token_.Swap(&other->new_token_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string TokenControlMessage::GetTypeName() const
    {
        return "ipc.invalidation.TokenControlMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // TokenControlMessage

    // optional bytes new_token = 1;
    bool TokenControlMessage::has_new_token() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void TokenControlMessage::set_has_new_token()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void TokenControlMessage::clear_has_new_token()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void TokenControlMessage::clear_new_token()
    {
        new_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_new_token();
    }
    const ::std::string& TokenControlMessage::new_token() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.TokenControlMessage.new_token)
        return new_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void TokenControlMessage::set_new_token(const ::std::string& value)
    {
        set_has_new_token();
        new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.TokenControlMessage.new_token)
    }
    void TokenControlMessage::set_new_token(const char* value)
    {
        set_has_new_token();
        new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.TokenControlMessage.new_token)
    }
    void TokenControlMessage::set_new_token(const void* value, size_t size)
    {
        set_has_new_token();
        new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.TokenControlMessage.new_token)
    }
    ::std::string* TokenControlMessage::mutable_new_token()
    {
        set_has_new_token();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.TokenControlMessage.new_token)
        return new_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* TokenControlMessage::release_new_token()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.TokenControlMessage.new_token)
        clear_has_new_token();
        return new_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void TokenControlMessage::set_allocated_new_token(::std::string* new_token)
    {
        if (new_token != NULL) {
            set_has_new_token();
        } else {
            clear_has_new_token();
        }
        new_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_token);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.TokenControlMessage.new_token)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationStatus(
        RegistrationStatus* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RegistrationStatus::kRegistrationFieldNumber;
    const int RegistrationStatus::kStatusFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationStatus::RegistrationStatus()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationStatus)
    }

    void RegistrationStatus::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        registration_ = const_cast<::ipc::invalidation::RegistrationP*>(
            ::ipc::invalidation::RegistrationP::internal_default_instance());
#else
        registration_ = const_cast<::ipc::invalidation::RegistrationP*>(&::ipc::invalidation::RegistrationP::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        status_ = const_cast<::ipc::invalidation::StatusP*>(
            ::ipc::invalidation::StatusP::internal_default_instance());
#else
        status_ = const_cast<::ipc::invalidation::StatusP*>(&::ipc::invalidation::StatusP::default_instance());
#endif
    }

    RegistrationStatus::RegistrationStatus(const RegistrationStatus& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationStatus)
    }

    void RegistrationStatus::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        registration_ = NULL;
        status_ = NULL;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationStatus::~RegistrationStatus()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationStatus)
        SharedDtor();
    }

    void RegistrationStatus::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete registration_;
            delete status_;
        }
    }

    void RegistrationStatus::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationStatus& RegistrationStatus::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationStatus* RegistrationStatus::default_instance_ = NULL;

    RegistrationStatus* RegistrationStatus::New(::google::protobuf::Arena* arena) const
    {
        RegistrationStatus* n = new RegistrationStatus;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationStatus::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationStatus)
        if (_has_bits_[0 / 32] & 3u) {
            if (has_registration()) {
                if (registration_ != NULL)
                    registration_->::ipc::invalidation::RegistrationP::Clear();
            }
            if (has_status()) {
                if (status_ != NULL)
                    status_->::ipc::invalidation::StatusP::Clear();
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationStatus::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationStatus, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationStatus)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.RegistrationP registration = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_registration()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_status;
                break;
            }

            // optional .ipc.invalidation.StatusP status = 2;
            case 2: {
                if (tag == 18) {
                parse_status:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_status()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationStatus)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationStatus)
        return false;
#undef DO_
    }

    void RegistrationStatus::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationStatus)
        // optional .ipc.invalidation.RegistrationP registration = 1;
        if (has_registration()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->registration_, output);
        }

        // optional .ipc.invalidation.StatusP status = 2;
        if (has_status()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, *this->status_, output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationStatus)
    }

    int RegistrationStatus::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationStatus)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional .ipc.invalidation.RegistrationP registration = 1;
            if (has_registration()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->registration_);
            }

            // optional .ipc.invalidation.StatusP status = 2;
            if (has_status()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->status_);
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationStatus::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationStatus*>(&from));
    }

    void RegistrationStatus::MergeFrom(const RegistrationStatus& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationStatus)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_registration()) {
                mutable_registration()->::ipc::invalidation::RegistrationP::MergeFrom(from.registration());
            }
            if (from.has_status()) {
                mutable_status()->::ipc::invalidation::StatusP::MergeFrom(from.status());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationStatus::CopyFrom(const RegistrationStatus& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationStatus)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationStatus::IsInitialized() const
    {

        return true;
    }

    void RegistrationStatus::Swap(RegistrationStatus* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationStatus::InternalSwap(RegistrationStatus* other)
    {
        std::swap(registration_, other->registration_);
        std::swap(status_, other->status_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationStatus::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationStatus";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationStatus

    // optional .ipc.invalidation.RegistrationP registration = 1;
    bool RegistrationStatus::has_registration() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RegistrationStatus::set_has_registration()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RegistrationStatus::clear_has_registration()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RegistrationStatus::clear_registration()
    {
        if (registration_ != NULL)
            registration_->::ipc::invalidation::RegistrationP::Clear();
        clear_has_registration();
    }
    const ::ipc::invalidation::RegistrationP& RegistrationStatus::registration() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.registration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_ != NULL ? *registration_ : *default_instance().registration_;
#else
        return registration_ != NULL ? *registration_ : *default_instance_->registration_;
#endif
    }
    ::ipc::invalidation::RegistrationP* RegistrationStatus::mutable_registration()
    {
        set_has_registration();
        if (registration_ == NULL) {
            registration_ = new ::ipc::invalidation::RegistrationP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.registration)
        return registration_;
    }
    ::ipc::invalidation::RegistrationP* RegistrationStatus::release_registration()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.registration)
        clear_has_registration();
        ::ipc::invalidation::RegistrationP* temp = registration_;
        registration_ = NULL;
        return temp;
    }
    void RegistrationStatus::set_allocated_registration(::ipc::invalidation::RegistrationP* registration)
    {
        delete registration_;
        registration_ = registration;
        if (registration) {
            set_has_registration();
        } else {
            clear_has_registration();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.registration)
    }

    // optional .ipc.invalidation.StatusP status = 2;
    bool RegistrationStatus::has_status() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RegistrationStatus::set_has_status()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RegistrationStatus::clear_has_status()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RegistrationStatus::clear_status()
    {
        if (status_ != NULL)
            status_->::ipc::invalidation::StatusP::Clear();
        clear_has_status();
    }
    const ::ipc::invalidation::StatusP& RegistrationStatus::status() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return status_ != NULL ? *status_ : *default_instance().status_;
#else
        return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
    }
    ::ipc::invalidation::StatusP* RegistrationStatus::mutable_status()
    {
        set_has_status();
        if (status_ == NULL) {
            status_ = new ::ipc::invalidation::StatusP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.status)
        return status_;
    }
    ::ipc::invalidation::StatusP* RegistrationStatus::release_status()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.status)
        clear_has_status();
        ::ipc::invalidation::StatusP* temp = status_;
        status_ = NULL;
        return temp;
    }
    void RegistrationStatus::set_allocated_status(::ipc::invalidation::StatusP* status)
    {
        delete status_;
        status_ = status;
        if (status) {
            set_has_status();
        } else {
            clear_has_status();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.status)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationStatusMessage(
        RegistrationStatusMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RegistrationStatusMessage::kRegistrationStatusFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationStatusMessage::RegistrationStatusMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationStatusMessage)
    }

    void RegistrationStatusMessage::InitAsDefaultInstance()
    {
    }

    RegistrationStatusMessage::RegistrationStatusMessage(const RegistrationStatusMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationStatusMessage)
    }

    void RegistrationStatusMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationStatusMessage::~RegistrationStatusMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationStatusMessage)
        SharedDtor();
    }

    void RegistrationStatusMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RegistrationStatusMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationStatusMessage& RegistrationStatusMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationStatusMessage* RegistrationStatusMessage::default_instance_ = NULL;

    RegistrationStatusMessage* RegistrationStatusMessage::New(::google::protobuf::Arena* arena) const
    {
        RegistrationStatusMessage* n = new RegistrationStatusMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationStatusMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationStatusMessage)
        registration_status_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationStatusMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationStatusMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationStatusMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_registration_status:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_registration_status()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_registration_status;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationStatusMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationStatusMessage)
        return false;
#undef DO_
    }

    void RegistrationStatusMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationStatusMessage)
        // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
        for (unsigned int i = 0, n = this->registration_status_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->registration_status(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationStatusMessage)
    }

    int RegistrationStatusMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationStatusMessage)
        int total_size = 0;

        // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
        total_size += 1 * this->registration_status_size();
        for (int i = 0; i < this->registration_status_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->registration_status(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationStatusMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationStatusMessage*>(&from));
    }

    void RegistrationStatusMessage::MergeFrom(const RegistrationStatusMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationStatusMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        registration_status_.MergeFrom(from.registration_status_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationStatusMessage::CopyFrom(const RegistrationStatusMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationStatusMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationStatusMessage::IsInitialized() const
    {

        return true;
    }

    void RegistrationStatusMessage::Swap(RegistrationStatusMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationStatusMessage::InternalSwap(RegistrationStatusMessage* other)
    {
        registration_status_.UnsafeArenaSwap(&other->registration_status_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationStatusMessage::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationStatusMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationStatusMessage

    // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
    int RegistrationStatusMessage::registration_status_size() const
    {
        return registration_status_.size();
    }
    void RegistrationStatusMessage::clear_registration_status()
    {
        registration_status_.Clear();
    }
    const ::ipc::invalidation::RegistrationStatus& RegistrationStatusMessage::registration_status(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_.Get(index);
    }
    ::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::mutable_registration_status(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_.Mutable(index);
    }
    ::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::add_registration_status()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationStatus>*
    RegistrationStatusMessage::mutable_registration_status()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return &registration_status_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationStatus>&
    RegistrationStatusMessage::registration_status() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRegistrationSyncRequestMessage(
        RegistrationSyncRequestMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RegistrationSyncRequestMessage::RegistrationSyncRequestMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSyncRequestMessage)
    }

    void RegistrationSyncRequestMessage::InitAsDefaultInstance()
    {
    }

    RegistrationSyncRequestMessage::RegistrationSyncRequestMessage(const RegistrationSyncRequestMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSyncRequestMessage)
    }

    void RegistrationSyncRequestMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RegistrationSyncRequestMessage::~RegistrationSyncRequestMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSyncRequestMessage)
        SharedDtor();
    }

    void RegistrationSyncRequestMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RegistrationSyncRequestMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RegistrationSyncRequestMessage& RegistrationSyncRequestMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RegistrationSyncRequestMessage* RegistrationSyncRequestMessage::default_instance_ = NULL;

    RegistrationSyncRequestMessage* RegistrationSyncRequestMessage::New(::google::protobuf::Arena* arena) const
    {
        RegistrationSyncRequestMessage* n = new RegistrationSyncRequestMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RegistrationSyncRequestMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSyncRequestMessage)
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RegistrationSyncRequestMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRegistrationSyncRequestMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSyncRequestMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSyncRequestMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSyncRequestMessage)
        return false;
#undef DO_
    }

    void RegistrationSyncRequestMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSyncRequestMessage)
        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSyncRequestMessage)
    }

    int RegistrationSyncRequestMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSyncRequestMessage)
        int total_size = 0;

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RegistrationSyncRequestMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RegistrationSyncRequestMessage*>(&from));
    }

    void RegistrationSyncRequestMessage::MergeFrom(const RegistrationSyncRequestMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSyncRequestMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RegistrationSyncRequestMessage::CopyFrom(const RegistrationSyncRequestMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSyncRequestMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RegistrationSyncRequestMessage::IsInitialized() const
    {

        return true;
    }

    void RegistrationSyncRequestMessage::Swap(RegistrationSyncRequestMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RegistrationSyncRequestMessage::InternalSwap(RegistrationSyncRequestMessage* other)
    {
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RegistrationSyncRequestMessage::GetTypeName() const
    {
        return "ipc.invalidation.RegistrationSyncRequestMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RegistrationSyncRequestMessage

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForInvalidationMessage(
        InvalidationMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int InvalidationMessage::kInvalidationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    InvalidationMessage::InvalidationMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.InvalidationMessage)
    }

    void InvalidationMessage::InitAsDefaultInstance()
    {
    }

    InvalidationMessage::InvalidationMessage(const InvalidationMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InvalidationMessage)
    }

    void InvalidationMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    InvalidationMessage::~InvalidationMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.InvalidationMessage)
        SharedDtor();
    }

    void InvalidationMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void InvalidationMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const InvalidationMessage& InvalidationMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    InvalidationMessage* InvalidationMessage::default_instance_ = NULL;

    InvalidationMessage* InvalidationMessage::New(::google::protobuf::Arena* arena) const
    {
        InvalidationMessage* n = new InvalidationMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void InvalidationMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.InvalidationMessage)
        invalidation_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool InvalidationMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForInvalidationMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.InvalidationMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .ipc.invalidation.InvalidationP invalidation = 1;
            case 1: {
                if (tag == 10) {
                    DO_(input->IncrementRecursionDepth());
                parse_loop_invalidation:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_invalidation()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(10))
                    goto parse_loop_invalidation;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.InvalidationMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.InvalidationMessage)
        return false;
#undef DO_
    }

    void InvalidationMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.InvalidationMessage)
        // repeated .ipc.invalidation.InvalidationP invalidation = 1;
        for (unsigned int i = 0, n = this->invalidation_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, this->invalidation(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.InvalidationMessage)
    }

    int InvalidationMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InvalidationMessage)
        int total_size = 0;

        // repeated .ipc.invalidation.InvalidationP invalidation = 1;
        total_size += 1 * this->invalidation_size();
        for (int i = 0; i < this->invalidation_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->invalidation(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void InvalidationMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const InvalidationMessage*>(&from));
    }

    void InvalidationMessage::MergeFrom(const InvalidationMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InvalidationMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        invalidation_.MergeFrom(from.invalidation_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void InvalidationMessage::CopyFrom(const InvalidationMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InvalidationMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool InvalidationMessage::IsInitialized() const
    {

        return true;
    }

    void InvalidationMessage::Swap(InvalidationMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void InvalidationMessage::InternalSwap(InvalidationMessage* other)
    {
        invalidation_.UnsafeArenaSwap(&other->invalidation_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string InvalidationMessage::GetTypeName() const
    {
        return "ipc.invalidation.InvalidationMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // InvalidationMessage

    // repeated .ipc.invalidation.InvalidationP invalidation = 1;
    int InvalidationMessage::invalidation_size() const
    {
        return invalidation_.size();
    }
    void InvalidationMessage::clear_invalidation()
    {
        invalidation_.Clear();
    }
    const ::ipc::invalidation::InvalidationP& InvalidationMessage::invalidation(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_.Get(index);
    }
    ::ipc::invalidation::InvalidationP* InvalidationMessage::mutable_invalidation(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_.Mutable(index);
    }
    ::ipc::invalidation::InvalidationP* InvalidationMessage::add_invalidation()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::InvalidationP>*
    InvalidationMessage::mutable_invalidation()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InvalidationMessage.invalidation)
        return &invalidation_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::InvalidationP>&
    InvalidationMessage::invalidation() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForInfoRequestMessage(
        InfoRequestMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool InfoRequestMessage_InfoType_IsValid(int value)
    {
        switch (value) {
        case 1:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const InfoRequestMessage_InfoType InfoRequestMessage::GET_PERFORMANCE_COUNTERS;
    const InfoRequestMessage_InfoType InfoRequestMessage::InfoType_MIN;
    const InfoRequestMessage_InfoType InfoRequestMessage::InfoType_MAX;
    const int InfoRequestMessage::InfoType_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int InfoRequestMessage::kInfoTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    InfoRequestMessage::InfoRequestMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.InfoRequestMessage)
    }

    void InfoRequestMessage::InitAsDefaultInstance()
    {
    }

    InfoRequestMessage::InfoRequestMessage(const InfoRequestMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InfoRequestMessage)
    }

    void InfoRequestMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    InfoRequestMessage::~InfoRequestMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.InfoRequestMessage)
        SharedDtor();
    }

    void InfoRequestMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void InfoRequestMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const InfoRequestMessage& InfoRequestMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    InfoRequestMessage* InfoRequestMessage::default_instance_ = NULL;

    InfoRequestMessage* InfoRequestMessage::New(::google::protobuf::Arena* arena) const
    {
        InfoRequestMessage* n = new InfoRequestMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void InfoRequestMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.InfoRequestMessage)
        info_type_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool InfoRequestMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForInfoRequestMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.InfoRequestMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
            case 1: {
                if (tag == 8) {
                parse_info_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value)) {
                        add_info_type(static_cast<::ipc::invalidation::InfoRequestMessage_InfoType>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(tag);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else if (tag == 10) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                        input,
                        1,
                        ::ipc::invalidation::InfoRequestMessage_InfoType_IsValid,
                        &unknown_fields_stream,
                        this->mutable_info_type())));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(8))
                    goto parse_info_type;
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.InfoRequestMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.InfoRequestMessage)
        return false;
#undef DO_
    }

    void InfoRequestMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.InfoRequestMessage)
        // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
        for (int i = 0; i < this->info_type_size(); i++) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                1, this->info_type(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.InfoRequestMessage)
    }

    int InfoRequestMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InfoRequestMessage)
        int total_size = 0;

        // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
        {
            int data_size = 0;
            for (int i = 0; i < this->info_type_size(); i++) {
                data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
                    this->info_type(i));
            }
            total_size += 1 * this->info_type_size() + data_size;
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void InfoRequestMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const InfoRequestMessage*>(&from));
    }

    void InfoRequestMessage::MergeFrom(const InfoRequestMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InfoRequestMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        info_type_.MergeFrom(from.info_type_);
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void InfoRequestMessage::CopyFrom(const InfoRequestMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InfoRequestMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool InfoRequestMessage::IsInitialized() const
    {

        return true;
    }

    void InfoRequestMessage::Swap(InfoRequestMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void InfoRequestMessage::InternalSwap(InfoRequestMessage* other)
    {
        info_type_.UnsafeArenaSwap(&other->info_type_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string InfoRequestMessage::GetTypeName() const
    {
        return "ipc.invalidation.InfoRequestMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // InfoRequestMessage

    // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
    int InfoRequestMessage::info_type_size() const
    {
        return info_type_.size();
    }
    void InfoRequestMessage::clear_info_type()
    {
        info_type_.Clear();
    }
    ::ipc::invalidation::InfoRequestMessage_InfoType InfoRequestMessage::info_type(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoRequestMessage.info_type)
        return static_cast<::ipc::invalidation::InfoRequestMessage_InfoType>(info_type_.Get(index));
    }
    void InfoRequestMessage::set_info_type(int index, ::ipc::invalidation::InfoRequestMessage_InfoType value)
    {
        assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
        info_type_.Set(index, value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.InfoRequestMessage.info_type)
    }
    void InfoRequestMessage::add_info_type(::ipc::invalidation::InfoRequestMessage_InfoType value)
    {
        assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
        info_type_.Add(value);
        // @@protoc_insertion_point(field_add:ipc.invalidation.InfoRequestMessage.info_type)
    }
    const ::google::protobuf::RepeatedField<int>&
    InfoRequestMessage::info_type() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InfoRequestMessage.info_type)
        return info_type_;
    }
    ::google::protobuf::RepeatedField<int>*
    InfoRequestMessage::mutable_info_type()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoRequestMessage.info_type)
        return &info_type_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForRateLimitP(
        RateLimitP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int RateLimitP::kWindowMsFieldNumber;
    const int RateLimitP::kCountFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    RateLimitP::RateLimitP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.RateLimitP)
    }

    void RateLimitP::InitAsDefaultInstance()
    {
    }

    RateLimitP::RateLimitP(const RateLimitP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RateLimitP)
    }

    void RateLimitP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        window_ms_ = 0;
        count_ = 0;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    RateLimitP::~RateLimitP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.RateLimitP)
        SharedDtor();
    }

    void RateLimitP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void RateLimitP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const RateLimitP& RateLimitP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    RateLimitP* RateLimitP::default_instance_ = NULL;

    RateLimitP* RateLimitP::New(::google::protobuf::Arena* arena) const
    {
        RateLimitP* n = new RateLimitP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void RateLimitP::Clear()
    {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RateLimitP)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                \
    _Pragma("clang diagnostic push")                                                                 \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(RateLimitP, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<RateLimitP*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

        ZR_(window_ms_, count_);

#undef ZR_HELPER_
#undef ZR_

        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool RateLimitP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForRateLimitP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.RateLimitP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 window_ms = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &window_ms_)));
                    set_has_window_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_count;
                break;
            }

            // optional int32 count = 2;
            case 2: {
                if (tag == 16) {
                parse_count:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &count_)));
                    set_has_count();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.RateLimitP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.RateLimitP)
        return false;
#undef DO_
    }

    void RateLimitP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.RateLimitP)
        // optional int32 window_ms = 1;
        if (has_window_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->window_ms(), output);
        }

        // optional int32 count = 2;
        if (has_count()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.RateLimitP)
    }

    int RateLimitP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RateLimitP)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional int32 window_ms = 1;
            if (has_window_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->window_ms());
            }

            // optional int32 count = 2;
            if (has_count()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->count());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void RateLimitP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const RateLimitP*>(&from));
    }

    void RateLimitP::MergeFrom(const RateLimitP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RateLimitP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_window_ms()) {
                set_window_ms(from.window_ms());
            }
            if (from.has_count()) {
                set_count(from.count());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void RateLimitP::CopyFrom(const RateLimitP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RateLimitP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool RateLimitP::IsInitialized() const
    {

        return true;
    }

    void RateLimitP::Swap(RateLimitP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void RateLimitP::InternalSwap(RateLimitP* other)
    {
        std::swap(window_ms_, other->window_ms_);
        std::swap(count_, other->count_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string RateLimitP::GetTypeName() const
    {
        return "ipc.invalidation.RateLimitP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // RateLimitP

    // optional int32 window_ms = 1;
    bool RateLimitP::has_window_ms() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void RateLimitP::set_has_window_ms()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void RateLimitP::clear_has_window_ms()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void RateLimitP::clear_window_ms()
    {
        window_ms_ = 0;
        clear_has_window_ms();
    }
    ::google::protobuf::int32 RateLimitP::window_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.window_ms)
        return window_ms_;
    }
    void RateLimitP::set_window_ms(::google::protobuf::int32 value)
    {
        set_has_window_ms();
        window_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.window_ms)
    }

    // optional int32 count = 2;
    bool RateLimitP::has_count() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void RateLimitP::set_has_count()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void RateLimitP::clear_has_count()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void RateLimitP::clear_count()
    {
        count_ = 0;
        clear_has_count();
    }
    ::google::protobuf::int32 RateLimitP::count() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.count)
        return count_;
    }
    void RateLimitP::set_count(::google::protobuf::int32 value)
    {
        set_has_count();
        count_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.count)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForProtocolHandlerConfigP(
        ProtocolHandlerConfigP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ProtocolHandlerConfigP::kBatchingDelayMsFieldNumber;
    const int ProtocolHandlerConfigP::kRateLimitFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ProtocolHandlerConfigP::ProtocolHandlerConfigP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ProtocolHandlerConfigP)
    }

    void ProtocolHandlerConfigP::InitAsDefaultInstance()
    {
    }

    ProtocolHandlerConfigP::ProtocolHandlerConfigP(const ProtocolHandlerConfigP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ProtocolHandlerConfigP)
    }

    void ProtocolHandlerConfigP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        batching_delay_ms_ = 500;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ProtocolHandlerConfigP::~ProtocolHandlerConfigP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ProtocolHandlerConfigP)
        SharedDtor();
    }

    void ProtocolHandlerConfigP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void ProtocolHandlerConfigP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ProtocolHandlerConfigP& ProtocolHandlerConfigP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ProtocolHandlerConfigP* ProtocolHandlerConfigP::default_instance_ = NULL;

    ProtocolHandlerConfigP* ProtocolHandlerConfigP::New(::google::protobuf::Arena* arena) const
    {
        ProtocolHandlerConfigP* n = new ProtocolHandlerConfigP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ProtocolHandlerConfigP::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ProtocolHandlerConfigP)
        batching_delay_ms_ = 500;
        rate_limit_.Clear();
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ProtocolHandlerConfigP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForProtocolHandlerConfigP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ProtocolHandlerConfigP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int32 batching_delay_ms = 1 [default = 500];
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &batching_delay_ms_)));
                    set_has_batching_delay_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_rate_limit;
                break;
            }

            // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
            case 2: {
                if (tag == 18) {
                parse_rate_limit:
                    DO_(input->IncrementRecursionDepth());
                parse_loop_rate_limit:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                        input, add_rate_limit()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_loop_rate_limit;
                input->UnsafeDecrementRecursionDepth();
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ProtocolHandlerConfigP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ProtocolHandlerConfigP)
        return false;
#undef DO_
    }

    void ProtocolHandlerConfigP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ProtocolHandlerConfigP)
        // optional int32 batching_delay_ms = 1 [default = 500];
        if (has_batching_delay_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->batching_delay_ms(), output);
        }

        // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
        for (unsigned int i = 0, n = this->rate_limit_size(); i < n; i++) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                2, this->rate_limit(i), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ProtocolHandlerConfigP)
    }

    int ProtocolHandlerConfigP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ProtocolHandlerConfigP)
        int total_size = 0;

        // optional int32 batching_delay_ms = 1 [default = 500];
        if (has_batching_delay_ms()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->batching_delay_ms());
        }

        // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
        total_size += 1 * this->rate_limit_size();
        for (int i = 0; i < this->rate_limit_size(); i++) {
            total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->rate_limit(i));
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ProtocolHandlerConfigP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ProtocolHandlerConfigP*>(&from));
    }

    void ProtocolHandlerConfigP::MergeFrom(const ProtocolHandlerConfigP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ProtocolHandlerConfigP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        rate_limit_.MergeFrom(from.rate_limit_);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_batching_delay_ms()) {
                set_batching_delay_ms(from.batching_delay_ms());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ProtocolHandlerConfigP::CopyFrom(const ProtocolHandlerConfigP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ProtocolHandlerConfigP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ProtocolHandlerConfigP::IsInitialized() const
    {

        return true;
    }

    void ProtocolHandlerConfigP::Swap(ProtocolHandlerConfigP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ProtocolHandlerConfigP::InternalSwap(ProtocolHandlerConfigP* other)
    {
        std::swap(batching_delay_ms_, other->batching_delay_ms_);
        rate_limit_.UnsafeArenaSwap(&other->rate_limit_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ProtocolHandlerConfigP::GetTypeName() const
    {
        return "ipc.invalidation.ProtocolHandlerConfigP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ProtocolHandlerConfigP

    // optional int32 batching_delay_ms = 1 [default = 500];
    bool ProtocolHandlerConfigP::has_batching_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ProtocolHandlerConfigP::set_has_batching_delay_ms()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ProtocolHandlerConfigP::clear_has_batching_delay_ms()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ProtocolHandlerConfigP::clear_batching_delay_ms()
    {
        batching_delay_ms_ = 500;
        clear_has_batching_delay_ms();
    }
    ::google::protobuf::int32 ProtocolHandlerConfigP::batching_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
        return batching_delay_ms_;
    }
    void ProtocolHandlerConfigP::set_batching_delay_ms(::google::protobuf::int32 value)
    {
        set_has_batching_delay_ms();
        batching_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
    }

    // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
    int ProtocolHandlerConfigP::rate_limit_size() const
    {
        return rate_limit_.size();
    }
    void ProtocolHandlerConfigP::clear_rate_limit()
    {
        rate_limit_.Clear();
    }
    const ::ipc::invalidation::RateLimitP& ProtocolHandlerConfigP::rate_limit(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_.Get(index);
    }
    ::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::mutable_rate_limit(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_.Mutable(index);
    }
    ::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::add_rate_limit()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_.Add();
    }
    ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RateLimitP>*
    ProtocolHandlerConfigP::mutable_rate_limit()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return &rate_limit_;
    }
    const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RateLimitP>&
    ProtocolHandlerConfigP::rate_limit() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_;
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForClientConfigP(
        ClientConfigP* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ClientConfigP::kVersionFieldNumber;
    const int ClientConfigP::kNetworkTimeoutDelayMsFieldNumber;
    const int ClientConfigP::kWriteRetryDelayMsFieldNumber;
    const int ClientConfigP::kHeartbeatIntervalMsFieldNumber;
    const int ClientConfigP::kPerfCounterDelayMsFieldNumber;
    const int ClientConfigP::kMaxExponentialBackoffFactorFieldNumber;
    const int ClientConfigP::kSmearPercentFieldNumber;
    const int ClientConfigP::kIsTransientFieldNumber;
    const int ClientConfigP::kInitialPersistentHeartbeatDelayMsFieldNumber;
    const int ClientConfigP::kProtocolHandlerConfigFieldNumber;
    const int ClientConfigP::kChannelSupportsOfflineDeliveryFieldNumber;
    const int ClientConfigP::kOfflineHeartbeatThresholdMsFieldNumber;
    const int ClientConfigP::kAllowSuppressionFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ClientConfigP::ClientConfigP()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ClientConfigP)
    }

    void ClientConfigP::InitAsDefaultInstance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        version_ = const_cast<::ipc::invalidation::Version*>(
            ::ipc::invalidation::Version::internal_default_instance());
#else
        version_ = const_cast<::ipc::invalidation::Version*>(&::ipc::invalidation::Version::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protocol_handler_config_ = const_cast<::ipc::invalidation::ProtocolHandlerConfigP*>(
            ::ipc::invalidation::ProtocolHandlerConfigP::internal_default_instance());
#else
        protocol_handler_config_ = const_cast<::ipc::invalidation::ProtocolHandlerConfigP*>(&::ipc::invalidation::ProtocolHandlerConfigP::default_instance());
#endif
    }

    ClientConfigP::ClientConfigP(const ClientConfigP& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientConfigP)
    }

    void ClientConfigP::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        version_ = NULL;
        network_timeout_delay_ms_ = 60000;
        write_retry_delay_ms_ = 10000;
        heartbeat_interval_ms_ = 1200000;
        perf_counter_delay_ms_ = 21600000;
        max_exponential_backoff_factor_ = 500;
        smear_percent_ = 20;
        is_transient_ = false;
        initial_persistent_heartbeat_delay_ms_ = 2000;
        protocol_handler_config_ = NULL;
        channel_supports_offline_delivery_ = false;
        offline_heartbeat_threshold_ms_ = 60000;
        allow_suppression_ = true;
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ClientConfigP::~ClientConfigP()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ClientConfigP)
        SharedDtor();
    }

    void ClientConfigP::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
            delete version_;
            delete protocol_handler_config_;
        }
    }

    void ClientConfigP::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ClientConfigP& ClientConfigP::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ClientConfigP* ClientConfigP::default_instance_ = NULL;

    ClientConfigP* ClientConfigP::New(::google::protobuf::Arena* arena) const
    {
        ClientConfigP* n = new ClientConfigP;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ClientConfigP::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientConfigP)
        if (_has_bits_[0 / 32] & 255u) {
            if (has_version()) {
                if (version_ != NULL)
                    version_->::ipc::invalidation::Version::Clear();
            }
            network_timeout_delay_ms_ = 60000;
            write_retry_delay_ms_ = 10000;
            heartbeat_interval_ms_ = 1200000;
            perf_counter_delay_ms_ = 21600000;
            max_exponential_backoff_factor_ = 500;
            smear_percent_ = 20;
            is_transient_ = false;
        }
        if (_has_bits_[8 / 32] & 7936u) {
            initial_persistent_heartbeat_delay_ms_ = 2000;
            if (has_protocol_handler_config()) {
                if (protocol_handler_config_ != NULL)
                    protocol_handler_config_->::ipc::invalidation::ProtocolHandlerConfigP::Clear();
            }
            channel_supports_offline_delivery_ = false;
            offline_heartbeat_threshold_ms_ = 60000;
            allow_suppression_ = true;
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ClientConfigP::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForClientConfigP, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientConfigP)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.Version version = 1;
            case 1: {
                if (tag == 10) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_version()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(16))
                    goto parse_network_timeout_delay_ms;
                break;
            }

            // optional int32 network_timeout_delay_ms = 2 [default = 60000];
            case 2: {
                if (tag == 16) {
                parse_network_timeout_delay_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &network_timeout_delay_ms_)));
                    set_has_network_timeout_delay_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(24))
                    goto parse_write_retry_delay_ms;
                break;
            }

            // optional int32 write_retry_delay_ms = 3 [default = 10000];
            case 3: {
                if (tag == 24) {
                parse_write_retry_delay_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &write_retry_delay_ms_)));
                    set_has_write_retry_delay_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(32))
                    goto parse_heartbeat_interval_ms;
                break;
            }

            // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
            case 4: {
                if (tag == 32) {
                parse_heartbeat_interval_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &heartbeat_interval_ms_)));
                    set_has_heartbeat_interval_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(40))
                    goto parse_perf_counter_delay_ms;
                break;
            }

            // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
            case 5: {
                if (tag == 40) {
                parse_perf_counter_delay_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &perf_counter_delay_ms_)));
                    set_has_perf_counter_delay_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(48))
                    goto parse_max_exponential_backoff_factor;
                break;
            }

            // optional int32 max_exponential_backoff_factor = 6 [default = 500];
            case 6: {
                if (tag == 48) {
                parse_max_exponential_backoff_factor:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &max_exponential_backoff_factor_)));
                    set_has_max_exponential_backoff_factor();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(56))
                    goto parse_smear_percent;
                break;
            }

            // optional int32 smear_percent = 7 [default = 20];
            case 7: {
                if (tag == 56) {
                parse_smear_percent:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &smear_percent_)));
                    set_has_smear_percent();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(64))
                    goto parse_is_transient;
                break;
            }

            // optional bool is_transient = 8 [default = false];
            case 8: {
                if (tag == 64) {
                parse_is_transient:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &is_transient_)));
                    set_has_is_transient();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(72))
                    goto parse_initial_persistent_heartbeat_delay_ms;
                break;
            }

            // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
            case 9: {
                if (tag == 72) {
                parse_initial_persistent_heartbeat_delay_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &initial_persistent_heartbeat_delay_ms_)));
                    set_has_initial_persistent_heartbeat_delay_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(82))
                    goto parse_protocol_handler_config;
                break;
            }

            // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
            case 10: {
                if (tag == 82) {
                parse_protocol_handler_config:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                        input, mutable_protocol_handler_config()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(88))
                    goto parse_channel_supports_offline_delivery;
                break;
            }

            // optional bool channel_supports_offline_delivery = 11 [default = false];
            case 11: {
                if (tag == 88) {
                parse_channel_supports_offline_delivery:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &channel_supports_offline_delivery_)));
                    set_has_channel_supports_offline_delivery();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(96))
                    goto parse_offline_heartbeat_threshold_ms;
                break;
            }

            // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
            case 12: {
                if (tag == 96) {
                parse_offline_heartbeat_threshold_ms:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                        input, &offline_heartbeat_threshold_ms_)));
                    set_has_offline_heartbeat_threshold_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(104))
                    goto parse_allow_suppression;
                break;
            }

            // optional bool allow_suppression = 13 [default = true];
            case 13: {
                if (tag == 104) {
                parse_allow_suppression:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                        input, &allow_suppression_)));
                    set_has_allow_suppression();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientConfigP)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientConfigP)
        return false;
#undef DO_
    }

    void ClientConfigP::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientConfigP)
        // optional .ipc.invalidation.Version version = 1;
        if (has_version()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                1, *this->version_, output);
        }

        // optional int32 network_timeout_delay_ms = 2 [default = 60000];
        if (has_network_timeout_delay_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->network_timeout_delay_ms(), output);
        }

        // optional int32 write_retry_delay_ms = 3 [default = 10000];
        if (has_write_retry_delay_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->write_retry_delay_ms(), output);
        }

        // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
        if (has_heartbeat_interval_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->heartbeat_interval_ms(), output);
        }

        // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
        if (has_perf_counter_delay_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->perf_counter_delay_ms(), output);
        }

        // optional int32 max_exponential_backoff_factor = 6 [default = 500];
        if (has_max_exponential_backoff_factor()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->max_exponential_backoff_factor(), output);
        }

        // optional int32 smear_percent = 7 [default = 20];
        if (has_smear_percent()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->smear_percent(), output);
        }

        // optional bool is_transient = 8 [default = false];
        if (has_is_transient()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_transient(), output);
        }

        // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
        if (has_initial_persistent_heartbeat_delay_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->initial_persistent_heartbeat_delay_ms(), output);
        }

        // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
        if (has_protocol_handler_config()) {
            ::google::protobuf::internal::WireFormatLite::WriteMessage(
                10, *this->protocol_handler_config_, output);
        }

        // optional bool channel_supports_offline_delivery = 11 [default = false];
        if (has_channel_supports_offline_delivery()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->channel_supports_offline_delivery(), output);
        }

        // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
        if (has_offline_heartbeat_threshold_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->offline_heartbeat_threshold_ms(), output);
        }

        // optional bool allow_suppression = 13 [default = true];
        if (has_allow_suppression()) {
            ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->allow_suppression(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientConfigP)
    }

    int ClientConfigP::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientConfigP)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 255u) {
            // optional .ipc.invalidation.Version version = 1;
            if (has_version()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->version_);
            }

            // optional int32 network_timeout_delay_ms = 2 [default = 60000];
            if (has_network_timeout_delay_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->network_timeout_delay_ms());
            }

            // optional int32 write_retry_delay_ms = 3 [default = 10000];
            if (has_write_retry_delay_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->write_retry_delay_ms());
            }

            // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
            if (has_heartbeat_interval_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->heartbeat_interval_ms());
            }

            // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
            if (has_perf_counter_delay_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->perf_counter_delay_ms());
            }

            // optional int32 max_exponential_backoff_factor = 6 [default = 500];
            if (has_max_exponential_backoff_factor()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->max_exponential_backoff_factor());
            }

            // optional int32 smear_percent = 7 [default = 20];
            if (has_smear_percent()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->smear_percent());
            }

            // optional bool is_transient = 8 [default = false];
            if (has_is_transient()) {
                total_size += 1 + 1;
            }
        }
        if (_has_bits_[8 / 32] & 7936u) {
            // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
            if (has_initial_persistent_heartbeat_delay_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->initial_persistent_heartbeat_delay_ms());
            }

            // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
            if (has_protocol_handler_config()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->protocol_handler_config_);
            }

            // optional bool channel_supports_offline_delivery = 11 [default = false];
            if (has_channel_supports_offline_delivery()) {
                total_size += 1 + 1;
            }

            // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
            if (has_offline_heartbeat_threshold_ms()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->offline_heartbeat_threshold_ms());
            }

            // optional bool allow_suppression = 13 [default = true];
            if (has_allow_suppression()) {
                total_size += 1 + 1;
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ClientConfigP::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ClientConfigP*>(&from));
    }

    void ClientConfigP::MergeFrom(const ClientConfigP& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientConfigP)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_version()) {
                mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
            }
            if (from.has_network_timeout_delay_ms()) {
                set_network_timeout_delay_ms(from.network_timeout_delay_ms());
            }
            if (from.has_write_retry_delay_ms()) {
                set_write_retry_delay_ms(from.write_retry_delay_ms());
            }
            if (from.has_heartbeat_interval_ms()) {
                set_heartbeat_interval_ms(from.heartbeat_interval_ms());
            }
            if (from.has_perf_counter_delay_ms()) {
                set_perf_counter_delay_ms(from.perf_counter_delay_ms());
            }
            if (from.has_max_exponential_backoff_factor()) {
                set_max_exponential_backoff_factor(from.max_exponential_backoff_factor());
            }
            if (from.has_smear_percent()) {
                set_smear_percent(from.smear_percent());
            }
            if (from.has_is_transient()) {
                set_is_transient(from.is_transient());
            }
        }
        if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
            if (from.has_initial_persistent_heartbeat_delay_ms()) {
                set_initial_persistent_heartbeat_delay_ms(from.initial_persistent_heartbeat_delay_ms());
            }
            if (from.has_protocol_handler_config()) {
                mutable_protocol_handler_config()->::ipc::invalidation::ProtocolHandlerConfigP::MergeFrom(from.protocol_handler_config());
            }
            if (from.has_channel_supports_offline_delivery()) {
                set_channel_supports_offline_delivery(from.channel_supports_offline_delivery());
            }
            if (from.has_offline_heartbeat_threshold_ms()) {
                set_offline_heartbeat_threshold_ms(from.offline_heartbeat_threshold_ms());
            }
            if (from.has_allow_suppression()) {
                set_allow_suppression(from.allow_suppression());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ClientConfigP::CopyFrom(const ClientConfigP& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientConfigP)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ClientConfigP::IsInitialized() const
    {

        return true;
    }

    void ClientConfigP::Swap(ClientConfigP* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ClientConfigP::InternalSwap(ClientConfigP* other)
    {
        std::swap(version_, other->version_);
        std::swap(network_timeout_delay_ms_, other->network_timeout_delay_ms_);
        std::swap(write_retry_delay_ms_, other->write_retry_delay_ms_);
        std::swap(heartbeat_interval_ms_, other->heartbeat_interval_ms_);
        std::swap(perf_counter_delay_ms_, other->perf_counter_delay_ms_);
        std::swap(max_exponential_backoff_factor_, other->max_exponential_backoff_factor_);
        std::swap(smear_percent_, other->smear_percent_);
        std::swap(is_transient_, other->is_transient_);
        std::swap(initial_persistent_heartbeat_delay_ms_, other->initial_persistent_heartbeat_delay_ms_);
        std::swap(protocol_handler_config_, other->protocol_handler_config_);
        std::swap(channel_supports_offline_delivery_, other->channel_supports_offline_delivery_);
        std::swap(offline_heartbeat_threshold_ms_, other->offline_heartbeat_threshold_ms_);
        std::swap(allow_suppression_, other->allow_suppression_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ClientConfigP::GetTypeName() const
    {
        return "ipc.invalidation.ClientConfigP";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ClientConfigP

    // optional .ipc.invalidation.Version version = 1;
    bool ClientConfigP::has_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ClientConfigP::set_has_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ClientConfigP::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ClientConfigP::clear_version()
    {
        if (version_ != NULL)
            version_->::ipc::invalidation::Version::Clear();
        clear_has_version();
    }
    const ::ipc::invalidation::Version& ClientConfigP::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return version_ != NULL ? *version_ : *default_instance().version_;
#else
        return version_ != NULL ? *version_ : *default_instance_->version_;
#endif
    }
    ::ipc::invalidation::Version* ClientConfigP::mutable_version()
    {
        set_has_version();
        if (version_ == NULL) {
            version_ = new ::ipc::invalidation::Version;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.version)
        return version_;
    }
    ::ipc::invalidation::Version* ClientConfigP::release_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.version)
        clear_has_version();
        ::ipc::invalidation::Version* temp = version_;
        version_ = NULL;
        return temp;
    }
    void ClientConfigP::set_allocated_version(::ipc::invalidation::Version* version)
    {
        delete version_;
        version_ = version;
        if (version) {
            set_has_version();
        } else {
            clear_has_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.version)
    }

    // optional int32 network_timeout_delay_ms = 2 [default = 60000];
    bool ClientConfigP::has_network_timeout_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ClientConfigP::set_has_network_timeout_delay_ms()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ClientConfigP::clear_has_network_timeout_delay_ms()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ClientConfigP::clear_network_timeout_delay_ms()
    {
        network_timeout_delay_ms_ = 60000;
        clear_has_network_timeout_delay_ms();
    }
    ::google::protobuf::int32 ClientConfigP::network_timeout_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
        return network_timeout_delay_ms_;
    }
    void ClientConfigP::set_network_timeout_delay_ms(::google::protobuf::int32 value)
    {
        set_has_network_timeout_delay_ms();
        network_timeout_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
    }

    // optional int32 write_retry_delay_ms = 3 [default = 10000];
    bool ClientConfigP::has_write_retry_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    void ClientConfigP::set_has_write_retry_delay_ms()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    void ClientConfigP::clear_has_write_retry_delay_ms()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    void ClientConfigP::clear_write_retry_delay_ms()
    {
        write_retry_delay_ms_ = 10000;
        clear_has_write_retry_delay_ms();
    }
    ::google::protobuf::int32 ClientConfigP::write_retry_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
        return write_retry_delay_ms_;
    }
    void ClientConfigP::set_write_retry_delay_ms(::google::protobuf::int32 value)
    {
        set_has_write_retry_delay_ms();
        write_retry_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
    }

    // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
    bool ClientConfigP::has_heartbeat_interval_ms() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    void ClientConfigP::set_has_heartbeat_interval_ms()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    void ClientConfigP::clear_has_heartbeat_interval_ms()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    void ClientConfigP::clear_heartbeat_interval_ms()
    {
        heartbeat_interval_ms_ = 1200000;
        clear_has_heartbeat_interval_ms();
    }
    ::google::protobuf::int32 ClientConfigP::heartbeat_interval_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
        return heartbeat_interval_ms_;
    }
    void ClientConfigP::set_heartbeat_interval_ms(::google::protobuf::int32 value)
    {
        set_has_heartbeat_interval_ms();
        heartbeat_interval_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
    }

    // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
    bool ClientConfigP::has_perf_counter_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    void ClientConfigP::set_has_perf_counter_delay_ms()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    void ClientConfigP::clear_has_perf_counter_delay_ms()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    void ClientConfigP::clear_perf_counter_delay_ms()
    {
        perf_counter_delay_ms_ = 21600000;
        clear_has_perf_counter_delay_ms();
    }
    ::google::protobuf::int32 ClientConfigP::perf_counter_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
        return perf_counter_delay_ms_;
    }
    void ClientConfigP::set_perf_counter_delay_ms(::google::protobuf::int32 value)
    {
        set_has_perf_counter_delay_ms();
        perf_counter_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
    }

    // optional int32 max_exponential_backoff_factor = 6 [default = 500];
    bool ClientConfigP::has_max_exponential_backoff_factor() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    void ClientConfigP::set_has_max_exponential_backoff_factor()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    void ClientConfigP::clear_has_max_exponential_backoff_factor()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    void ClientConfigP::clear_max_exponential_backoff_factor()
    {
        max_exponential_backoff_factor_ = 500;
        clear_has_max_exponential_backoff_factor();
    }
    ::google::protobuf::int32 ClientConfigP::max_exponential_backoff_factor() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
        return max_exponential_backoff_factor_;
    }
    void ClientConfigP::set_max_exponential_backoff_factor(::google::protobuf::int32 value)
    {
        set_has_max_exponential_backoff_factor();
        max_exponential_backoff_factor_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
    }

    // optional int32 smear_percent = 7 [default = 20];
    bool ClientConfigP::has_smear_percent() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    void ClientConfigP::set_has_smear_percent()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    void ClientConfigP::clear_has_smear_percent()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    void ClientConfigP::clear_smear_percent()
    {
        smear_percent_ = 20;
        clear_has_smear_percent();
    }
    ::google::protobuf::int32 ClientConfigP::smear_percent() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.smear_percent)
        return smear_percent_;
    }
    void ClientConfigP::set_smear_percent(::google::protobuf::int32 value)
    {
        set_has_smear_percent();
        smear_percent_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.smear_percent)
    }

    // optional bool is_transient = 8 [default = false];
    bool ClientConfigP::has_is_transient() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    void ClientConfigP::set_has_is_transient()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    void ClientConfigP::clear_has_is_transient()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    void ClientConfigP::clear_is_transient()
    {
        is_transient_ = false;
        clear_has_is_transient();
    }
    bool ClientConfigP::is_transient() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.is_transient)
        return is_transient_;
    }
    void ClientConfigP::set_is_transient(bool value)
    {
        set_has_is_transient();
        is_transient_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.is_transient)
    }

    // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
    bool ClientConfigP::has_initial_persistent_heartbeat_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    void ClientConfigP::set_has_initial_persistent_heartbeat_delay_ms()
    {
        _has_bits_[0] |= 0x00000100u;
    }
    void ClientConfigP::clear_has_initial_persistent_heartbeat_delay_ms()
    {
        _has_bits_[0] &= ~0x00000100u;
    }
    void ClientConfigP::clear_initial_persistent_heartbeat_delay_ms()
    {
        initial_persistent_heartbeat_delay_ms_ = 2000;
        clear_has_initial_persistent_heartbeat_delay_ms();
    }
    ::google::protobuf::int32 ClientConfigP::initial_persistent_heartbeat_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
        return initial_persistent_heartbeat_delay_ms_;
    }
    void ClientConfigP::set_initial_persistent_heartbeat_delay_ms(::google::protobuf::int32 value)
    {
        set_has_initial_persistent_heartbeat_delay_ms();
        initial_persistent_heartbeat_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
    }

    // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
    bool ClientConfigP::has_protocol_handler_config() const
    {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    void ClientConfigP::set_has_protocol_handler_config()
    {
        _has_bits_[0] |= 0x00000200u;
    }
    void ClientConfigP::clear_has_protocol_handler_config()
    {
        _has_bits_[0] &= ~0x00000200u;
    }
    void ClientConfigP::clear_protocol_handler_config()
    {
        if (protocol_handler_config_ != NULL)
            protocol_handler_config_->::ipc::invalidation::ProtocolHandlerConfigP::Clear();
        clear_has_protocol_handler_config();
    }
    const ::ipc::invalidation::ProtocolHandlerConfigP& ClientConfigP::protocol_handler_config() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.protocol_handler_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return protocol_handler_config_ != NULL ? *protocol_handler_config_ : *default_instance().protocol_handler_config_;
#else
        return protocol_handler_config_ != NULL ? *protocol_handler_config_ : *default_instance_->protocol_handler_config_;
#endif
    }
    ::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::mutable_protocol_handler_config()
    {
        set_has_protocol_handler_config();
        if (protocol_handler_config_ == NULL) {
            protocol_handler_config_ = new ::ipc::invalidation::ProtocolHandlerConfigP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.protocol_handler_config)
        return protocol_handler_config_;
    }
    ::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::release_protocol_handler_config()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.protocol_handler_config)
        clear_has_protocol_handler_config();
        ::ipc::invalidation::ProtocolHandlerConfigP* temp = protocol_handler_config_;
        protocol_handler_config_ = NULL;
        return temp;
    }
    void ClientConfigP::set_allocated_protocol_handler_config(::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config)
    {
        delete protocol_handler_config_;
        protocol_handler_config_ = protocol_handler_config;
        if (protocol_handler_config) {
            set_has_protocol_handler_config();
        } else {
            clear_has_protocol_handler_config();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.protocol_handler_config)
    }

    // optional bool channel_supports_offline_delivery = 11 [default = false];
    bool ClientConfigP::has_channel_supports_offline_delivery() const
    {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    void ClientConfigP::set_has_channel_supports_offline_delivery()
    {
        _has_bits_[0] |= 0x00000400u;
    }
    void ClientConfigP::clear_has_channel_supports_offline_delivery()
    {
        _has_bits_[0] &= ~0x00000400u;
    }
    void ClientConfigP::clear_channel_supports_offline_delivery()
    {
        channel_supports_offline_delivery_ = false;
        clear_has_channel_supports_offline_delivery();
    }
    bool ClientConfigP::channel_supports_offline_delivery() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
        return channel_supports_offline_delivery_;
    }
    void ClientConfigP::set_channel_supports_offline_delivery(bool value)
    {
        set_has_channel_supports_offline_delivery();
        channel_supports_offline_delivery_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
    }

    // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
    bool ClientConfigP::has_offline_heartbeat_threshold_ms() const
    {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    void ClientConfigP::set_has_offline_heartbeat_threshold_ms()
    {
        _has_bits_[0] |= 0x00000800u;
    }
    void ClientConfigP::clear_has_offline_heartbeat_threshold_ms()
    {
        _has_bits_[0] &= ~0x00000800u;
    }
    void ClientConfigP::clear_offline_heartbeat_threshold_ms()
    {
        offline_heartbeat_threshold_ms_ = 60000;
        clear_has_offline_heartbeat_threshold_ms();
    }
    ::google::protobuf::int32 ClientConfigP::offline_heartbeat_threshold_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
        return offline_heartbeat_threshold_ms_;
    }
    void ClientConfigP::set_offline_heartbeat_threshold_ms(::google::protobuf::int32 value)
    {
        set_has_offline_heartbeat_threshold_ms();
        offline_heartbeat_threshold_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
    }

    // optional bool allow_suppression = 13 [default = true];
    bool ClientConfigP::has_allow_suppression() const
    {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    void ClientConfigP::set_has_allow_suppression()
    {
        _has_bits_[0] |= 0x00001000u;
    }
    void ClientConfigP::clear_has_allow_suppression()
    {
        _has_bits_[0] &= ~0x00001000u;
    }
    void ClientConfigP::clear_allow_suppression()
    {
        allow_suppression_ = true;
        clear_has_allow_suppression();
    }
    bool ClientConfigP::allow_suppression() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.allow_suppression)
        return allow_suppression_;
    }
    void ClientConfigP::set_allow_suppression(bool value)
    {
        set_has_allow_suppression();
        allow_suppression_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.allow_suppression)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForConfigChangeMessage(
        ConfigChangeMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ConfigChangeMessage::kNextMessageDelayMsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ConfigChangeMessage::ConfigChangeMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ConfigChangeMessage)
    }

    void ConfigChangeMessage::InitAsDefaultInstance()
    {
    }

    ConfigChangeMessage::ConfigChangeMessage(const ConfigChangeMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ConfigChangeMessage)
    }

    void ConfigChangeMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        next_message_delay_ms_ = GOOGLE_LONGLONG(0);
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ConfigChangeMessage::~ConfigChangeMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ConfigChangeMessage)
        SharedDtor();
    }

    void ConfigChangeMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void ConfigChangeMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ConfigChangeMessage& ConfigChangeMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ConfigChangeMessage* ConfigChangeMessage::default_instance_ = NULL;

    ConfigChangeMessage* ConfigChangeMessage::New(::google::protobuf::Arena* arena) const
    {
        ConfigChangeMessage* n = new ConfigChangeMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ConfigChangeMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ConfigChangeMessage)
        next_message_delay_ms_ = GOOGLE_LONGLONG(0);
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ConfigChangeMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForConfigChangeMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ConfigChangeMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional int64 next_message_delay_ms = 1;
            case 1: {
                if (tag == 8) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                        input, &next_message_delay_ms_)));
                    set_has_next_message_delay_ms();
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ConfigChangeMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ConfigChangeMessage)
        return false;
#undef DO_
    }

    void ConfigChangeMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ConfigChangeMessage)
        // optional int64 next_message_delay_ms = 1;
        if (has_next_message_delay_ms()) {
            ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->next_message_delay_ms(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ConfigChangeMessage)
    }

    int ConfigChangeMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ConfigChangeMessage)
        int total_size = 0;

        // optional int64 next_message_delay_ms = 1;
        if (has_next_message_delay_ms()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->next_message_delay_ms());
        }

        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ConfigChangeMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ConfigChangeMessage*>(&from));
    }

    void ConfigChangeMessage::MergeFrom(const ConfigChangeMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ConfigChangeMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_next_message_delay_ms()) {
                set_next_message_delay_ms(from.next_message_delay_ms());
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ConfigChangeMessage::CopyFrom(const ConfigChangeMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ConfigChangeMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ConfigChangeMessage::IsInitialized() const
    {

        return true;
    }

    void ConfigChangeMessage::Swap(ConfigChangeMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ConfigChangeMessage::InternalSwap(ConfigChangeMessage* other)
    {
        std::swap(next_message_delay_ms_, other->next_message_delay_ms_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ConfigChangeMessage::GetTypeName() const
    {
        return "ipc.invalidation.ConfigChangeMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ConfigChangeMessage

    // optional int64 next_message_delay_ms = 1;
    bool ConfigChangeMessage::has_next_message_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ConfigChangeMessage::set_has_next_message_delay_ms()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ConfigChangeMessage::clear_has_next_message_delay_ms()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ConfigChangeMessage::clear_next_message_delay_ms()
    {
        next_message_delay_ms_ = GOOGLE_LONGLONG(0);
        clear_has_next_message_delay_ms();
    }
    ::google::protobuf::int64 ConfigChangeMessage::next_message_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
        return next_message_delay_ms_;
    }
    void ConfigChangeMessage::set_next_message_delay_ms(::google::protobuf::int64 value)
    {
        set_has_next_message_delay_ms();
        next_message_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // ===================================================================

    static ::std::string* MutableUnknownFieldsForErrorMessage(
        ErrorMessage* ptr)
    {
        return ptr->mutable_unknown_fields();
    }

    bool ErrorMessage_Code_IsValid(int value)
    {
        switch (value) {
        case 1:
        case 10000:
            return true;
        default:
            return false;
        }
    }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const ErrorMessage_Code ErrorMessage::AUTH_FAILURE;
    const ErrorMessage_Code ErrorMessage::UNKNOWN_FAILURE;
    const ErrorMessage_Code ErrorMessage::Code_MIN;
    const ErrorMessage_Code ErrorMessage::Code_MAX;
    const int ErrorMessage::Code_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
    const int ErrorMessage::kCodeFieldNumber;
    const int ErrorMessage::kDescriptionFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

    ErrorMessage::ErrorMessage()
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        // @@protoc_insertion_point(constructor:ipc.invalidation.ErrorMessage)
    }

    void ErrorMessage::InitAsDefaultInstance()
    {
    }

    ErrorMessage::ErrorMessage(const ErrorMessage& from)
        : ::google::protobuf::MessageLite()
        , _arena_ptr_(NULL)
    {
        SharedCtor();
        MergeFrom(from);
        // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ErrorMessage)
    }

    void ErrorMessage::SharedCtor()
    {
        ::google::protobuf::internal::GetEmptyString();
        _cached_size_ = 0;
        _unknown_fields_.UnsafeSetDefault(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        code_ = 1;
        description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
    }

    ErrorMessage::~ErrorMessage()
    {
        // @@protoc_insertion_point(destructor:ipc.invalidation.ErrorMessage)
        SharedDtor();
    }

    void ErrorMessage::SharedDtor()
    {
        _unknown_fields_.DestroyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        if (this != &default_instance()) {
#else
        if (this != default_instance_) {
#endif
        }
    }

    void ErrorMessage::SetCachedSize(int size) const
    {
        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
    }
    const ErrorMessage& ErrorMessage::default_instance()
    {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        protobuf_AddDesc_client_5fprotocol_2eproto();
#else
        if (default_instance_ == NULL)
            protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        return *default_instance_;
    }

    ErrorMessage* ErrorMessage::default_instance_ = NULL;

    ErrorMessage* ErrorMessage::New(::google::protobuf::Arena* arena) const
    {
        ErrorMessage* n = new ErrorMessage;
        if (arena != NULL) {
            arena->Own(n);
        }
        return n;
    }

    void ErrorMessage::Clear()
    {
        // @@protoc_insertion_point(message_clear_start:ipc.invalidation.ErrorMessage)
        if (_has_bits_[0 / 32] & 3u) {
            code_ = 1;
            if (has_description()) {
                description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
        }
        ::memset(_has_bits_, 0, sizeof(_has_bits_));
        _unknown_fields_.ClearToEmptyNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    bool ErrorMessage::MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input)
    {
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
        ::google::protobuf::uint32 tag;
        ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
            ::google::protobuf::internal::NewPermanentCallback(
                &MutableUnknownFieldsForErrorMessage, this));
        ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
            &unknown_fields_string, false);
        // @@protoc_insertion_point(parse_start:ipc.invalidation.ErrorMessage)
        for (;;) {
            ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
            tag = p.first;
            if (!p.second)
                goto handle_unusual;
            switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
            // optional .ipc.invalidation.ErrorMessage.Code code = 1;
            case 1: {
                if (tag == 8) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                        int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                        input, &value)));
                    if (::ipc::invalidation::ErrorMessage_Code_IsValid(value)) {
                        set_code(static_cast<::ipc::invalidation::ErrorMessage_Code>(value));
                    } else {
                        unknown_fields_stream.WriteVarint32(8);
                        unknown_fields_stream.WriteVarint32(value);
                    }
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectTag(18))
                    goto parse_description;
                break;
            }

            // optional string description = 2;
            case 2: {
                if (tag == 18) {
                parse_description:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                        input, this->mutable_description()));
                } else {
                    goto handle_unusual;
                }
                if (input->ExpectAtEnd())
                    goto success;
                break;
            }

            default: {
            handle_unusual:
                if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    goto success;
                }
                DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                    input, tag, &unknown_fields_stream));
                break;
            }
            }
        }
    success:
        // @@protoc_insertion_point(parse_success:ipc.invalidation.ErrorMessage)
        return true;
    failure:
        // @@protoc_insertion_point(parse_failure:ipc.invalidation.ErrorMessage)
        return false;
#undef DO_
    }

    void ErrorMessage::SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const
    {
        // @@protoc_insertion_point(serialize_start:ipc.invalidation.ErrorMessage)
        // optional .ipc.invalidation.ErrorMessage.Code code = 1;
        if (has_code()) {
            ::google::protobuf::internal::WireFormatLite::WriteEnum(
                1, this->code(), output);
        }

        // optional string description = 2;
        if (has_description()) {
            ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
                2, this->description(), output);
        }

        output->WriteRaw(unknown_fields().data(),
            static_cast<int>(unknown_fields().size()));
        // @@protoc_insertion_point(serialize_end:ipc.invalidation.ErrorMessage)
    }

    int ErrorMessage::ByteSize() const
    {
        // @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ErrorMessage)
        int total_size = 0;

        if (_has_bits_[0 / 32] & 3u) {
            // optional .ipc.invalidation.ErrorMessage.Code code = 1;
            if (has_code()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
            }

            // optional string description = 2;
            if (has_description()) {
                total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->description());
            }
        }
        total_size += unknown_fields().size();

        GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
        _cached_size_ = total_size;
        GOOGLE_SAFE_CONCURRENT_WRITES_END();
        return total_size;
    }

    void ErrorMessage::CheckTypeAndMergeFrom(
        const ::google::protobuf::MessageLite& from)
    {
        MergeFrom(*::google::protobuf::down_cast<const ErrorMessage*>(&from));
    }

    void ErrorMessage::MergeFrom(const ErrorMessage& from)
    {
        // @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ErrorMessage)
        if (GOOGLE_PREDICT_FALSE(&from == this))
            MergeFromFail(__LINE__);
        if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
            if (from.has_code()) {
                set_code(from.code());
            }
            if (from.has_description()) {
                set_has_description();
                description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
            }
        }
        if (!from.unknown_fields().empty()) {
            mutable_unknown_fields()->append(from.unknown_fields());
        }
    }

    void ErrorMessage::CopyFrom(const ErrorMessage& from)
    {
        // @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ErrorMessage)
        if (&from == this)
            return;
        Clear();
        MergeFrom(from);
    }

    bool ErrorMessage::IsInitialized() const
    {

        return true;
    }

    void ErrorMessage::Swap(ErrorMessage* other)
    {
        if (other == this)
            return;
        InternalSwap(other);
    }
    void ErrorMessage::InternalSwap(ErrorMessage* other)
    {
        std::swap(code_, other->code_);
        description_.Swap(&other->description_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        _unknown_fields_.Swap(&other->_unknown_fields_);
        std::swap(_cached_size_, other->_cached_size_);
    }

    ::std::string ErrorMessage::GetTypeName() const
    {
        return "ipc.invalidation.ErrorMessage";
    }

#if PROTOBUF_INLINE_NOT_IN_HEADERS
    // ErrorMessage

    // optional .ipc.invalidation.ErrorMessage.Code code = 1;
    bool ErrorMessage::has_code() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    void ErrorMessage::set_has_code()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    void ErrorMessage::clear_has_code()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    void ErrorMessage::clear_code()
    {
        code_ = 1;
        clear_has_code();
    }
    ::ipc::invalidation::ErrorMessage_Code ErrorMessage::code() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.code)
        return static_cast<::ipc::invalidation::ErrorMessage_Code>(code_);
    }
    void ErrorMessage::set_code(::ipc::invalidation::ErrorMessage_Code value)
    {
        assert(::ipc::invalidation::ErrorMessage_Code_IsValid(value));
        set_has_code();
        code_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.code)
    }

    // optional string description = 2;
    bool ErrorMessage::has_description() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    void ErrorMessage::set_has_description()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    void ErrorMessage::clear_has_description()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    void ErrorMessage::clear_description()
    {
        description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_description();
    }
    const ::std::string& ErrorMessage::description() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.description)
        return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ErrorMessage::set_description(const ::std::string& value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.description)
    }
    void ErrorMessage::set_description(const char* value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ErrorMessage.description)
    }
    void ErrorMessage::set_description(const char* value, size_t size)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ErrorMessage.description)
    }
    ::std::string* ErrorMessage::mutable_description()
    {
        set_has_description();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ErrorMessage.description)
        return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::std::string* ErrorMessage::release_description()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ErrorMessage.description)
        clear_has_description();
        return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    void ErrorMessage::set_allocated_description(::std::string* description)
    {
        if (description != NULL) {
            set_has_description();
        } else {
            clear_has_description();
        }
        description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ErrorMessage.description)
    }

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

    // @@protoc_insertion_point(namespace_scope)

} // namespace invalidation
} // namespace ipc

// @@protoc_insertion_point(global_scope)
