// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_protocol.proto

#ifndef PROTOBUF_client_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_client_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)

namespace ipc {
namespace invalidation {

    // Internal implementation detail -- do not call these.
    void protobuf_AddDesc_client_5fprotocol_2eproto();
    void protobuf_AssignDesc_client_5fprotocol_2eproto();
    void protobuf_ShutdownFile_client_5fprotocol_2eproto();

    class ApplicationClientIdP;
    class ClientConfigP;
    class ClientHeader;
    class ClientToServerMessage;
    class ClientVersion;
    class ConfigChangeMessage;
    class ErrorMessage;
    class InfoMessage;
    class InfoRequestMessage;
    class InitializeMessage;
    class InvalidationMessage;
    class InvalidationP;
    class ObjectIdP;
    class PropertyRecord;
    class ProtocolHandlerConfigP;
    class ProtocolVersion;
    class RateLimitP;
    class RegistrationMessage;
    class RegistrationP;
    class RegistrationStatus;
    class RegistrationStatusMessage;
    class RegistrationSubtree;
    class RegistrationSummary;
    class RegistrationSyncMessage;
    class RegistrationSyncRequestMessage;
    class ServerHeader;
    class ServerToClientMessage;
    class StatusP;
    class TokenControlMessage;
    class Version;

    enum StatusP_Code {
        StatusP_Code_SUCCESS = 1,
        StatusP_Code_TRANSIENT_FAILURE = 2,
        StatusP_Code_PERMANENT_FAILURE = 3
    };
    bool StatusP_Code_IsValid(int value);
    const StatusP_Code StatusP_Code_Code_MIN = StatusP_Code_SUCCESS;
    const StatusP_Code StatusP_Code_Code_MAX = StatusP_Code_PERMANENT_FAILURE;
    const int StatusP_Code_Code_ARRAYSIZE = StatusP_Code_Code_MAX + 1;

    enum RegistrationP_OpType {
        RegistrationP_OpType_REGISTER = 1,
        RegistrationP_OpType_UNREGISTER = 2
    };
    bool RegistrationP_OpType_IsValid(int value);
    const RegistrationP_OpType RegistrationP_OpType_OpType_MIN = RegistrationP_OpType_REGISTER;
    const RegistrationP_OpType RegistrationP_OpType_OpType_MAX = RegistrationP_OpType_UNREGISTER;
    const int RegistrationP_OpType_OpType_ARRAYSIZE = RegistrationP_OpType_OpType_MAX + 1;

    enum InitializeMessage_DigestSerializationType {
        InitializeMessage_DigestSerializationType_BYTE_BASED = 1,
        InitializeMessage_DigestSerializationType_NUMBER_BASED = 2
    };
    bool InitializeMessage_DigestSerializationType_IsValid(int value);
    const InitializeMessage_DigestSerializationType InitializeMessage_DigestSerializationType_DigestSerializationType_MIN = InitializeMessage_DigestSerializationType_BYTE_BASED;
    const InitializeMessage_DigestSerializationType InitializeMessage_DigestSerializationType_DigestSerializationType_MAX = InitializeMessage_DigestSerializationType_NUMBER_BASED;
    const int InitializeMessage_DigestSerializationType_DigestSerializationType_ARRAYSIZE = InitializeMessage_DigestSerializationType_DigestSerializationType_MAX + 1;

    enum InfoRequestMessage_InfoType {
        InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS = 1
    };
    bool InfoRequestMessage_InfoType_IsValid(int value);
    const InfoRequestMessage_InfoType InfoRequestMessage_InfoType_InfoType_MIN = InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS;
    const InfoRequestMessage_InfoType InfoRequestMessage_InfoType_InfoType_MAX = InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS;
    const int InfoRequestMessage_InfoType_InfoType_ARRAYSIZE = InfoRequestMessage_InfoType_InfoType_MAX + 1;

    enum ErrorMessage_Code {
        ErrorMessage_Code_AUTH_FAILURE = 1,
        ErrorMessage_Code_UNKNOWN_FAILURE = 10000
    };
    bool ErrorMessage_Code_IsValid(int value);
    const ErrorMessage_Code ErrorMessage_Code_Code_MIN = ErrorMessage_Code_AUTH_FAILURE;
    const ErrorMessage_Code ErrorMessage_Code_Code_MAX = ErrorMessage_Code_UNKNOWN_FAILURE;
    const int ErrorMessage_Code_Code_ARRAYSIZE = ErrorMessage_Code_Code_MAX + 1;

    // ===================================================================

    class Version : public ::google::protobuf::MessageLite {
    public:
        Version();
        virtual ~Version();

        Version(const Version& from);

        inline Version& operator=(const Version& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Version& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Version* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Version* other);

        // implements Message ----------------------------------------------

        inline Version* New() const { return New(NULL); }

        Version* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Version& from);
        void MergeFrom(const Version& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Version* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 major_version = 1;
        bool has_major_version() const;
        void clear_major_version();
        static const int kMajorVersionFieldNumber = 1;
        ::google::protobuf::int32 major_version() const;
        void set_major_version(::google::protobuf::int32 value);

        // optional int32 minor_version = 2;
        bool has_minor_version() const;
        void clear_minor_version();
        static const int kMinorVersionFieldNumber = 2;
        ::google::protobuf::int32 minor_version() const;
        void set_minor_version(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.Version)
    private:
        inline void set_has_major_version();
        inline void clear_has_major_version();
        inline void set_has_minor_version();
        inline void clear_has_minor_version();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int32 major_version_;
        ::google::protobuf::int32 minor_version_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static Version* default_instance_;
    };
    // -------------------------------------------------------------------

    class ProtocolVersion : public ::google::protobuf::MessageLite {
    public:
        ProtocolVersion();
        virtual ~ProtocolVersion();

        ProtocolVersion(const ProtocolVersion& from);

        inline ProtocolVersion& operator=(const ProtocolVersion& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ProtocolVersion& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ProtocolVersion* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ProtocolVersion* other);

        // implements Message ----------------------------------------------

        inline ProtocolVersion* New() const { return New(NULL); }

        ProtocolVersion* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ProtocolVersion& from);
        void MergeFrom(const ProtocolVersion& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ProtocolVersion* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.Version version = 1;
        bool has_version() const;
        void clear_version();
        static const int kVersionFieldNumber = 1;
        const ::ipc::invalidation::Version& version() const;
        ::ipc::invalidation::Version* mutable_version();
        ::ipc::invalidation::Version* release_version();
        void set_allocated_version(::ipc::invalidation::Version* version);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ProtocolVersion)
    private:
        inline void set_has_version();
        inline void clear_has_version();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::Version* version_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ProtocolVersion* default_instance_;
    };
    // -------------------------------------------------------------------

    class ClientVersion : public ::google::protobuf::MessageLite {
    public:
        ClientVersion();
        virtual ~ClientVersion();

        ClientVersion(const ClientVersion& from);

        inline ClientVersion& operator=(const ClientVersion& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ClientVersion& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ClientVersion* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ClientVersion* other);

        // implements Message ----------------------------------------------

        inline ClientVersion* New() const { return New(NULL); }

        ClientVersion* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ClientVersion& from);
        void MergeFrom(const ClientVersion& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ClientVersion* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.Version version = 1;
        bool has_version() const;
        void clear_version();
        static const int kVersionFieldNumber = 1;
        const ::ipc::invalidation::Version& version() const;
        ::ipc::invalidation::Version* mutable_version();
        ::ipc::invalidation::Version* release_version();
        void set_allocated_version(::ipc::invalidation::Version* version);

        // optional string platform = 2;
        bool has_platform() const;
        void clear_platform();
        static const int kPlatformFieldNumber = 2;
        const ::std::string& platform() const;
        void set_platform(const ::std::string& value);
        void set_platform(const char* value);
        void set_platform(const char* value, size_t size);
        ::std::string* mutable_platform();
        ::std::string* release_platform();
        void set_allocated_platform(::std::string* platform);

        // optional string language = 3;
        bool has_language() const;
        void clear_language();
        static const int kLanguageFieldNumber = 3;
        const ::std::string& language() const;
        void set_language(const ::std::string& value);
        void set_language(const char* value);
        void set_language(const char* value, size_t size);
        ::std::string* mutable_language();
        ::std::string* release_language();
        void set_allocated_language(::std::string* language);

        // optional string application_info = 4;
        bool has_application_info() const;
        void clear_application_info();
        static const int kApplicationInfoFieldNumber = 4;
        const ::std::string& application_info() const;
        void set_application_info(const ::std::string& value);
        void set_application_info(const char* value);
        void set_application_info(const char* value, size_t size);
        ::std::string* mutable_application_info();
        ::std::string* release_application_info();
        void set_allocated_application_info(::std::string* application_info);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientVersion)
    private:
        inline void set_has_version();
        inline void clear_has_version();
        inline void set_has_platform();
        inline void clear_has_platform();
        inline void set_has_language();
        inline void clear_has_language();
        inline void set_has_application_info();
        inline void clear_has_application_info();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::Version* version_;
        ::google::protobuf::internal::ArenaStringPtr platform_;
        ::google::protobuf::internal::ArenaStringPtr language_;
        ::google::protobuf::internal::ArenaStringPtr application_info_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ClientVersion* default_instance_;
    };
    // -------------------------------------------------------------------

    class StatusP : public ::google::protobuf::MessageLite {
    public:
        StatusP();
        virtual ~StatusP();

        StatusP(const StatusP& from);

        inline StatusP& operator=(const StatusP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const StatusP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const StatusP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(StatusP* other);

        // implements Message ----------------------------------------------

        inline StatusP* New() const { return New(NULL); }

        StatusP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const StatusP& from);
        void MergeFrom(const StatusP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(StatusP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef StatusP_Code Code;
        static const Code SUCCESS = StatusP_Code_SUCCESS;
        static const Code TRANSIENT_FAILURE = StatusP_Code_TRANSIENT_FAILURE;
        static const Code PERMANENT_FAILURE = StatusP_Code_PERMANENT_FAILURE;
        static inline bool Code_IsValid(int value)
        {
            return StatusP_Code_IsValid(value);
        }
        static const Code Code_MIN = StatusP_Code_Code_MIN;
        static const Code Code_MAX = StatusP_Code_Code_MAX;
        static const int Code_ARRAYSIZE = StatusP_Code_Code_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.StatusP.Code code = 1;
        bool has_code() const;
        void clear_code();
        static const int kCodeFieldNumber = 1;
        ::ipc::invalidation::StatusP_Code code() const;
        void set_code(::ipc::invalidation::StatusP_Code value);

        // optional string description = 2;
        bool has_description() const;
        void clear_description();
        static const int kDescriptionFieldNumber = 2;
        const ::std::string& description() const;
        void set_description(const ::std::string& value);
        void set_description(const char* value);
        void set_description(const char* value, size_t size);
        ::std::string* mutable_description();
        ::std::string* release_description();
        void set_allocated_description(::std::string* description);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.StatusP)
    private:
        inline void set_has_code();
        inline void clear_has_code();
        inline void set_has_description();
        inline void clear_has_description();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr description_;
        int code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static StatusP* default_instance_;
    };
    // -------------------------------------------------------------------

    class ObjectIdP : public ::google::protobuf::MessageLite {
    public:
        ObjectIdP();
        virtual ~ObjectIdP();

        ObjectIdP(const ObjectIdP& from);

        inline ObjectIdP& operator=(const ObjectIdP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ObjectIdP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ObjectIdP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ObjectIdP* other);

        // implements Message ----------------------------------------------

        inline ObjectIdP* New() const { return New(NULL); }

        ObjectIdP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ObjectIdP& from);
        void MergeFrom(const ObjectIdP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ObjectIdP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 source = 1;
        bool has_source() const;
        void clear_source();
        static const int kSourceFieldNumber = 1;
        ::google::protobuf::int32 source() const;
        void set_source(::google::protobuf::int32 value);

        // optional bytes name = 2;
        bool has_name() const;
        void clear_name();
        static const int kNameFieldNumber = 2;
        const ::std::string& name() const;
        void set_name(const ::std::string& value);
        void set_name(const char* value);
        void set_name(const void* value, size_t size);
        ::std::string* mutable_name();
        ::std::string* release_name();
        void set_allocated_name(::std::string* name);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ObjectIdP)
    private:
        inline void set_has_source();
        inline void clear_has_source();
        inline void set_has_name();
        inline void clear_has_name();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr name_;
        ::google::protobuf::int32 source_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ObjectIdP* default_instance_;
    };
    // -------------------------------------------------------------------

    class ApplicationClientIdP : public ::google::protobuf::MessageLite {
    public:
        ApplicationClientIdP();
        virtual ~ApplicationClientIdP();

        ApplicationClientIdP(const ApplicationClientIdP& from);

        inline ApplicationClientIdP& operator=(const ApplicationClientIdP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ApplicationClientIdP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ApplicationClientIdP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ApplicationClientIdP* other);

        // implements Message ----------------------------------------------

        inline ApplicationClientIdP* New() const { return New(NULL); }

        ApplicationClientIdP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ApplicationClientIdP& from);
        void MergeFrom(const ApplicationClientIdP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ApplicationClientIdP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 client_type = 1;
        bool has_client_type() const;
        void clear_client_type();
        static const int kClientTypeFieldNumber = 1;
        ::google::protobuf::int32 client_type() const;
        void set_client_type(::google::protobuf::int32 value);

        // optional bytes client_name = 2;
        bool has_client_name() const;
        void clear_client_name();
        static const int kClientNameFieldNumber = 2;
        const ::std::string& client_name() const;
        void set_client_name(const ::std::string& value);
        void set_client_name(const char* value);
        void set_client_name(const void* value, size_t size);
        ::std::string* mutable_client_name();
        ::std::string* release_client_name();
        void set_allocated_client_name(::std::string* client_name);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ApplicationClientIdP)
    private:
        inline void set_has_client_type();
        inline void clear_has_client_type();
        inline void set_has_client_name();
        inline void clear_has_client_name();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr client_name_;
        ::google::protobuf::int32 client_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ApplicationClientIdP* default_instance_;
    };
    // -------------------------------------------------------------------

    class InvalidationP : public ::google::protobuf::MessageLite {
    public:
        InvalidationP();
        virtual ~InvalidationP();

        InvalidationP(const InvalidationP& from);

        inline InvalidationP& operator=(const InvalidationP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const InvalidationP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const InvalidationP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(InvalidationP* other);

        // implements Message ----------------------------------------------

        inline InvalidationP* New() const { return New(NULL); }

        InvalidationP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const InvalidationP& from);
        void MergeFrom(const InvalidationP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(InvalidationP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ObjectIdP object_id = 1;
        bool has_object_id() const;
        void clear_object_id();
        static const int kObjectIdFieldNumber = 1;
        const ::ipc::invalidation::ObjectIdP& object_id() const;
        ::ipc::invalidation::ObjectIdP* mutable_object_id();
        ::ipc::invalidation::ObjectIdP* release_object_id();
        void set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id);

        // optional bool is_known_version = 2;
        bool has_is_known_version() const;
        void clear_is_known_version();
        static const int kIsKnownVersionFieldNumber = 2;
        bool is_known_version() const;
        void set_is_known_version(bool value);

        // optional int64 version = 3;
        bool has_version() const;
        void clear_version();
        static const int kVersionFieldNumber = 3;
        ::google::protobuf::int64 version() const;
        void set_version(::google::protobuf::int64 value);

        // optional bool is_trickle_restart = 6 [default = false];
        bool has_is_trickle_restart() const;
        void clear_is_trickle_restart();
        static const int kIsTrickleRestartFieldNumber = 6;
        bool is_trickle_restart() const;
        void set_is_trickle_restart(bool value);

        // optional bytes payload = 4;
        bool has_payload() const;
        void clear_payload();
        static const int kPayloadFieldNumber = 4;
        const ::std::string& payload() const;
        void set_payload(const ::std::string& value);
        void set_payload(const char* value);
        void set_payload(const void* value, size_t size);
        ::std::string* mutable_payload();
        ::std::string* release_payload();
        void set_allocated_payload(::std::string* payload);

        // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
        PROTOBUF_DEPRECATED_ATTR bool has_bridge_arrival_time_ms_deprecated() const;
        PROTOBUF_DEPRECATED_ATTR void clear_bridge_arrival_time_ms_deprecated();
        PROTOBUF_DEPRECATED_ATTR static const int kBridgeArrivalTimeMsDeprecatedFieldNumber = 5;
        PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int64 bridge_arrival_time_ms_deprecated() const;
        PROTOBUF_DEPRECATED_ATTR void set_bridge_arrival_time_ms_deprecated(::google::protobuf::int64 value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.InvalidationP)
    private:
        inline void set_has_object_id();
        inline void clear_has_object_id();
        inline void set_has_is_known_version();
        inline void clear_has_is_known_version();
        inline void set_has_version();
        inline void clear_has_version();
        inline void set_has_is_trickle_restart();
        inline void clear_has_is_trickle_restart();
        inline void set_has_payload();
        inline void clear_has_payload();
        inline void set_has_bridge_arrival_time_ms_deprecated();
        inline void clear_has_bridge_arrival_time_ms_deprecated();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::ObjectIdP* object_id_;
        ::google::protobuf::int64 version_;
        ::google::protobuf::internal::ArenaStringPtr payload_;
        ::google::protobuf::int64 bridge_arrival_time_ms_deprecated_;
        bool is_known_version_;
        bool is_trickle_restart_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static InvalidationP* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationP : public ::google::protobuf::MessageLite {
    public:
        RegistrationP();
        virtual ~RegistrationP();

        RegistrationP(const RegistrationP& from);

        inline RegistrationP& operator=(const RegistrationP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationP* other);

        // implements Message ----------------------------------------------

        inline RegistrationP* New() const { return New(NULL); }

        RegistrationP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationP& from);
        void MergeFrom(const RegistrationP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef RegistrationP_OpType OpType;
        static const OpType REGISTER = RegistrationP_OpType_REGISTER;
        static const OpType UNREGISTER = RegistrationP_OpType_UNREGISTER;
        static inline bool OpType_IsValid(int value)
        {
            return RegistrationP_OpType_IsValid(value);
        }
        static const OpType OpType_MIN = RegistrationP_OpType_OpType_MIN;
        static const OpType OpType_MAX = RegistrationP_OpType_OpType_MAX;
        static const int OpType_ARRAYSIZE = RegistrationP_OpType_OpType_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ObjectIdP object_id = 1;
        bool has_object_id() const;
        void clear_object_id();
        static const int kObjectIdFieldNumber = 1;
        const ::ipc::invalidation::ObjectIdP& object_id() const;
        ::ipc::invalidation::ObjectIdP* mutable_object_id();
        ::ipc::invalidation::ObjectIdP* release_object_id();
        void set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id);

        // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
        bool has_op_type() const;
        void clear_op_type();
        static const int kOpTypeFieldNumber = 2;
        ::ipc::invalidation::RegistrationP_OpType op_type() const;
        void set_op_type(::ipc::invalidation::RegistrationP_OpType value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationP)
    private:
        inline void set_has_object_id();
        inline void clear_has_object_id();
        inline void set_has_op_type();
        inline void clear_has_op_type();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::ObjectIdP* object_id_;
        int op_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationP* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationSummary : public ::google::protobuf::MessageLite {
    public:
        RegistrationSummary();
        virtual ~RegistrationSummary();

        RegistrationSummary(const RegistrationSummary& from);

        inline RegistrationSummary& operator=(const RegistrationSummary& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationSummary& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationSummary* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationSummary* other);

        // implements Message ----------------------------------------------

        inline RegistrationSummary* New() const { return New(NULL); }

        RegistrationSummary* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationSummary& from);
        void MergeFrom(const RegistrationSummary& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationSummary* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 num_registrations = 1;
        bool has_num_registrations() const;
        void clear_num_registrations();
        static const int kNumRegistrationsFieldNumber = 1;
        ::google::protobuf::int32 num_registrations() const;
        void set_num_registrations(::google::protobuf::int32 value);

        // optional bytes registration_digest = 2;
        bool has_registration_digest() const;
        void clear_registration_digest();
        static const int kRegistrationDigestFieldNumber = 2;
        const ::std::string& registration_digest() const;
        void set_registration_digest(const ::std::string& value);
        void set_registration_digest(const char* value);
        void set_registration_digest(const void* value, size_t size);
        ::std::string* mutable_registration_digest();
        ::std::string* release_registration_digest();
        void set_allocated_registration_digest(::std::string* registration_digest);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSummary)
    private:
        inline void set_has_num_registrations();
        inline void clear_has_num_registrations();
        inline void set_has_registration_digest();
        inline void clear_has_registration_digest();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr registration_digest_;
        ::google::protobuf::int32 num_registrations_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationSummary* default_instance_;
    };
    // -------------------------------------------------------------------

    class ClientHeader : public ::google::protobuf::MessageLite {
    public:
        ClientHeader();
        virtual ~ClientHeader();

        ClientHeader(const ClientHeader& from);

        inline ClientHeader& operator=(const ClientHeader& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ClientHeader& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ClientHeader* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ClientHeader* other);

        // implements Message ----------------------------------------------

        inline ClientHeader* New() const { return New(NULL); }

        ClientHeader* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ClientHeader& from);
        void MergeFrom(const ClientHeader& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ClientHeader* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
        bool has_protocol_version() const;
        void clear_protocol_version();
        static const int kProtocolVersionFieldNumber = 1;
        const ::ipc::invalidation::ProtocolVersion& protocol_version() const;
        ::ipc::invalidation::ProtocolVersion* mutable_protocol_version();
        ::ipc::invalidation::ProtocolVersion* release_protocol_version();
        void set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version);

        // optional bytes client_token = 2;
        bool has_client_token() const;
        void clear_client_token();
        static const int kClientTokenFieldNumber = 2;
        const ::std::string& client_token() const;
        void set_client_token(const ::std::string& value);
        void set_client_token(const char* value);
        void set_client_token(const void* value, size_t size);
        ::std::string* mutable_client_token();
        ::std::string* release_client_token();
        void set_allocated_client_token(::std::string* client_token);

        // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
        bool has_registration_summary() const;
        void clear_registration_summary();
        static const int kRegistrationSummaryFieldNumber = 3;
        const ::ipc::invalidation::RegistrationSummary& registration_summary() const;
        ::ipc::invalidation::RegistrationSummary* mutable_registration_summary();
        ::ipc::invalidation::RegistrationSummary* release_registration_summary();
        void set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary);

        // optional int64 client_time_ms = 4;
        bool has_client_time_ms() const;
        void clear_client_time_ms();
        static const int kClientTimeMsFieldNumber = 4;
        ::google::protobuf::int64 client_time_ms() const;
        void set_client_time_ms(::google::protobuf::int64 value);

        // optional int64 max_known_server_time_ms = 5;
        bool has_max_known_server_time_ms() const;
        void clear_max_known_server_time_ms();
        static const int kMaxKnownServerTimeMsFieldNumber = 5;
        ::google::protobuf::int64 max_known_server_time_ms() const;
        void set_max_known_server_time_ms(::google::protobuf::int64 value);

        // optional string message_id = 6;
        bool has_message_id() const;
        void clear_message_id();
        static const int kMessageIdFieldNumber = 6;
        const ::std::string& message_id() const;
        void set_message_id(const ::std::string& value);
        void set_message_id(const char* value);
        void set_message_id(const char* value, size_t size);
        ::std::string* mutable_message_id();
        ::std::string* release_message_id();
        void set_allocated_message_id(::std::string* message_id);

        // optional int32 client_type = 7;
        bool has_client_type() const;
        void clear_client_type();
        static const int kClientTypeFieldNumber = 7;
        ::google::protobuf::int32 client_type() const;
        void set_client_type(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientHeader)
    private:
        inline void set_has_protocol_version();
        inline void clear_has_protocol_version();
        inline void set_has_client_token();
        inline void clear_has_client_token();
        inline void set_has_registration_summary();
        inline void clear_has_registration_summary();
        inline void set_has_client_time_ms();
        inline void clear_has_client_time_ms();
        inline void set_has_max_known_server_time_ms();
        inline void clear_has_max_known_server_time_ms();
        inline void set_has_message_id();
        inline void clear_has_message_id();
        inline void set_has_client_type();
        inline void clear_has_client_type();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::ProtocolVersion* protocol_version_;
        ::google::protobuf::internal::ArenaStringPtr client_token_;
        ::ipc::invalidation::RegistrationSummary* registration_summary_;
        ::google::protobuf::int64 client_time_ms_;
        ::google::protobuf::int64 max_known_server_time_ms_;
        ::google::protobuf::internal::ArenaStringPtr message_id_;
        ::google::protobuf::int32 client_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ClientHeader* default_instance_;
    };
    // -------------------------------------------------------------------

    class ClientToServerMessage : public ::google::protobuf::MessageLite {
    public:
        ClientToServerMessage();
        virtual ~ClientToServerMessage();

        ClientToServerMessage(const ClientToServerMessage& from);

        inline ClientToServerMessage& operator=(const ClientToServerMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ClientToServerMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ClientToServerMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ClientToServerMessage* other);

        // implements Message ----------------------------------------------

        inline ClientToServerMessage* New() const { return New(NULL); }

        ClientToServerMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ClientToServerMessage& from);
        void MergeFrom(const ClientToServerMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ClientToServerMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ClientHeader header = 1;
        bool has_header() const;
        void clear_header();
        static const int kHeaderFieldNumber = 1;
        const ::ipc::invalidation::ClientHeader& header() const;
        ::ipc::invalidation::ClientHeader* mutable_header();
        ::ipc::invalidation::ClientHeader* release_header();
        void set_allocated_header(::ipc::invalidation::ClientHeader* header);

        // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
        bool has_initialize_message() const;
        void clear_initialize_message();
        static const int kInitializeMessageFieldNumber = 2;
        const ::ipc::invalidation::InitializeMessage& initialize_message() const;
        ::ipc::invalidation::InitializeMessage* mutable_initialize_message();
        ::ipc::invalidation::InitializeMessage* release_initialize_message();
        void set_allocated_initialize_message(::ipc::invalidation::InitializeMessage* initialize_message);

        // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
        bool has_registration_message() const;
        void clear_registration_message();
        static const int kRegistrationMessageFieldNumber = 3;
        const ::ipc::invalidation::RegistrationMessage& registration_message() const;
        ::ipc::invalidation::RegistrationMessage* mutable_registration_message();
        ::ipc::invalidation::RegistrationMessage* release_registration_message();
        void set_allocated_registration_message(::ipc::invalidation::RegistrationMessage* registration_message);

        // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
        bool has_registration_sync_message() const;
        void clear_registration_sync_message();
        static const int kRegistrationSyncMessageFieldNumber = 4;
        const ::ipc::invalidation::RegistrationSyncMessage& registration_sync_message() const;
        ::ipc::invalidation::RegistrationSyncMessage* mutable_registration_sync_message();
        ::ipc::invalidation::RegistrationSyncMessage* release_registration_sync_message();
        void set_allocated_registration_sync_message(::ipc::invalidation::RegistrationSyncMessage* registration_sync_message);

        // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
        bool has_invalidation_ack_message() const;
        void clear_invalidation_ack_message();
        static const int kInvalidationAckMessageFieldNumber = 5;
        const ::ipc::invalidation::InvalidationMessage& invalidation_ack_message() const;
        ::ipc::invalidation::InvalidationMessage* mutable_invalidation_ack_message();
        ::ipc::invalidation::InvalidationMessage* release_invalidation_ack_message();
        void set_allocated_invalidation_ack_message(::ipc::invalidation::InvalidationMessage* invalidation_ack_message);

        // optional .ipc.invalidation.InfoMessage info_message = 6;
        bool has_info_message() const;
        void clear_info_message();
        static const int kInfoMessageFieldNumber = 6;
        const ::ipc::invalidation::InfoMessage& info_message() const;
        ::ipc::invalidation::InfoMessage* mutable_info_message();
        ::ipc::invalidation::InfoMessage* release_info_message();
        void set_allocated_info_message(::ipc::invalidation::InfoMessage* info_message);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientToServerMessage)
    private:
        inline void set_has_header();
        inline void clear_has_header();
        inline void set_has_initialize_message();
        inline void clear_has_initialize_message();
        inline void set_has_registration_message();
        inline void clear_has_registration_message();
        inline void set_has_registration_sync_message();
        inline void clear_has_registration_sync_message();
        inline void set_has_invalidation_ack_message();
        inline void clear_has_invalidation_ack_message();
        inline void set_has_info_message();
        inline void clear_has_info_message();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::ClientHeader* header_;
        ::ipc::invalidation::InitializeMessage* initialize_message_;
        ::ipc::invalidation::RegistrationMessage* registration_message_;
        ::ipc::invalidation::RegistrationSyncMessage* registration_sync_message_;
        ::ipc::invalidation::InvalidationMessage* invalidation_ack_message_;
        ::ipc::invalidation::InfoMessage* info_message_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ClientToServerMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class InitializeMessage : public ::google::protobuf::MessageLite {
    public:
        InitializeMessage();
        virtual ~InitializeMessage();

        InitializeMessage(const InitializeMessage& from);

        inline InitializeMessage& operator=(const InitializeMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const InitializeMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const InitializeMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(InitializeMessage* other);

        // implements Message ----------------------------------------------

        inline InitializeMessage* New() const { return New(NULL); }

        InitializeMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const InitializeMessage& from);
        void MergeFrom(const InitializeMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(InitializeMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef InitializeMessage_DigestSerializationType DigestSerializationType;
        static const DigestSerializationType BYTE_BASED = InitializeMessage_DigestSerializationType_BYTE_BASED;
        static const DigestSerializationType NUMBER_BASED = InitializeMessage_DigestSerializationType_NUMBER_BASED;
        static inline bool DigestSerializationType_IsValid(int value)
        {
            return InitializeMessage_DigestSerializationType_IsValid(value);
        }
        static const DigestSerializationType DigestSerializationType_MIN = InitializeMessage_DigestSerializationType_DigestSerializationType_MIN;
        static const DigestSerializationType DigestSerializationType_MAX = InitializeMessage_DigestSerializationType_DigestSerializationType_MAX;
        static const int DigestSerializationType_ARRAYSIZE = InitializeMessage_DigestSerializationType_DigestSerializationType_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional int32 client_type = 1;
        bool has_client_type() const;
        void clear_client_type();
        static const int kClientTypeFieldNumber = 1;
        ::google::protobuf::int32 client_type() const;
        void set_client_type(::google::protobuf::int32 value);

        // optional bytes nonce = 2;
        bool has_nonce() const;
        void clear_nonce();
        static const int kNonceFieldNumber = 2;
        const ::std::string& nonce() const;
        void set_nonce(const ::std::string& value);
        void set_nonce(const char* value);
        void set_nonce(const void* value, size_t size);
        ::std::string* mutable_nonce();
        ::std::string* release_nonce();
        void set_allocated_nonce(::std::string* nonce);

        // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
        bool has_application_client_id() const;
        void clear_application_client_id();
        static const int kApplicationClientIdFieldNumber = 3;
        const ::ipc::invalidation::ApplicationClientIdP& application_client_id() const;
        ::ipc::invalidation::ApplicationClientIdP* mutable_application_client_id();
        ::ipc::invalidation::ApplicationClientIdP* release_application_client_id();
        void set_allocated_application_client_id(::ipc::invalidation::ApplicationClientIdP* application_client_id);

        // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
        bool has_digest_serialization_type() const;
        void clear_digest_serialization_type();
        static const int kDigestSerializationTypeFieldNumber = 4;
        ::ipc::invalidation::InitializeMessage_DigestSerializationType digest_serialization_type() const;
        void set_digest_serialization_type(::ipc::invalidation::InitializeMessage_DigestSerializationType value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.InitializeMessage)
    private:
        inline void set_has_client_type();
        inline void clear_has_client_type();
        inline void set_has_nonce();
        inline void clear_has_nonce();
        inline void set_has_application_client_id();
        inline void clear_has_application_client_id();
        inline void set_has_digest_serialization_type();
        inline void clear_has_digest_serialization_type();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr nonce_;
        ::google::protobuf::int32 client_type_;
        int digest_serialization_type_;
        ::ipc::invalidation::ApplicationClientIdP* application_client_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static InitializeMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationMessage : public ::google::protobuf::MessageLite {
    public:
        RegistrationMessage();
        virtual ~RegistrationMessage();

        RegistrationMessage(const RegistrationMessage& from);

        inline RegistrationMessage& operator=(const RegistrationMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationMessage* other);

        // implements Message ----------------------------------------------

        inline RegistrationMessage* New() const { return New(NULL); }

        RegistrationMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationMessage& from);
        void MergeFrom(const RegistrationMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .ipc.invalidation.RegistrationP registration = 1;
        int registration_size() const;
        void clear_registration();
        static const int kRegistrationFieldNumber = 1;
        const ::ipc::invalidation::RegistrationP& registration(int index) const;
        ::ipc::invalidation::RegistrationP* mutable_registration(int index);
        ::ipc::invalidation::RegistrationP* add_registration();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationP>*
        mutable_registration();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationP>&
        registration() const;

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationMessage)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationP> registration_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationSyncMessage : public ::google::protobuf::MessageLite {
    public:
        RegistrationSyncMessage();
        virtual ~RegistrationSyncMessage();

        RegistrationSyncMessage(const RegistrationSyncMessage& from);

        inline RegistrationSyncMessage& operator=(const RegistrationSyncMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationSyncMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationSyncMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationSyncMessage* other);

        // implements Message ----------------------------------------------

        inline RegistrationSyncMessage* New() const { return New(NULL); }

        RegistrationSyncMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationSyncMessage& from);
        void MergeFrom(const RegistrationSyncMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationSyncMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
        int subtree_size() const;
        void clear_subtree();
        static const int kSubtreeFieldNumber = 1;
        const ::ipc::invalidation::RegistrationSubtree& subtree(int index) const;
        ::ipc::invalidation::RegistrationSubtree* mutable_subtree(int index);
        ::ipc::invalidation::RegistrationSubtree* add_subtree();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationSubtree>*
        mutable_subtree();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationSubtree>&
        subtree() const;

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSyncMessage)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationSubtree> subtree_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationSyncMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationSubtree : public ::google::protobuf::MessageLite {
    public:
        RegistrationSubtree();
        virtual ~RegistrationSubtree();

        RegistrationSubtree(const RegistrationSubtree& from);

        inline RegistrationSubtree& operator=(const RegistrationSubtree& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationSubtree& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationSubtree* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationSubtree* other);

        // implements Message ----------------------------------------------

        inline RegistrationSubtree* New() const { return New(NULL); }

        RegistrationSubtree* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationSubtree& from);
        void MergeFrom(const RegistrationSubtree& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationSubtree* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
        int registered_object_size() const;
        void clear_registered_object();
        static const int kRegisteredObjectFieldNumber = 1;
        const ::ipc::invalidation::ObjectIdP& registered_object(int index) const;
        ::ipc::invalidation::ObjectIdP* mutable_registered_object(int index);
        ::ipc::invalidation::ObjectIdP* add_registered_object();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::ObjectIdP>*
        mutable_registered_object();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::ObjectIdP>&
        registered_object() const;

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSubtree)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::ObjectIdP> registered_object_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationSubtree* default_instance_;
    };
    // -------------------------------------------------------------------

    class InfoMessage : public ::google::protobuf::MessageLite {
    public:
        InfoMessage();
        virtual ~InfoMessage();

        InfoMessage(const InfoMessage& from);

        inline InfoMessage& operator=(const InfoMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const InfoMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const InfoMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(InfoMessage* other);

        // implements Message ----------------------------------------------

        inline InfoMessage* New() const { return New(NULL); }

        InfoMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const InfoMessage& from);
        void MergeFrom(const InfoMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(InfoMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ClientVersion client_version = 1;
        bool has_client_version() const;
        void clear_client_version();
        static const int kClientVersionFieldNumber = 1;
        const ::ipc::invalidation::ClientVersion& client_version() const;
        ::ipc::invalidation::ClientVersion* mutable_client_version();
        ::ipc::invalidation::ClientVersion* release_client_version();
        void set_allocated_client_version(::ipc::invalidation::ClientVersion* client_version);

        // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
        int config_parameter_size() const;
        void clear_config_parameter();
        static const int kConfigParameterFieldNumber = 2;
        const ::ipc::invalidation::PropertyRecord& config_parameter(int index) const;
        ::ipc::invalidation::PropertyRecord* mutable_config_parameter(int index);
        ::ipc::invalidation::PropertyRecord* add_config_parameter();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>*
        mutable_config_parameter();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>&
        config_parameter() const;

        // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
        int performance_counter_size() const;
        void clear_performance_counter();
        static const int kPerformanceCounterFieldNumber = 3;
        const ::ipc::invalidation::PropertyRecord& performance_counter(int index) const;
        ::ipc::invalidation::PropertyRecord* mutable_performance_counter(int index);
        ::ipc::invalidation::PropertyRecord* add_performance_counter();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>*
        mutable_performance_counter();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>&
        performance_counter() const;

        // optional bool server_registration_summary_requested = 4;
        bool has_server_registration_summary_requested() const;
        void clear_server_registration_summary_requested();
        static const int kServerRegistrationSummaryRequestedFieldNumber = 4;
        bool server_registration_summary_requested() const;
        void set_server_registration_summary_requested(bool value);

        // optional .ipc.invalidation.ClientConfigP client_config = 5;
        bool has_client_config() const;
        void clear_client_config();
        static const int kClientConfigFieldNumber = 5;
        const ::ipc::invalidation::ClientConfigP& client_config() const;
        ::ipc::invalidation::ClientConfigP* mutable_client_config();
        ::ipc::invalidation::ClientConfigP* release_client_config();
        void set_allocated_client_config(::ipc::invalidation::ClientConfigP* client_config);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.InfoMessage)
    private:
        inline void set_has_client_version();
        inline void clear_has_client_version();
        inline void set_has_server_registration_summary_requested();
        inline void clear_has_server_registration_summary_requested();
        inline void set_has_client_config();
        inline void clear_has_client_config();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::ClientVersion* client_version_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord> config_parameter_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord> performance_counter_;
        ::ipc::invalidation::ClientConfigP* client_config_;
        bool server_registration_summary_requested_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static InfoMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class PropertyRecord : public ::google::protobuf::MessageLite {
    public:
        PropertyRecord();
        virtual ~PropertyRecord();

        PropertyRecord(const PropertyRecord& from);

        inline PropertyRecord& operator=(const PropertyRecord& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const PropertyRecord& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const PropertyRecord* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(PropertyRecord* other);

        // implements Message ----------------------------------------------

        inline PropertyRecord* New() const { return New(NULL); }

        PropertyRecord* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const PropertyRecord& from);
        void MergeFrom(const PropertyRecord& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(PropertyRecord* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional string name = 1;
        bool has_name() const;
        void clear_name();
        static const int kNameFieldNumber = 1;
        const ::std::string& name() const;
        void set_name(const ::std::string& value);
        void set_name(const char* value);
        void set_name(const char* value, size_t size);
        ::std::string* mutable_name();
        ::std::string* release_name();
        void set_allocated_name(::std::string* name);

        // optional int32 value = 2;
        bool has_value() const;
        void clear_value();
        static const int kValueFieldNumber = 2;
        ::google::protobuf::int32 value() const;
        void set_value(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.PropertyRecord)
    private:
        inline void set_has_name();
        inline void clear_has_name();
        inline void set_has_value();
        inline void clear_has_value();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr name_;
        ::google::protobuf::int32 value_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static PropertyRecord* default_instance_;
    };
    // -------------------------------------------------------------------

    class ServerHeader : public ::google::protobuf::MessageLite {
    public:
        ServerHeader();
        virtual ~ServerHeader();

        ServerHeader(const ServerHeader& from);

        inline ServerHeader& operator=(const ServerHeader& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ServerHeader& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ServerHeader* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ServerHeader* other);

        // implements Message ----------------------------------------------

        inline ServerHeader* New() const { return New(NULL); }

        ServerHeader* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ServerHeader& from);
        void MergeFrom(const ServerHeader& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ServerHeader* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
        bool has_protocol_version() const;
        void clear_protocol_version();
        static const int kProtocolVersionFieldNumber = 1;
        const ::ipc::invalidation::ProtocolVersion& protocol_version() const;
        ::ipc::invalidation::ProtocolVersion* mutable_protocol_version();
        ::ipc::invalidation::ProtocolVersion* release_protocol_version();
        void set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version);

        // optional bytes client_token = 2;
        bool has_client_token() const;
        void clear_client_token();
        static const int kClientTokenFieldNumber = 2;
        const ::std::string& client_token() const;
        void set_client_token(const ::std::string& value);
        void set_client_token(const char* value);
        void set_client_token(const void* value, size_t size);
        ::std::string* mutable_client_token();
        ::std::string* release_client_token();
        void set_allocated_client_token(::std::string* client_token);

        // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
        bool has_registration_summary() const;
        void clear_registration_summary();
        static const int kRegistrationSummaryFieldNumber = 3;
        const ::ipc::invalidation::RegistrationSummary& registration_summary() const;
        ::ipc::invalidation::RegistrationSummary* mutable_registration_summary();
        ::ipc::invalidation::RegistrationSummary* release_registration_summary();
        void set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary);

        // optional int64 server_time_ms = 4;
        bool has_server_time_ms() const;
        void clear_server_time_ms();
        static const int kServerTimeMsFieldNumber = 4;
        ::google::protobuf::int64 server_time_ms() const;
        void set_server_time_ms(::google::protobuf::int64 value);

        // optional string message_id = 5;
        bool has_message_id() const;
        void clear_message_id();
        static const int kMessageIdFieldNumber = 5;
        const ::std::string& message_id() const;
        void set_message_id(const ::std::string& value);
        void set_message_id(const char* value);
        void set_message_id(const char* value, size_t size);
        ::std::string* mutable_message_id();
        ::std::string* release_message_id();
        void set_allocated_message_id(::std::string* message_id);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ServerHeader)
    private:
        inline void set_has_protocol_version();
        inline void clear_has_protocol_version();
        inline void set_has_client_token();
        inline void clear_has_client_token();
        inline void set_has_registration_summary();
        inline void clear_has_registration_summary();
        inline void set_has_server_time_ms();
        inline void clear_has_server_time_ms();
        inline void set_has_message_id();
        inline void clear_has_message_id();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::ProtocolVersion* protocol_version_;
        ::google::protobuf::internal::ArenaStringPtr client_token_;
        ::ipc::invalidation::RegistrationSummary* registration_summary_;
        ::google::protobuf::int64 server_time_ms_;
        ::google::protobuf::internal::ArenaStringPtr message_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ServerHeader* default_instance_;
    };
    // -------------------------------------------------------------------

    class ServerToClientMessage : public ::google::protobuf::MessageLite {
    public:
        ServerToClientMessage();
        virtual ~ServerToClientMessage();

        ServerToClientMessage(const ServerToClientMessage& from);

        inline ServerToClientMessage& operator=(const ServerToClientMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ServerToClientMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ServerToClientMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ServerToClientMessage* other);

        // implements Message ----------------------------------------------

        inline ServerToClientMessage* New() const { return New(NULL); }

        ServerToClientMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ServerToClientMessage& from);
        void MergeFrom(const ServerToClientMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ServerToClientMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ServerHeader header = 1;
        bool has_header() const;
        void clear_header();
        static const int kHeaderFieldNumber = 1;
        const ::ipc::invalidation::ServerHeader& header() const;
        ::ipc::invalidation::ServerHeader* mutable_header();
        ::ipc::invalidation::ServerHeader* release_header();
        void set_allocated_header(::ipc::invalidation::ServerHeader* header);

        // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
        bool has_token_control_message() const;
        void clear_token_control_message();
        static const int kTokenControlMessageFieldNumber = 2;
        const ::ipc::invalidation::TokenControlMessage& token_control_message() const;
        ::ipc::invalidation::TokenControlMessage* mutable_token_control_message();
        ::ipc::invalidation::TokenControlMessage* release_token_control_message();
        void set_allocated_token_control_message(::ipc::invalidation::TokenControlMessage* token_control_message);

        // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
        bool has_invalidation_message() const;
        void clear_invalidation_message();
        static const int kInvalidationMessageFieldNumber = 3;
        const ::ipc::invalidation::InvalidationMessage& invalidation_message() const;
        ::ipc::invalidation::InvalidationMessage* mutable_invalidation_message();
        ::ipc::invalidation::InvalidationMessage* release_invalidation_message();
        void set_allocated_invalidation_message(::ipc::invalidation::InvalidationMessage* invalidation_message);

        // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
        bool has_registration_status_message() const;
        void clear_registration_status_message();
        static const int kRegistrationStatusMessageFieldNumber = 4;
        const ::ipc::invalidation::RegistrationStatusMessage& registration_status_message() const;
        ::ipc::invalidation::RegistrationStatusMessage* mutable_registration_status_message();
        ::ipc::invalidation::RegistrationStatusMessage* release_registration_status_message();
        void set_allocated_registration_status_message(::ipc::invalidation::RegistrationStatusMessage* registration_status_message);

        // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
        bool has_registration_sync_request_message() const;
        void clear_registration_sync_request_message();
        static const int kRegistrationSyncRequestMessageFieldNumber = 5;
        const ::ipc::invalidation::RegistrationSyncRequestMessage& registration_sync_request_message() const;
        ::ipc::invalidation::RegistrationSyncRequestMessage* mutable_registration_sync_request_message();
        ::ipc::invalidation::RegistrationSyncRequestMessage* release_registration_sync_request_message();
        void set_allocated_registration_sync_request_message(::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message);

        // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
        bool has_config_change_message() const;
        void clear_config_change_message();
        static const int kConfigChangeMessageFieldNumber = 6;
        const ::ipc::invalidation::ConfigChangeMessage& config_change_message() const;
        ::ipc::invalidation::ConfigChangeMessage* mutable_config_change_message();
        ::ipc::invalidation::ConfigChangeMessage* release_config_change_message();
        void set_allocated_config_change_message(::ipc::invalidation::ConfigChangeMessage* config_change_message);

        // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
        bool has_info_request_message() const;
        void clear_info_request_message();
        static const int kInfoRequestMessageFieldNumber = 7;
        const ::ipc::invalidation::InfoRequestMessage& info_request_message() const;
        ::ipc::invalidation::InfoRequestMessage* mutable_info_request_message();
        ::ipc::invalidation::InfoRequestMessage* release_info_request_message();
        void set_allocated_info_request_message(::ipc::invalidation::InfoRequestMessage* info_request_message);

        // optional .ipc.invalidation.ErrorMessage error_message = 8;
        bool has_error_message() const;
        void clear_error_message();
        static const int kErrorMessageFieldNumber = 8;
        const ::ipc::invalidation::ErrorMessage& error_message() const;
        ::ipc::invalidation::ErrorMessage* mutable_error_message();
        ::ipc::invalidation::ErrorMessage* release_error_message();
        void set_allocated_error_message(::ipc::invalidation::ErrorMessage* error_message);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ServerToClientMessage)
    private:
        inline void set_has_header();
        inline void clear_has_header();
        inline void set_has_token_control_message();
        inline void clear_has_token_control_message();
        inline void set_has_invalidation_message();
        inline void clear_has_invalidation_message();
        inline void set_has_registration_status_message();
        inline void clear_has_registration_status_message();
        inline void set_has_registration_sync_request_message();
        inline void clear_has_registration_sync_request_message();
        inline void set_has_config_change_message();
        inline void clear_has_config_change_message();
        inline void set_has_info_request_message();
        inline void clear_has_info_request_message();
        inline void set_has_error_message();
        inline void clear_has_error_message();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::ServerHeader* header_;
        ::ipc::invalidation::TokenControlMessage* token_control_message_;
        ::ipc::invalidation::InvalidationMessage* invalidation_message_;
        ::ipc::invalidation::RegistrationStatusMessage* registration_status_message_;
        ::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message_;
        ::ipc::invalidation::ConfigChangeMessage* config_change_message_;
        ::ipc::invalidation::InfoRequestMessage* info_request_message_;
        ::ipc::invalidation::ErrorMessage* error_message_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ServerToClientMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class TokenControlMessage : public ::google::protobuf::MessageLite {
    public:
        TokenControlMessage();
        virtual ~TokenControlMessage();

        TokenControlMessage(const TokenControlMessage& from);

        inline TokenControlMessage& operator=(const TokenControlMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const TokenControlMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const TokenControlMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(TokenControlMessage* other);

        // implements Message ----------------------------------------------

        inline TokenControlMessage* New() const { return New(NULL); }

        TokenControlMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const TokenControlMessage& from);
        void MergeFrom(const TokenControlMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(TokenControlMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional bytes new_token = 1;
        bool has_new_token() const;
        void clear_new_token();
        static const int kNewTokenFieldNumber = 1;
        const ::std::string& new_token() const;
        void set_new_token(const ::std::string& value);
        void set_new_token(const char* value);
        void set_new_token(const void* value, size_t size);
        ::std::string* mutable_new_token();
        ::std::string* release_new_token();
        void set_allocated_new_token(::std::string* new_token);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.TokenControlMessage)
    private:
        inline void set_has_new_token();
        inline void clear_has_new_token();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr new_token_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static TokenControlMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationStatus : public ::google::protobuf::MessageLite {
    public:
        RegistrationStatus();
        virtual ~RegistrationStatus();

        RegistrationStatus(const RegistrationStatus& from);

        inline RegistrationStatus& operator=(const RegistrationStatus& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationStatus& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationStatus* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationStatus* other);

        // implements Message ----------------------------------------------

        inline RegistrationStatus* New() const { return New(NULL); }

        RegistrationStatus* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationStatus& from);
        void MergeFrom(const RegistrationStatus& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationStatus* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.RegistrationP registration = 1;
        bool has_registration() const;
        void clear_registration();
        static const int kRegistrationFieldNumber = 1;
        const ::ipc::invalidation::RegistrationP& registration() const;
        ::ipc::invalidation::RegistrationP* mutable_registration();
        ::ipc::invalidation::RegistrationP* release_registration();
        void set_allocated_registration(::ipc::invalidation::RegistrationP* registration);

        // optional .ipc.invalidation.StatusP status = 2;
        bool has_status() const;
        void clear_status();
        static const int kStatusFieldNumber = 2;
        const ::ipc::invalidation::StatusP& status() const;
        ::ipc::invalidation::StatusP* mutable_status();
        ::ipc::invalidation::StatusP* release_status();
        void set_allocated_status(::ipc::invalidation::StatusP* status);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationStatus)
    private:
        inline void set_has_registration();
        inline void clear_has_registration();
        inline void set_has_status();
        inline void clear_has_status();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::RegistrationP* registration_;
        ::ipc::invalidation::StatusP* status_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationStatus* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationStatusMessage : public ::google::protobuf::MessageLite {
    public:
        RegistrationStatusMessage();
        virtual ~RegistrationStatusMessage();

        RegistrationStatusMessage(const RegistrationStatusMessage& from);

        inline RegistrationStatusMessage& operator=(const RegistrationStatusMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationStatusMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationStatusMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationStatusMessage* other);

        // implements Message ----------------------------------------------

        inline RegistrationStatusMessage* New() const { return New(NULL); }

        RegistrationStatusMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationStatusMessage& from);
        void MergeFrom(const RegistrationStatusMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationStatusMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
        int registration_status_size() const;
        void clear_registration_status();
        static const int kRegistrationStatusFieldNumber = 1;
        const ::ipc::invalidation::RegistrationStatus& registration_status(int index) const;
        ::ipc::invalidation::RegistrationStatus* mutable_registration_status(int index);
        ::ipc::invalidation::RegistrationStatus* add_registration_status();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationStatus>*
        mutable_registration_status();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationStatus>&
        registration_status() const;

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationStatusMessage)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationStatus> registration_status_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationStatusMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class RegistrationSyncRequestMessage : public ::google::protobuf::MessageLite {
    public:
        RegistrationSyncRequestMessage();
        virtual ~RegistrationSyncRequestMessage();

        RegistrationSyncRequestMessage(const RegistrationSyncRequestMessage& from);

        inline RegistrationSyncRequestMessage& operator=(const RegistrationSyncRequestMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RegistrationSyncRequestMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RegistrationSyncRequestMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RegistrationSyncRequestMessage* other);

        // implements Message ----------------------------------------------

        inline RegistrationSyncRequestMessage* New() const { return New(NULL); }

        RegistrationSyncRequestMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RegistrationSyncRequestMessage& from);
        void MergeFrom(const RegistrationSyncRequestMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RegistrationSyncRequestMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RegistrationSyncRequestMessage)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RegistrationSyncRequestMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class InvalidationMessage : public ::google::protobuf::MessageLite {
    public:
        InvalidationMessage();
        virtual ~InvalidationMessage();

        InvalidationMessage(const InvalidationMessage& from);

        inline InvalidationMessage& operator=(const InvalidationMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const InvalidationMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const InvalidationMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(InvalidationMessage* other);

        // implements Message ----------------------------------------------

        inline InvalidationMessage* New() const { return New(NULL); }

        InvalidationMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const InvalidationMessage& from);
        void MergeFrom(const InvalidationMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(InvalidationMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // repeated .ipc.invalidation.InvalidationP invalidation = 1;
        int invalidation_size() const;
        void clear_invalidation();
        static const int kInvalidationFieldNumber = 1;
        const ::ipc::invalidation::InvalidationP& invalidation(int index) const;
        ::ipc::invalidation::InvalidationP* mutable_invalidation(int index);
        ::ipc::invalidation::InvalidationP* add_invalidation();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::InvalidationP>*
        mutable_invalidation();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::InvalidationP>&
        invalidation() const;

        // @@protoc_insertion_point(class_scope:ipc.invalidation.InvalidationMessage)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::InvalidationP> invalidation_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static InvalidationMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class InfoRequestMessage : public ::google::protobuf::MessageLite {
    public:
        InfoRequestMessage();
        virtual ~InfoRequestMessage();

        InfoRequestMessage(const InfoRequestMessage& from);

        inline InfoRequestMessage& operator=(const InfoRequestMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const InfoRequestMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const InfoRequestMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(InfoRequestMessage* other);

        // implements Message ----------------------------------------------

        inline InfoRequestMessage* New() const { return New(NULL); }

        InfoRequestMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const InfoRequestMessage& from);
        void MergeFrom(const InfoRequestMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(InfoRequestMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef InfoRequestMessage_InfoType InfoType;
        static const InfoType GET_PERFORMANCE_COUNTERS = InfoRequestMessage_InfoType_GET_PERFORMANCE_COUNTERS;
        static inline bool InfoType_IsValid(int value)
        {
            return InfoRequestMessage_InfoType_IsValid(value);
        }
        static const InfoType InfoType_MIN = InfoRequestMessage_InfoType_InfoType_MIN;
        static const InfoType InfoType_MAX = InfoRequestMessage_InfoType_InfoType_MAX;
        static const int InfoType_ARRAYSIZE = InfoRequestMessage_InfoType_InfoType_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
        int info_type_size() const;
        void clear_info_type();
        static const int kInfoTypeFieldNumber = 1;
        ::ipc::invalidation::InfoRequestMessage_InfoType info_type(int index) const;
        void set_info_type(int index, ::ipc::invalidation::InfoRequestMessage_InfoType value);
        void add_info_type(::ipc::invalidation::InfoRequestMessage_InfoType value);
        const ::google::protobuf::RepeatedField<int>& info_type() const;
        ::google::protobuf::RepeatedField<int>* mutable_info_type();

        // @@protoc_insertion_point(class_scope:ipc.invalidation.InfoRequestMessage)
    private:
        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedField<int> info_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static InfoRequestMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class RateLimitP : public ::google::protobuf::MessageLite {
    public:
        RateLimitP();
        virtual ~RateLimitP();

        RateLimitP(const RateLimitP& from);

        inline RateLimitP& operator=(const RateLimitP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const RateLimitP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const RateLimitP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(RateLimitP* other);

        // implements Message ----------------------------------------------

        inline RateLimitP* New() const { return New(NULL); }

        RateLimitP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const RateLimitP& from);
        void MergeFrom(const RateLimitP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(RateLimitP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 window_ms = 1;
        bool has_window_ms() const;
        void clear_window_ms();
        static const int kWindowMsFieldNumber = 1;
        ::google::protobuf::int32 window_ms() const;
        void set_window_ms(::google::protobuf::int32 value);

        // optional int32 count = 2;
        bool has_count() const;
        void clear_count();
        static const int kCountFieldNumber = 2;
        ::google::protobuf::int32 count() const;
        void set_count(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.RateLimitP)
    private:
        inline void set_has_window_ms();
        inline void clear_has_window_ms();
        inline void set_has_count();
        inline void clear_has_count();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int32 window_ms_;
        ::google::protobuf::int32 count_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static RateLimitP* default_instance_;
    };
    // -------------------------------------------------------------------

    class ProtocolHandlerConfigP : public ::google::protobuf::MessageLite {
    public:
        ProtocolHandlerConfigP();
        virtual ~ProtocolHandlerConfigP();

        ProtocolHandlerConfigP(const ProtocolHandlerConfigP& from);

        inline ProtocolHandlerConfigP& operator=(const ProtocolHandlerConfigP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ProtocolHandlerConfigP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ProtocolHandlerConfigP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ProtocolHandlerConfigP* other);

        // implements Message ----------------------------------------------

        inline ProtocolHandlerConfigP* New() const { return New(NULL); }

        ProtocolHandlerConfigP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ProtocolHandlerConfigP& from);
        void MergeFrom(const ProtocolHandlerConfigP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ProtocolHandlerConfigP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 batching_delay_ms = 1 [default = 500];
        bool has_batching_delay_ms() const;
        void clear_batching_delay_ms();
        static const int kBatchingDelayMsFieldNumber = 1;
        ::google::protobuf::int32 batching_delay_ms() const;
        void set_batching_delay_ms(::google::protobuf::int32 value);

        // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
        int rate_limit_size() const;
        void clear_rate_limit();
        static const int kRateLimitFieldNumber = 2;
        const ::ipc::invalidation::RateLimitP& rate_limit(int index) const;
        ::ipc::invalidation::RateLimitP* mutable_rate_limit(int index);
        ::ipc::invalidation::RateLimitP* add_rate_limit();
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RateLimitP>*
        mutable_rate_limit();
        const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RateLimitP>&
        rate_limit() const;

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ProtocolHandlerConfigP)
    private:
        inline void set_has_batching_delay_ms();
        inline void clear_has_batching_delay_ms();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RateLimitP> rate_limit_;
        ::google::protobuf::int32 batching_delay_ms_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ProtocolHandlerConfigP* default_instance_;
    };
    // -------------------------------------------------------------------

    class ClientConfigP : public ::google::protobuf::MessageLite {
    public:
        ClientConfigP();
        virtual ~ClientConfigP();

        ClientConfigP(const ClientConfigP& from);

        inline ClientConfigP& operator=(const ClientConfigP& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ClientConfigP& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ClientConfigP* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ClientConfigP* other);

        // implements Message ----------------------------------------------

        inline ClientConfigP* New() const { return New(NULL); }

        ClientConfigP* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ClientConfigP& from);
        void MergeFrom(const ClientConfigP& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ClientConfigP* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.Version version = 1;
        bool has_version() const;
        void clear_version();
        static const int kVersionFieldNumber = 1;
        const ::ipc::invalidation::Version& version() const;
        ::ipc::invalidation::Version* mutable_version();
        ::ipc::invalidation::Version* release_version();
        void set_allocated_version(::ipc::invalidation::Version* version);

        // optional int32 network_timeout_delay_ms = 2 [default = 60000];
        bool has_network_timeout_delay_ms() const;
        void clear_network_timeout_delay_ms();
        static const int kNetworkTimeoutDelayMsFieldNumber = 2;
        ::google::protobuf::int32 network_timeout_delay_ms() const;
        void set_network_timeout_delay_ms(::google::protobuf::int32 value);

        // optional int32 write_retry_delay_ms = 3 [default = 10000];
        bool has_write_retry_delay_ms() const;
        void clear_write_retry_delay_ms();
        static const int kWriteRetryDelayMsFieldNumber = 3;
        ::google::protobuf::int32 write_retry_delay_ms() const;
        void set_write_retry_delay_ms(::google::protobuf::int32 value);

        // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
        bool has_heartbeat_interval_ms() const;
        void clear_heartbeat_interval_ms();
        static const int kHeartbeatIntervalMsFieldNumber = 4;
        ::google::protobuf::int32 heartbeat_interval_ms() const;
        void set_heartbeat_interval_ms(::google::protobuf::int32 value);

        // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
        bool has_perf_counter_delay_ms() const;
        void clear_perf_counter_delay_ms();
        static const int kPerfCounterDelayMsFieldNumber = 5;
        ::google::protobuf::int32 perf_counter_delay_ms() const;
        void set_perf_counter_delay_ms(::google::protobuf::int32 value);

        // optional int32 max_exponential_backoff_factor = 6 [default = 500];
        bool has_max_exponential_backoff_factor() const;
        void clear_max_exponential_backoff_factor();
        static const int kMaxExponentialBackoffFactorFieldNumber = 6;
        ::google::protobuf::int32 max_exponential_backoff_factor() const;
        void set_max_exponential_backoff_factor(::google::protobuf::int32 value);

        // optional int32 smear_percent = 7 [default = 20];
        bool has_smear_percent() const;
        void clear_smear_percent();
        static const int kSmearPercentFieldNumber = 7;
        ::google::protobuf::int32 smear_percent() const;
        void set_smear_percent(::google::protobuf::int32 value);

        // optional bool is_transient = 8 [default = false];
        bool has_is_transient() const;
        void clear_is_transient();
        static const int kIsTransientFieldNumber = 8;
        bool is_transient() const;
        void set_is_transient(bool value);

        // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
        bool has_initial_persistent_heartbeat_delay_ms() const;
        void clear_initial_persistent_heartbeat_delay_ms();
        static const int kInitialPersistentHeartbeatDelayMsFieldNumber = 9;
        ::google::protobuf::int32 initial_persistent_heartbeat_delay_ms() const;
        void set_initial_persistent_heartbeat_delay_ms(::google::protobuf::int32 value);

        // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
        bool has_protocol_handler_config() const;
        void clear_protocol_handler_config();
        static const int kProtocolHandlerConfigFieldNumber = 10;
        const ::ipc::invalidation::ProtocolHandlerConfigP& protocol_handler_config() const;
        ::ipc::invalidation::ProtocolHandlerConfigP* mutable_protocol_handler_config();
        ::ipc::invalidation::ProtocolHandlerConfigP* release_protocol_handler_config();
        void set_allocated_protocol_handler_config(::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config);

        // optional bool channel_supports_offline_delivery = 11 [default = false];
        bool has_channel_supports_offline_delivery() const;
        void clear_channel_supports_offline_delivery();
        static const int kChannelSupportsOfflineDeliveryFieldNumber = 11;
        bool channel_supports_offline_delivery() const;
        void set_channel_supports_offline_delivery(bool value);

        // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
        bool has_offline_heartbeat_threshold_ms() const;
        void clear_offline_heartbeat_threshold_ms();
        static const int kOfflineHeartbeatThresholdMsFieldNumber = 12;
        ::google::protobuf::int32 offline_heartbeat_threshold_ms() const;
        void set_offline_heartbeat_threshold_ms(::google::protobuf::int32 value);

        // optional bool allow_suppression = 13 [default = true];
        bool has_allow_suppression() const;
        void clear_allow_suppression();
        static const int kAllowSuppressionFieldNumber = 13;
        bool allow_suppression() const;
        void set_allow_suppression(bool value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ClientConfigP)
    private:
        inline void set_has_version();
        inline void clear_has_version();
        inline void set_has_network_timeout_delay_ms();
        inline void clear_has_network_timeout_delay_ms();
        inline void set_has_write_retry_delay_ms();
        inline void clear_has_write_retry_delay_ms();
        inline void set_has_heartbeat_interval_ms();
        inline void clear_has_heartbeat_interval_ms();
        inline void set_has_perf_counter_delay_ms();
        inline void clear_has_perf_counter_delay_ms();
        inline void set_has_max_exponential_backoff_factor();
        inline void clear_has_max_exponential_backoff_factor();
        inline void set_has_smear_percent();
        inline void clear_has_smear_percent();
        inline void set_has_is_transient();
        inline void clear_has_is_transient();
        inline void set_has_initial_persistent_heartbeat_delay_ms();
        inline void clear_has_initial_persistent_heartbeat_delay_ms();
        inline void set_has_protocol_handler_config();
        inline void clear_has_protocol_handler_config();
        inline void set_has_channel_supports_offline_delivery();
        inline void clear_has_channel_supports_offline_delivery();
        inline void set_has_offline_heartbeat_threshold_ms();
        inline void clear_has_offline_heartbeat_threshold_ms();
        inline void set_has_allow_suppression();
        inline void clear_has_allow_suppression();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::ipc::invalidation::Version* version_;
        ::google::protobuf::int32 network_timeout_delay_ms_;
        ::google::protobuf::int32 write_retry_delay_ms_;
        ::google::protobuf::int32 heartbeat_interval_ms_;
        ::google::protobuf::int32 perf_counter_delay_ms_;
        ::google::protobuf::int32 max_exponential_backoff_factor_;
        ::google::protobuf::int32 smear_percent_;
        ::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config_;
        ::google::protobuf::int32 initial_persistent_heartbeat_delay_ms_;
        bool is_transient_;
        bool channel_supports_offline_delivery_;
        bool allow_suppression_;
        ::google::protobuf::int32 offline_heartbeat_threshold_ms_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ClientConfigP* default_instance_;
    };
    // -------------------------------------------------------------------

    class ConfigChangeMessage : public ::google::protobuf::MessageLite {
    public:
        ConfigChangeMessage();
        virtual ~ConfigChangeMessage();

        ConfigChangeMessage(const ConfigChangeMessage& from);

        inline ConfigChangeMessage& operator=(const ConfigChangeMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ConfigChangeMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ConfigChangeMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ConfigChangeMessage* other);

        // implements Message ----------------------------------------------

        inline ConfigChangeMessage* New() const { return New(NULL); }

        ConfigChangeMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ConfigChangeMessage& from);
        void MergeFrom(const ConfigChangeMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ConfigChangeMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int64 next_message_delay_ms = 1;
        bool has_next_message_delay_ms() const;
        void clear_next_message_delay_ms();
        static const int kNextMessageDelayMsFieldNumber = 1;
        ::google::protobuf::int64 next_message_delay_ms() const;
        void set_next_message_delay_ms(::google::protobuf::int64 value);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ConfigChangeMessage)
    private:
        inline void set_has_next_message_delay_ms();
        inline void clear_has_next_message_delay_ms();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 next_message_delay_ms_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ConfigChangeMessage* default_instance_;
    };
    // -------------------------------------------------------------------

    class ErrorMessage : public ::google::protobuf::MessageLite {
    public:
        ErrorMessage();
        virtual ~ErrorMessage();

        ErrorMessage(const ErrorMessage& from);

        inline ErrorMessage& operator=(const ErrorMessage& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const ErrorMessage& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const ErrorMessage* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(ErrorMessage* other);

        // implements Message ----------------------------------------------

        inline ErrorMessage* New() const { return New(NULL); }

        ErrorMessage* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const ErrorMessage& from);
        void MergeFrom(const ErrorMessage& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(ErrorMessage* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef ErrorMessage_Code Code;
        static const Code AUTH_FAILURE = ErrorMessage_Code_AUTH_FAILURE;
        static const Code UNKNOWN_FAILURE = ErrorMessage_Code_UNKNOWN_FAILURE;
        static inline bool Code_IsValid(int value)
        {
            return ErrorMessage_Code_IsValid(value);
        }
        static const Code Code_MIN = ErrorMessage_Code_Code_MIN;
        static const Code Code_MAX = ErrorMessage_Code_Code_MAX;
        static const int Code_ARRAYSIZE = ErrorMessage_Code_Code_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional .ipc.invalidation.ErrorMessage.Code code = 1;
        bool has_code() const;
        void clear_code();
        static const int kCodeFieldNumber = 1;
        ::ipc::invalidation::ErrorMessage_Code code() const;
        void set_code(::ipc::invalidation::ErrorMessage_Code value);

        // optional string description = 2;
        bool has_description() const;
        void clear_description();
        static const int kDescriptionFieldNumber = 2;
        const ::std::string& description() const;
        void set_description(const ::std::string& value);
        void set_description(const char* value);
        void set_description(const char* value, size_t size);
        ::std::string* mutable_description();
        ::std::string* release_description();
        void set_allocated_description(::std::string* description);

        // @@protoc_insertion_point(class_scope:ipc.invalidation.ErrorMessage)
    private:
        inline void set_has_code();
        inline void clear_has_code();
        inline void set_has_description();
        inline void clear_has_description();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr description_;
        int code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_client_5fprotocol_2eproto_impl();
#else
        friend void protobuf_AddDesc_client_5fprotocol_2eproto();
#endif
        friend void protobuf_AssignDesc_client_5fprotocol_2eproto();
        friend void protobuf_ShutdownFile_client_5fprotocol_2eproto();

        void InitAsDefaultInstance();
        static ErrorMessage* default_instance_;
    };
    // ===================================================================

    // ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
    // Version

    // optional int32 major_version = 1;
    inline bool Version::has_major_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Version::set_has_major_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Version::clear_has_major_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Version::clear_major_version()
    {
        major_version_ = 0;
        clear_has_major_version();
    }
    inline ::google::protobuf::int32 Version::major_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.Version.major_version)
        return major_version_;
    }
    inline void Version::set_major_version(::google::protobuf::int32 value)
    {
        set_has_major_version();
        major_version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.Version.major_version)
    }

    // optional int32 minor_version = 2;
    inline bool Version::has_minor_version() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Version::set_has_minor_version()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Version::clear_has_minor_version()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Version::clear_minor_version()
    {
        minor_version_ = 0;
        clear_has_minor_version();
    }
    inline ::google::protobuf::int32 Version::minor_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.Version.minor_version)
        return minor_version_;
    }
    inline void Version::set_minor_version(::google::protobuf::int32 value)
    {
        set_has_minor_version();
        minor_version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.Version.minor_version)
    }

    // -------------------------------------------------------------------

    // ProtocolVersion

    // optional .ipc.invalidation.Version version = 1;
    inline bool ProtocolVersion::has_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ProtocolVersion::set_has_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ProtocolVersion::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ProtocolVersion::clear_version()
    {
        if (version_ != NULL)
            version_->::ipc::invalidation::Version::Clear();
        clear_has_version();
    }
    inline const ::ipc::invalidation::Version& ProtocolVersion::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolVersion.version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return version_ != NULL ? *version_ : *default_instance().version_;
#else
        return version_ != NULL ? *version_ : *default_instance_->version_;
#endif
    }
    inline ::ipc::invalidation::Version* ProtocolVersion::mutable_version()
    {
        set_has_version();
        if (version_ == NULL) {
            version_ = new ::ipc::invalidation::Version;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolVersion.version)
        return version_;
    }
    inline ::ipc::invalidation::Version* ProtocolVersion::release_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ProtocolVersion.version)
        clear_has_version();
        ::ipc::invalidation::Version* temp = version_;
        version_ = NULL;
        return temp;
    }
    inline void ProtocolVersion::set_allocated_version(::ipc::invalidation::Version* version)
    {
        delete version_;
        version_ = version;
        if (version) {
            set_has_version();
        } else {
            clear_has_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ProtocolVersion.version)
    }

    // -------------------------------------------------------------------

    // ClientVersion

    // optional .ipc.invalidation.Version version = 1;
    inline bool ClientVersion::has_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ClientVersion::set_has_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ClientVersion::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ClientVersion::clear_version()
    {
        if (version_ != NULL)
            version_->::ipc::invalidation::Version::Clear();
        clear_has_version();
    }
    inline const ::ipc::invalidation::Version& ClientVersion::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return version_ != NULL ? *version_ : *default_instance().version_;
#else
        return version_ != NULL ? *version_ : *default_instance_->version_;
#endif
    }
    inline ::ipc::invalidation::Version* ClientVersion::mutable_version()
    {
        set_has_version();
        if (version_ == NULL) {
            version_ = new ::ipc::invalidation::Version;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.version)
        return version_;
    }
    inline ::ipc::invalidation::Version* ClientVersion::release_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.version)
        clear_has_version();
        ::ipc::invalidation::Version* temp = version_;
        version_ = NULL;
        return temp;
    }
    inline void ClientVersion::set_allocated_version(::ipc::invalidation::Version* version)
    {
        delete version_;
        version_ = version;
        if (version) {
            set_has_version();
        } else {
            clear_has_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.version)
    }

    // optional string platform = 2;
    inline bool ClientVersion::has_platform() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ClientVersion::set_has_platform()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ClientVersion::clear_has_platform()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ClientVersion::clear_platform()
    {
        platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_platform();
    }
    inline const ::std::string& ClientVersion::platform() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.platform)
        return platform_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientVersion::set_platform(const ::std::string& value)
    {
        set_has_platform();
        platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.platform)
    }
    inline void ClientVersion::set_platform(const char* value)
    {
        set_has_platform();
        platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.platform)
    }
    inline void ClientVersion::set_platform(const char* value, size_t size)
    {
        set_has_platform();
        platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.platform)
    }
    inline ::std::string* ClientVersion::mutable_platform()
    {
        set_has_platform();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.platform)
        return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ClientVersion::release_platform()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.platform)
        clear_has_platform();
        return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientVersion::set_allocated_platform(::std::string* platform)
    {
        if (platform != NULL) {
            set_has_platform();
        } else {
            clear_has_platform();
        }
        platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.platform)
    }

    // optional string language = 3;
    inline bool ClientVersion::has_language() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ClientVersion::set_has_language()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ClientVersion::clear_has_language()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ClientVersion::clear_language()
    {
        language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_language();
    }
    inline const ::std::string& ClientVersion::language() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.language)
        return language_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientVersion::set_language(const ::std::string& value)
    {
        set_has_language();
        language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.language)
    }
    inline void ClientVersion::set_language(const char* value)
    {
        set_has_language();
        language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.language)
    }
    inline void ClientVersion::set_language(const char* value, size_t size)
    {
        set_has_language();
        language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.language)
    }
    inline ::std::string* ClientVersion::mutable_language()
    {
        set_has_language();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.language)
        return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ClientVersion::release_language()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.language)
        clear_has_language();
        return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientVersion::set_allocated_language(::std::string* language)
    {
        if (language != NULL) {
            set_has_language();
        } else {
            clear_has_language();
        }
        language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.language)
    }

    // optional string application_info = 4;
    inline bool ClientVersion::has_application_info() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void ClientVersion::set_has_application_info()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void ClientVersion::clear_has_application_info()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void ClientVersion::clear_application_info()
    {
        application_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_application_info();
    }
    inline const ::std::string& ClientVersion::application_info() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.application_info)
        return application_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientVersion::set_application_info(const ::std::string& value)
    {
        set_has_application_info();
        application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.application_info)
    }
    inline void ClientVersion::set_application_info(const char* value)
    {
        set_has_application_info();
        application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.application_info)
    }
    inline void ClientVersion::set_application_info(const char* value, size_t size)
    {
        set_has_application_info();
        application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.application_info)
    }
    inline ::std::string* ClientVersion::mutable_application_info()
    {
        set_has_application_info();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.application_info)
        return application_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ClientVersion::release_application_info()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.application_info)
        clear_has_application_info();
        return application_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientVersion::set_allocated_application_info(::std::string* application_info)
    {
        if (application_info != NULL) {
            set_has_application_info();
        } else {
            clear_has_application_info();
        }
        application_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_info);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.application_info)
    }

    // -------------------------------------------------------------------

    // StatusP

    // optional .ipc.invalidation.StatusP.Code code = 1;
    inline bool StatusP::has_code() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void StatusP::set_has_code()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void StatusP::clear_has_code()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void StatusP::clear_code()
    {
        code_ = 1;
        clear_has_code();
    }
    inline ::ipc::invalidation::StatusP_Code StatusP::code() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.code)
        return static_cast<::ipc::invalidation::StatusP_Code>(code_);
    }
    inline void StatusP::set_code(::ipc::invalidation::StatusP_Code value)
    {
        assert(::ipc::invalidation::StatusP_Code_IsValid(value));
        set_has_code();
        code_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.code)
    }

    // optional string description = 2;
    inline bool StatusP::has_description() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void StatusP::set_has_description()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void StatusP::clear_has_description()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void StatusP::clear_description()
    {
        description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_description();
    }
    inline const ::std::string& StatusP::description() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.description)
        return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void StatusP::set_description(const ::std::string& value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.description)
    }
    inline void StatusP::set_description(const char* value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.StatusP.description)
    }
    inline void StatusP::set_description(const char* value, size_t size)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.StatusP.description)
    }
    inline ::std::string* StatusP::mutable_description()
    {
        set_has_description();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.StatusP.description)
        return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* StatusP::release_description()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.StatusP.description)
        clear_has_description();
        return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void StatusP::set_allocated_description(::std::string* description)
    {
        if (description != NULL) {
            set_has_description();
        } else {
            clear_has_description();
        }
        description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.StatusP.description)
    }

    // -------------------------------------------------------------------

    // ObjectIdP

    // optional int32 source = 1;
    inline bool ObjectIdP::has_source() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ObjectIdP::set_has_source()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ObjectIdP::clear_has_source()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ObjectIdP::clear_source()
    {
        source_ = 0;
        clear_has_source();
    }
    inline ::google::protobuf::int32 ObjectIdP::source() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.source)
        return source_;
    }
    inline void ObjectIdP::set_source(::google::protobuf::int32 value)
    {
        set_has_source();
        source_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.source)
    }

    // optional bytes name = 2;
    inline bool ObjectIdP::has_name() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ObjectIdP::set_has_name()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ObjectIdP::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ObjectIdP::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    inline const ::std::string& ObjectIdP::name() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ObjectIdP::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.name)
    }
    inline void ObjectIdP::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ObjectIdP.name)
    }
    inline void ObjectIdP::set_name(const void* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ObjectIdP.name)
    }
    inline ::std::string* ObjectIdP::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ObjectIdP.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ObjectIdP::release_name()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ObjectIdP.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ObjectIdP::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ObjectIdP.name)
    }

    // -------------------------------------------------------------------

    // ApplicationClientIdP

    // optional int32 client_type = 1;
    inline bool ApplicationClientIdP::has_client_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ApplicationClientIdP::set_has_client_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ApplicationClientIdP::clear_has_client_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ApplicationClientIdP::clear_client_type()
    {
        client_type_ = 0;
        clear_has_client_type();
    }
    inline ::google::protobuf::int32 ApplicationClientIdP::client_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_type)
        return client_type_;
    }
    inline void ApplicationClientIdP::set_client_type(::google::protobuf::int32 value)
    {
        set_has_client_type();
        client_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_type)
    }

    // optional bytes client_name = 2;
    inline bool ApplicationClientIdP::has_client_name() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ApplicationClientIdP::set_has_client_name()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ApplicationClientIdP::clear_has_client_name()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ApplicationClientIdP::clear_client_name()
    {
        client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_client_name();
    }
    inline const ::std::string& ApplicationClientIdP::client_name() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_name)
        return client_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ApplicationClientIdP::set_client_name(const ::std::string& value)
    {
        set_has_client_name();
        client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_name)
    }
    inline void ApplicationClientIdP::set_client_name(const char* value)
    {
        set_has_client_name();
        client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ApplicationClientIdP.client_name)
    }
    inline void ApplicationClientIdP::set_client_name(const void* value, size_t size)
    {
        set_has_client_name();
        client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ApplicationClientIdP.client_name)
    }
    inline ::std::string* ApplicationClientIdP::mutable_client_name()
    {
        set_has_client_name();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ApplicationClientIdP.client_name)
        return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ApplicationClientIdP::release_client_name()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ApplicationClientIdP.client_name)
        clear_has_client_name();
        return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ApplicationClientIdP::set_allocated_client_name(::std::string* client_name)
    {
        if (client_name != NULL) {
            set_has_client_name();
        } else {
            clear_has_client_name();
        }
        client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ApplicationClientIdP.client_name)
    }

    // -------------------------------------------------------------------

    // InvalidationP

    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    inline bool InvalidationP::has_object_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void InvalidationP::set_has_object_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void InvalidationP::clear_has_object_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void InvalidationP::clear_object_id()
    {
        if (object_id_ != NULL)
            object_id_->::ipc::invalidation::ObjectIdP::Clear();
        clear_has_object_id();
    }
    inline const ::ipc::invalidation::ObjectIdP& InvalidationP::object_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
        return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
    }
    inline ::ipc::invalidation::ObjectIdP* InvalidationP::mutable_object_id()
    {
        set_has_object_id();
        if (object_id_ == NULL) {
            object_id_ = new ::ipc::invalidation::ObjectIdP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.object_id)
        return object_id_;
    }
    inline ::ipc::invalidation::ObjectIdP* InvalidationP::release_object_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.object_id)
        clear_has_object_id();
        ::ipc::invalidation::ObjectIdP* temp = object_id_;
        object_id_ = NULL;
        return temp;
    }
    inline void InvalidationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id)
    {
        delete object_id_;
        object_id_ = object_id;
        if (object_id) {
            set_has_object_id();
        } else {
            clear_has_object_id();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.object_id)
    }

    // optional bool is_known_version = 2;
    inline bool InvalidationP::has_is_known_version() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void InvalidationP::set_has_is_known_version()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void InvalidationP::clear_has_is_known_version()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void InvalidationP::clear_is_known_version()
    {
        is_known_version_ = false;
        clear_has_is_known_version();
    }
    inline bool InvalidationP::is_known_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_known_version)
        return is_known_version_;
    }
    inline void InvalidationP::set_is_known_version(bool value)
    {
        set_has_is_known_version();
        is_known_version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_known_version)
    }

    // optional int64 version = 3;
    inline bool InvalidationP::has_version() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void InvalidationP::set_has_version()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void InvalidationP::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void InvalidationP::clear_version()
    {
        version_ = GOOGLE_LONGLONG(0);
        clear_has_version();
    }
    inline ::google::protobuf::int64 InvalidationP::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.version)
        return version_;
    }
    inline void InvalidationP::set_version(::google::protobuf::int64 value)
    {
        set_has_version();
        version_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.version)
    }

    // optional bool is_trickle_restart = 6 [default = false];
    inline bool InvalidationP::has_is_trickle_restart() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void InvalidationP::set_has_is_trickle_restart()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void InvalidationP::clear_has_is_trickle_restart()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void InvalidationP::clear_is_trickle_restart()
    {
        is_trickle_restart_ = false;
        clear_has_is_trickle_restart();
    }
    inline bool InvalidationP::is_trickle_restart() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_trickle_restart)
        return is_trickle_restart_;
    }
    inline void InvalidationP::set_is_trickle_restart(bool value)
    {
        set_has_is_trickle_restart();
        is_trickle_restart_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_trickle_restart)
    }

    // optional bytes payload = 4;
    inline bool InvalidationP::has_payload() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void InvalidationP::set_has_payload()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void InvalidationP::clear_has_payload()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void InvalidationP::clear_payload()
    {
        payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_payload();
    }
    inline const ::std::string& InvalidationP::payload() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.payload)
        return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void InvalidationP::set_payload(const ::std::string& value)
    {
        set_has_payload();
        payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.payload)
    }
    inline void InvalidationP::set_payload(const char* value)
    {
        set_has_payload();
        payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.InvalidationP.payload)
    }
    inline void InvalidationP::set_payload(const void* value, size_t size)
    {
        set_has_payload();
        payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InvalidationP.payload)
    }
    inline ::std::string* InvalidationP::mutable_payload()
    {
        set_has_payload();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.payload)
        return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* InvalidationP::release_payload()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.payload)
        clear_has_payload();
        return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void InvalidationP::set_allocated_payload(::std::string* payload)
    {
        if (payload != NULL) {
            set_has_payload();
        } else {
            clear_has_payload();
        }
        payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.payload)
    }

    // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
    inline bool InvalidationP::has_bridge_arrival_time_ms_deprecated() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void InvalidationP::set_has_bridge_arrival_time_ms_deprecated()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void InvalidationP::clear_has_bridge_arrival_time_ms_deprecated()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void InvalidationP::clear_bridge_arrival_time_ms_deprecated()
    {
        bridge_arrival_time_ms_deprecated_ = GOOGLE_LONGLONG(0);
        clear_has_bridge_arrival_time_ms_deprecated();
    }
    inline ::google::protobuf::int64 InvalidationP::bridge_arrival_time_ms_deprecated() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
        return bridge_arrival_time_ms_deprecated_;
    }
    inline void InvalidationP::set_bridge_arrival_time_ms_deprecated(::google::protobuf::int64 value)
    {
        set_has_bridge_arrival_time_ms_deprecated();
        bridge_arrival_time_ms_deprecated_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
    }

    // -------------------------------------------------------------------

    // RegistrationP

    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    inline bool RegistrationP::has_object_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RegistrationP::set_has_object_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RegistrationP::clear_has_object_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RegistrationP::clear_object_id()
    {
        if (object_id_ != NULL)
            object_id_->::ipc::invalidation::ObjectIdP::Clear();
        clear_has_object_id();
    }
    inline const ::ipc::invalidation::ObjectIdP& RegistrationP::object_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
        return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
    }
    inline ::ipc::invalidation::ObjectIdP* RegistrationP::mutable_object_id()
    {
        set_has_object_id();
        if (object_id_ == NULL) {
            object_id_ = new ::ipc::invalidation::ObjectIdP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationP.object_id)
        return object_id_;
    }
    inline ::ipc::invalidation::ObjectIdP* RegistrationP::release_object_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationP.object_id)
        clear_has_object_id();
        ::ipc::invalidation::ObjectIdP* temp = object_id_;
        object_id_ = NULL;
        return temp;
    }
    inline void RegistrationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id)
    {
        delete object_id_;
        object_id_ = object_id;
        if (object_id) {
            set_has_object_id();
        } else {
            clear_has_object_id();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationP.object_id)
    }

    // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
    inline bool RegistrationP::has_op_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RegistrationP::set_has_op_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RegistrationP::clear_has_op_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RegistrationP::clear_op_type()
    {
        op_type_ = 1;
        clear_has_op_type();
    }
    inline ::ipc::invalidation::RegistrationP_OpType RegistrationP::op_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.op_type)
        return static_cast<::ipc::invalidation::RegistrationP_OpType>(op_type_);
    }
    inline void RegistrationP::set_op_type(::ipc::invalidation::RegistrationP_OpType value)
    {
        assert(::ipc::invalidation::RegistrationP_OpType_IsValid(value));
        set_has_op_type();
        op_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationP.op_type)
    }

    // -------------------------------------------------------------------

    // RegistrationSummary

    // optional int32 num_registrations = 1;
    inline bool RegistrationSummary::has_num_registrations() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RegistrationSummary::set_has_num_registrations()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RegistrationSummary::clear_has_num_registrations()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RegistrationSummary::clear_num_registrations()
    {
        num_registrations_ = 0;
        clear_has_num_registrations();
    }
    inline ::google::protobuf::int32 RegistrationSummary::num_registrations() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.num_registrations)
        return num_registrations_;
    }
    inline void RegistrationSummary::set_num_registrations(::google::protobuf::int32 value)
    {
        set_has_num_registrations();
        num_registrations_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.num_registrations)
    }

    // optional bytes registration_digest = 2;
    inline bool RegistrationSummary::has_registration_digest() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RegistrationSummary::set_has_registration_digest()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RegistrationSummary::clear_has_registration_digest()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RegistrationSummary::clear_registration_digest()
    {
        registration_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_registration_digest();
    }
    inline const ::std::string& RegistrationSummary::registration_digest() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.registration_digest)
        return registration_digest_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RegistrationSummary::set_registration_digest(const ::std::string& value)
    {
        set_has_registration_digest();
        registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.registration_digest)
    }
    inline void RegistrationSummary::set_registration_digest(const char* value)
    {
        set_has_registration_digest();
        registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.RegistrationSummary.registration_digest)
    }
    inline void RegistrationSummary::set_registration_digest(const void* value, size_t size)
    {
        set_has_registration_digest();
        registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.RegistrationSummary.registration_digest)
    }
    inline ::std::string* RegistrationSummary::mutable_registration_digest()
    {
        set_has_registration_digest();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSummary.registration_digest)
        return registration_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* RegistrationSummary::release_registration_digest()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationSummary.registration_digest)
        clear_has_registration_digest();
        return registration_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void RegistrationSummary::set_allocated_registration_digest(::std::string* registration_digest)
    {
        if (registration_digest != NULL) {
            set_has_registration_digest();
        } else {
            clear_has_registration_digest();
        }
        registration_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), registration_digest);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationSummary.registration_digest)
    }

    // -------------------------------------------------------------------

    // ClientHeader

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    inline bool ClientHeader::has_protocol_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ClientHeader::set_has_protocol_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ClientHeader::clear_has_protocol_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ClientHeader::clear_protocol_version()
    {
        if (protocol_version_ != NULL)
            protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
        clear_has_protocol_version();
    }
    inline const ::ipc::invalidation::ProtocolVersion& ClientHeader::protocol_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.protocol_version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance().protocol_version_;
#else
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance_->protocol_version_;
#endif
    }
    inline ::ipc::invalidation::ProtocolVersion* ClientHeader::mutable_protocol_version()
    {
        set_has_protocol_version();
        if (protocol_version_ == NULL) {
            protocol_version_ = new ::ipc::invalidation::ProtocolVersion;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.protocol_version)
        return protocol_version_;
    }
    inline ::ipc::invalidation::ProtocolVersion* ClientHeader::release_protocol_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.protocol_version)
        clear_has_protocol_version();
        ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
        protocol_version_ = NULL;
        return temp;
    }
    inline void ClientHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version)
    {
        delete protocol_version_;
        protocol_version_ = protocol_version;
        if (protocol_version) {
            set_has_protocol_version();
        } else {
            clear_has_protocol_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.protocol_version)
    }

    // optional bytes client_token = 2;
    inline bool ClientHeader::has_client_token() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ClientHeader::set_has_client_token()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ClientHeader::clear_has_client_token()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ClientHeader::clear_client_token()
    {
        client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_client_token();
    }
    inline const ::std::string& ClientHeader::client_token() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_token)
        return client_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientHeader::set_client_token(const ::std::string& value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_token)
    }
    inline void ClientHeader::set_client_token(const char* value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.client_token)
    }
    inline void ClientHeader::set_client_token(const void* value, size_t size)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.client_token)
    }
    inline ::std::string* ClientHeader::mutable_client_token()
    {
        set_has_client_token();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.client_token)
        return client_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ClientHeader::release_client_token()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.client_token)
        clear_has_client_token();
        return client_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientHeader::set_allocated_client_token(::std::string* client_token)
    {
        if (client_token != NULL) {
            set_has_client_token();
        } else {
            clear_has_client_token();
        }
        client_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_token);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.client_token)
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    inline bool ClientHeader::has_registration_summary() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ClientHeader::set_has_registration_summary()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ClientHeader::clear_has_registration_summary()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ClientHeader::clear_registration_summary()
    {
        if (registration_summary_ != NULL)
            registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
        clear_has_registration_summary();
    }
    inline const ::ipc::invalidation::RegistrationSummary& ClientHeader::registration_summary() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.registration_summary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance().registration_summary_;
#else
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance_->registration_summary_;
#endif
    }
    inline ::ipc::invalidation::RegistrationSummary* ClientHeader::mutable_registration_summary()
    {
        set_has_registration_summary();
        if (registration_summary_ == NULL) {
            registration_summary_ = new ::ipc::invalidation::RegistrationSummary;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.registration_summary)
        return registration_summary_;
    }
    inline ::ipc::invalidation::RegistrationSummary* ClientHeader::release_registration_summary()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.registration_summary)
        clear_has_registration_summary();
        ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
        registration_summary_ = NULL;
        return temp;
    }
    inline void ClientHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary)
    {
        delete registration_summary_;
        registration_summary_ = registration_summary;
        if (registration_summary) {
            set_has_registration_summary();
        } else {
            clear_has_registration_summary();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.registration_summary)
    }

    // optional int64 client_time_ms = 4;
    inline bool ClientHeader::has_client_time_ms() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void ClientHeader::set_has_client_time_ms()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void ClientHeader::clear_has_client_time_ms()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void ClientHeader::clear_client_time_ms()
    {
        client_time_ms_ = GOOGLE_LONGLONG(0);
        clear_has_client_time_ms();
    }
    inline ::google::protobuf::int64 ClientHeader::client_time_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_time_ms)
        return client_time_ms_;
    }
    inline void ClientHeader::set_client_time_ms(::google::protobuf::int64 value)
    {
        set_has_client_time_ms();
        client_time_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_time_ms)
    }

    // optional int64 max_known_server_time_ms = 5;
    inline bool ClientHeader::has_max_known_server_time_ms() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void ClientHeader::set_has_max_known_server_time_ms()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void ClientHeader::clear_has_max_known_server_time_ms()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void ClientHeader::clear_max_known_server_time_ms()
    {
        max_known_server_time_ms_ = GOOGLE_LONGLONG(0);
        clear_has_max_known_server_time_ms();
    }
    inline ::google::protobuf::int64 ClientHeader::max_known_server_time_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.max_known_server_time_ms)
        return max_known_server_time_ms_;
    }
    inline void ClientHeader::set_max_known_server_time_ms(::google::protobuf::int64 value)
    {
        set_has_max_known_server_time_ms();
        max_known_server_time_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.max_known_server_time_ms)
    }

    // optional string message_id = 6;
    inline bool ClientHeader::has_message_id() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void ClientHeader::set_has_message_id()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void ClientHeader::clear_has_message_id()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void ClientHeader::clear_message_id()
    {
        message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_message_id();
    }
    inline const ::std::string& ClientHeader::message_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.message_id)
        return message_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientHeader::set_message_id(const ::std::string& value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.message_id)
    }
    inline void ClientHeader::set_message_id(const char* value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.message_id)
    }
    inline void ClientHeader::set_message_id(const char* value, size_t size)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.message_id)
    }
    inline ::std::string* ClientHeader::mutable_message_id()
    {
        set_has_message_id();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.message_id)
        return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ClientHeader::release_message_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.message_id)
        clear_has_message_id();
        return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ClientHeader::set_allocated_message_id(::std::string* message_id)
    {
        if (message_id != NULL) {
            set_has_message_id();
        } else {
            clear_has_message_id();
        }
        message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.message_id)
    }

    // optional int32 client_type = 7;
    inline bool ClientHeader::has_client_type() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void ClientHeader::set_has_client_type()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void ClientHeader::clear_has_client_type()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void ClientHeader::clear_client_type()
    {
        client_type_ = 0;
        clear_has_client_type();
    }
    inline ::google::protobuf::int32 ClientHeader::client_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_type)
        return client_type_;
    }
    inline void ClientHeader::set_client_type(::google::protobuf::int32 value)
    {
        set_has_client_type();
        client_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_type)
    }

    // -------------------------------------------------------------------

    // ClientToServerMessage

    // optional .ipc.invalidation.ClientHeader header = 1;
    inline bool ClientToServerMessage::has_header() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ClientToServerMessage::set_has_header()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ClientToServerMessage::clear_has_header()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ClientToServerMessage::clear_header()
    {
        if (header_ != NULL)
            header_->::ipc::invalidation::ClientHeader::Clear();
        clear_has_header();
    }
    inline const ::ipc::invalidation::ClientHeader& ClientToServerMessage::header() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return header_ != NULL ? *header_ : *default_instance().header_;
#else
        return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
    }
    inline ::ipc::invalidation::ClientHeader* ClientToServerMessage::mutable_header()
    {
        set_has_header();
        if (header_ == NULL) {
            header_ = new ::ipc::invalidation::ClientHeader;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.header)
        return header_;
    }
    inline ::ipc::invalidation::ClientHeader* ClientToServerMessage::release_header()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.header)
        clear_has_header();
        ::ipc::invalidation::ClientHeader* temp = header_;
        header_ = NULL;
        return temp;
    }
    inline void ClientToServerMessage::set_allocated_header(::ipc::invalidation::ClientHeader* header)
    {
        delete header_;
        header_ = header;
        if (header) {
            set_has_header();
        } else {
            clear_has_header();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.header)
    }

    // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
    inline bool ClientToServerMessage::has_initialize_message() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ClientToServerMessage::set_has_initialize_message()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ClientToServerMessage::clear_has_initialize_message()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ClientToServerMessage::clear_initialize_message()
    {
        if (initialize_message_ != NULL)
            initialize_message_->::ipc::invalidation::InitializeMessage::Clear();
        clear_has_initialize_message();
    }
    inline const ::ipc::invalidation::InitializeMessage& ClientToServerMessage::initialize_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.initialize_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return initialize_message_ != NULL ? *initialize_message_ : *default_instance().initialize_message_;
#else
        return initialize_message_ != NULL ? *initialize_message_ : *default_instance_->initialize_message_;
#endif
    }
    inline ::ipc::invalidation::InitializeMessage* ClientToServerMessage::mutable_initialize_message()
    {
        set_has_initialize_message();
        if (initialize_message_ == NULL) {
            initialize_message_ = new ::ipc::invalidation::InitializeMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.initialize_message)
        return initialize_message_;
    }
    inline ::ipc::invalidation::InitializeMessage* ClientToServerMessage::release_initialize_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.initialize_message)
        clear_has_initialize_message();
        ::ipc::invalidation::InitializeMessage* temp = initialize_message_;
        initialize_message_ = NULL;
        return temp;
    }
    inline void ClientToServerMessage::set_allocated_initialize_message(::ipc::invalidation::InitializeMessage* initialize_message)
    {
        delete initialize_message_;
        initialize_message_ = initialize_message;
        if (initialize_message) {
            set_has_initialize_message();
        } else {
            clear_has_initialize_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.initialize_message)
    }

    // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
    inline bool ClientToServerMessage::has_registration_message() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ClientToServerMessage::set_has_registration_message()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ClientToServerMessage::clear_has_registration_message()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ClientToServerMessage::clear_registration_message()
    {
        if (registration_message_ != NULL)
            registration_message_->::ipc::invalidation::RegistrationMessage::Clear();
        clear_has_registration_message();
    }
    inline const ::ipc::invalidation::RegistrationMessage& ClientToServerMessage::registration_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_message_ != NULL ? *registration_message_ : *default_instance().registration_message_;
#else
        return registration_message_ != NULL ? *registration_message_ : *default_instance_->registration_message_;
#endif
    }
    inline ::ipc::invalidation::RegistrationMessage* ClientToServerMessage::mutable_registration_message()
    {
        set_has_registration_message();
        if (registration_message_ == NULL) {
            registration_message_ = new ::ipc::invalidation::RegistrationMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_message)
        return registration_message_;
    }
    inline ::ipc::invalidation::RegistrationMessage* ClientToServerMessage::release_registration_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_message)
        clear_has_registration_message();
        ::ipc::invalidation::RegistrationMessage* temp = registration_message_;
        registration_message_ = NULL;
        return temp;
    }
    inline void ClientToServerMessage::set_allocated_registration_message(::ipc::invalidation::RegistrationMessage* registration_message)
    {
        delete registration_message_;
        registration_message_ = registration_message;
        if (registration_message) {
            set_has_registration_message();
        } else {
            clear_has_registration_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_message)
    }

    // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
    inline bool ClientToServerMessage::has_registration_sync_message() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void ClientToServerMessage::set_has_registration_sync_message()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void ClientToServerMessage::clear_has_registration_sync_message()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void ClientToServerMessage::clear_registration_sync_message()
    {
        if (registration_sync_message_ != NULL)
            registration_sync_message_->::ipc::invalidation::RegistrationSyncMessage::Clear();
        clear_has_registration_sync_message();
    }
    inline const ::ipc::invalidation::RegistrationSyncMessage& ClientToServerMessage::registration_sync_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_sync_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_sync_message_ != NULL ? *registration_sync_message_ : *default_instance().registration_sync_message_;
#else
        return registration_sync_message_ != NULL ? *registration_sync_message_ : *default_instance_->registration_sync_message_;
#endif
    }
    inline ::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::mutable_registration_sync_message()
    {
        set_has_registration_sync_message();
        if (registration_sync_message_ == NULL) {
            registration_sync_message_ = new ::ipc::invalidation::RegistrationSyncMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_sync_message)
        return registration_sync_message_;
    }
    inline ::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::release_registration_sync_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_sync_message)
        clear_has_registration_sync_message();
        ::ipc::invalidation::RegistrationSyncMessage* temp = registration_sync_message_;
        registration_sync_message_ = NULL;
        return temp;
    }
    inline void ClientToServerMessage::set_allocated_registration_sync_message(::ipc::invalidation::RegistrationSyncMessage* registration_sync_message)
    {
        delete registration_sync_message_;
        registration_sync_message_ = registration_sync_message;
        if (registration_sync_message) {
            set_has_registration_sync_message();
        } else {
            clear_has_registration_sync_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_sync_message)
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
    inline bool ClientToServerMessage::has_invalidation_ack_message() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void ClientToServerMessage::set_has_invalidation_ack_message()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void ClientToServerMessage::clear_has_invalidation_ack_message()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void ClientToServerMessage::clear_invalidation_ack_message()
    {
        if (invalidation_ack_message_ != NULL)
            invalidation_ack_message_->::ipc::invalidation::InvalidationMessage::Clear();
        clear_has_invalidation_ack_message();
    }
    inline const ::ipc::invalidation::InvalidationMessage& ClientToServerMessage::invalidation_ack_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return invalidation_ack_message_ != NULL ? *invalidation_ack_message_ : *default_instance().invalidation_ack_message_;
#else
        return invalidation_ack_message_ != NULL ? *invalidation_ack_message_ : *default_instance_->invalidation_ack_message_;
#endif
    }
    inline ::ipc::invalidation::InvalidationMessage* ClientToServerMessage::mutable_invalidation_ack_message()
    {
        set_has_invalidation_ack_message();
        if (invalidation_ack_message_ == NULL) {
            invalidation_ack_message_ = new ::ipc::invalidation::InvalidationMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
        return invalidation_ack_message_;
    }
    inline ::ipc::invalidation::InvalidationMessage* ClientToServerMessage::release_invalidation_ack_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
        clear_has_invalidation_ack_message();
        ::ipc::invalidation::InvalidationMessage* temp = invalidation_ack_message_;
        invalidation_ack_message_ = NULL;
        return temp;
    }
    inline void ClientToServerMessage::set_allocated_invalidation_ack_message(::ipc::invalidation::InvalidationMessage* invalidation_ack_message)
    {
        delete invalidation_ack_message_;
        invalidation_ack_message_ = invalidation_ack_message;
        if (invalidation_ack_message) {
            set_has_invalidation_ack_message();
        } else {
            clear_has_invalidation_ack_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
    }

    // optional .ipc.invalidation.InfoMessage info_message = 6;
    inline bool ClientToServerMessage::has_info_message() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void ClientToServerMessage::set_has_info_message()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void ClientToServerMessage::clear_has_info_message()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void ClientToServerMessage::clear_info_message()
    {
        if (info_message_ != NULL)
            info_message_->::ipc::invalidation::InfoMessage::Clear();
        clear_has_info_message();
    }
    inline const ::ipc::invalidation::InfoMessage& ClientToServerMessage::info_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.info_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return info_message_ != NULL ? *info_message_ : *default_instance().info_message_;
#else
        return info_message_ != NULL ? *info_message_ : *default_instance_->info_message_;
#endif
    }
    inline ::ipc::invalidation::InfoMessage* ClientToServerMessage::mutable_info_message()
    {
        set_has_info_message();
        if (info_message_ == NULL) {
            info_message_ = new ::ipc::invalidation::InfoMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.info_message)
        return info_message_;
    }
    inline ::ipc::invalidation::InfoMessage* ClientToServerMessage::release_info_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.info_message)
        clear_has_info_message();
        ::ipc::invalidation::InfoMessage* temp = info_message_;
        info_message_ = NULL;
        return temp;
    }
    inline void ClientToServerMessage::set_allocated_info_message(::ipc::invalidation::InfoMessage* info_message)
    {
        delete info_message_;
        info_message_ = info_message;
        if (info_message) {
            set_has_info_message();
        } else {
            clear_has_info_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.info_message)
    }

    // -------------------------------------------------------------------

    // InitializeMessage

    // optional int32 client_type = 1;
    inline bool InitializeMessage::has_client_type() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void InitializeMessage::set_has_client_type()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void InitializeMessage::clear_has_client_type()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void InitializeMessage::clear_client_type()
    {
        client_type_ = 0;
        clear_has_client_type();
    }
    inline ::google::protobuf::int32 InitializeMessage::client_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.client_type)
        return client_type_;
    }
    inline void InitializeMessage::set_client_type(::google::protobuf::int32 value)
    {
        set_has_client_type();
        client_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.client_type)
    }

    // optional bytes nonce = 2;
    inline bool InitializeMessage::has_nonce() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void InitializeMessage::set_has_nonce()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void InitializeMessage::clear_has_nonce()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void InitializeMessage::clear_nonce()
    {
        nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_nonce();
    }
    inline const ::std::string& InitializeMessage::nonce() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.nonce)
        return nonce_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void InitializeMessage::set_nonce(const ::std::string& value)
    {
        set_has_nonce();
        nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.nonce)
    }
    inline void InitializeMessage::set_nonce(const char* value)
    {
        set_has_nonce();
        nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.InitializeMessage.nonce)
    }
    inline void InitializeMessage::set_nonce(const void* value, size_t size)
    {
        set_has_nonce();
        nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InitializeMessage.nonce)
    }
    inline ::std::string* InitializeMessage::mutable_nonce()
    {
        set_has_nonce();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.nonce)
        return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* InitializeMessage::release_nonce()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.nonce)
        clear_has_nonce();
        return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void InitializeMessage::set_allocated_nonce(::std::string* nonce)
    {
        if (nonce != NULL) {
            set_has_nonce();
        } else {
            clear_has_nonce();
        }
        nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.nonce)
    }

    // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
    inline bool InitializeMessage::has_application_client_id() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void InitializeMessage::set_has_application_client_id()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void InitializeMessage::clear_has_application_client_id()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void InitializeMessage::clear_application_client_id()
    {
        if (application_client_id_ != NULL)
            application_client_id_->::ipc::invalidation::ApplicationClientIdP::Clear();
        clear_has_application_client_id();
    }
    inline const ::ipc::invalidation::ApplicationClientIdP& InitializeMessage::application_client_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.application_client_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return application_client_id_ != NULL ? *application_client_id_ : *default_instance().application_client_id_;
#else
        return application_client_id_ != NULL ? *application_client_id_ : *default_instance_->application_client_id_;
#endif
    }
    inline ::ipc::invalidation::ApplicationClientIdP* InitializeMessage::mutable_application_client_id()
    {
        set_has_application_client_id();
        if (application_client_id_ == NULL) {
            application_client_id_ = new ::ipc::invalidation::ApplicationClientIdP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.application_client_id)
        return application_client_id_;
    }
    inline ::ipc::invalidation::ApplicationClientIdP* InitializeMessage::release_application_client_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.application_client_id)
        clear_has_application_client_id();
        ::ipc::invalidation::ApplicationClientIdP* temp = application_client_id_;
        application_client_id_ = NULL;
        return temp;
    }
    inline void InitializeMessage::set_allocated_application_client_id(::ipc::invalidation::ApplicationClientIdP* application_client_id)
    {
        delete application_client_id_;
        application_client_id_ = application_client_id;
        if (application_client_id) {
            set_has_application_client_id();
        } else {
            clear_has_application_client_id();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.application_client_id)
    }

    // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
    inline bool InitializeMessage::has_digest_serialization_type() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void InitializeMessage::set_has_digest_serialization_type()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void InitializeMessage::clear_has_digest_serialization_type()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void InitializeMessage::clear_digest_serialization_type()
    {
        digest_serialization_type_ = 1;
        clear_has_digest_serialization_type();
    }
    inline ::ipc::invalidation::InitializeMessage_DigestSerializationType InitializeMessage::digest_serialization_type() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.digest_serialization_type)
        return static_cast<::ipc::invalidation::InitializeMessage_DigestSerializationType>(digest_serialization_type_);
    }
    inline void InitializeMessage::set_digest_serialization_type(::ipc::invalidation::InitializeMessage_DigestSerializationType value)
    {
        assert(::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(value));
        set_has_digest_serialization_type();
        digest_serialization_type_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.digest_serialization_type)
    }

    // -------------------------------------------------------------------

    // RegistrationMessage

    // repeated .ipc.invalidation.RegistrationP registration = 1;
    inline int RegistrationMessage::registration_size() const
    {
        return registration_.size();
    }
    inline void RegistrationMessage::clear_registration()
    {
        registration_.Clear();
    }
    inline const ::ipc::invalidation::RegistrationP& RegistrationMessage::registration(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationMessage.registration)
        return registration_.Get(index);
    }
    inline ::ipc::invalidation::RegistrationP* RegistrationMessage::mutable_registration(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationMessage.registration)
        return registration_.Mutable(index);
    }
    inline ::ipc::invalidation::RegistrationP* RegistrationMessage::add_registration()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationMessage.registration)
        return registration_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationP>*
    RegistrationMessage::mutable_registration()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationMessage.registration)
        return &registration_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationP>&
    RegistrationMessage::registration() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationMessage.registration)
        return registration_;
    }

    // -------------------------------------------------------------------

    // RegistrationSyncMessage

    // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
    inline int RegistrationSyncMessage::subtree_size() const
    {
        return subtree_.size();
    }
    inline void RegistrationSyncMessage::clear_subtree()
    {
        subtree_.Clear();
    }
    inline const ::ipc::invalidation::RegistrationSubtree& RegistrationSyncMessage::subtree(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_.Get(index);
    }
    inline ::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::mutable_subtree(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_.Mutable(index);
    }
    inline ::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::add_subtree()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationSubtree>*
    RegistrationSyncMessage::mutable_subtree()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSyncMessage.subtree)
        return &subtree_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationSubtree>&
    RegistrationSyncMessage::subtree() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSyncMessage.subtree)
        return subtree_;
    }

    // -------------------------------------------------------------------

    // RegistrationSubtree

    // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
    inline int RegistrationSubtree::registered_object_size() const
    {
        return registered_object_.size();
    }
    inline void RegistrationSubtree::clear_registered_object()
    {
        registered_object_.Clear();
    }
    inline const ::ipc::invalidation::ObjectIdP& RegistrationSubtree::registered_object(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_.Get(index);
    }
    inline ::ipc::invalidation::ObjectIdP* RegistrationSubtree::mutable_registered_object(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_.Mutable(index);
    }
    inline ::ipc::invalidation::ObjectIdP* RegistrationSubtree::add_registered_object()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::ObjectIdP>*
    RegistrationSubtree::mutable_registered_object()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSubtree.registered_object)
        return &registered_object_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::ObjectIdP>&
    RegistrationSubtree::registered_object() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSubtree.registered_object)
        return registered_object_;
    }

    // -------------------------------------------------------------------

    // InfoMessage

    // optional .ipc.invalidation.ClientVersion client_version = 1;
    inline bool InfoMessage::has_client_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void InfoMessage::set_has_client_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void InfoMessage::clear_has_client_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void InfoMessage::clear_client_version()
    {
        if (client_version_ != NULL)
            client_version_->::ipc::invalidation::ClientVersion::Clear();
        clear_has_client_version();
    }
    inline const ::ipc::invalidation::ClientVersion& InfoMessage::client_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return client_version_ != NULL ? *client_version_ : *default_instance().client_version_;
#else
        return client_version_ != NULL ? *client_version_ : *default_instance_->client_version_;
#endif
    }
    inline ::ipc::invalidation::ClientVersion* InfoMessage::mutable_client_version()
    {
        set_has_client_version();
        if (client_version_ == NULL) {
            client_version_ = new ::ipc::invalidation::ClientVersion;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_version)
        return client_version_;
    }
    inline ::ipc::invalidation::ClientVersion* InfoMessage::release_client_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_version)
        clear_has_client_version();
        ::ipc::invalidation::ClientVersion* temp = client_version_;
        client_version_ = NULL;
        return temp;
    }
    inline void InfoMessage::set_allocated_client_version(::ipc::invalidation::ClientVersion* client_version)
    {
        delete client_version_;
        client_version_ = client_version;
        if (client_version) {
            set_has_client_version();
        } else {
            clear_has_client_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_version)
    }

    // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
    inline int InfoMessage::config_parameter_size() const
    {
        return config_parameter_.size();
    }
    inline void InfoMessage::clear_config_parameter()
    {
        config_parameter_.Clear();
    }
    inline const ::ipc::invalidation::PropertyRecord& InfoMessage::config_parameter(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_.Get(index);
    }
    inline ::ipc::invalidation::PropertyRecord* InfoMessage::mutable_config_parameter(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_.Mutable(index);
    }
    inline ::ipc::invalidation::PropertyRecord* InfoMessage::add_config_parameter()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>*
    InfoMessage::mutable_config_parameter()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.config_parameter)
        return &config_parameter_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>&
    InfoMessage::config_parameter() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.config_parameter)
        return config_parameter_;
    }

    // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
    inline int InfoMessage::performance_counter_size() const
    {
        return performance_counter_.size();
    }
    inline void InfoMessage::clear_performance_counter()
    {
        performance_counter_.Clear();
    }
    inline const ::ipc::invalidation::PropertyRecord& InfoMessage::performance_counter(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_.Get(index);
    }
    inline ::ipc::invalidation::PropertyRecord* InfoMessage::mutable_performance_counter(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_.Mutable(index);
    }
    inline ::ipc::invalidation::PropertyRecord* InfoMessage::add_performance_counter()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>*
    InfoMessage::mutable_performance_counter()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.performance_counter)
        return &performance_counter_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::PropertyRecord>&
    InfoMessage::performance_counter() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.performance_counter)
        return performance_counter_;
    }

    // optional bool server_registration_summary_requested = 4;
    inline bool InfoMessage::has_server_registration_summary_requested() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void InfoMessage::set_has_server_registration_summary_requested()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void InfoMessage::clear_has_server_registration_summary_requested()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void InfoMessage::clear_server_registration_summary_requested()
    {
        server_registration_summary_requested_ = false;
        clear_has_server_registration_summary_requested();
    }
    inline bool InfoMessage::server_registration_summary_requested() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.server_registration_summary_requested)
        return server_registration_summary_requested_;
    }
    inline void InfoMessage::set_server_registration_summary_requested(bool value)
    {
        set_has_server_registration_summary_requested();
        server_registration_summary_requested_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.InfoMessage.server_registration_summary_requested)
    }

    // optional .ipc.invalidation.ClientConfigP client_config = 5;
    inline bool InfoMessage::has_client_config() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void InfoMessage::set_has_client_config()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void InfoMessage::clear_has_client_config()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void InfoMessage::clear_client_config()
    {
        if (client_config_ != NULL)
            client_config_->::ipc::invalidation::ClientConfigP::Clear();
        clear_has_client_config();
    }
    inline const ::ipc::invalidation::ClientConfigP& InfoMessage::client_config() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return client_config_ != NULL ? *client_config_ : *default_instance().client_config_;
#else
        return client_config_ != NULL ? *client_config_ : *default_instance_->client_config_;
#endif
    }
    inline ::ipc::invalidation::ClientConfigP* InfoMessage::mutable_client_config()
    {
        set_has_client_config();
        if (client_config_ == NULL) {
            client_config_ = new ::ipc::invalidation::ClientConfigP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_config)
        return client_config_;
    }
    inline ::ipc::invalidation::ClientConfigP* InfoMessage::release_client_config()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_config)
        clear_has_client_config();
        ::ipc::invalidation::ClientConfigP* temp = client_config_;
        client_config_ = NULL;
        return temp;
    }
    inline void InfoMessage::set_allocated_client_config(::ipc::invalidation::ClientConfigP* client_config)
    {
        delete client_config_;
        client_config_ = client_config;
        if (client_config) {
            set_has_client_config();
        } else {
            clear_has_client_config();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_config)
    }

    // -------------------------------------------------------------------

    // PropertyRecord

    // optional string name = 1;
    inline bool PropertyRecord::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void PropertyRecord::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void PropertyRecord::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void PropertyRecord::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    inline const ::std::string& PropertyRecord::name() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void PropertyRecord::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.name)
    }
    inline void PropertyRecord::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.PropertyRecord.name)
    }
    inline void PropertyRecord::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.PropertyRecord.name)
    }
    inline ::std::string* PropertyRecord::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.PropertyRecord.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* PropertyRecord::release_name()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.PropertyRecord.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void PropertyRecord::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.PropertyRecord.name)
    }

    // optional int32 value = 2;
    inline bool PropertyRecord::has_value() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void PropertyRecord::set_has_value()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void PropertyRecord::clear_has_value()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void PropertyRecord::clear_value()
    {
        value_ = 0;
        clear_has_value();
    }
    inline ::google::protobuf::int32 PropertyRecord::value() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.value)
        return value_;
    }
    inline void PropertyRecord::set_value(::google::protobuf::int32 value)
    {
        set_has_value();
        value_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.value)
    }

    // -------------------------------------------------------------------

    // ServerHeader

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    inline bool ServerHeader::has_protocol_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ServerHeader::set_has_protocol_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ServerHeader::clear_has_protocol_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ServerHeader::clear_protocol_version()
    {
        if (protocol_version_ != NULL)
            protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
        clear_has_protocol_version();
    }
    inline const ::ipc::invalidation::ProtocolVersion& ServerHeader::protocol_version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.protocol_version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance().protocol_version_;
#else
        return protocol_version_ != NULL ? *protocol_version_ : *default_instance_->protocol_version_;
#endif
    }
    inline ::ipc::invalidation::ProtocolVersion* ServerHeader::mutable_protocol_version()
    {
        set_has_protocol_version();
        if (protocol_version_ == NULL) {
            protocol_version_ = new ::ipc::invalidation::ProtocolVersion;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.protocol_version)
        return protocol_version_;
    }
    inline ::ipc::invalidation::ProtocolVersion* ServerHeader::release_protocol_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.protocol_version)
        clear_has_protocol_version();
        ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
        protocol_version_ = NULL;
        return temp;
    }
    inline void ServerHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version)
    {
        delete protocol_version_;
        protocol_version_ = protocol_version;
        if (protocol_version) {
            set_has_protocol_version();
        } else {
            clear_has_protocol_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.protocol_version)
    }

    // optional bytes client_token = 2;
    inline bool ServerHeader::has_client_token() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ServerHeader::set_has_client_token()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ServerHeader::clear_has_client_token()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ServerHeader::clear_client_token()
    {
        client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_client_token();
    }
    inline const ::std::string& ServerHeader::client_token() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.client_token)
        return client_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ServerHeader::set_client_token(const ::std::string& value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.client_token)
    }
    inline void ServerHeader::set_client_token(const char* value)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.client_token)
    }
    inline void ServerHeader::set_client_token(const void* value, size_t size)
    {
        set_has_client_token();
        client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.client_token)
    }
    inline ::std::string* ServerHeader::mutable_client_token()
    {
        set_has_client_token();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.client_token)
        return client_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ServerHeader::release_client_token()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.client_token)
        clear_has_client_token();
        return client_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ServerHeader::set_allocated_client_token(::std::string* client_token)
    {
        if (client_token != NULL) {
            set_has_client_token();
        } else {
            clear_has_client_token();
        }
        client_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_token);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.client_token)
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    inline bool ServerHeader::has_registration_summary() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ServerHeader::set_has_registration_summary()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ServerHeader::clear_has_registration_summary()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ServerHeader::clear_registration_summary()
    {
        if (registration_summary_ != NULL)
            registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
        clear_has_registration_summary();
    }
    inline const ::ipc::invalidation::RegistrationSummary& ServerHeader::registration_summary() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.registration_summary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance().registration_summary_;
#else
        return registration_summary_ != NULL ? *registration_summary_ : *default_instance_->registration_summary_;
#endif
    }
    inline ::ipc::invalidation::RegistrationSummary* ServerHeader::mutable_registration_summary()
    {
        set_has_registration_summary();
        if (registration_summary_ == NULL) {
            registration_summary_ = new ::ipc::invalidation::RegistrationSummary;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.registration_summary)
        return registration_summary_;
    }
    inline ::ipc::invalidation::RegistrationSummary* ServerHeader::release_registration_summary()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.registration_summary)
        clear_has_registration_summary();
        ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
        registration_summary_ = NULL;
        return temp;
    }
    inline void ServerHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary)
    {
        delete registration_summary_;
        registration_summary_ = registration_summary;
        if (registration_summary) {
            set_has_registration_summary();
        } else {
            clear_has_registration_summary();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.registration_summary)
    }

    // optional int64 server_time_ms = 4;
    inline bool ServerHeader::has_server_time_ms() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void ServerHeader::set_has_server_time_ms()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void ServerHeader::clear_has_server_time_ms()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void ServerHeader::clear_server_time_ms()
    {
        server_time_ms_ = GOOGLE_LONGLONG(0);
        clear_has_server_time_ms();
    }
    inline ::google::protobuf::int64 ServerHeader::server_time_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.server_time_ms)
        return server_time_ms_;
    }
    inline void ServerHeader::set_server_time_ms(::google::protobuf::int64 value)
    {
        set_has_server_time_ms();
        server_time_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.server_time_ms)
    }

    // optional string message_id = 5;
    inline bool ServerHeader::has_message_id() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void ServerHeader::set_has_message_id()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void ServerHeader::clear_has_message_id()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void ServerHeader::clear_message_id()
    {
        message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_message_id();
    }
    inline const ::std::string& ServerHeader::message_id() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.message_id)
        return message_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ServerHeader::set_message_id(const ::std::string& value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.message_id)
    }
    inline void ServerHeader::set_message_id(const char* value)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.message_id)
    }
    inline void ServerHeader::set_message_id(const char* value, size_t size)
    {
        set_has_message_id();
        message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.message_id)
    }
    inline ::std::string* ServerHeader::mutable_message_id()
    {
        set_has_message_id();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.message_id)
        return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ServerHeader::release_message_id()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.message_id)
        clear_has_message_id();
        return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ServerHeader::set_allocated_message_id(::std::string* message_id)
    {
        if (message_id != NULL) {
            set_has_message_id();
        } else {
            clear_has_message_id();
        }
        message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.message_id)
    }

    // -------------------------------------------------------------------

    // ServerToClientMessage

    // optional .ipc.invalidation.ServerHeader header = 1;
    inline bool ServerToClientMessage::has_header() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ServerToClientMessage::set_has_header()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ServerToClientMessage::clear_has_header()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ServerToClientMessage::clear_header()
    {
        if (header_ != NULL)
            header_->::ipc::invalidation::ServerHeader::Clear();
        clear_has_header();
    }
    inline const ::ipc::invalidation::ServerHeader& ServerToClientMessage::header() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return header_ != NULL ? *header_ : *default_instance().header_;
#else
        return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
    }
    inline ::ipc::invalidation::ServerHeader* ServerToClientMessage::mutable_header()
    {
        set_has_header();
        if (header_ == NULL) {
            header_ = new ::ipc::invalidation::ServerHeader;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.header)
        return header_;
    }
    inline ::ipc::invalidation::ServerHeader* ServerToClientMessage::release_header()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.header)
        clear_has_header();
        ::ipc::invalidation::ServerHeader* temp = header_;
        header_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_header(::ipc::invalidation::ServerHeader* header)
    {
        delete header_;
        header_ = header;
        if (header) {
            set_has_header();
        } else {
            clear_has_header();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.header)
    }

    // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
    inline bool ServerToClientMessage::has_token_control_message() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ServerToClientMessage::set_has_token_control_message()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ServerToClientMessage::clear_has_token_control_message()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ServerToClientMessage::clear_token_control_message()
    {
        if (token_control_message_ != NULL)
            token_control_message_->::ipc::invalidation::TokenControlMessage::Clear();
        clear_has_token_control_message();
    }
    inline const ::ipc::invalidation::TokenControlMessage& ServerToClientMessage::token_control_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.token_control_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return token_control_message_ != NULL ? *token_control_message_ : *default_instance().token_control_message_;
#else
        return token_control_message_ != NULL ? *token_control_message_ : *default_instance_->token_control_message_;
#endif
    }
    inline ::ipc::invalidation::TokenControlMessage* ServerToClientMessage::mutable_token_control_message()
    {
        set_has_token_control_message();
        if (token_control_message_ == NULL) {
            token_control_message_ = new ::ipc::invalidation::TokenControlMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.token_control_message)
        return token_control_message_;
    }
    inline ::ipc::invalidation::TokenControlMessage* ServerToClientMessage::release_token_control_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.token_control_message)
        clear_has_token_control_message();
        ::ipc::invalidation::TokenControlMessage* temp = token_control_message_;
        token_control_message_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_token_control_message(::ipc::invalidation::TokenControlMessage* token_control_message)
    {
        delete token_control_message_;
        token_control_message_ = token_control_message;
        if (token_control_message) {
            set_has_token_control_message();
        } else {
            clear_has_token_control_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.token_control_message)
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
    inline bool ServerToClientMessage::has_invalidation_message() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ServerToClientMessage::set_has_invalidation_message()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ServerToClientMessage::clear_has_invalidation_message()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ServerToClientMessage::clear_invalidation_message()
    {
        if (invalidation_message_ != NULL)
            invalidation_message_->::ipc::invalidation::InvalidationMessage::Clear();
        clear_has_invalidation_message();
    }
    inline const ::ipc::invalidation::InvalidationMessage& ServerToClientMessage::invalidation_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.invalidation_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return invalidation_message_ != NULL ? *invalidation_message_ : *default_instance().invalidation_message_;
#else
        return invalidation_message_ != NULL ? *invalidation_message_ : *default_instance_->invalidation_message_;
#endif
    }
    inline ::ipc::invalidation::InvalidationMessage* ServerToClientMessage::mutable_invalidation_message()
    {
        set_has_invalidation_message();
        if (invalidation_message_ == NULL) {
            invalidation_message_ = new ::ipc::invalidation::InvalidationMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.invalidation_message)
        return invalidation_message_;
    }
    inline ::ipc::invalidation::InvalidationMessage* ServerToClientMessage::release_invalidation_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.invalidation_message)
        clear_has_invalidation_message();
        ::ipc::invalidation::InvalidationMessage* temp = invalidation_message_;
        invalidation_message_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_invalidation_message(::ipc::invalidation::InvalidationMessage* invalidation_message)
    {
        delete invalidation_message_;
        invalidation_message_ = invalidation_message;
        if (invalidation_message) {
            set_has_invalidation_message();
        } else {
            clear_has_invalidation_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.invalidation_message)
    }

    // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
    inline bool ServerToClientMessage::has_registration_status_message() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void ServerToClientMessage::set_has_registration_status_message()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void ServerToClientMessage::clear_has_registration_status_message()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void ServerToClientMessage::clear_registration_status_message()
    {
        if (registration_status_message_ != NULL)
            registration_status_message_->::ipc::invalidation::RegistrationStatusMessage::Clear();
        clear_has_registration_status_message();
    }
    inline const ::ipc::invalidation::RegistrationStatusMessage& ServerToClientMessage::registration_status_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_status_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_status_message_ != NULL ? *registration_status_message_ : *default_instance().registration_status_message_;
#else
        return registration_status_message_ != NULL ? *registration_status_message_ : *default_instance_->registration_status_message_;
#endif
    }
    inline ::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::mutable_registration_status_message()
    {
        set_has_registration_status_message();
        if (registration_status_message_ == NULL) {
            registration_status_message_ = new ::ipc::invalidation::RegistrationStatusMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_status_message)
        return registration_status_message_;
    }
    inline ::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::release_registration_status_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_status_message)
        clear_has_registration_status_message();
        ::ipc::invalidation::RegistrationStatusMessage* temp = registration_status_message_;
        registration_status_message_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_registration_status_message(::ipc::invalidation::RegistrationStatusMessage* registration_status_message)
    {
        delete registration_status_message_;
        registration_status_message_ = registration_status_message;
        if (registration_status_message) {
            set_has_registration_status_message();
        } else {
            clear_has_registration_status_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_status_message)
    }

    // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
    inline bool ServerToClientMessage::has_registration_sync_request_message() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void ServerToClientMessage::set_has_registration_sync_request_message()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void ServerToClientMessage::clear_has_registration_sync_request_message()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void ServerToClientMessage::clear_registration_sync_request_message()
    {
        if (registration_sync_request_message_ != NULL)
            registration_sync_request_message_->::ipc::invalidation::RegistrationSyncRequestMessage::Clear();
        clear_has_registration_sync_request_message();
    }
    inline const ::ipc::invalidation::RegistrationSyncRequestMessage& ServerToClientMessage::registration_sync_request_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_sync_request_message_ != NULL ? *registration_sync_request_message_ : *default_instance().registration_sync_request_message_;
#else
        return registration_sync_request_message_ != NULL ? *registration_sync_request_message_ : *default_instance_->registration_sync_request_message_;
#endif
    }
    inline ::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::mutable_registration_sync_request_message()
    {
        set_has_registration_sync_request_message();
        if (registration_sync_request_message_ == NULL) {
            registration_sync_request_message_ = new ::ipc::invalidation::RegistrationSyncRequestMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
        return registration_sync_request_message_;
    }
    inline ::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::release_registration_sync_request_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
        clear_has_registration_sync_request_message();
        ::ipc::invalidation::RegistrationSyncRequestMessage* temp = registration_sync_request_message_;
        registration_sync_request_message_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_registration_sync_request_message(::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message)
    {
        delete registration_sync_request_message_;
        registration_sync_request_message_ = registration_sync_request_message;
        if (registration_sync_request_message) {
            set_has_registration_sync_request_message();
        } else {
            clear_has_registration_sync_request_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
    }

    // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
    inline bool ServerToClientMessage::has_config_change_message() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void ServerToClientMessage::set_has_config_change_message()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void ServerToClientMessage::clear_has_config_change_message()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void ServerToClientMessage::clear_config_change_message()
    {
        if (config_change_message_ != NULL)
            config_change_message_->::ipc::invalidation::ConfigChangeMessage::Clear();
        clear_has_config_change_message();
    }
    inline const ::ipc::invalidation::ConfigChangeMessage& ServerToClientMessage::config_change_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.config_change_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return config_change_message_ != NULL ? *config_change_message_ : *default_instance().config_change_message_;
#else
        return config_change_message_ != NULL ? *config_change_message_ : *default_instance_->config_change_message_;
#endif
    }
    inline ::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::mutable_config_change_message()
    {
        set_has_config_change_message();
        if (config_change_message_ == NULL) {
            config_change_message_ = new ::ipc::invalidation::ConfigChangeMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.config_change_message)
        return config_change_message_;
    }
    inline ::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::release_config_change_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.config_change_message)
        clear_has_config_change_message();
        ::ipc::invalidation::ConfigChangeMessage* temp = config_change_message_;
        config_change_message_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_config_change_message(::ipc::invalidation::ConfigChangeMessage* config_change_message)
    {
        delete config_change_message_;
        config_change_message_ = config_change_message;
        if (config_change_message) {
            set_has_config_change_message();
        } else {
            clear_has_config_change_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.config_change_message)
    }

    // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
    inline bool ServerToClientMessage::has_info_request_message() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void ServerToClientMessage::set_has_info_request_message()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void ServerToClientMessage::clear_has_info_request_message()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void ServerToClientMessage::clear_info_request_message()
    {
        if (info_request_message_ != NULL)
            info_request_message_->::ipc::invalidation::InfoRequestMessage::Clear();
        clear_has_info_request_message();
    }
    inline const ::ipc::invalidation::InfoRequestMessage& ServerToClientMessage::info_request_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.info_request_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return info_request_message_ != NULL ? *info_request_message_ : *default_instance().info_request_message_;
#else
        return info_request_message_ != NULL ? *info_request_message_ : *default_instance_->info_request_message_;
#endif
    }
    inline ::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::mutable_info_request_message()
    {
        set_has_info_request_message();
        if (info_request_message_ == NULL) {
            info_request_message_ = new ::ipc::invalidation::InfoRequestMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.info_request_message)
        return info_request_message_;
    }
    inline ::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::release_info_request_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.info_request_message)
        clear_has_info_request_message();
        ::ipc::invalidation::InfoRequestMessage* temp = info_request_message_;
        info_request_message_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_info_request_message(::ipc::invalidation::InfoRequestMessage* info_request_message)
    {
        delete info_request_message_;
        info_request_message_ = info_request_message;
        if (info_request_message) {
            set_has_info_request_message();
        } else {
            clear_has_info_request_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.info_request_message)
    }

    // optional .ipc.invalidation.ErrorMessage error_message = 8;
    inline bool ServerToClientMessage::has_error_message() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void ServerToClientMessage::set_has_error_message()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void ServerToClientMessage::clear_has_error_message()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void ServerToClientMessage::clear_error_message()
    {
        if (error_message_ != NULL)
            error_message_->::ipc::invalidation::ErrorMessage::Clear();
        clear_has_error_message();
    }
    inline const ::ipc::invalidation::ErrorMessage& ServerToClientMessage::error_message() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.error_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return error_message_ != NULL ? *error_message_ : *default_instance().error_message_;
#else
        return error_message_ != NULL ? *error_message_ : *default_instance_->error_message_;
#endif
    }
    inline ::ipc::invalidation::ErrorMessage* ServerToClientMessage::mutable_error_message()
    {
        set_has_error_message();
        if (error_message_ == NULL) {
            error_message_ = new ::ipc::invalidation::ErrorMessage;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.error_message)
        return error_message_;
    }
    inline ::ipc::invalidation::ErrorMessage* ServerToClientMessage::release_error_message()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.error_message)
        clear_has_error_message();
        ::ipc::invalidation::ErrorMessage* temp = error_message_;
        error_message_ = NULL;
        return temp;
    }
    inline void ServerToClientMessage::set_allocated_error_message(::ipc::invalidation::ErrorMessage* error_message)
    {
        delete error_message_;
        error_message_ = error_message;
        if (error_message) {
            set_has_error_message();
        } else {
            clear_has_error_message();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.error_message)
    }

    // -------------------------------------------------------------------

    // TokenControlMessage

    // optional bytes new_token = 1;
    inline bool TokenControlMessage::has_new_token() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void TokenControlMessage::set_has_new_token()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void TokenControlMessage::clear_has_new_token()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void TokenControlMessage::clear_new_token()
    {
        new_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_new_token();
    }
    inline const ::std::string& TokenControlMessage::new_token() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.TokenControlMessage.new_token)
        return new_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void TokenControlMessage::set_new_token(const ::std::string& value)
    {
        set_has_new_token();
        new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.TokenControlMessage.new_token)
    }
    inline void TokenControlMessage::set_new_token(const char* value)
    {
        set_has_new_token();
        new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.TokenControlMessage.new_token)
    }
    inline void TokenControlMessage::set_new_token(const void* value, size_t size)
    {
        set_has_new_token();
        new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.TokenControlMessage.new_token)
    }
    inline ::std::string* TokenControlMessage::mutable_new_token()
    {
        set_has_new_token();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.TokenControlMessage.new_token)
        return new_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* TokenControlMessage::release_new_token()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.TokenControlMessage.new_token)
        clear_has_new_token();
        return new_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void TokenControlMessage::set_allocated_new_token(::std::string* new_token)
    {
        if (new_token != NULL) {
            set_has_new_token();
        } else {
            clear_has_new_token();
        }
        new_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_token);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.TokenControlMessage.new_token)
    }

    // -------------------------------------------------------------------

    // RegistrationStatus

    // optional .ipc.invalidation.RegistrationP registration = 1;
    inline bool RegistrationStatus::has_registration() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RegistrationStatus::set_has_registration()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RegistrationStatus::clear_has_registration()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RegistrationStatus::clear_registration()
    {
        if (registration_ != NULL)
            registration_->::ipc::invalidation::RegistrationP::Clear();
        clear_has_registration();
    }
    inline const ::ipc::invalidation::RegistrationP& RegistrationStatus::registration() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.registration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return registration_ != NULL ? *registration_ : *default_instance().registration_;
#else
        return registration_ != NULL ? *registration_ : *default_instance_->registration_;
#endif
    }
    inline ::ipc::invalidation::RegistrationP* RegistrationStatus::mutable_registration()
    {
        set_has_registration();
        if (registration_ == NULL) {
            registration_ = new ::ipc::invalidation::RegistrationP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.registration)
        return registration_;
    }
    inline ::ipc::invalidation::RegistrationP* RegistrationStatus::release_registration()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.registration)
        clear_has_registration();
        ::ipc::invalidation::RegistrationP* temp = registration_;
        registration_ = NULL;
        return temp;
    }
    inline void RegistrationStatus::set_allocated_registration(::ipc::invalidation::RegistrationP* registration)
    {
        delete registration_;
        registration_ = registration;
        if (registration) {
            set_has_registration();
        } else {
            clear_has_registration();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.registration)
    }

    // optional .ipc.invalidation.StatusP status = 2;
    inline bool RegistrationStatus::has_status() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RegistrationStatus::set_has_status()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RegistrationStatus::clear_has_status()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RegistrationStatus::clear_status()
    {
        if (status_ != NULL)
            status_->::ipc::invalidation::StatusP::Clear();
        clear_has_status();
    }
    inline const ::ipc::invalidation::StatusP& RegistrationStatus::status() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return status_ != NULL ? *status_ : *default_instance().status_;
#else
        return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
    }
    inline ::ipc::invalidation::StatusP* RegistrationStatus::mutable_status()
    {
        set_has_status();
        if (status_ == NULL) {
            status_ = new ::ipc::invalidation::StatusP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.status)
        return status_;
    }
    inline ::ipc::invalidation::StatusP* RegistrationStatus::release_status()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.status)
        clear_has_status();
        ::ipc::invalidation::StatusP* temp = status_;
        status_ = NULL;
        return temp;
    }
    inline void RegistrationStatus::set_allocated_status(::ipc::invalidation::StatusP* status)
    {
        delete status_;
        status_ = status;
        if (status) {
            set_has_status();
        } else {
            clear_has_status();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.status)
    }

    // -------------------------------------------------------------------

    // RegistrationStatusMessage

    // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
    inline int RegistrationStatusMessage::registration_status_size() const
    {
        return registration_status_.size();
    }
    inline void RegistrationStatusMessage::clear_registration_status()
    {
        registration_status_.Clear();
    }
    inline const ::ipc::invalidation::RegistrationStatus& RegistrationStatusMessage::registration_status(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_.Get(index);
    }
    inline ::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::mutable_registration_status(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_.Mutable(index);
    }
    inline ::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::add_registration_status()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationStatus>*
    RegistrationStatusMessage::mutable_registration_status()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return &registration_status_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RegistrationStatus>&
    RegistrationStatusMessage::registration_status() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
        return registration_status_;
    }

    // -------------------------------------------------------------------

    // RegistrationSyncRequestMessage

    // -------------------------------------------------------------------

    // InvalidationMessage

    // repeated .ipc.invalidation.InvalidationP invalidation = 1;
    inline int InvalidationMessage::invalidation_size() const
    {
        return invalidation_.size();
    }
    inline void InvalidationMessage::clear_invalidation()
    {
        invalidation_.Clear();
    }
    inline const ::ipc::invalidation::InvalidationP& InvalidationMessage::invalidation(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_.Get(index);
    }
    inline ::ipc::invalidation::InvalidationP* InvalidationMessage::mutable_invalidation(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_.Mutable(index);
    }
    inline ::ipc::invalidation::InvalidationP* InvalidationMessage::add_invalidation()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::InvalidationP>*
    InvalidationMessage::mutable_invalidation()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InvalidationMessage.invalidation)
        return &invalidation_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::InvalidationP>&
    InvalidationMessage::invalidation() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InvalidationMessage.invalidation)
        return invalidation_;
    }

    // -------------------------------------------------------------------

    // InfoRequestMessage

    // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
    inline int InfoRequestMessage::info_type_size() const
    {
        return info_type_.size();
    }
    inline void InfoRequestMessage::clear_info_type()
    {
        info_type_.Clear();
    }
    inline ::ipc::invalidation::InfoRequestMessage_InfoType InfoRequestMessage::info_type(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.InfoRequestMessage.info_type)
        return static_cast<::ipc::invalidation::InfoRequestMessage_InfoType>(info_type_.Get(index));
    }
    inline void InfoRequestMessage::set_info_type(int index, ::ipc::invalidation::InfoRequestMessage_InfoType value)
    {
        assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
        info_type_.Set(index, value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.InfoRequestMessage.info_type)
    }
    inline void InfoRequestMessage::add_info_type(::ipc::invalidation::InfoRequestMessage_InfoType value)
    {
        assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
        info_type_.Add(value);
        // @@protoc_insertion_point(field_add:ipc.invalidation.InfoRequestMessage.info_type)
    }
    inline const ::google::protobuf::RepeatedField<int>&
    InfoRequestMessage::info_type() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.InfoRequestMessage.info_type)
        return info_type_;
    }
    inline ::google::protobuf::RepeatedField<int>*
    InfoRequestMessage::mutable_info_type()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoRequestMessage.info_type)
        return &info_type_;
    }

    // -------------------------------------------------------------------

    // RateLimitP

    // optional int32 window_ms = 1;
    inline bool RateLimitP::has_window_ms() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void RateLimitP::set_has_window_ms()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void RateLimitP::clear_has_window_ms()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void RateLimitP::clear_window_ms()
    {
        window_ms_ = 0;
        clear_has_window_ms();
    }
    inline ::google::protobuf::int32 RateLimitP::window_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.window_ms)
        return window_ms_;
    }
    inline void RateLimitP::set_window_ms(::google::protobuf::int32 value)
    {
        set_has_window_ms();
        window_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.window_ms)
    }

    // optional int32 count = 2;
    inline bool RateLimitP::has_count() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void RateLimitP::set_has_count()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void RateLimitP::clear_has_count()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void RateLimitP::clear_count()
    {
        count_ = 0;
        clear_has_count();
    }
    inline ::google::protobuf::int32 RateLimitP::count() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.count)
        return count_;
    }
    inline void RateLimitP::set_count(::google::protobuf::int32 value)
    {
        set_has_count();
        count_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.count)
    }

    // -------------------------------------------------------------------

    // ProtocolHandlerConfigP

    // optional int32 batching_delay_ms = 1 [default = 500];
    inline bool ProtocolHandlerConfigP::has_batching_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ProtocolHandlerConfigP::set_has_batching_delay_ms()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ProtocolHandlerConfigP::clear_has_batching_delay_ms()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ProtocolHandlerConfigP::clear_batching_delay_ms()
    {
        batching_delay_ms_ = 500;
        clear_has_batching_delay_ms();
    }
    inline ::google::protobuf::int32 ProtocolHandlerConfigP::batching_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
        return batching_delay_ms_;
    }
    inline void ProtocolHandlerConfigP::set_batching_delay_ms(::google::protobuf::int32 value)
    {
        set_has_batching_delay_ms();
        batching_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
    }

    // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
    inline int ProtocolHandlerConfigP::rate_limit_size() const
    {
        return rate_limit_.size();
    }
    inline void ProtocolHandlerConfigP::clear_rate_limit()
    {
        rate_limit_.Clear();
    }
    inline const ::ipc::invalidation::RateLimitP& ProtocolHandlerConfigP::rate_limit(int index) const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_.Get(index);
    }
    inline ::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::mutable_rate_limit(int index)
    {
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_.Mutable(index);
    }
    inline ::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::add_rate_limit()
    {
        // @@protoc_insertion_point(field_add:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RateLimitP>*
    ProtocolHandlerConfigP::mutable_rate_limit()
    {
        // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return &rate_limit_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::ipc::invalidation::RateLimitP>&
    ProtocolHandlerConfigP::rate_limit() const
    {
        // @@protoc_insertion_point(field_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
        return rate_limit_;
    }

    // -------------------------------------------------------------------

    // ClientConfigP

    // optional .ipc.invalidation.Version version = 1;
    inline bool ClientConfigP::has_version() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ClientConfigP::set_has_version()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ClientConfigP::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ClientConfigP::clear_version()
    {
        if (version_ != NULL)
            version_->::ipc::invalidation::Version::Clear();
        clear_has_version();
    }
    inline const ::ipc::invalidation::Version& ClientConfigP::version() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return version_ != NULL ? *version_ : *default_instance().version_;
#else
        return version_ != NULL ? *version_ : *default_instance_->version_;
#endif
    }
    inline ::ipc::invalidation::Version* ClientConfigP::mutable_version()
    {
        set_has_version();
        if (version_ == NULL) {
            version_ = new ::ipc::invalidation::Version;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.version)
        return version_;
    }
    inline ::ipc::invalidation::Version* ClientConfigP::release_version()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.version)
        clear_has_version();
        ::ipc::invalidation::Version* temp = version_;
        version_ = NULL;
        return temp;
    }
    inline void ClientConfigP::set_allocated_version(::ipc::invalidation::Version* version)
    {
        delete version_;
        version_ = version;
        if (version) {
            set_has_version();
        } else {
            clear_has_version();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.version)
    }

    // optional int32 network_timeout_delay_ms = 2 [default = 60000];
    inline bool ClientConfigP::has_network_timeout_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ClientConfigP::set_has_network_timeout_delay_ms()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ClientConfigP::clear_has_network_timeout_delay_ms()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ClientConfigP::clear_network_timeout_delay_ms()
    {
        network_timeout_delay_ms_ = 60000;
        clear_has_network_timeout_delay_ms();
    }
    inline ::google::protobuf::int32 ClientConfigP::network_timeout_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
        return network_timeout_delay_ms_;
    }
    inline void ClientConfigP::set_network_timeout_delay_ms(::google::protobuf::int32 value)
    {
        set_has_network_timeout_delay_ms();
        network_timeout_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
    }

    // optional int32 write_retry_delay_ms = 3 [default = 10000];
    inline bool ClientConfigP::has_write_retry_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void ClientConfigP::set_has_write_retry_delay_ms()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void ClientConfigP::clear_has_write_retry_delay_ms()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void ClientConfigP::clear_write_retry_delay_ms()
    {
        write_retry_delay_ms_ = 10000;
        clear_has_write_retry_delay_ms();
    }
    inline ::google::protobuf::int32 ClientConfigP::write_retry_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
        return write_retry_delay_ms_;
    }
    inline void ClientConfigP::set_write_retry_delay_ms(::google::protobuf::int32 value)
    {
        set_has_write_retry_delay_ms();
        write_retry_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
    }

    // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
    inline bool ClientConfigP::has_heartbeat_interval_ms() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void ClientConfigP::set_has_heartbeat_interval_ms()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void ClientConfigP::clear_has_heartbeat_interval_ms()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void ClientConfigP::clear_heartbeat_interval_ms()
    {
        heartbeat_interval_ms_ = 1200000;
        clear_has_heartbeat_interval_ms();
    }
    inline ::google::protobuf::int32 ClientConfigP::heartbeat_interval_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
        return heartbeat_interval_ms_;
    }
    inline void ClientConfigP::set_heartbeat_interval_ms(::google::protobuf::int32 value)
    {
        set_has_heartbeat_interval_ms();
        heartbeat_interval_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
    }

    // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
    inline bool ClientConfigP::has_perf_counter_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void ClientConfigP::set_has_perf_counter_delay_ms()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void ClientConfigP::clear_has_perf_counter_delay_ms()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void ClientConfigP::clear_perf_counter_delay_ms()
    {
        perf_counter_delay_ms_ = 21600000;
        clear_has_perf_counter_delay_ms();
    }
    inline ::google::protobuf::int32 ClientConfigP::perf_counter_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
        return perf_counter_delay_ms_;
    }
    inline void ClientConfigP::set_perf_counter_delay_ms(::google::protobuf::int32 value)
    {
        set_has_perf_counter_delay_ms();
        perf_counter_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
    }

    // optional int32 max_exponential_backoff_factor = 6 [default = 500];
    inline bool ClientConfigP::has_max_exponential_backoff_factor() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void ClientConfigP::set_has_max_exponential_backoff_factor()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void ClientConfigP::clear_has_max_exponential_backoff_factor()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void ClientConfigP::clear_max_exponential_backoff_factor()
    {
        max_exponential_backoff_factor_ = 500;
        clear_has_max_exponential_backoff_factor();
    }
    inline ::google::protobuf::int32 ClientConfigP::max_exponential_backoff_factor() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
        return max_exponential_backoff_factor_;
    }
    inline void ClientConfigP::set_max_exponential_backoff_factor(::google::protobuf::int32 value)
    {
        set_has_max_exponential_backoff_factor();
        max_exponential_backoff_factor_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
    }

    // optional int32 smear_percent = 7 [default = 20];
    inline bool ClientConfigP::has_smear_percent() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void ClientConfigP::set_has_smear_percent()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void ClientConfigP::clear_has_smear_percent()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void ClientConfigP::clear_smear_percent()
    {
        smear_percent_ = 20;
        clear_has_smear_percent();
    }
    inline ::google::protobuf::int32 ClientConfigP::smear_percent() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.smear_percent)
        return smear_percent_;
    }
    inline void ClientConfigP::set_smear_percent(::google::protobuf::int32 value)
    {
        set_has_smear_percent();
        smear_percent_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.smear_percent)
    }

    // optional bool is_transient = 8 [default = false];
    inline bool ClientConfigP::has_is_transient() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void ClientConfigP::set_has_is_transient()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void ClientConfigP::clear_has_is_transient()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void ClientConfigP::clear_is_transient()
    {
        is_transient_ = false;
        clear_has_is_transient();
    }
    inline bool ClientConfigP::is_transient() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.is_transient)
        return is_transient_;
    }
    inline void ClientConfigP::set_is_transient(bool value)
    {
        set_has_is_transient();
        is_transient_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.is_transient)
    }

    // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
    inline bool ClientConfigP::has_initial_persistent_heartbeat_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void ClientConfigP::set_has_initial_persistent_heartbeat_delay_ms()
    {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void ClientConfigP::clear_has_initial_persistent_heartbeat_delay_ms()
    {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void ClientConfigP::clear_initial_persistent_heartbeat_delay_ms()
    {
        initial_persistent_heartbeat_delay_ms_ = 2000;
        clear_has_initial_persistent_heartbeat_delay_ms();
    }
    inline ::google::protobuf::int32 ClientConfigP::initial_persistent_heartbeat_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
        return initial_persistent_heartbeat_delay_ms_;
    }
    inline void ClientConfigP::set_initial_persistent_heartbeat_delay_ms(::google::protobuf::int32 value)
    {
        set_has_initial_persistent_heartbeat_delay_ms();
        initial_persistent_heartbeat_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
    }

    // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
    inline bool ClientConfigP::has_protocol_handler_config() const
    {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void ClientConfigP::set_has_protocol_handler_config()
    {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void ClientConfigP::clear_has_protocol_handler_config()
    {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void ClientConfigP::clear_protocol_handler_config()
    {
        if (protocol_handler_config_ != NULL)
            protocol_handler_config_->::ipc::invalidation::ProtocolHandlerConfigP::Clear();
        clear_has_protocol_handler_config();
    }
    inline const ::ipc::invalidation::ProtocolHandlerConfigP& ClientConfigP::protocol_handler_config() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.protocol_handler_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return protocol_handler_config_ != NULL ? *protocol_handler_config_ : *default_instance().protocol_handler_config_;
#else
        return protocol_handler_config_ != NULL ? *protocol_handler_config_ : *default_instance_->protocol_handler_config_;
#endif
    }
    inline ::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::mutable_protocol_handler_config()
    {
        set_has_protocol_handler_config();
        if (protocol_handler_config_ == NULL) {
            protocol_handler_config_ = new ::ipc::invalidation::ProtocolHandlerConfigP;
        }
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.protocol_handler_config)
        return protocol_handler_config_;
    }
    inline ::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::release_protocol_handler_config()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.protocol_handler_config)
        clear_has_protocol_handler_config();
        ::ipc::invalidation::ProtocolHandlerConfigP* temp = protocol_handler_config_;
        protocol_handler_config_ = NULL;
        return temp;
    }
    inline void ClientConfigP::set_allocated_protocol_handler_config(::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config)
    {
        delete protocol_handler_config_;
        protocol_handler_config_ = protocol_handler_config;
        if (protocol_handler_config) {
            set_has_protocol_handler_config();
        } else {
            clear_has_protocol_handler_config();
        }
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.protocol_handler_config)
    }

    // optional bool channel_supports_offline_delivery = 11 [default = false];
    inline bool ClientConfigP::has_channel_supports_offline_delivery() const
    {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void ClientConfigP::set_has_channel_supports_offline_delivery()
    {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void ClientConfigP::clear_has_channel_supports_offline_delivery()
    {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void ClientConfigP::clear_channel_supports_offline_delivery()
    {
        channel_supports_offline_delivery_ = false;
        clear_has_channel_supports_offline_delivery();
    }
    inline bool ClientConfigP::channel_supports_offline_delivery() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
        return channel_supports_offline_delivery_;
    }
    inline void ClientConfigP::set_channel_supports_offline_delivery(bool value)
    {
        set_has_channel_supports_offline_delivery();
        channel_supports_offline_delivery_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
    }

    // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
    inline bool ClientConfigP::has_offline_heartbeat_threshold_ms() const
    {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void ClientConfigP::set_has_offline_heartbeat_threshold_ms()
    {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void ClientConfigP::clear_has_offline_heartbeat_threshold_ms()
    {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void ClientConfigP::clear_offline_heartbeat_threshold_ms()
    {
        offline_heartbeat_threshold_ms_ = 60000;
        clear_has_offline_heartbeat_threshold_ms();
    }
    inline ::google::protobuf::int32 ClientConfigP::offline_heartbeat_threshold_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
        return offline_heartbeat_threshold_ms_;
    }
    inline void ClientConfigP::set_offline_heartbeat_threshold_ms(::google::protobuf::int32 value)
    {
        set_has_offline_heartbeat_threshold_ms();
        offline_heartbeat_threshold_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
    }

    // optional bool allow_suppression = 13 [default = true];
    inline bool ClientConfigP::has_allow_suppression() const
    {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void ClientConfigP::set_has_allow_suppression()
    {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void ClientConfigP::clear_has_allow_suppression()
    {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void ClientConfigP::clear_allow_suppression()
    {
        allow_suppression_ = true;
        clear_has_allow_suppression();
    }
    inline bool ClientConfigP::allow_suppression() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.allow_suppression)
        return allow_suppression_;
    }
    inline void ClientConfigP::set_allow_suppression(bool value)
    {
        set_has_allow_suppression();
        allow_suppression_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.allow_suppression)
    }

    // -------------------------------------------------------------------

    // ConfigChangeMessage

    // optional int64 next_message_delay_ms = 1;
    inline bool ConfigChangeMessage::has_next_message_delay_ms() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ConfigChangeMessage::set_has_next_message_delay_ms()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ConfigChangeMessage::clear_has_next_message_delay_ms()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ConfigChangeMessage::clear_next_message_delay_ms()
    {
        next_message_delay_ms_ = GOOGLE_LONGLONG(0);
        clear_has_next_message_delay_ms();
    }
    inline ::google::protobuf::int64 ConfigChangeMessage::next_message_delay_ms() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
        return next_message_delay_ms_;
    }
    inline void ConfigChangeMessage::set_next_message_delay_ms(::google::protobuf::int64 value)
    {
        set_has_next_message_delay_ms();
        next_message_delay_ms_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
    }

    // -------------------------------------------------------------------

    // ErrorMessage

    // optional .ipc.invalidation.ErrorMessage.Code code = 1;
    inline bool ErrorMessage::has_code() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void ErrorMessage::set_has_code()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void ErrorMessage::clear_has_code()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void ErrorMessage::clear_code()
    {
        code_ = 1;
        clear_has_code();
    }
    inline ::ipc::invalidation::ErrorMessage_Code ErrorMessage::code() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.code)
        return static_cast<::ipc::invalidation::ErrorMessage_Code>(code_);
    }
    inline void ErrorMessage::set_code(::ipc::invalidation::ErrorMessage_Code value)
    {
        assert(::ipc::invalidation::ErrorMessage_Code_IsValid(value));
        set_has_code();
        code_ = value;
        // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.code)
    }

    // optional string description = 2;
    inline bool ErrorMessage::has_description() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void ErrorMessage::set_has_description()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void ErrorMessage::clear_has_description()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void ErrorMessage::clear_description()
    {
        description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_description();
    }
    inline const ::std::string& ErrorMessage::description() const
    {
        // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.description)
        return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ErrorMessage::set_description(const ::std::string& value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.description)
    }
    inline void ErrorMessage::set_description(const char* value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:ipc.invalidation.ErrorMessage.description)
    }
    inline void ErrorMessage::set_description(const char* value, size_t size)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ErrorMessage.description)
    }
    inline ::std::string* ErrorMessage::mutable_description()
    {
        set_has_description();
        // @@protoc_insertion_point(field_mutable:ipc.invalidation.ErrorMessage.description)
        return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* ErrorMessage::release_description()
    {
        // @@protoc_insertion_point(field_release:ipc.invalidation.ErrorMessage.description)
        clear_has_description();
        return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void ErrorMessage::set_allocated_description(::std::string* description)
    {
        if (description != NULL) {
            set_has_description();
        } else {
            clear_has_description();
        }
        description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
        // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ErrorMessage.description)
    }

#endif // !PROTOBUF_INLINE_NOT_IN_HEADERS
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

} // namespace invalidation
} // namespace ipc

#ifndef SWIG
namespace google {
namespace protobuf {

    template <>
    struct is_proto_enum<::ipc::invalidation::StatusP_Code> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::ipc::invalidation::RegistrationP_OpType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::ipc::invalidation::InitializeMessage_DigestSerializationType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::ipc::invalidation::InfoRequestMessage_InfoType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::ipc::invalidation::ErrorMessage_Code> : ::google::protobuf::internal::true_type {
    };

} // namespace protobuf
} // namespace google
#endif // SWIG

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_client_5fprotocol_2eproto__INCLUDED
