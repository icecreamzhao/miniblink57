// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "safebrowsing.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace safe_browsing {

void protobuf_ShutdownFile_safebrowsing_2eproto()
{
    delete ThreatInfo::default_instance_;
    delete ThreatMatch::default_instance_;
    delete FindThreatMatchesRequest::default_instance_;
    delete FindThreatMatchesResponse::default_instance_;
    delete FetchThreatListUpdatesRequest::default_instance_;
    delete FetchThreatListUpdatesRequest_ListUpdateRequest::default_instance_;
    delete FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance_;
    delete FetchThreatListUpdatesResponse::default_instance_;
    delete FetchThreatListUpdatesResponse_ListUpdateResponse::default_instance_;
    delete FindFullHashesRequest::default_instance_;
    delete FindFullHashesResponse::default_instance_;
    delete ThreatHit::default_instance_;
    delete ThreatHit_ThreatSource::default_instance_;
    delete ClientInfo::default_instance_;
    delete ChromeClientInfo::default_instance_;
    delete Checksum::default_instance_;
    delete ThreatEntry::default_instance_;
    delete ThreatEntrySet::default_instance_;
    delete RawIndices::default_instance_;
    delete RawHashes::default_instance_;
    delete RiceDeltaEncoding::default_instance_;
    delete ThreatEntryMetadata::default_instance_;
    delete ThreatEntryMetadata_MetadataEntry::default_instance_;
    delete ThreatListDescriptor::default_instance_;
    delete ListThreatListsResponse::default_instance_;
    delete Duration::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_safebrowsing_2eproto_impl()
{
    GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_safebrowsing_2eproto()
{
    static bool already_here = false;
    if (already_here)
        return;
    already_here = true;
    GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
    ThreatInfo::default_instance_ = new ThreatInfo();
    ThreatMatch::default_instance_ = new ThreatMatch();
    FindThreatMatchesRequest::default_instance_ = new FindThreatMatchesRequest();
    FindThreatMatchesResponse::default_instance_ = new FindThreatMatchesResponse();
    FetchThreatListUpdatesRequest::default_instance_ = new FetchThreatListUpdatesRequest();
    FetchThreatListUpdatesRequest_ListUpdateRequest::default_instance_ = new FetchThreatListUpdatesRequest_ListUpdateRequest();
    FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance_ = new FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();
    FetchThreatListUpdatesResponse::default_instance_ = new FetchThreatListUpdatesResponse();
    FetchThreatListUpdatesResponse_ListUpdateResponse::default_instance_ = new FetchThreatListUpdatesResponse_ListUpdateResponse();
    FindFullHashesRequest::default_instance_ = new FindFullHashesRequest();
    FindFullHashesResponse::default_instance_ = new FindFullHashesResponse();
    ThreatHit::default_instance_ = new ThreatHit();
    ThreatHit_ThreatSource::default_instance_ = new ThreatHit_ThreatSource();
    ClientInfo::default_instance_ = new ClientInfo();
    ChromeClientInfo::default_instance_ = new ChromeClientInfo();
    Checksum::default_instance_ = new Checksum();
    ThreatEntry::default_instance_ = new ThreatEntry();
    ThreatEntrySet::default_instance_ = new ThreatEntrySet();
    RawIndices::default_instance_ = new RawIndices();
    RawHashes::default_instance_ = new RawHashes();
    RiceDeltaEncoding::default_instance_ = new RiceDeltaEncoding();
    ThreatEntryMetadata::default_instance_ = new ThreatEntryMetadata();
    ThreatEntryMetadata_MetadataEntry::default_instance_ = new ThreatEntryMetadata_MetadataEntry();
    ThreatListDescriptor::default_instance_ = new ThreatListDescriptor();
    ListThreatListsResponse::default_instance_ = new ListThreatListsResponse();
    Duration::default_instance_ = new Duration();
    ThreatInfo::default_instance_->InitAsDefaultInstance();
    ThreatMatch::default_instance_->InitAsDefaultInstance();
    FindThreatMatchesRequest::default_instance_->InitAsDefaultInstance();
    FindThreatMatchesResponse::default_instance_->InitAsDefaultInstance();
    FetchThreatListUpdatesRequest::default_instance_->InitAsDefaultInstance();
    FetchThreatListUpdatesRequest_ListUpdateRequest::default_instance_->InitAsDefaultInstance();
    FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance_->InitAsDefaultInstance();
    FetchThreatListUpdatesResponse::default_instance_->InitAsDefaultInstance();
    FetchThreatListUpdatesResponse_ListUpdateResponse::default_instance_->InitAsDefaultInstance();
    FindFullHashesRequest::default_instance_->InitAsDefaultInstance();
    FindFullHashesResponse::default_instance_->InitAsDefaultInstance();
    ThreatHit::default_instance_->InitAsDefaultInstance();
    ThreatHit_ThreatSource::default_instance_->InitAsDefaultInstance();
    ClientInfo::default_instance_->InitAsDefaultInstance();
    ChromeClientInfo::default_instance_->InitAsDefaultInstance();
    Checksum::default_instance_->InitAsDefaultInstance();
    ThreatEntry::default_instance_->InitAsDefaultInstance();
    ThreatEntrySet::default_instance_->InitAsDefaultInstance();
    RawIndices::default_instance_->InitAsDefaultInstance();
    RawHashes::default_instance_->InitAsDefaultInstance();
    RiceDeltaEncoding::default_instance_->InitAsDefaultInstance();
    ThreatEntryMetadata::default_instance_->InitAsDefaultInstance();
    ThreatEntryMetadata_MetadataEntry::default_instance_->InitAsDefaultInstance();
    ThreatListDescriptor::default_instance_->InitAsDefaultInstance();
    ListThreatListsResponse::default_instance_->InitAsDefaultInstance();
    Duration::default_instance_->InitAsDefaultInstance();
    ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_safebrowsing_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_safebrowsing_2eproto_once_);
void protobuf_AddDesc_safebrowsing_2eproto()
{
    ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_safebrowsing_2eproto_once_,
        &protobuf_AddDesc_safebrowsing_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_safebrowsing_2eproto {
    StaticDescriptorInitializer_safebrowsing_2eproto()
    {
        protobuf_AddDesc_safebrowsing_2eproto();
    }
} static_descriptor_initializer_safebrowsing_2eproto_;
#endif
bool ThreatType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
        return true;
    default:
        return false;
    }
}

bool PlatformType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
        return true;
    default:
        return false;
    }
}

bool CompressionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

bool ThreatEntryType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

namespace {

    static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
    GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line)
    {
        GOOGLE_CHECK(false) << __FILE__ << ":" << line;
    }

} // namespace

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreatInfo(
    ThreatInfo* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatInfo::kThreatTypesFieldNumber;
const int ThreatInfo::kPlatformTypesFieldNumber;
const int ThreatInfo::kThreatEntryTypesFieldNumber;
const int ThreatInfo::kThreatEntriesFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatInfo::ThreatInfo()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatInfo)
}

void ThreatInfo::InitAsDefaultInstance()
{
}

ThreatInfo::ThreatInfo(const ThreatInfo& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatInfo)
}

void ThreatInfo::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatInfo::~ThreatInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatInfo)
    SharedDtor();
}

void ThreatInfo::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ThreatInfo::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatInfo& ThreatInfo::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatInfo* ThreatInfo::default_instance_ = NULL;

ThreatInfo* ThreatInfo::New(::google::protobuf::Arena* arena) const
{
    ThreatInfo* n = new ThreatInfo;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatInfo)
    threat_types_.Clear();
    platform_types_.Clear();
    threat_entry_types_.Clear();
    threat_entries_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatInfo, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatInfo)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // repeated .safe_browsing.ThreatType threat_types = 1;
        case 1: {
            if (tag == 8) {
            parse_threat_types:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatType_IsValid(value)) {
                    add_threat_types(static_cast<::safe_browsing::ThreatType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(tag);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else if (tag == 10) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                    input,
                    1,
                    ::safe_browsing::ThreatType_IsValid,
                    &unknown_fields_stream,
                    this->mutable_threat_types())));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(8))
                goto parse_threat_types;
            if (input->ExpectTag(16))
                goto parse_platform_types;
            break;
        }

        // repeated .safe_browsing.PlatformType platform_types = 2;
        case 2: {
            if (tag == 16) {
            parse_platform_types:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::PlatformType_IsValid(value)) {
                    add_platform_types(static_cast<::safe_browsing::PlatformType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(tag);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else if (tag == 18) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                    input,
                    2,
                    ::safe_browsing::PlatformType_IsValid,
                    &unknown_fields_stream,
                    this->mutable_platform_types())));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_platform_types;
            if (input->ExpectTag(26))
                goto parse_threat_entries;
            break;
        }

        // repeated .safe_browsing.ThreatEntry threat_entries = 3;
        case 3: {
            if (tag == 26) {
            parse_threat_entries:
                DO_(input->IncrementRecursionDepth());
            parse_loop_threat_entries:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_threat_entries()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_loop_threat_entries;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectTag(32))
                goto parse_threat_entry_types;
            break;
        }

        // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
        case 4: {
            if (tag == 32) {
            parse_threat_entry_types:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatEntryType_IsValid(value)) {
                    add_threat_entry_types(static_cast<::safe_browsing::ThreatEntryType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(tag);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else if (tag == 34) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                    input,
                    4,
                    ::safe_browsing::ThreatEntryType_IsValid,
                    &unknown_fields_stream,
                    this->mutable_threat_entry_types())));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(32))
                goto parse_threat_entry_types;
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatInfo)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatInfo)
    return false;
#undef DO_
}

void ThreatInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatInfo)
    // repeated .safe_browsing.ThreatType threat_types = 1;
    for (int i = 0; i < this->threat_types_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->threat_types(i), output);
    }

    // repeated .safe_browsing.PlatformType platform_types = 2;
    for (int i = 0; i < this->platform_types_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->platform_types(i), output);
    }

    // repeated .safe_browsing.ThreatEntry threat_entries = 3;
    for (unsigned int i = 0, n = this->threat_entries_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->threat_entries(i), output);
    }

    // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
    for (int i = 0; i < this->threat_entry_types_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            4, this->threat_entry_types(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatInfo)
}

int ThreatInfo::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatInfo)
    int total_size = 0;

    // repeated .safe_browsing.ThreatType threat_types = 1;
    {
        int data_size = 0;
        for (int i = 0; i < this->threat_types_size(); i++) {
            data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
                this->threat_types(i));
        }
        total_size += 1 * this->threat_types_size() + data_size;
    }

    // repeated .safe_browsing.PlatformType platform_types = 2;
    {
        int data_size = 0;
        for (int i = 0; i < this->platform_types_size(); i++) {
            data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
                this->platform_types(i));
        }
        total_size += 1 * this->platform_types_size() + data_size;
    }

    // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
    {
        int data_size = 0;
        for (int i = 0; i < this->threat_entry_types_size(); i++) {
            data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
                this->threat_entry_types(i));
        }
        total_size += 1 * this->threat_entry_types_size() + data_size;
    }

    // repeated .safe_browsing.ThreatEntry threat_entries = 3;
    total_size += 1 * this->threat_entries_size();
    for (int i = 0; i < this->threat_entries_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->threat_entries(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatInfo*>(&from));
}

void ThreatInfo::MergeFrom(const ThreatInfo& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatInfo)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    threat_types_.MergeFrom(from.threat_types_);
    platform_types_.MergeFrom(from.platform_types_);
    threat_entry_types_.MergeFrom(from.threat_entry_types_);
    threat_entries_.MergeFrom(from.threat_entries_);
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatInfo::CopyFrom(const ThreatInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatInfo::IsInitialized() const
{

    return true;
}

void ThreatInfo::Swap(ThreatInfo* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatInfo::InternalSwap(ThreatInfo* other)
{
    threat_types_.UnsafeArenaSwap(&other->threat_types_);
    platform_types_.UnsafeArenaSwap(&other->platform_types_);
    threat_entry_types_.UnsafeArenaSwap(&other->threat_entry_types_);
    threat_entries_.UnsafeArenaSwap(&other->threat_entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatInfo::GetTypeName() const
{
    return "safe_browsing.ThreatInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatInfo

// repeated .safe_browsing.ThreatType threat_types = 1;
int ThreatInfo::threat_types_size() const
{
    return threat_types_.size();
}
void ThreatInfo::clear_threat_types()
{
    threat_types_.Clear();
}
::safe_browsing::ThreatType ThreatInfo::threat_types(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_types)
    return static_cast<::safe_browsing::ThreatType>(threat_types_.Get(index));
}
void ThreatInfo::set_threat_types(int index, ::safe_browsing::ThreatType value)
{
    assert(::safe_browsing::ThreatType_IsValid(value));
    threat_types_.Set(index, value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.threat_types)
}
void ThreatInfo::add_threat_types(::safe_browsing::ThreatType value)
{
    assert(::safe_browsing::ThreatType_IsValid(value));
    threat_types_.Add(value);
    // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_types)
}
const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_types() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_types)
    return threat_types_;
}
::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_types()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_types)
    return &threat_types_;
}

// repeated .safe_browsing.PlatformType platform_types = 2;
int ThreatInfo::platform_types_size() const
{
    return platform_types_.size();
}
void ThreatInfo::clear_platform_types()
{
    platform_types_.Clear();
}
::safe_browsing::PlatformType ThreatInfo::platform_types(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.platform_types)
    return static_cast<::safe_browsing::PlatformType>(platform_types_.Get(index));
}
void ThreatInfo::set_platform_types(int index, ::safe_browsing::PlatformType value)
{
    assert(::safe_browsing::PlatformType_IsValid(value));
    platform_types_.Set(index, value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.platform_types)
}
void ThreatInfo::add_platform_types(::safe_browsing::PlatformType value)
{
    assert(::safe_browsing::PlatformType_IsValid(value));
    platform_types_.Add(value);
    // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.platform_types)
}
const ::google::protobuf::RepeatedField<int>&
ThreatInfo::platform_types() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.platform_types)
    return platform_types_;
}
::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_platform_types()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.platform_types)
    return &platform_types_;
}

// repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
int ThreatInfo::threat_entry_types_size() const
{
    return threat_entry_types_.size();
}
void ThreatInfo::clear_threat_entry_types()
{
    threat_entry_types_.Clear();
}
::safe_browsing::ThreatEntryType ThreatInfo::threat_entry_types(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_entry_types)
    return static_cast<::safe_browsing::ThreatEntryType>(threat_entry_types_.Get(index));
}
void ThreatInfo::set_threat_entry_types(int index, ::safe_browsing::ThreatEntryType value)
{
    assert(::safe_browsing::ThreatEntryType_IsValid(value));
    threat_entry_types_.Set(index, value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.threat_entry_types)
}
void ThreatInfo::add_threat_entry_types(::safe_browsing::ThreatEntryType value)
{
    assert(::safe_browsing::ThreatEntryType_IsValid(value));
    threat_entry_types_.Add(value);
    // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_entry_types)
}
const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_entry_types() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_entry_types)
    return threat_entry_types_;
}
::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_entry_types()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_entry_types)
    return &threat_entry_types_;
}

// repeated .safe_browsing.ThreatEntry threat_entries = 3;
int ThreatInfo::threat_entries_size() const
{
    return threat_entries_.size();
}
void ThreatInfo::clear_threat_entries()
{
    threat_entries_.Clear();
}
const ::safe_browsing::ThreatEntry& ThreatInfo::threat_entries(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_entries)
    return threat_entries_.Get(index);
}
::safe_browsing::ThreatEntry* ThreatInfo::mutable_threat_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatInfo.threat_entries)
    return threat_entries_.Mutable(index);
}
::safe_browsing::ThreatEntry* ThreatInfo::add_threat_entries()
{
    // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_entries)
    return threat_entries_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntry>*
ThreatInfo::mutable_threat_entries()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_entries)
    return &threat_entries_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntry>&
ThreatInfo::threat_entries() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_entries)
    return threat_entries_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreatMatch(
    ThreatMatch* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatMatch::kThreatTypeFieldNumber;
const int ThreatMatch::kPlatformTypeFieldNumber;
const int ThreatMatch::kThreatEntryTypeFieldNumber;
const int ThreatMatch::kThreatFieldNumber;
const int ThreatMatch::kThreatEntryMetadataFieldNumber;
const int ThreatMatch::kCacheDurationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatMatch::ThreatMatch()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatMatch)
}

void ThreatMatch::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    threat_ = const_cast<::safe_browsing::ThreatEntry*>(
        ::safe_browsing::ThreatEntry::internal_default_instance());
#else
    threat_ = const_cast<::safe_browsing::ThreatEntry*>(&::safe_browsing::ThreatEntry::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    threat_entry_metadata_ = const_cast<::safe_browsing::ThreatEntryMetadata*>(
        ::safe_browsing::ThreatEntryMetadata::internal_default_instance());
#else
    threat_entry_metadata_ = const_cast<::safe_browsing::ThreatEntryMetadata*>(&::safe_browsing::ThreatEntryMetadata::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    cache_duration_ = const_cast<::safe_browsing::Duration*>(
        ::safe_browsing::Duration::internal_default_instance());
#else
    cache_duration_ = const_cast<::safe_browsing::Duration*>(&::safe_browsing::Duration::default_instance());
#endif
}

ThreatMatch::ThreatMatch(const ThreatMatch& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatMatch)
}

void ThreatMatch::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    threat_type_ = 0;
    platform_type_ = 0;
    threat_entry_type_ = 0;
    threat_ = NULL;
    threat_entry_metadata_ = NULL;
    cache_duration_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatMatch::~ThreatMatch()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatMatch)
    SharedDtor();
}

void ThreatMatch::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete threat_;
        delete threat_entry_metadata_;
        delete cache_duration_;
    }
}

void ThreatMatch::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatMatch& ThreatMatch::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatMatch* ThreatMatch::default_instance_ = NULL;

ThreatMatch* ThreatMatch::New(::google::protobuf::Arena* arena) const
{
    ThreatMatch* n = new ThreatMatch;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatMatch::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatMatch)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                 \
    _Pragma("clang diagnostic push")                                                                  \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ThreatMatch, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ThreatMatch*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 63u) {
        ZR_(threat_type_, platform_type_);
        threat_entry_type_ = 0;
        if (has_threat()) {
            if (threat_ != NULL)
                threat_->::safe_browsing::ThreatEntry::Clear();
        }
        if (has_threat_entry_metadata()) {
            if (threat_entry_metadata_ != NULL)
                threat_entry_metadata_->::safe_browsing::ThreatEntryMetadata::Clear();
        }
        if (has_cache_duration()) {
            if (cache_duration_ != NULL)
                cache_duration_->::safe_browsing::Duration::Clear();
        }
    }

#undef ZR_HELPER_
#undef ZR_

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatMatch, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatMatch)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        case 1: {
            if (tag == 8) {
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatType_IsValid(value)) {
                    set_threat_type(static_cast<::safe_browsing::ThreatType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(8);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_platform_type;
            break;
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        case 2: {
            if (tag == 16) {
            parse_platform_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::PlatformType_IsValid(value)) {
                    set_platform_type(static_cast<::safe_browsing::PlatformType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(16);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_threat;
            break;
        }

        // optional .safe_browsing.ThreatEntry threat = 3;
        case 3: {
            if (tag == 26) {
            parse_threat:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_threat()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_threat_entry_metadata;
            break;
        }

        // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
        case 4: {
            if (tag == 34) {
            parse_threat_entry_metadata:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_threat_entry_metadata()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(42))
                goto parse_cache_duration;
            break;
        }

        // optional .safe_browsing.Duration cache_duration = 5;
        case 5: {
            if (tag == 42) {
            parse_cache_duration:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_cache_duration()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(48))
                goto parse_threat_entry_type;
            break;
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
        case 6: {
            if (tag == 48) {
            parse_threat_entry_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatEntryType_IsValid(value)) {
                    set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(48);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatMatch)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatMatch)
    return false;
#undef DO_
}

void ThreatMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatMatch)
    // optional .safe_browsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->threat_type(), output);
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->platform_type(), output);
    }

    // optional .safe_browsing.ThreatEntry threat = 3;
    if (has_threat()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, *this->threat_, output);
    }

    // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
    if (has_threat_entry_metadata()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, *this->threat_entry_metadata_, output);
    }

    // optional .safe_browsing.Duration cache_duration = 5;
    if (has_cache_duration()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            5, *this->cache_duration_, output);
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
    if (has_threat_entry_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            6, this->threat_entry_type(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatMatch)
}

int ThreatMatch::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatMatch)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 63u) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        if (has_threat_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        if (has_platform_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
        if (has_threat_entry_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
        }

        // optional .safe_browsing.ThreatEntry threat = 3;
        if (has_threat()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->threat_);
        }

        // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
        if (has_threat_entry_metadata()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->threat_entry_metadata_);
        }

        // optional .safe_browsing.Duration cache_duration = 5;
        if (has_cache_duration()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->cache_duration_);
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatMatch*>(&from));
}

void ThreatMatch::MergeFrom(const ThreatMatch& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatMatch)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_threat_type()) {
            set_threat_type(from.threat_type());
        }
        if (from.has_platform_type()) {
            set_platform_type(from.platform_type());
        }
        if (from.has_threat_entry_type()) {
            set_threat_entry_type(from.threat_entry_type());
        }
        if (from.has_threat()) {
            mutable_threat()->::safe_browsing::ThreatEntry::MergeFrom(from.threat());
        }
        if (from.has_threat_entry_metadata()) {
            mutable_threat_entry_metadata()->::safe_browsing::ThreatEntryMetadata::MergeFrom(from.threat_entry_metadata());
        }
        if (from.has_cache_duration()) {
            mutable_cache_duration()->::safe_browsing::Duration::MergeFrom(from.cache_duration());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatMatch::CopyFrom(const ThreatMatch& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatMatch)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatMatch::IsInitialized() const
{

    return true;
}

void ThreatMatch::Swap(ThreatMatch* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatMatch::InternalSwap(ThreatMatch* other)
{
    std::swap(threat_type_, other->threat_type_);
    std::swap(platform_type_, other->platform_type_);
    std::swap(threat_entry_type_, other->threat_entry_type_);
    std::swap(threat_, other->threat_);
    std::swap(threat_entry_metadata_, other->threat_entry_metadata_);
    std::swap(cache_duration_, other->cache_duration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatMatch::GetTypeName() const
{
    return "safe_browsing.ThreatMatch";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatMatch

// optional .safe_browsing.ThreatType threat_type = 1;
bool ThreatMatch::has_threat_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatMatch::set_has_threat_type()
{
    _has_bits_[0] |= 0x00000001u;
}
void ThreatMatch::clear_has_threat_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ThreatMatch::clear_threat_type()
{
    threat_type_ = 0;
    clear_has_threat_type();
}
::safe_browsing::ThreatType ThreatMatch::threat_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_type)
    return static_cast<::safe_browsing::ThreatType>(threat_type_);
}
void ThreatMatch::set_threat_type(::safe_browsing::ThreatType value)
{
    assert(::safe_browsing::ThreatType_IsValid(value));
    set_has_threat_type();
    threat_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
bool ThreatMatch::has_platform_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatMatch::set_has_platform_type()
{
    _has_bits_[0] |= 0x00000002u;
}
void ThreatMatch::clear_has_platform_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ThreatMatch::clear_platform_type()
{
    platform_type_ = 0;
    clear_has_platform_type();
}
::safe_browsing::PlatformType ThreatMatch::platform_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.platform_type)
    return static_cast<::safe_browsing::PlatformType>(platform_type_);
}
void ThreatMatch::set_platform_type(::safe_browsing::PlatformType value)
{
    assert(::safe_browsing::PlatformType_IsValid(value));
    set_has_platform_type();
    platform_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
bool ThreatMatch::has_threat_entry_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatMatch::set_has_threat_entry_type()
{
    _has_bits_[0] |= 0x00000004u;
}
void ThreatMatch::clear_has_threat_entry_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ThreatMatch::clear_threat_entry_type()
{
    threat_entry_type_ = 0;
    clear_has_threat_entry_type();
}
::safe_browsing::ThreatEntryType ThreatMatch::threat_entry_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_entry_type)
    return static_cast<::safe_browsing::ThreatEntryType>(threat_entry_type_);
}
void ThreatMatch::set_threat_entry_type(::safe_browsing::ThreatEntryType value)
{
    assert(::safe_browsing::ThreatEntryType_IsValid(value));
    set_has_threat_entry_type();
    threat_entry_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.threat_entry_type)
}

// optional .safe_browsing.ThreatEntry threat = 3;
bool ThreatMatch::has_threat() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void ThreatMatch::set_has_threat()
{
    _has_bits_[0] |= 0x00000008u;
}
void ThreatMatch::clear_has_threat()
{
    _has_bits_[0] &= ~0x00000008u;
}
void ThreatMatch::clear_threat()
{
    if (threat_ != NULL)
        threat_->::safe_browsing::ThreatEntry::Clear();
    clear_has_threat();
}
const ::safe_browsing::ThreatEntry& ThreatMatch::threat() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return threat_ != NULL ? *threat_ : *default_instance().threat_;
#else
    return threat_ != NULL ? *threat_ : *default_instance_->threat_;
#endif
}
::safe_browsing::ThreatEntry* ThreatMatch::mutable_threat()
{
    set_has_threat();
    if (threat_ == NULL) {
        threat_ = new ::safe_browsing::ThreatEntry;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.threat)
    return threat_;
}
::safe_browsing::ThreatEntry* ThreatMatch::release_threat()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.threat)
    clear_has_threat();
    ::safe_browsing::ThreatEntry* temp = threat_;
    threat_ = NULL;
    return temp;
}
void ThreatMatch::set_allocated_threat(::safe_browsing::ThreatEntry* threat)
{
    delete threat_;
    threat_ = threat;
    if (threat) {
        set_has_threat();
    } else {
        clear_has_threat();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.threat)
}

// optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
bool ThreatMatch::has_threat_entry_metadata() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
void ThreatMatch::set_has_threat_entry_metadata()
{
    _has_bits_[0] |= 0x00000010u;
}
void ThreatMatch::clear_has_threat_entry_metadata()
{
    _has_bits_[0] &= ~0x00000010u;
}
void ThreatMatch::clear_threat_entry_metadata()
{
    if (threat_entry_metadata_ != NULL)
        threat_entry_metadata_->::safe_browsing::ThreatEntryMetadata::Clear();
    clear_has_threat_entry_metadata();
}
const ::safe_browsing::ThreatEntryMetadata& ThreatMatch::threat_entry_metadata() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_entry_metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return threat_entry_metadata_ != NULL ? *threat_entry_metadata_ : *default_instance().threat_entry_metadata_;
#else
    return threat_entry_metadata_ != NULL ? *threat_entry_metadata_ : *default_instance_->threat_entry_metadata_;
#endif
}
::safe_browsing::ThreatEntryMetadata* ThreatMatch::mutable_threat_entry_metadata()
{
    set_has_threat_entry_metadata();
    if (threat_entry_metadata_ == NULL) {
        threat_entry_metadata_ = new ::safe_browsing::ThreatEntryMetadata;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.threat_entry_metadata)
    return threat_entry_metadata_;
}
::safe_browsing::ThreatEntryMetadata* ThreatMatch::release_threat_entry_metadata()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.threat_entry_metadata)
    clear_has_threat_entry_metadata();
    ::safe_browsing::ThreatEntryMetadata* temp = threat_entry_metadata_;
    threat_entry_metadata_ = NULL;
    return temp;
}
void ThreatMatch::set_allocated_threat_entry_metadata(::safe_browsing::ThreatEntryMetadata* threat_entry_metadata)
{
    delete threat_entry_metadata_;
    threat_entry_metadata_ = threat_entry_metadata;
    if (threat_entry_metadata) {
        set_has_threat_entry_metadata();
    } else {
        clear_has_threat_entry_metadata();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.threat_entry_metadata)
}

// optional .safe_browsing.Duration cache_duration = 5;
bool ThreatMatch::has_cache_duration() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
void ThreatMatch::set_has_cache_duration()
{
    _has_bits_[0] |= 0x00000020u;
}
void ThreatMatch::clear_has_cache_duration()
{
    _has_bits_[0] &= ~0x00000020u;
}
void ThreatMatch::clear_cache_duration()
{
    if (cache_duration_ != NULL)
        cache_duration_->::safe_browsing::Duration::Clear();
    clear_has_cache_duration();
}
const ::safe_browsing::Duration& ThreatMatch::cache_duration() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.cache_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return cache_duration_ != NULL ? *cache_duration_ : *default_instance().cache_duration_;
#else
    return cache_duration_ != NULL ? *cache_duration_ : *default_instance_->cache_duration_;
#endif
}
::safe_browsing::Duration* ThreatMatch::mutable_cache_duration()
{
    set_has_cache_duration();
    if (cache_duration_ == NULL) {
        cache_duration_ = new ::safe_browsing::Duration;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.cache_duration)
    return cache_duration_;
}
::safe_browsing::Duration* ThreatMatch::release_cache_duration()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.cache_duration)
    clear_has_cache_duration();
    ::safe_browsing::Duration* temp = cache_duration_;
    cache_duration_ = NULL;
    return temp;
}
void ThreatMatch::set_allocated_cache_duration(::safe_browsing::Duration* cache_duration)
{
    delete cache_duration_;
    cache_duration_ = cache_duration;
    if (cache_duration) {
        set_has_cache_duration();
    } else {
        clear_has_cache_duration();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.cache_duration)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindThreatMatchesRequest(
    FindThreatMatchesRequest* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindThreatMatchesRequest::kClientFieldNumber;
const int FindThreatMatchesRequest::kThreatInfoFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FindThreatMatchesRequest::FindThreatMatchesRequest()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FindThreatMatchesRequest)
}

void FindThreatMatchesRequest::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    client_ = const_cast<::safe_browsing::ClientInfo*>(
        ::safe_browsing::ClientInfo::internal_default_instance());
#else
    client_ = const_cast<::safe_browsing::ClientInfo*>(&::safe_browsing::ClientInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    threat_info_ = const_cast<::safe_browsing::ThreatInfo*>(
        ::safe_browsing::ThreatInfo::internal_default_instance());
#else
    threat_info_ = const_cast<::safe_browsing::ThreatInfo*>(&::safe_browsing::ThreatInfo::default_instance());
#endif
}

FindThreatMatchesRequest::FindThreatMatchesRequest(const FindThreatMatchesRequest& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FindThreatMatchesRequest)
}

void FindThreatMatchesRequest::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    client_ = NULL;
    threat_info_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindThreatMatchesRequest::~FindThreatMatchesRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FindThreatMatchesRequest)
    SharedDtor();
}

void FindThreatMatchesRequest::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete client_;
        delete threat_info_;
    }
}

void FindThreatMatchesRequest::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindThreatMatchesRequest& FindThreatMatchesRequest::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FindThreatMatchesRequest* FindThreatMatchesRequest::default_instance_ = NULL;

FindThreatMatchesRequest* FindThreatMatchesRequest::New(::google::protobuf::Arena* arena) const
{
    FindThreatMatchesRequest* n = new FindThreatMatchesRequest;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FindThreatMatchesRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.FindThreatMatchesRequest)
    if (_has_bits_[0 / 32] & 3u) {
        if (has_client()) {
            if (client_ != NULL)
                client_->::safe_browsing::ClientInfo::Clear();
        }
        if (has_threat_info()) {
            if (threat_info_ != NULL)
                threat_info_->::safe_browsing::ThreatInfo::Clear();
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindThreatMatchesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFindThreatMatchesRequest, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FindThreatMatchesRequest)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ClientInfo client = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_client()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_threat_info;
            break;
        }

        // optional .safe_browsing.ThreatInfo threat_info = 2;
        case 2: {
            if (tag == 18) {
            parse_threat_info:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_threat_info()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FindThreatMatchesRequest)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FindThreatMatchesRequest)
    return false;
#undef DO_
}

void FindThreatMatchesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FindThreatMatchesRequest)
    // optional .safe_browsing.ClientInfo client = 1;
    if (has_client()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->client_, output);
    }

    // optional .safe_browsing.ThreatInfo threat_info = 2;
    if (has_threat_info()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, *this->threat_info_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FindThreatMatchesRequest)
}

int FindThreatMatchesRequest::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindThreatMatchesRequest)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional .safe_browsing.ClientInfo client = 1;
        if (has_client()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->client_);
        }

        // optional .safe_browsing.ThreatInfo threat_info = 2;
        if (has_threat_info()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->threat_info_);
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FindThreatMatchesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FindThreatMatchesRequest*>(&from));
}

void FindThreatMatchesRequest::MergeFrom(const FindThreatMatchesRequest& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindThreatMatchesRequest)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_client()) {
            mutable_client()->::safe_browsing::ClientInfo::MergeFrom(from.client());
        }
        if (from.has_threat_info()) {
            mutable_threat_info()->::safe_browsing::ThreatInfo::MergeFrom(from.threat_info());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FindThreatMatchesRequest::CopyFrom(const FindThreatMatchesRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindThreatMatchesRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FindThreatMatchesRequest::IsInitialized() const
{

    return true;
}

void FindThreatMatchesRequest::Swap(FindThreatMatchesRequest* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FindThreatMatchesRequest::InternalSwap(FindThreatMatchesRequest* other)
{
    std::swap(client_, other->client_);
    std::swap(threat_info_, other->threat_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindThreatMatchesRequest::GetTypeName() const
{
    return "safe_browsing.FindThreatMatchesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindThreatMatchesRequest

// optional .safe_browsing.ClientInfo client = 1;
bool FindThreatMatchesRequest::has_client() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindThreatMatchesRequest::set_has_client()
{
    _has_bits_[0] |= 0x00000001u;
}
void FindThreatMatchesRequest::clear_has_client()
{
    _has_bits_[0] &= ~0x00000001u;
}
void FindThreatMatchesRequest::clear_client()
{
    if (client_ != NULL)
        client_->::safe_browsing::ClientInfo::Clear();
    clear_has_client();
}
const ::safe_browsing::ClientInfo& FindThreatMatchesRequest::client() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesRequest.client)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return client_ != NULL ? *client_ : *default_instance().client_;
#else
    return client_ != NULL ? *client_ : *default_instance_->client_;
#endif
}
::safe_browsing::ClientInfo* FindThreatMatchesRequest::mutable_client()
{
    set_has_client();
    if (client_ == NULL) {
        client_ = new ::safe_browsing::ClientInfo;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesRequest.client)
    return client_;
}
::safe_browsing::ClientInfo* FindThreatMatchesRequest::release_client()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FindThreatMatchesRequest.client)
    clear_has_client();
    ::safe_browsing::ClientInfo* temp = client_;
    client_ = NULL;
    return temp;
}
void FindThreatMatchesRequest::set_allocated_client(::safe_browsing::ClientInfo* client)
{
    delete client_;
    client_ = client;
    if (client) {
        set_has_client();
    } else {
        clear_has_client();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindThreatMatchesRequest.client)
}

// optional .safe_browsing.ThreatInfo threat_info = 2;
bool FindThreatMatchesRequest::has_threat_info() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void FindThreatMatchesRequest::set_has_threat_info()
{
    _has_bits_[0] |= 0x00000002u;
}
void FindThreatMatchesRequest::clear_has_threat_info()
{
    _has_bits_[0] &= ~0x00000002u;
}
void FindThreatMatchesRequest::clear_threat_info()
{
    if (threat_info_ != NULL)
        threat_info_->::safe_browsing::ThreatInfo::Clear();
    clear_has_threat_info();
}
const ::safe_browsing::ThreatInfo& FindThreatMatchesRequest::threat_info() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesRequest.threat_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return threat_info_ != NULL ? *threat_info_ : *default_instance().threat_info_;
#else
    return threat_info_ != NULL ? *threat_info_ : *default_instance_->threat_info_;
#endif
}
::safe_browsing::ThreatInfo* FindThreatMatchesRequest::mutable_threat_info()
{
    set_has_threat_info();
    if (threat_info_ == NULL) {
        threat_info_ = new ::safe_browsing::ThreatInfo;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesRequest.threat_info)
    return threat_info_;
}
::safe_browsing::ThreatInfo* FindThreatMatchesRequest::release_threat_info()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FindThreatMatchesRequest.threat_info)
    clear_has_threat_info();
    ::safe_browsing::ThreatInfo* temp = threat_info_;
    threat_info_ = NULL;
    return temp;
}
void FindThreatMatchesRequest::set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info)
{
    delete threat_info_;
    threat_info_ = threat_info;
    if (threat_info) {
        set_has_threat_info();
    } else {
        clear_has_threat_info();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindThreatMatchesRequest.threat_info)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindThreatMatchesResponse(
    FindThreatMatchesResponse* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindThreatMatchesResponse::kMatchesFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FindThreatMatchesResponse::FindThreatMatchesResponse()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FindThreatMatchesResponse)
}

void FindThreatMatchesResponse::InitAsDefaultInstance()
{
}

FindThreatMatchesResponse::FindThreatMatchesResponse(const FindThreatMatchesResponse& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FindThreatMatchesResponse)
}

void FindThreatMatchesResponse::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindThreatMatchesResponse::~FindThreatMatchesResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FindThreatMatchesResponse)
    SharedDtor();
}

void FindThreatMatchesResponse::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void FindThreatMatchesResponse::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindThreatMatchesResponse& FindThreatMatchesResponse::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FindThreatMatchesResponse* FindThreatMatchesResponse::default_instance_ = NULL;

FindThreatMatchesResponse* FindThreatMatchesResponse::New(::google::protobuf::Arena* arena) const
{
    FindThreatMatchesResponse* n = new FindThreatMatchesResponse;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FindThreatMatchesResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.FindThreatMatchesResponse)
    matches_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindThreatMatchesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFindThreatMatchesResponse, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FindThreatMatchesResponse)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // repeated .safe_browsing.ThreatMatch matches = 1;
        case 1: {
            if (tag == 10) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_matches:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_matches()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(10))
                goto parse_loop_matches;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FindThreatMatchesResponse)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FindThreatMatchesResponse)
    return false;
#undef DO_
}

void FindThreatMatchesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FindThreatMatchesResponse)
    // repeated .safe_browsing.ThreatMatch matches = 1;
    for (unsigned int i = 0, n = this->matches_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->matches(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FindThreatMatchesResponse)
}

int FindThreatMatchesResponse::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindThreatMatchesResponse)
    int total_size = 0;

    // repeated .safe_browsing.ThreatMatch matches = 1;
    total_size += 1 * this->matches_size();
    for (int i = 0; i < this->matches_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->matches(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FindThreatMatchesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FindThreatMatchesResponse*>(&from));
}

void FindThreatMatchesResponse::MergeFrom(const FindThreatMatchesResponse& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindThreatMatchesResponse)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    matches_.MergeFrom(from.matches_);
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FindThreatMatchesResponse::CopyFrom(const FindThreatMatchesResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindThreatMatchesResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FindThreatMatchesResponse::IsInitialized() const
{

    return true;
}

void FindThreatMatchesResponse::Swap(FindThreatMatchesResponse* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FindThreatMatchesResponse::InternalSwap(FindThreatMatchesResponse* other)
{
    matches_.UnsafeArenaSwap(&other->matches_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindThreatMatchesResponse::GetTypeName() const
{
    return "safe_browsing.FindThreatMatchesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindThreatMatchesResponse

// repeated .safe_browsing.ThreatMatch matches = 1;
int FindThreatMatchesResponse::matches_size() const
{
    return matches_.size();
}
void FindThreatMatchesResponse::clear_matches()
{
    matches_.Clear();
}
const ::safe_browsing::ThreatMatch& FindThreatMatchesResponse::matches(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesResponse.matches)
    return matches_.Get(index);
}
::safe_browsing::ThreatMatch* FindThreatMatchesResponse::mutable_matches(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesResponse.matches)
    return matches_.Mutable(index);
}
::safe_browsing::ThreatMatch* FindThreatMatchesResponse::add_matches()
{
    // @@protoc_insertion_point(field_add:safe_browsing.FindThreatMatchesResponse.matches)
    return matches_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatMatch>*
FindThreatMatchesResponse::mutable_matches()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindThreatMatchesResponse.matches)
    return &matches_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatMatch>&
FindThreatMatchesResponse::matches() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FindThreatMatchesResponse.matches)
    return matches_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFetchThreatListUpdatesRequest(
    FetchThreatListUpdatesRequest* ptr)
{
    return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForFetchThreatListUpdatesRequest_ListUpdateRequest(
    FetchThreatListUpdatesRequest_ListUpdateRequest* ptr)
{
    return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForFetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(
    FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kMaxUpdateEntriesFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kMaxDatabaseEntriesFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kRegionFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::kSupportedCompressionsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InitAsDefaultInstance()
{
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    max_update_entries_ = 0;
    max_database_entries_ = 0;
    region_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    SharedDtor();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    region_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance_ = NULL;

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::New(::google::protobuf::Arena* arena) const
{
    FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* n = new FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                                                                 \
    _Pragma("clang diagnostic push")                                                                                                                  \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 7u) {
        ZR_(max_update_entries_, max_database_entries_);
        if (has_region()) {
            region_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }

#undef ZR_HELPER_
#undef ZR_

    supported_compressions_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFetchThreatListUpdatesRequest_ListUpdateRequest_Constraints, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional int32 max_update_entries = 1;
        case 1: {
            if (tag == 8) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &max_update_entries_)));
                set_has_max_update_entries();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_max_database_entries;
            break;
        }

        // optional int32 max_database_entries = 2;
        case 2: {
            if (tag == 16) {
            parse_max_database_entries:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &max_database_entries_)));
                set_has_max_database_entries();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_region;
            break;
        }

        // optional string region = 3;
        case 3: {
            if (tag == 26) {
            parse_region:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_region()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(32))
                goto parse_supported_compressions;
            break;
        }

        // repeated .safe_browsing.CompressionType supported_compressions = 4;
        case 4: {
            if (tag == 32) {
            parse_supported_compressions:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::CompressionType_IsValid(value)) {
                    add_supported_compressions(static_cast<::safe_browsing::CompressionType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(tag);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else if (tag == 34) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                    input,
                    4,
                    ::safe_browsing::CompressionType_IsValid,
                    &unknown_fields_stream,
                    this->mutable_supported_compressions())));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(32))
                goto parse_supported_compressions;
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    return false;
#undef DO_
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    // optional int32 max_update_entries = 1;
    if (has_max_update_entries()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->max_update_entries(), output);
    }

    // optional int32 max_database_entries = 2;
    if (has_max_database_entries()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_database_entries(), output);
    }

    // optional string region = 3;
    if (has_region()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            3, this->region(), output);
    }

    // repeated .safe_browsing.CompressionType supported_compressions = 4;
    for (int i = 0; i < this->supported_compressions_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            4, this->supported_compressions(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 7u) {
        // optional int32 max_update_entries = 1;
        if (has_max_update_entries()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->max_update_entries());
        }

        // optional int32 max_database_entries = 2;
        if (has_max_database_entries()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->max_database_entries());
        }

        // optional string region = 3;
        if (has_region()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->region());
        }
    }
    // repeated .safe_browsing.CompressionType supported_compressions = 4;
    {
        int data_size = 0;
        for (int i = 0; i < this->supported_compressions_size(); i++) {
            data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
                this->supported_compressions(i));
        }
        total_size += 1 * this->supported_compressions_size() + data_size;
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(&from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    supported_compressions_.MergeFrom(from.supported_compressions_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_max_update_entries()) {
            set_max_update_entries(from.max_update_entries());
        }
        if (from.has_max_database_entries()) {
            set_max_database_entries(from.max_database_entries());
        }
        if (from.has_region()) {
            set_has_region();
            region_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.region_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::IsInitialized() const
{

    return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other)
{
    std::swap(max_update_entries_, other->max_update_entries_);
    std::swap(max_database_entries_, other->max_database_entries_);
    region_.Swap(&other->region_);
    supported_compressions_.UnsafeArenaSwap(&other->supported_compressions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::GetTypeName() const
{
    return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints";
}

// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kThreatTypeFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kPlatformTypeFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kThreatEntryTypeFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kStateFieldNumber;
const int FetchThreatListUpdatesRequest_ListUpdateRequest::kConstraintsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    constraints_ = const_cast<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
        ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::internal_default_instance());
#else
    constraints_ = const_cast<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(&::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance());
#endif
}

FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    threat_type_ = 0;
    platform_type_ = 0;
    threat_entry_type_ = 0;
    state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    constraints_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest::~FetchThreatListUpdatesRequest_ListUpdateRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    SharedDtor();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete constraints_;
    }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest_ListUpdateRequest::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest_ListUpdateRequest::default_instance_ = NULL;

FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest_ListUpdateRequest::New(::google::protobuf::Arena* arena) const
{
    FetchThreatListUpdatesRequest_ListUpdateRequest* n = new FetchThreatListUpdatesRequest_ListUpdateRequest;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                                                     \
    _Pragma("clang diagnostic push")                                                                                                      \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(FetchThreatListUpdatesRequest_ListUpdateRequest, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<FetchThreatListUpdatesRequest_ListUpdateRequest*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 31u) {
        ZR_(threat_type_, platform_type_);
        threat_entry_type_ = 0;
        if (has_state()) {
            state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_constraints()) {
            if (constraints_ != NULL)
                constraints_->::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear();
        }
    }

#undef ZR_HELPER_
#undef ZR_

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFetchThreatListUpdatesRequest_ListUpdateRequest, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        case 1: {
            if (tag == 8) {
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatType_IsValid(value)) {
                    set_threat_type(static_cast<::safe_browsing::ThreatType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(8);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_platform_type;
            break;
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        case 2: {
            if (tag == 16) {
            parse_platform_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::PlatformType_IsValid(value)) {
                    set_platform_type(static_cast<::safe_browsing::PlatformType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(16);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_state;
            break;
        }

        // optional bytes state = 3;
        case 3: {
            if (tag == 26) {
            parse_state:
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_state()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_constraints;
            break;
        }

        // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
        case 4: {
            if (tag == 34) {
            parse_constraints:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_constraints()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(40))
                goto parse_threat_entry_type;
            break;
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
        case 5: {
            if (tag == 40) {
            parse_threat_entry_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatEntryType_IsValid(value)) {
                    set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(40);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    return false;
#undef DO_
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    // optional .safe_browsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->threat_type(), output);
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->platform_type(), output);
    }

    // optional bytes state = 3;
    if (has_state()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            3, this->state(), output);
    }

    // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
    if (has_constraints()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, *this->constraints_, output);
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
    if (has_threat_entry_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            5, this->threat_entry_type(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

int FetchThreatListUpdatesRequest_ListUpdateRequest::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 31u) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        if (has_threat_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        if (has_platform_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
        if (has_threat_entry_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
        }

        // optional bytes state = 3;
        if (has_state()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->state());
        }

        // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
        if (has_constraints()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->constraints_);
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(&from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_threat_type()) {
            set_threat_type(from.threat_type());
        }
        if (from.has_platform_type()) {
            set_platform_type(from.platform_type());
        }
        if (from.has_threat_entry_type()) {
            set_threat_entry_type(from.threat_entry_type());
        }
        if (from.has_state()) {
            set_has_state();
            state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.state_);
        }
        if (from.has_constraints()) {
            mutable_constraints()->::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(from.constraints());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest::IsInitialized() const
{

    return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::Swap(FetchThreatListUpdatesRequest_ListUpdateRequest* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other)
{
    std::swap(threat_type_, other->threat_type_);
    std::swap(platform_type_, other->platform_type_);
    std::swap(threat_entry_type_, other->threat_entry_type_);
    state_.Swap(&other->state_);
    std::swap(constraints_, other->constraints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesRequest_ListUpdateRequest::GetTypeName() const
{
    return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest";
}

// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesRequest::kClientFieldNumber;
const int FetchThreatListUpdatesRequest::kListUpdateRequestsFieldNumber;
const int FetchThreatListUpdatesRequest::kChromeClientInfoFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FetchThreatListUpdatesRequest)
}

void FetchThreatListUpdatesRequest::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    client_ = const_cast<::safe_browsing::ClientInfo*>(
        ::safe_browsing::ClientInfo::internal_default_instance());
#else
    client_ = const_cast<::safe_browsing::ClientInfo*>(&::safe_browsing::ClientInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    chrome_client_info_ = const_cast<::safe_browsing::ChromeClientInfo*>(
        ::safe_browsing::ChromeClientInfo::internal_default_instance());
#else
    chrome_client_info_ = const_cast<::safe_browsing::ChromeClientInfo*>(&::safe_browsing::ChromeClientInfo::default_instance());
#endif
}

FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesRequest)
}

void FetchThreatListUpdatesRequest::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    client_ = NULL;
    chrome_client_info_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FetchThreatListUpdatesRequest::~FetchThreatListUpdatesRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesRequest)
    SharedDtor();
}

void FetchThreatListUpdatesRequest::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete client_;
        delete chrome_client_info_;
    }
}

void FetchThreatListUpdatesRequest::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesRequest& FetchThreatListUpdatesRequest::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FetchThreatListUpdatesRequest* FetchThreatListUpdatesRequest::default_instance_ = NULL;

FetchThreatListUpdatesRequest* FetchThreatListUpdatesRequest::New(::google::protobuf::Arena* arena) const
{
    FetchThreatListUpdatesRequest* n = new FetchThreatListUpdatesRequest;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FetchThreatListUpdatesRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesRequest)
    if (_has_bits_[0 / 32] & 5u) {
        if (has_client()) {
            if (client_ != NULL)
                client_->::safe_browsing::ClientInfo::Clear();
        }
        if (has_chrome_client_info()) {
            if (chrome_client_info_ != NULL)
                chrome_client_info_->::safe_browsing::ChromeClientInfo::Clear();
        }
    }
    list_update_requests_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FetchThreatListUpdatesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFetchThreatListUpdatesRequest, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FetchThreatListUpdatesRequest)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ClientInfo client = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_client()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_list_update_requests;
            break;
        }

        // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
        case 3: {
            if (tag == 26) {
            parse_list_update_requests:
                DO_(input->IncrementRecursionDepth());
            parse_loop_list_update_requests:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_list_update_requests()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_loop_list_update_requests;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectTag(34))
                goto parse_chrome_client_info;
            break;
        }

        // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
        case 4: {
            if (tag == 34) {
            parse_chrome_client_info:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_chrome_client_info()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FetchThreatListUpdatesRequest)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FetchThreatListUpdatesRequest)
    return false;
#undef DO_
}

void FetchThreatListUpdatesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FetchThreatListUpdatesRequest)
    // optional .safe_browsing.ClientInfo client = 1;
    if (has_client()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->client_, output);
    }

    // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
    for (unsigned int i = 0, n = this->list_update_requests_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->list_update_requests(i), output);
    }

    // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
    if (has_chrome_client_info()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, *this->chrome_client_info_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FetchThreatListUpdatesRequest)
}

int FetchThreatListUpdatesRequest::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesRequest)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 5u) {
        // optional .safe_browsing.ClientInfo client = 1;
        if (has_client()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->client_);
        }

        // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
        if (has_chrome_client_info()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->chrome_client_info_);
        }
    }
    // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
    total_size += 1 * this->list_update_requests_size();
    for (int i = 0; i < this->list_update_requests_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->list_update_requests(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FetchThreatListUpdatesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesRequest*>(&from));
}

void FetchThreatListUpdatesRequest::MergeFrom(const FetchThreatListUpdatesRequest& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesRequest)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    list_update_requests_.MergeFrom(from.list_update_requests_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_client()) {
            mutable_client()->::safe_browsing::ClientInfo::MergeFrom(from.client());
        }
        if (from.has_chrome_client_info()) {
            mutable_chrome_client_info()->::safe_browsing::ChromeClientInfo::MergeFrom(from.chrome_client_info());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FetchThreatListUpdatesRequest::CopyFrom(const FetchThreatListUpdatesRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FetchThreatListUpdatesRequest::IsInitialized() const
{

    return true;
}

void FetchThreatListUpdatesRequest::Swap(FetchThreatListUpdatesRequest* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FetchThreatListUpdatesRequest::InternalSwap(FetchThreatListUpdatesRequest* other)
{
    std::swap(client_, other->client_);
    list_update_requests_.UnsafeArenaSwap(&other->list_update_requests_);
    std::swap(chrome_client_info_, other->chrome_client_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesRequest::GetTypeName() const
{
    return "safe_browsing.FetchThreatListUpdatesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints

// optional int32 max_update_entries = 1;
bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_update_entries() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_update_entries()
{
    _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_update_entries()
{
    _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_update_entries()
{
    max_update_entries_ = 0;
    clear_has_max_update_entries();
}
::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_update_entries() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
    return max_update_entries_;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_update_entries(::google::protobuf::int32 value)
{
    set_has_max_update_entries();
    max_update_entries_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
}

// optional int32 max_database_entries = 2;
bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_database_entries() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_database_entries()
{
    _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_database_entries()
{
    _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_database_entries()
{
    max_database_entries_ = 0;
    clear_has_max_database_entries();
}
::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_database_entries() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
    return max_database_entries_;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_database_entries(::google::protobuf::int32 value)
{
    set_has_max_database_entries();
    max_database_entries_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
}

// optional string region = 3;
bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_region() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_region()
{
    _has_bits_[0] |= 0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_region()
{
    _has_bits_[0] &= ~0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_region()
{
    region_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_region();
}
const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::region() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
    return region_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const ::std::string& value)
{
    set_has_region();
    region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value)
{
    set_has_region();
    region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value, size_t size)
{
    set_has_region();
    region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_region()
{
    set_has_region();
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
    return region_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::release_region()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
    clear_has_region();
    return region_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_allocated_region(::std::string* region)
{
    if (region != NULL) {
        set_has_region();
    } else {
        clear_has_region();
    }
    region_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}

// repeated .safe_browsing.CompressionType supported_compressions = 4;
int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions_size() const
{
    return supported_compressions_.size();
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_supported_compressions()
{
    supported_compressions_.Clear();
}
::safe_browsing::CompressionType FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
    return static_cast<::safe_browsing::CompressionType>(supported_compressions_.Get(index));
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_supported_compressions(int index, ::safe_browsing::CompressionType value)
{
    assert(::safe_browsing::CompressionType_IsValid(value));
    supported_compressions_.Set(index, value);
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::add_supported_compressions(::safe_browsing::CompressionType value)
{
    assert(::safe_browsing::CompressionType_IsValid(value));
    supported_compressions_.Add(value);
    // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
const ::google::protobuf::RepeatedField<int>&
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
    return supported_compressions_;
}
::google::protobuf::RepeatedField<int>*
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_supported_compressions()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
    return &supported_compressions_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest

// optional .safe_browsing.ThreatType threat_type = 1;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_type()
{
    _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_type()
{
    threat_type_ = 0;
    clear_has_threat_type();
}
::safe_browsing::ThreatType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
    return static_cast<::safe_browsing::ThreatType>(threat_type_);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_type(::safe_browsing::ThreatType value)
{
    assert(::safe_browsing::ThreatType_IsValid(value));
    set_has_threat_type();
    threat_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_platform_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_platform_type()
{
    _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_platform_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_platform_type()
{
    platform_type_ = 0;
    clear_has_platform_type();
}
::safe_browsing::PlatformType FetchThreatListUpdatesRequest_ListUpdateRequest::platform_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
    return static_cast<::safe_browsing::PlatformType>(platform_type_);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_platform_type(::safe_browsing::PlatformType value)
{
    assert(::safe_browsing::PlatformType_IsValid(value));
    set_has_platform_type();
    platform_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_entry_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_entry_type()
{
    _has_bits_[0] |= 0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_entry_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_entry_type()
{
    threat_entry_type_ = 0;
    clear_has_threat_entry_type();
}
::safe_browsing::ThreatEntryType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_entry_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
    return static_cast<::safe_browsing::ThreatEntryType>(threat_entry_type_);
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_entry_type(::safe_browsing::ThreatEntryType value)
{
    assert(::safe_browsing::ThreatEntryType_IsValid(value));
    set_has_threat_entry_type();
    threat_entry_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
}

// optional bytes state = 3;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_state() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_state()
{
    _has_bits_[0] |= 0x00000008u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_state()
{
    _has_bits_[0] &= ~0x00000008u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_state()
{
    state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_state();
}
const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest::state() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
    return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const ::std::string& value)
{
    set_has_state();
    state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const char* value)
{
    set_has_state();
    state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const void* value, size_t size)
{
    set_has_state();
    state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_state()
{
    set_has_state();
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
    return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::release_state()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
    clear_has_state();
    return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_state(::std::string* state)
{
    if (state != NULL) {
        set_has_state();
    } else {
        clear_has_state();
    }
    state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}

// optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_constraints() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_constraints()
{
    _has_bits_[0] |= 0x00000010u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_constraints()
{
    _has_bits_[0] &= ~0x00000010u;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_constraints()
{
    if (constraints_ != NULL)
        constraints_->::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear();
    clear_has_constraints();
}
const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest::constraints() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return constraints_ != NULL ? *constraints_ : *default_instance().constraints_;
#else
    return constraints_ != NULL ? *constraints_ : *default_instance_->constraints_;
#endif
}
::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_constraints()
{
    set_has_constraints();
    if (constraints_ == NULL) {
        constraints_ = new ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
    return constraints_;
}
::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::release_constraints()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
    clear_has_constraints();
    ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* temp = constraints_;
    constraints_ = NULL;
    return temp;
}
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_constraints(::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints)
{
    delete constraints_;
    constraints_ = constraints;
    if (constraints) {
        set_has_constraints();
    } else {
        clear_has_constraints();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest

// optional .safe_browsing.ClientInfo client = 1;
bool FetchThreatListUpdatesRequest::has_client() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesRequest::set_has_client()
{
    _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesRequest::clear_has_client()
{
    _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesRequest::clear_client()
{
    if (client_ != NULL)
        client_->::safe_browsing::ClientInfo::Clear();
    clear_has_client();
}
const ::safe_browsing::ClientInfo& FetchThreatListUpdatesRequest::client() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.client)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return client_ != NULL ? *client_ : *default_instance().client_;
#else
    return client_ != NULL ? *client_ : *default_instance_->client_;
#endif
}
::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::mutable_client()
{
    set_has_client();
    if (client_ == NULL) {
        client_ = new ::safe_browsing::ClientInfo;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.client)
    return client_;
}
::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::release_client()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.client)
    clear_has_client();
    ::safe_browsing::ClientInfo* temp = client_;
    client_ = NULL;
    return temp;
}
void FetchThreatListUpdatesRequest::set_allocated_client(::safe_browsing::ClientInfo* client)
{
    delete client_;
    client_ = client;
    if (client) {
        set_has_client();
    } else {
        clear_has_client();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.client)
}

// repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
int FetchThreatListUpdatesRequest::list_update_requests_size() const
{
    return list_update_requests_.size();
}
void FetchThreatListUpdatesRequest::clear_list_update_requests()
{
    list_update_requests_.Clear();
}
const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest::list_update_requests(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
    return list_update_requests_.Get(index);
}
::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::mutable_list_update_requests(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
    return list_update_requests_.Mutable(index);
}
::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::add_list_update_requests()
{
    // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
    return list_update_requests_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest>*
FetchThreatListUpdatesRequest::mutable_list_update_requests()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
    return &list_update_requests_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest>&
FetchThreatListUpdatesRequest::list_update_requests() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
    return list_update_requests_;
}

// optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
bool FetchThreatListUpdatesRequest::has_chrome_client_info() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void FetchThreatListUpdatesRequest::set_has_chrome_client_info()
{
    _has_bits_[0] |= 0x00000004u;
}
void FetchThreatListUpdatesRequest::clear_has_chrome_client_info()
{
    _has_bits_[0] &= ~0x00000004u;
}
void FetchThreatListUpdatesRequest::clear_chrome_client_info()
{
    if (chrome_client_info_ != NULL)
        chrome_client_info_->::safe_browsing::ChromeClientInfo::Clear();
    clear_has_chrome_client_info();
}
const ::safe_browsing::ChromeClientInfo& FetchThreatListUpdatesRequest::chrome_client_info() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return chrome_client_info_ != NULL ? *chrome_client_info_ : *default_instance().chrome_client_info_;
#else
    return chrome_client_info_ != NULL ? *chrome_client_info_ : *default_instance_->chrome_client_info_;
#endif
}
::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::mutable_chrome_client_info()
{
    set_has_chrome_client_info();
    if (chrome_client_info_ == NULL) {
        chrome_client_info_ = new ::safe_browsing::ChromeClientInfo;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
    return chrome_client_info_;
}
::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::release_chrome_client_info()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
    clear_has_chrome_client_info();
    ::safe_browsing::ChromeClientInfo* temp = chrome_client_info_;
    chrome_client_info_ = NULL;
    return temp;
}
void FetchThreatListUpdatesRequest::set_allocated_chrome_client_info(::safe_browsing::ChromeClientInfo* chrome_client_info)
{
    delete chrome_client_info_;
    chrome_client_info_ = chrome_client_info;
    if (chrome_client_info) {
        set_has_chrome_client_info();
    } else {
        clear_has_chrome_client_info();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFetchThreatListUpdatesResponse(
    FetchThreatListUpdatesResponse* ptr)
{
    return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForFetchThreatListUpdatesResponse_ListUpdateResponse(
    FetchThreatListUpdatesResponse_ListUpdateResponse* ptr)
{
    return ptr->mutable_unknown_fields();
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::RESPONSE_TYPE_UNSPECIFIED;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::PARTIAL_UPDATE;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::FULL_UPDATE;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MIN;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MAX;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kThreatTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kThreatEntryTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kPlatformTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kResponseTypeFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kAdditionsFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kRemovalsFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kNewClientStateFieldNumber;
const int FetchThreatListUpdatesResponse_ListUpdateResponse::kChecksumFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    checksum_ = const_cast<::safe_browsing::Checksum*>(
        ::safe_browsing::Checksum::internal_default_instance());
#else
    checksum_ = const_cast<::safe_browsing::Checksum*>(&::safe_browsing::Checksum::default_instance());
#endif
}

FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    threat_type_ = 0;
    threat_entry_type_ = 0;
    platform_type_ = 0;
    response_type_ = 0;
    new_client_state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    checksum_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FetchThreatListUpdatesResponse_ListUpdateResponse::~FetchThreatListUpdatesResponse_ListUpdateResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    SharedDtor();
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    new_client_state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete checksum_;
    }
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse_ListUpdateResponse::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse_ListUpdateResponse::default_instance_ = NULL;

FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse_ListUpdateResponse::New(::google::protobuf::Arena* arena) const
{
    FetchThreatListUpdatesResponse_ListUpdateResponse* n = new FetchThreatListUpdatesResponse_ListUpdateResponse;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                                                       \
    _Pragma("clang diagnostic push")                                                                                                        \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(FetchThreatListUpdatesResponse_ListUpdateResponse, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<FetchThreatListUpdatesResponse_ListUpdateResponse*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 207u) {
        ZR_(threat_type_, response_type_);
        if (has_new_client_state()) {
            new_client_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_checksum()) {
            if (checksum_ != NULL)
                checksum_->::safe_browsing::Checksum::Clear();
        }
    }

#undef ZR_HELPER_
#undef ZR_

    additions_.Clear();
    removals_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFetchThreatListUpdatesResponse_ListUpdateResponse, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        case 1: {
            if (tag == 8) {
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatType_IsValid(value)) {
                    set_threat_type(static_cast<::safe_browsing::ThreatType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(8);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_threat_entry_type;
            break;
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
        case 2: {
            if (tag == 16) {
            parse_threat_entry_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatEntryType_IsValid(value)) {
                    set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(16);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(24))
                goto parse_platform_type;
            break;
        }

        // optional .safe_browsing.PlatformType platform_type = 3;
        case 3: {
            if (tag == 24) {
            parse_platform_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::PlatformType_IsValid(value)) {
                    set_platform_type(static_cast<::safe_browsing::PlatformType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(24);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(32))
                goto parse_response_type;
            break;
        }

        // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
        case 4: {
            if (tag == 32) {
            parse_response_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value)) {
                    set_response_type(static_cast<::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(32);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(42))
                goto parse_additions;
            break;
        }

        // repeated .safe_browsing.ThreatEntrySet additions = 5;
        case 5: {
            if (tag == 42) {
            parse_additions:
                DO_(input->IncrementRecursionDepth());
            parse_loop_additions:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_additions()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(42))
                goto parse_loop_additions;
            if (input->ExpectTag(50))
                goto parse_loop_removals;
            input->UnsafeDecrementRecursionDepth();
            break;
        }

        // repeated .safe_browsing.ThreatEntrySet removals = 6;
        case 6: {
            if (tag == 50) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_removals:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_removals()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(50))
                goto parse_loop_removals;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectTag(58))
                goto parse_new_client_state;
            break;
        }

        // optional bytes new_client_state = 7;
        case 7: {
            if (tag == 58) {
            parse_new_client_state:
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_new_client_state()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(66))
                goto parse_checksum;
            break;
        }

        // optional .safe_browsing.Checksum checksum = 8;
        case 8: {
            if (tag == 66) {
            parse_checksum:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_checksum()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    return false;
#undef DO_
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    // optional .safe_browsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->threat_type(), output);
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
    if (has_threat_entry_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->threat_entry_type(), output);
    }

    // optional .safe_browsing.PlatformType platform_type = 3;
    if (has_platform_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            3, this->platform_type(), output);
    }

    // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
    if (has_response_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            4, this->response_type(), output);
    }

    // repeated .safe_browsing.ThreatEntrySet additions = 5;
    for (unsigned int i = 0, n = this->additions_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            5, this->additions(i), output);
    }

    // repeated .safe_browsing.ThreatEntrySet removals = 6;
    for (unsigned int i = 0, n = this->removals_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            6, this->removals(i), output);
    }

    // optional bytes new_client_state = 7;
    if (has_new_client_state()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            7, this->new_client_state(), output);
    }

    // optional .safe_browsing.Checksum checksum = 8;
    if (has_checksum()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            8, *this->checksum_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

int FetchThreatListUpdatesResponse_ListUpdateResponse::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 207u) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        if (has_threat_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
        if (has_threat_entry_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
        }

        // optional .safe_browsing.PlatformType platform_type = 3;
        if (has_platform_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
        }

        // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
        if (has_response_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->response_type());
        }

        // optional bytes new_client_state = 7;
        if (has_new_client_state()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->new_client_state());
        }

        // optional .safe_browsing.Checksum checksum = 8;
        if (has_checksum()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->checksum_);
        }
    }
    // repeated .safe_browsing.ThreatEntrySet additions = 5;
    total_size += 1 * this->additions_size();
    for (int i = 0; i < this->additions_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->additions(i));
    }

    // repeated .safe_browsing.ThreatEntrySet removals = 6;
    total_size += 1 * this->removals_size();
    for (int i = 0; i < this->removals_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->removals(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(&from));
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    additions_.MergeFrom(from.additions_);
    removals_.MergeFrom(from.removals_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_threat_type()) {
            set_threat_type(from.threat_type());
        }
        if (from.has_threat_entry_type()) {
            set_threat_entry_type(from.threat_entry_type());
        }
        if (from.has_platform_type()) {
            set_platform_type(from.platform_type());
        }
        if (from.has_response_type()) {
            set_response_type(from.response_type());
        }
        if (from.has_new_client_state()) {
            set_has_new_client_state();
            new_client_state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.new_client_state_);
        }
        if (from.has_checksum()) {
            mutable_checksum()->::safe_browsing::Checksum::MergeFrom(from.checksum());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse::IsInitialized() const
{

    return true;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::Swap(FetchThreatListUpdatesResponse_ListUpdateResponse* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other)
{
    std::swap(threat_type_, other->threat_type_);
    std::swap(threat_entry_type_, other->threat_entry_type_);
    std::swap(platform_type_, other->platform_type_);
    std::swap(response_type_, other->response_type_);
    additions_.UnsafeArenaSwap(&other->additions_);
    removals_.UnsafeArenaSwap(&other->removals_);
    new_client_state_.Swap(&other->new_client_state_);
    std::swap(checksum_, other->checksum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesResponse_ListUpdateResponse::GetTypeName() const
{
    return "safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse";
}

// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FetchThreatListUpdatesResponse::kListUpdateResponsesFieldNumber;
const int FetchThreatListUpdatesResponse::kMinimumWaitDurationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FetchThreatListUpdatesResponse)
}

void FetchThreatListUpdatesResponse::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    minimum_wait_duration_ = const_cast<::safe_browsing::Duration*>(
        ::safe_browsing::Duration::internal_default_instance());
#else
    minimum_wait_duration_ = const_cast<::safe_browsing::Duration*>(&::safe_browsing::Duration::default_instance());
#endif
}

FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesResponse)
}

void FetchThreatListUpdatesResponse::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    minimum_wait_duration_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FetchThreatListUpdatesResponse::~FetchThreatListUpdatesResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesResponse)
    SharedDtor();
}

void FetchThreatListUpdatesResponse::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete minimum_wait_duration_;
    }
}

void FetchThreatListUpdatesResponse::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FetchThreatListUpdatesResponse& FetchThreatListUpdatesResponse::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FetchThreatListUpdatesResponse* FetchThreatListUpdatesResponse::default_instance_ = NULL;

FetchThreatListUpdatesResponse* FetchThreatListUpdatesResponse::New(::google::protobuf::Arena* arena) const
{
    FetchThreatListUpdatesResponse* n = new FetchThreatListUpdatesResponse;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FetchThreatListUpdatesResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesResponse)
    if (has_minimum_wait_duration()) {
        if (minimum_wait_duration_ != NULL)
            minimum_wait_duration_->::safe_browsing::Duration::Clear();
    }
    list_update_responses_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FetchThreatListUpdatesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFetchThreatListUpdatesResponse, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FetchThreatListUpdatesResponse)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
        case 1: {
            if (tag == 10) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_list_update_responses:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_list_update_responses()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(10))
                goto parse_loop_list_update_responses;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectTag(18))
                goto parse_minimum_wait_duration;
            break;
        }

        // optional .safe_browsing.Duration minimum_wait_duration = 2;
        case 2: {
            if (tag == 18) {
            parse_minimum_wait_duration:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_minimum_wait_duration()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FetchThreatListUpdatesResponse)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FetchThreatListUpdatesResponse)
    return false;
#undef DO_
}

void FetchThreatListUpdatesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FetchThreatListUpdatesResponse)
    // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
    for (unsigned int i = 0, n = this->list_update_responses_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->list_update_responses(i), output);
    }

    // optional .safe_browsing.Duration minimum_wait_duration = 2;
    if (has_minimum_wait_duration()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, *this->minimum_wait_duration_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FetchThreatListUpdatesResponse)
}

int FetchThreatListUpdatesResponse::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesResponse)
    int total_size = 0;

    // optional .safe_browsing.Duration minimum_wait_duration = 2;
    if (has_minimum_wait_duration()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->minimum_wait_duration_);
    }

    // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
    total_size += 1 * this->list_update_responses_size();
    for (int i = 0; i < this->list_update_responses_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->list_update_responses(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FetchThreatListUpdatesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FetchThreatListUpdatesResponse*>(&from));
}

void FetchThreatListUpdatesResponse::MergeFrom(const FetchThreatListUpdatesResponse& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesResponse)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    list_update_responses_.MergeFrom(from.list_update_responses_);
    if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
        if (from.has_minimum_wait_duration()) {
            mutable_minimum_wait_duration()->::safe_browsing::Duration::MergeFrom(from.minimum_wait_duration());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FetchThreatListUpdatesResponse::CopyFrom(const FetchThreatListUpdatesResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FetchThreatListUpdatesResponse::IsInitialized() const
{

    return true;
}

void FetchThreatListUpdatesResponse::Swap(FetchThreatListUpdatesResponse* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FetchThreatListUpdatesResponse::InternalSwap(FetchThreatListUpdatesResponse* other)
{
    list_update_responses_.UnsafeArenaSwap(&other->list_update_responses_);
    std::swap(minimum_wait_duration_, other->minimum_wait_duration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FetchThreatListUpdatesResponse::GetTypeName() const
{
    return "safe_browsing.FetchThreatListUpdatesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FetchThreatListUpdatesResponse_ListUpdateResponse

// optional .safe_browsing.ThreatType threat_type = 1;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_type()
{
    _has_bits_[0] |= 0x00000001u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_type()
{
    threat_type_ = 0;
    clear_has_threat_type();
}
::safe_browsing::ThreatType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
    return static_cast<::safe_browsing::ThreatType>(threat_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_type(::safe_browsing::ThreatType value)
{
    assert(::safe_browsing::ThreatType_IsValid(value));
    set_has_threat_type();
    threat_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_entry_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_entry_type()
{
    _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_entry_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_entry_type()
{
    threat_entry_type_ = 0;
    clear_has_threat_entry_type();
}
::safe_browsing::ThreatEntryType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_entry_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
    return static_cast<::safe_browsing::ThreatEntryType>(threat_entry_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_entry_type(::safe_browsing::ThreatEntryType value)
{
    assert(::safe_browsing::ThreatEntryType_IsValid(value));
    set_has_threat_entry_type();
    threat_entry_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
}

// optional .safe_browsing.PlatformType platform_type = 3;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_platform_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_platform_type()
{
    _has_bits_[0] |= 0x00000004u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_platform_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_platform_type()
{
    platform_type_ = 0;
    clear_has_platform_type();
}
::safe_browsing::PlatformType FetchThreatListUpdatesResponse_ListUpdateResponse::platform_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
    return static_cast<::safe_browsing::PlatformType>(platform_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_platform_type(::safe_browsing::PlatformType value)
{
    assert(::safe_browsing::PlatformType_IsValid(value));
    set_has_platform_type();
    platform_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
}

// optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_response_type() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_response_type()
{
    _has_bits_[0] |= 0x00000008u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_response_type()
{
    _has_bits_[0] &= ~0x00000008u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_response_type()
{
    response_type_ = 0;
    clear_has_response_type();
}
::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::response_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
    return static_cast<::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(response_type_);
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_response_type(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value)
{
    assert(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value));
    set_has_response_type();
    response_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
}

// repeated .safe_browsing.ThreatEntrySet additions = 5;
int FetchThreatListUpdatesResponse_ListUpdateResponse::additions_size() const
{
    return additions_.size();
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_additions()
{
    additions_.Clear();
}
const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::additions(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
    return additions_.Get(index);
}
::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
    return additions_.Mutable(index);
}
::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_additions()
{
    // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
    return additions_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntrySet>*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
    return &additions_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntrySet>&
FetchThreatListUpdatesResponse_ListUpdateResponse::additions() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
    return additions_;
}

// repeated .safe_browsing.ThreatEntrySet removals = 6;
int FetchThreatListUpdatesResponse_ListUpdateResponse::removals_size() const
{
    return removals_.size();
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_removals()
{
    removals_.Clear();
}
const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::removals(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
    return removals_.Get(index);
}
::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
    return removals_.Mutable(index);
}
::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_removals()
{
    // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
    return removals_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntrySet>*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
    return &removals_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntrySet>&
FetchThreatListUpdatesResponse_ListUpdateResponse::removals() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
    return removals_;
}

// optional bytes new_client_state = 7;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_new_client_state() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_new_client_state()
{
    _has_bits_[0] |= 0x00000040u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_new_client_state()
{
    _has_bits_[0] &= ~0x00000040u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_new_client_state()
{
    new_client_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_client_state();
}
const ::std::string& FetchThreatListUpdatesResponse_ListUpdateResponse::new_client_state() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
    return new_client_state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const ::std::string& value)
{
    set_has_new_client_state();
    new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const char* value)
{
    set_has_new_client_state();
    new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const void* value, size_t size)
{
    set_has_new_client_state();
    new_client_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_new_client_state()
{
    set_has_new_client_state();
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
    return new_client_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::release_new_client_state()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
    clear_has_new_client_state();
    return new_client_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_new_client_state(::std::string* new_client_state)
{
    if (new_client_state != NULL) {
        set_has_new_client_state();
    } else {
        clear_has_new_client_state();
    }
    new_client_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_client_state);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}

// optional .safe_browsing.Checksum checksum = 8;
bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_checksum() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_checksum()
{
    _has_bits_[0] |= 0x00000080u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_checksum()
{
    _has_bits_[0] &= ~0x00000080u;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_checksum()
{
    if (checksum_ != NULL)
        checksum_->::safe_browsing::Checksum::Clear();
    clear_has_checksum();
}
const ::safe_browsing::Checksum& FetchThreatListUpdatesResponse_ListUpdateResponse::checksum() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return checksum_ != NULL ? *checksum_ : *default_instance().checksum_;
#else
    return checksum_ != NULL ? *checksum_ : *default_instance_->checksum_;
#endif
}
::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_checksum()
{
    set_has_checksum();
    if (checksum_ == NULL) {
        checksum_ = new ::safe_browsing::Checksum;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
    return checksum_;
}
::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::release_checksum()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
    clear_has_checksum();
    ::safe_browsing::Checksum* temp = checksum_;
    checksum_ = NULL;
    return temp;
}
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_checksum(::safe_browsing::Checksum* checksum)
{
    delete checksum_;
    checksum_ = checksum;
    if (checksum) {
        set_has_checksum();
    } else {
        clear_has_checksum();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse

// repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
int FetchThreatListUpdatesResponse::list_update_responses_size() const
{
    return list_update_responses_.size();
}
void FetchThreatListUpdatesResponse::clear_list_update_responses()
{
    list_update_responses_.Clear();
}
const ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse::list_update_responses(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
    return list_update_responses_.Get(index);
}
::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::mutable_list_update_responses(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
    return list_update_responses_.Mutable(index);
}
::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::add_list_update_responses()
{
    // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
    return list_update_responses_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse>*
FetchThreatListUpdatesResponse::mutable_list_update_responses()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
    return &list_update_responses_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse>&
FetchThreatListUpdatesResponse::list_update_responses() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
    return list_update_responses_;
}

// optional .safe_browsing.Duration minimum_wait_duration = 2;
bool FetchThreatListUpdatesResponse::has_minimum_wait_duration() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void FetchThreatListUpdatesResponse::set_has_minimum_wait_duration()
{
    _has_bits_[0] |= 0x00000002u;
}
void FetchThreatListUpdatesResponse::clear_has_minimum_wait_duration()
{
    _has_bits_[0] &= ~0x00000002u;
}
void FetchThreatListUpdatesResponse::clear_minimum_wait_duration()
{
    if (minimum_wait_duration_ != NULL)
        minimum_wait_duration_->::safe_browsing::Duration::Clear();
    clear_has_minimum_wait_duration();
}
const ::safe_browsing::Duration& FetchThreatListUpdatesResponse::minimum_wait_duration() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance().minimum_wait_duration_;
#else
    return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance_->minimum_wait_duration_;
#endif
}
::safe_browsing::Duration* FetchThreatListUpdatesResponse::mutable_minimum_wait_duration()
{
    set_has_minimum_wait_duration();
    if (minimum_wait_duration_ == NULL) {
        minimum_wait_duration_ = new ::safe_browsing::Duration;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
    return minimum_wait_duration_;
}
::safe_browsing::Duration* FetchThreatListUpdatesResponse::release_minimum_wait_duration()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
    clear_has_minimum_wait_duration();
    ::safe_browsing::Duration* temp = minimum_wait_duration_;
    minimum_wait_duration_ = NULL;
    return temp;
}
void FetchThreatListUpdatesResponse::set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration)
{
    delete minimum_wait_duration_;
    minimum_wait_duration_ = minimum_wait_duration;
    if (minimum_wait_duration) {
        set_has_minimum_wait_duration();
    } else {
        clear_has_minimum_wait_duration();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindFullHashesRequest(
    FindFullHashesRequest* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindFullHashesRequest::kClientFieldNumber;
const int FindFullHashesRequest::kClientStatesFieldNumber;
const int FindFullHashesRequest::kThreatInfoFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FindFullHashesRequest::FindFullHashesRequest()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FindFullHashesRequest)
}

void FindFullHashesRequest::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    client_ = const_cast<::safe_browsing::ClientInfo*>(
        ::safe_browsing::ClientInfo::internal_default_instance());
#else
    client_ = const_cast<::safe_browsing::ClientInfo*>(&::safe_browsing::ClientInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    threat_info_ = const_cast<::safe_browsing::ThreatInfo*>(
        ::safe_browsing::ThreatInfo::internal_default_instance());
#else
    threat_info_ = const_cast<::safe_browsing::ThreatInfo*>(&::safe_browsing::ThreatInfo::default_instance());
#endif
}

FindFullHashesRequest::FindFullHashesRequest(const FindFullHashesRequest& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FindFullHashesRequest)
}

void FindFullHashesRequest::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    client_ = NULL;
    threat_info_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindFullHashesRequest::~FindFullHashesRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FindFullHashesRequest)
    SharedDtor();
}

void FindFullHashesRequest::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete client_;
        delete threat_info_;
    }
}

void FindFullHashesRequest::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindFullHashesRequest& FindFullHashesRequest::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FindFullHashesRequest* FindFullHashesRequest::default_instance_ = NULL;

FindFullHashesRequest* FindFullHashesRequest::New(::google::protobuf::Arena* arena) const
{
    FindFullHashesRequest* n = new FindFullHashesRequest;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FindFullHashesRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.FindFullHashesRequest)
    if (_has_bits_[0 / 32] & 5u) {
        if (has_client()) {
            if (client_ != NULL)
                client_->::safe_browsing::ClientInfo::Clear();
        }
        if (has_threat_info()) {
            if (threat_info_ != NULL)
                threat_info_->::safe_browsing::ThreatInfo::Clear();
        }
    }
    client_states_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindFullHashesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFindFullHashesRequest, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FindFullHashesRequest)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ClientInfo client = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_client()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_client_states;
            break;
        }

        // repeated bytes client_states = 2;
        case 2: {
            if (tag == 18) {
            parse_client_states:
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->add_client_states()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_client_states;
            if (input->ExpectTag(26))
                goto parse_threat_info;
            break;
        }

        // optional .safe_browsing.ThreatInfo threat_info = 3;
        case 3: {
            if (tag == 26) {
            parse_threat_info:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_threat_info()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FindFullHashesRequest)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FindFullHashesRequest)
    return false;
#undef DO_
}

void FindFullHashesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FindFullHashesRequest)
    // optional .safe_browsing.ClientInfo client = 1;
    if (has_client()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *this->client_, output);
    }

    // repeated bytes client_states = 2;
    for (int i = 0; i < this->client_states_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->client_states(i), output);
    }

    // optional .safe_browsing.ThreatInfo threat_info = 3;
    if (has_threat_info()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, *this->threat_info_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FindFullHashesRequest)
}

int FindFullHashesRequest::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindFullHashesRequest)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 5u) {
        // optional .safe_browsing.ClientInfo client = 1;
        if (has_client()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->client_);
        }

        // optional .safe_browsing.ThreatInfo threat_info = 3;
        if (has_threat_info()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->threat_info_);
        }
    }
    // repeated bytes client_states = 2;
    total_size += 1 * this->client_states_size();
    for (int i = 0; i < this->client_states_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
            this->client_states(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FindFullHashesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FindFullHashesRequest*>(&from));
}

void FindFullHashesRequest::MergeFrom(const FindFullHashesRequest& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindFullHashesRequest)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    client_states_.MergeFrom(from.client_states_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_client()) {
            mutable_client()->::safe_browsing::ClientInfo::MergeFrom(from.client());
        }
        if (from.has_threat_info()) {
            mutable_threat_info()->::safe_browsing::ThreatInfo::MergeFrom(from.threat_info());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FindFullHashesRequest::CopyFrom(const FindFullHashesRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindFullHashesRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FindFullHashesRequest::IsInitialized() const
{

    return true;
}

void FindFullHashesRequest::Swap(FindFullHashesRequest* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FindFullHashesRequest::InternalSwap(FindFullHashesRequest* other)
{
    std::swap(client_, other->client_);
    client_states_.UnsafeArenaSwap(&other->client_states_);
    std::swap(threat_info_, other->threat_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindFullHashesRequest::GetTypeName() const
{
    return "safe_browsing.FindFullHashesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindFullHashesRequest

// optional .safe_browsing.ClientInfo client = 1;
bool FindFullHashesRequest::has_client() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindFullHashesRequest::set_has_client()
{
    _has_bits_[0] |= 0x00000001u;
}
void FindFullHashesRequest::clear_has_client()
{
    _has_bits_[0] &= ~0x00000001u;
}
void FindFullHashesRequest::clear_client()
{
    if (client_ != NULL)
        client_->::safe_browsing::ClientInfo::Clear();
    clear_has_client();
}
const ::safe_browsing::ClientInfo& FindFullHashesRequest::client() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.client)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return client_ != NULL ? *client_ : *default_instance().client_;
#else
    return client_ != NULL ? *client_ : *default_instance_->client_;
#endif
}
::safe_browsing::ClientInfo* FindFullHashesRequest::mutable_client()
{
    set_has_client();
    if (client_ == NULL) {
        client_ = new ::safe_browsing::ClientInfo;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.client)
    return client_;
}
::safe_browsing::ClientInfo* FindFullHashesRequest::release_client()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesRequest.client)
    clear_has_client();
    ::safe_browsing::ClientInfo* temp = client_;
    client_ = NULL;
    return temp;
}
void FindFullHashesRequest::set_allocated_client(::safe_browsing::ClientInfo* client)
{
    delete client_;
    client_ = client;
    if (client) {
        set_has_client();
    } else {
        clear_has_client();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesRequest.client)
}

// repeated bytes client_states = 2;
int FindFullHashesRequest::client_states_size() const
{
    return client_states_.size();
}
void FindFullHashesRequest::clear_client_states()
{
    client_states_.Clear();
}
const ::std::string& FindFullHashesRequest::client_states(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.client_states)
    return client_states_.Get(index);
}
::std::string* FindFullHashesRequest::mutable_client_states(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.client_states)
    return client_states_.Mutable(index);
}
void FindFullHashesRequest::set_client_states(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:safe_browsing.FindFullHashesRequest.client_states)
    client_states_.Mutable(index)->assign(value);
}
void FindFullHashesRequest::set_client_states(int index, const char* value)
{
    client_states_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:safe_browsing.FindFullHashesRequest.client_states)
}
void FindFullHashesRequest::set_client_states(int index, const void* value, size_t size)
{
    client_states_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.FindFullHashesRequest.client_states)
}
::std::string* FindFullHashesRequest::add_client_states()
{
    // @@protoc_insertion_point(field_add_mutable:safe_browsing.FindFullHashesRequest.client_states)
    return client_states_.Add();
}
void FindFullHashesRequest::add_client_states(const ::std::string& value)
{
    client_states_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesRequest.client_states)
}
void FindFullHashesRequest::add_client_states(const char* value)
{
    client_states_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:safe_browsing.FindFullHashesRequest.client_states)
}
void FindFullHashesRequest::add_client_states(const void* value, size_t size)
{
    client_states_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:safe_browsing.FindFullHashesRequest.client_states)
}
const ::google::protobuf::RepeatedPtrField<::std::string>&
FindFullHashesRequest::client_states() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FindFullHashesRequest.client_states)
    return client_states_;
}
::google::protobuf::RepeatedPtrField<::std::string>*
FindFullHashesRequest::mutable_client_states()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindFullHashesRequest.client_states)
    return &client_states_;
}

// optional .safe_browsing.ThreatInfo threat_info = 3;
bool FindFullHashesRequest::has_threat_info() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void FindFullHashesRequest::set_has_threat_info()
{
    _has_bits_[0] |= 0x00000004u;
}
void FindFullHashesRequest::clear_has_threat_info()
{
    _has_bits_[0] &= ~0x00000004u;
}
void FindFullHashesRequest::clear_threat_info()
{
    if (threat_info_ != NULL)
        threat_info_->::safe_browsing::ThreatInfo::Clear();
    clear_has_threat_info();
}
const ::safe_browsing::ThreatInfo& FindFullHashesRequest::threat_info() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.threat_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return threat_info_ != NULL ? *threat_info_ : *default_instance().threat_info_;
#else
    return threat_info_ != NULL ? *threat_info_ : *default_instance_->threat_info_;
#endif
}
::safe_browsing::ThreatInfo* FindFullHashesRequest::mutable_threat_info()
{
    set_has_threat_info();
    if (threat_info_ == NULL) {
        threat_info_ = new ::safe_browsing::ThreatInfo;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.threat_info)
    return threat_info_;
}
::safe_browsing::ThreatInfo* FindFullHashesRequest::release_threat_info()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesRequest.threat_info)
    clear_has_threat_info();
    ::safe_browsing::ThreatInfo* temp = threat_info_;
    threat_info_ = NULL;
    return temp;
}
void FindFullHashesRequest::set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info)
{
    delete threat_info_;
    threat_info_ = threat_info;
    if (threat_info) {
        set_has_threat_info();
    } else {
        clear_has_threat_info();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesRequest.threat_info)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindFullHashesResponse(
    FindFullHashesResponse* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindFullHashesResponse::kMatchesFieldNumber;
const int FindFullHashesResponse::kMinimumWaitDurationFieldNumber;
const int FindFullHashesResponse::kNegativeCacheDurationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

FindFullHashesResponse::FindFullHashesResponse()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.FindFullHashesResponse)
}

void FindFullHashesResponse::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    minimum_wait_duration_ = const_cast<::safe_browsing::Duration*>(
        ::safe_browsing::Duration::internal_default_instance());
#else
    minimum_wait_duration_ = const_cast<::safe_browsing::Duration*>(&::safe_browsing::Duration::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    negative_cache_duration_ = const_cast<::safe_browsing::Duration*>(
        ::safe_browsing::Duration::internal_default_instance());
#else
    negative_cache_duration_ = const_cast<::safe_browsing::Duration*>(&::safe_browsing::Duration::default_instance());
#endif
}

FindFullHashesResponse::FindFullHashesResponse(const FindFullHashesResponse& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.FindFullHashesResponse)
}

void FindFullHashesResponse::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    minimum_wait_duration_ = NULL;
    negative_cache_duration_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindFullHashesResponse::~FindFullHashesResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.FindFullHashesResponse)
    SharedDtor();
}

void FindFullHashesResponse::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete minimum_wait_duration_;
        delete negative_cache_duration_;
    }
}

void FindFullHashesResponse::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindFullHashesResponse& FindFullHashesResponse::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

FindFullHashesResponse* FindFullHashesResponse::default_instance_ = NULL;

FindFullHashesResponse* FindFullHashesResponse::New(::google::protobuf::Arena* arena) const
{
    FindFullHashesResponse* n = new FindFullHashesResponse;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void FindFullHashesResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.FindFullHashesResponse)
    if (_has_bits_[0 / 32] & 6u) {
        if (has_minimum_wait_duration()) {
            if (minimum_wait_duration_ != NULL)
                minimum_wait_duration_->::safe_browsing::Duration::Clear();
        }
        if (has_negative_cache_duration()) {
            if (negative_cache_duration_ != NULL)
                negative_cache_duration_->::safe_browsing::Duration::Clear();
        }
    }
    matches_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindFullHashesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForFindFullHashesResponse, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.FindFullHashesResponse)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // repeated .safe_browsing.ThreatMatch matches = 1;
        case 1: {
            if (tag == 10) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_matches:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_matches()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(10))
                goto parse_loop_matches;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectTag(18))
                goto parse_minimum_wait_duration;
            break;
        }

        // optional .safe_browsing.Duration minimum_wait_duration = 2;
        case 2: {
            if (tag == 18) {
            parse_minimum_wait_duration:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_minimum_wait_duration()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_negative_cache_duration;
            break;
        }

        // optional .safe_browsing.Duration negative_cache_duration = 3;
        case 3: {
            if (tag == 26) {
            parse_negative_cache_duration:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_negative_cache_duration()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.FindFullHashesResponse)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.FindFullHashesResponse)
    return false;
#undef DO_
}

void FindFullHashesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.FindFullHashesResponse)
    // repeated .safe_browsing.ThreatMatch matches = 1;
    for (unsigned int i = 0, n = this->matches_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->matches(i), output);
    }

    // optional .safe_browsing.Duration minimum_wait_duration = 2;
    if (has_minimum_wait_duration()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, *this->minimum_wait_duration_, output);
    }

    // optional .safe_browsing.Duration negative_cache_duration = 3;
    if (has_negative_cache_duration()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, *this->negative_cache_duration_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.FindFullHashesResponse)
}

int FindFullHashesResponse::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindFullHashesResponse)
    int total_size = 0;

    if (_has_bits_[1 / 32] & 6u) {
        // optional .safe_browsing.Duration minimum_wait_duration = 2;
        if (has_minimum_wait_duration()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->minimum_wait_duration_);
        }

        // optional .safe_browsing.Duration negative_cache_duration = 3;
        if (has_negative_cache_duration()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->negative_cache_duration_);
        }
    }
    // repeated .safe_browsing.ThreatMatch matches = 1;
    total_size += 1 * this->matches_size();
    for (int i = 0; i < this->matches_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->matches(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void FindFullHashesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const FindFullHashesResponse*>(&from));
}

void FindFullHashesResponse::MergeFrom(const FindFullHashesResponse& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindFullHashesResponse)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    matches_.MergeFrom(from.matches_);
    if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
        if (from.has_minimum_wait_duration()) {
            mutable_minimum_wait_duration()->::safe_browsing::Duration::MergeFrom(from.minimum_wait_duration());
        }
        if (from.has_negative_cache_duration()) {
            mutable_negative_cache_duration()->::safe_browsing::Duration::MergeFrom(from.negative_cache_duration());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void FindFullHashesResponse::CopyFrom(const FindFullHashesResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindFullHashesResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FindFullHashesResponse::IsInitialized() const
{

    return true;
}

void FindFullHashesResponse::Swap(FindFullHashesResponse* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void FindFullHashesResponse::InternalSwap(FindFullHashesResponse* other)
{
    matches_.UnsafeArenaSwap(&other->matches_);
    std::swap(minimum_wait_duration_, other->minimum_wait_duration_);
    std::swap(negative_cache_duration_, other->negative_cache_duration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindFullHashesResponse::GetTypeName() const
{
    return "safe_browsing.FindFullHashesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindFullHashesResponse

// repeated .safe_browsing.ThreatMatch matches = 1;
int FindFullHashesResponse::matches_size() const
{
    return matches_.size();
}
void FindFullHashesResponse::clear_matches()
{
    matches_.Clear();
}
const ::safe_browsing::ThreatMatch& FindFullHashesResponse::matches(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.matches)
    return matches_.Get(index);
}
::safe_browsing::ThreatMatch* FindFullHashesResponse::mutable_matches(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.matches)
    return matches_.Mutable(index);
}
::safe_browsing::ThreatMatch* FindFullHashesResponse::add_matches()
{
    // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesResponse.matches)
    return matches_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatMatch>*
FindFullHashesResponse::mutable_matches()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindFullHashesResponse.matches)
    return &matches_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatMatch>&
FindFullHashesResponse::matches() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.FindFullHashesResponse.matches)
    return matches_;
}

// optional .safe_browsing.Duration minimum_wait_duration = 2;
bool FindFullHashesResponse::has_minimum_wait_duration() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void FindFullHashesResponse::set_has_minimum_wait_duration()
{
    _has_bits_[0] |= 0x00000002u;
}
void FindFullHashesResponse::clear_has_minimum_wait_duration()
{
    _has_bits_[0] &= ~0x00000002u;
}
void FindFullHashesResponse::clear_minimum_wait_duration()
{
    if (minimum_wait_duration_ != NULL)
        minimum_wait_duration_->::safe_browsing::Duration::Clear();
    clear_has_minimum_wait_duration();
}
const ::safe_browsing::Duration& FindFullHashesResponse::minimum_wait_duration() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance().minimum_wait_duration_;
#else
    return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance_->minimum_wait_duration_;
#endif
}
::safe_browsing::Duration* FindFullHashesResponse::mutable_minimum_wait_duration()
{
    set_has_minimum_wait_duration();
    if (minimum_wait_duration_ == NULL) {
        minimum_wait_duration_ = new ::safe_browsing::Duration;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
    return minimum_wait_duration_;
}
::safe_browsing::Duration* FindFullHashesResponse::release_minimum_wait_duration()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
    clear_has_minimum_wait_duration();
    ::safe_browsing::Duration* temp = minimum_wait_duration_;
    minimum_wait_duration_ = NULL;
    return temp;
}
void FindFullHashesResponse::set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration)
{
    delete minimum_wait_duration_;
    minimum_wait_duration_ = minimum_wait_duration;
    if (minimum_wait_duration) {
        set_has_minimum_wait_duration();
    } else {
        clear_has_minimum_wait_duration();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
}

// optional .safe_browsing.Duration negative_cache_duration = 3;
bool FindFullHashesResponse::has_negative_cache_duration() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void FindFullHashesResponse::set_has_negative_cache_duration()
{
    _has_bits_[0] |= 0x00000004u;
}
void FindFullHashesResponse::clear_has_negative_cache_duration()
{
    _has_bits_[0] &= ~0x00000004u;
}
void FindFullHashesResponse::clear_negative_cache_duration()
{
    if (negative_cache_duration_ != NULL)
        negative_cache_duration_->::safe_browsing::Duration::Clear();
    clear_has_negative_cache_duration();
}
const ::safe_browsing::Duration& FindFullHashesResponse::negative_cache_duration() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.negative_cache_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return negative_cache_duration_ != NULL ? *negative_cache_duration_ : *default_instance().negative_cache_duration_;
#else
    return negative_cache_duration_ != NULL ? *negative_cache_duration_ : *default_instance_->negative_cache_duration_;
#endif
}
::safe_browsing::Duration* FindFullHashesResponse::mutable_negative_cache_duration()
{
    set_has_negative_cache_duration();
    if (negative_cache_duration_ == NULL) {
        negative_cache_duration_ = new ::safe_browsing::Duration;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.negative_cache_duration)
    return negative_cache_duration_;
}
::safe_browsing::Duration* FindFullHashesResponse::release_negative_cache_duration()
{
    // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesResponse.negative_cache_duration)
    clear_has_negative_cache_duration();
    ::safe_browsing::Duration* temp = negative_cache_duration_;
    negative_cache_duration_ = NULL;
    return temp;
}
void FindFullHashesResponse::set_allocated_negative_cache_duration(::safe_browsing::Duration* negative_cache_duration)
{
    delete negative_cache_duration_;
    negative_cache_duration_ = negative_cache_duration;
    if (negative_cache_duration) {
        set_has_negative_cache_duration();
    } else {
        clear_has_negative_cache_duration();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesResponse.negative_cache_duration)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreatHit(
    ThreatHit* ptr)
{
    return ptr->mutable_unknown_fields();
}

bool ThreatHit_ThreatSourceType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ThreatHit_ThreatSourceType ThreatHit::THREAT_SOURCE_TYPE_UNSPECIFIED;
const ThreatHit_ThreatSourceType ThreatHit::MATCHING_URL;
const ThreatHit_ThreatSourceType ThreatHit::TAB_URL;
const ThreatHit_ThreatSourceType ThreatHit::TAB_REDIRECT;
const ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MIN;
const ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MAX;
const int ThreatHit::ThreatSourceType_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
static ::std::string* MutableUnknownFieldsForThreatHit_ThreatSource(
    ThreatHit_ThreatSource* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatHit_ThreatSource::kUrlFieldNumber;
const int ThreatHit_ThreatSource::kTypeFieldNumber;
const int ThreatHit_ThreatSource::kRemoteIpFieldNumber;
const int ThreatHit_ThreatSource::kReferrerFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatHit_ThreatSource::ThreatHit_ThreatSource()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatHit.ThreatSource)
}

void ThreatHit_ThreatSource::InitAsDefaultInstance()
{
}

ThreatHit_ThreatSource::ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatHit.ThreatSource)
}

void ThreatHit_ThreatSource::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    url_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    type_ = 0;
    remote_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    referrer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatHit_ThreatSource::~ThreatHit_ThreatSource()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatHit.ThreatSource)
    SharedDtor();
}

void ThreatHit_ThreatSource::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    url_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    remote_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    referrer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ThreatHit_ThreatSource::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatHit_ThreatSource& ThreatHit_ThreatSource::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatHit_ThreatSource* ThreatHit_ThreatSource::default_instance_ = NULL;

ThreatHit_ThreatSource* ThreatHit_ThreatSource::New(::google::protobuf::Arena* arena) const
{
    ThreatHit_ThreatSource* n = new ThreatHit_ThreatSource;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatHit_ThreatSource::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatHit.ThreatSource)
    if (_has_bits_[0 / 32] & 15u) {
        if (has_url()) {
            url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        type_ = 0;
        if (has_remote_ip()) {
            remote_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_referrer()) {
            referrer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatHit_ThreatSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatHit_ThreatSource, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatHit.ThreatSource)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional string url = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_url()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_type;
            break;
        }

        // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
        case 2: {
            if (tag == 16) {
            parse_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatHit_ThreatSourceType_IsValid(value)) {
                    set_type(static_cast<::safe_browsing::ThreatHit_ThreatSourceType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(16);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_remote_ip;
            break;
        }

        // optional string remote_ip = 3;
        case 3: {
            if (tag == 26) {
            parse_remote_ip:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_remote_ip()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_referrer;
            break;
        }

        // optional string referrer = 4;
        case 4: {
            if (tag == 34) {
            parse_referrer:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_referrer()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatHit.ThreatSource)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatHit.ThreatSource)
    return false;
#undef DO_
}

void ThreatHit_ThreatSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatHit.ThreatSource)
    // optional string url = 1;
    if (has_url()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            1, this->url(), output);
    }

    // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->type(), output);
    }

    // optional string remote_ip = 3;
    if (has_remote_ip()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            3, this->remote_ip(), output);
    }

    // optional string referrer = 4;
    if (has_referrer()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            4, this->referrer(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatHit.ThreatSource)
}

int ThreatHit_ThreatSource::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatHit.ThreatSource)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 15u) {
        // optional string url = 1;
        if (has_url()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->url());
        }

        // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
        if (has_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional string remote_ip = 3;
        if (has_remote_ip()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->remote_ip());
        }

        // optional string referrer = 4;
        if (has_referrer()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->referrer());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatHit_ThreatSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatHit_ThreatSource*>(&from));
}

void ThreatHit_ThreatSource::MergeFrom(const ThreatHit_ThreatSource& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatHit.ThreatSource)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_url()) {
            set_has_url();
            url_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.url_);
        }
        if (from.has_type()) {
            set_type(from.type());
        }
        if (from.has_remote_ip()) {
            set_has_remote_ip();
            remote_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.remote_ip_);
        }
        if (from.has_referrer()) {
            set_has_referrer();
            referrer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.referrer_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatHit_ThreatSource::CopyFrom(const ThreatHit_ThreatSource& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatHit.ThreatSource)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatHit_ThreatSource::IsInitialized() const
{

    return true;
}

void ThreatHit_ThreatSource::Swap(ThreatHit_ThreatSource* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatHit_ThreatSource::InternalSwap(ThreatHit_ThreatSource* other)
{
    url_.Swap(&other->url_);
    std::swap(type_, other->type_);
    remote_ip_.Swap(&other->remote_ip_);
    referrer_.Swap(&other->referrer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatHit_ThreatSource::GetTypeName() const
{
    return "safe_browsing.ThreatHit.ThreatSource";
}

// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatHit::kThreatTypeFieldNumber;
const int ThreatHit::kPlatformTypeFieldNumber;
const int ThreatHit::kEntryFieldNumber;
const int ThreatHit::kResourcesFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatHit::ThreatHit()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatHit)
}

void ThreatHit::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    entry_ = const_cast<::safe_browsing::ThreatEntry*>(
        ::safe_browsing::ThreatEntry::internal_default_instance());
#else
    entry_ = const_cast<::safe_browsing::ThreatEntry*>(&::safe_browsing::ThreatEntry::default_instance());
#endif
}

ThreatHit::ThreatHit(const ThreatHit& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatHit)
}

void ThreatHit::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    threat_type_ = 0;
    platform_type_ = 0;
    entry_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatHit::~ThreatHit()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatHit)
    SharedDtor();
}

void ThreatHit::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete entry_;
    }
}

void ThreatHit::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatHit& ThreatHit::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatHit* ThreatHit::default_instance_ = NULL;

ThreatHit* ThreatHit::New(::google::protobuf::Arena* arena) const
{
    ThreatHit* n = new ThreatHit;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatHit::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatHit)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                               \
    _Pragma("clang diagnostic push")                                                                \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ThreatHit, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ThreatHit*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 7u) {
        ZR_(threat_type_, platform_type_);
        if (has_entry()) {
            if (entry_ != NULL)
                entry_->::safe_browsing::ThreatEntry::Clear();
        }
    }

#undef ZR_HELPER_
#undef ZR_

    resources_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatHit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatHit, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatHit)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        case 1: {
            if (tag == 8) {
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatType_IsValid(value)) {
                    set_threat_type(static_cast<::safe_browsing::ThreatType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(8);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_platform_type;
            break;
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        case 2: {
            if (tag == 16) {
            parse_platform_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::PlatformType_IsValid(value)) {
                    set_platform_type(static_cast<::safe_browsing::PlatformType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(16);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_entry;
            break;
        }

        // optional .safe_browsing.ThreatEntry entry = 3;
        case 3: {
            if (tag == 26) {
            parse_entry:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_entry()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_resources;
            break;
        }

        // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
        case 4: {
            if (tag == 34) {
            parse_resources:
                DO_(input->IncrementRecursionDepth());
            parse_loop_resources:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_resources()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_loop_resources;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatHit)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatHit)
    return false;
#undef DO_
}

void ThreatHit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatHit)
    // optional .safe_browsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->threat_type(), output);
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->platform_type(), output);
    }

    // optional .safe_browsing.ThreatEntry entry = 3;
    if (has_entry()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, *this->entry_, output);
    }

    // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
    for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, this->resources(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatHit)
}

int ThreatHit::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatHit)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 7u) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        if (has_threat_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        if (has_platform_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
        }

        // optional .safe_browsing.ThreatEntry entry = 3;
        if (has_entry()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->entry_);
        }
    }
    // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
    total_size += 1 * this->resources_size();
    for (int i = 0; i < this->resources_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->resources(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatHit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatHit*>(&from));
}

void ThreatHit::MergeFrom(const ThreatHit& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatHit)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    resources_.MergeFrom(from.resources_);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_threat_type()) {
            set_threat_type(from.threat_type());
        }
        if (from.has_platform_type()) {
            set_platform_type(from.platform_type());
        }
        if (from.has_entry()) {
            mutable_entry()->::safe_browsing::ThreatEntry::MergeFrom(from.entry());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatHit::CopyFrom(const ThreatHit& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatHit)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatHit::IsInitialized() const
{

    return true;
}

void ThreatHit::Swap(ThreatHit* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatHit::InternalSwap(ThreatHit* other)
{
    std::swap(threat_type_, other->threat_type_);
    std::swap(platform_type_, other->platform_type_);
    std::swap(entry_, other->entry_);
    resources_.UnsafeArenaSwap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatHit::GetTypeName() const
{
    return "safe_browsing.ThreatHit";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatHit_ThreatSource

// optional string url = 1;
bool ThreatHit_ThreatSource::has_url() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatHit_ThreatSource::set_has_url()
{
    _has_bits_[0] |= 0x00000001u;
}
void ThreatHit_ThreatSource::clear_has_url()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ThreatHit_ThreatSource::clear_url()
{
    url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_url();
}
const ::std::string& ThreatHit_ThreatSource::url() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.url)
    return url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_url(const ::std::string& value)
{
    set_has_url();
    url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.url)
}
void ThreatHit_ThreatSource::set_url(const char* value)
{
    set_has_url();
    url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatHit.ThreatSource.url)
}
void ThreatHit_ThreatSource::set_url(const char* value, size_t size)
{
    set_has_url();
    url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatHit.ThreatSource.url)
}
::std::string* ThreatHit_ThreatSource::mutable_url()
{
    set_has_url();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.url)
    return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_ThreatSource::release_url()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.url)
    clear_has_url();
    return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_allocated_url(::std::string* url)
{
    if (url != NULL) {
        set_has_url();
    } else {
        clear_has_url();
    }
    url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.url)
}

// optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
bool ThreatHit_ThreatSource::has_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatHit_ThreatSource::set_has_type()
{
    _has_bits_[0] |= 0x00000002u;
}
void ThreatHit_ThreatSource::clear_has_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ThreatHit_ThreatSource::clear_type()
{
    type_ = 0;
    clear_has_type();
}
::safe_browsing::ThreatHit_ThreatSourceType ThreatHit_ThreatSource::type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.type)
    return static_cast<::safe_browsing::ThreatHit_ThreatSourceType>(type_);
}
void ThreatHit_ThreatSource::set_type(::safe_browsing::ThreatHit_ThreatSourceType value)
{
    assert(::safe_browsing::ThreatHit_ThreatSourceType_IsValid(value));
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.type)
}

// optional string remote_ip = 3;
bool ThreatHit_ThreatSource::has_remote_ip() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatHit_ThreatSource::set_has_remote_ip()
{
    _has_bits_[0] |= 0x00000004u;
}
void ThreatHit_ThreatSource::clear_has_remote_ip()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ThreatHit_ThreatSource::clear_remote_ip()
{
    remote_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_remote_ip();
}
const ::std::string& ThreatHit_ThreatSource::remote_ip() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.remote_ip)
    return remote_ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_remote_ip(const ::std::string& value)
{
    set_has_remote_ip();
    remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
void ThreatHit_ThreatSource::set_remote_ip(const char* value)
{
    set_has_remote_ip();
    remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
void ThreatHit_ThreatSource::set_remote_ip(const char* value, size_t size)
{
    set_has_remote_ip();
    remote_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
::std::string* ThreatHit_ThreatSource::mutable_remote_ip()
{
    set_has_remote_ip();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.remote_ip)
    return remote_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_ThreatSource::release_remote_ip()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.remote_ip)
    clear_has_remote_ip();
    return remote_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_allocated_remote_ip(::std::string* remote_ip)
{
    if (remote_ip != NULL) {
        set_has_remote_ip();
    } else {
        clear_has_remote_ip();
    }
    remote_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_ip);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}

// optional string referrer = 4;
bool ThreatHit_ThreatSource::has_referrer() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void ThreatHit_ThreatSource::set_has_referrer()
{
    _has_bits_[0] |= 0x00000008u;
}
void ThreatHit_ThreatSource::clear_has_referrer()
{
    _has_bits_[0] &= ~0x00000008u;
}
void ThreatHit_ThreatSource::clear_referrer()
{
    referrer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_referrer();
}
const ::std::string& ThreatHit_ThreatSource::referrer() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.referrer)
    return referrer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_referrer(const ::std::string& value)
{
    set_has_referrer();
    referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.referrer)
}
void ThreatHit_ThreatSource::set_referrer(const char* value)
{
    set_has_referrer();
    referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatHit.ThreatSource.referrer)
}
void ThreatHit_ThreatSource::set_referrer(const char* value, size_t size)
{
    set_has_referrer();
    referrer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatHit.ThreatSource.referrer)
}
::std::string* ThreatHit_ThreatSource::mutable_referrer()
{
    set_has_referrer();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.referrer)
    return referrer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatHit_ThreatSource::release_referrer()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.referrer)
    clear_has_referrer();
    return referrer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatHit_ThreatSource::set_allocated_referrer(::std::string* referrer)
{
    if (referrer != NULL) {
        set_has_referrer();
    } else {
        clear_has_referrer();
    }
    referrer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), referrer);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.referrer)
}

// -------------------------------------------------------------------

// ThreatHit

// optional .safe_browsing.ThreatType threat_type = 1;
bool ThreatHit::has_threat_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatHit::set_has_threat_type()
{
    _has_bits_[0] |= 0x00000001u;
}
void ThreatHit::clear_has_threat_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ThreatHit::clear_threat_type()
{
    threat_type_ = 0;
    clear_has_threat_type();
}
::safe_browsing::ThreatType ThreatHit::threat_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.threat_type)
    return static_cast<::safe_browsing::ThreatType>(threat_type_);
}
void ThreatHit::set_threat_type(::safe_browsing::ThreatType value)
{
    assert(::safe_browsing::ThreatType_IsValid(value));
    set_has_threat_type();
    threat_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
bool ThreatHit::has_platform_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatHit::set_has_platform_type()
{
    _has_bits_[0] |= 0x00000002u;
}
void ThreatHit::clear_has_platform_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ThreatHit::clear_platform_type()
{
    platform_type_ = 0;
    clear_has_platform_type();
}
::safe_browsing::PlatformType ThreatHit::platform_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.platform_type)
    return static_cast<::safe_browsing::PlatformType>(platform_type_);
}
void ThreatHit::set_platform_type(::safe_browsing::PlatformType value)
{
    assert(::safe_browsing::PlatformType_IsValid(value));
    set_has_platform_type();
    platform_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.platform_type)
}

// optional .safe_browsing.ThreatEntry entry = 3;
bool ThreatHit::has_entry() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatHit::set_has_entry()
{
    _has_bits_[0] |= 0x00000004u;
}
void ThreatHit::clear_has_entry()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ThreatHit::clear_entry()
{
    if (entry_ != NULL)
        entry_->::safe_browsing::ThreatEntry::Clear();
    clear_has_entry();
}
const ::safe_browsing::ThreatEntry& ThreatHit::entry() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.entry)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return entry_ != NULL ? *entry_ : *default_instance().entry_;
#else
    return entry_ != NULL ? *entry_ : *default_instance_->entry_;
#endif
}
::safe_browsing::ThreatEntry* ThreatHit::mutable_entry()
{
    set_has_entry();
    if (entry_ == NULL) {
        entry_ = new ::safe_browsing::ThreatEntry;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.entry)
    return entry_;
}
::safe_browsing::ThreatEntry* ThreatHit::release_entry()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.entry)
    clear_has_entry();
    ::safe_browsing::ThreatEntry* temp = entry_;
    entry_ = NULL;
    return temp;
}
void ThreatHit::set_allocated_entry(::safe_browsing::ThreatEntry* entry)
{
    delete entry_;
    entry_ = entry;
    if (entry) {
        set_has_entry();
    } else {
        clear_has_entry();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.entry)
}

// repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
int ThreatHit::resources_size() const
{
    return resources_.size();
}
void ThreatHit::clear_resources()
{
    resources_.Clear();
}
const ::safe_browsing::ThreatHit_ThreatSource& ThreatHit::resources(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.resources)
    return resources_.Get(index);
}
::safe_browsing::ThreatHit_ThreatSource* ThreatHit::mutable_resources(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.resources)
    return resources_.Mutable(index);
}
::safe_browsing::ThreatHit_ThreatSource* ThreatHit::add_resources()
{
    // @@protoc_insertion_point(field_add:safe_browsing.ThreatHit.resources)
    return resources_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatHit_ThreatSource>*
ThreatHit::mutable_resources()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatHit.resources)
    return &resources_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatHit_ThreatSource>&
ThreatHit::resources() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.ThreatHit.resources)
    return resources_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForClientInfo(
    ClientInfo* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientInfo::kClientIdFieldNumber;
const int ClientInfo::kClientVersionFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientInfo::ClientInfo()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ClientInfo)
}

void ClientInfo::InitAsDefaultInstance()
{
}

ClientInfo::ClientInfo(const ClientInfo& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientInfo)
}

void ClientInfo::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    client_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientInfo::~ClientInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientInfo)
    SharedDtor();
}

void ClientInfo::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    client_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ClientInfo::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientInfo& ClientInfo::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ClientInfo* ClientInfo::default_instance_ = NULL;

ClientInfo* ClientInfo::New(::google::protobuf::Arena* arena) const
{
    ClientInfo* n = new ClientInfo;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ClientInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientInfo)
    if (_has_bits_[0 / 32] & 3u) {
        if (has_client_id()) {
            client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_client_version()) {
            client_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ClientInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForClientInfo, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ClientInfo)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional string client_id = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_client_id()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_client_version;
            break;
        }

        // optional string client_version = 2;
        case 2: {
            if (tag == 18) {
            parse_client_version:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_client_version()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ClientInfo)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ClientInfo)
    return false;
#undef DO_
}

void ClientInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ClientInfo)
    // optional string client_id = 1;
    if (has_client_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            1, this->client_id(), output);
    }

    // optional string client_version = 2;
    if (has_client_version()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            2, this->client_version(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ClientInfo)
}

int ClientInfo::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientInfo)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional string client_id = 1;
        if (has_client_id()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->client_id());
        }

        // optional string client_version = 2;
        if (has_client_version()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->client_version());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ClientInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ClientInfo*>(&from));
}

void ClientInfo::MergeFrom(const ClientInfo& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientInfo)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_client_id()) {
            set_has_client_id();
            client_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_id_);
        }
        if (from.has_client_version()) {
            set_has_client_version();
            client_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_version_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ClientInfo::CopyFrom(const ClientInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientInfo::IsInitialized() const
{

    return true;
}

void ClientInfo::Swap(ClientInfo* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ClientInfo::InternalSwap(ClientInfo* other)
{
    client_id_.Swap(&other->client_id_);
    client_version_.Swap(&other->client_version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClientInfo::GetTypeName() const
{
    return "safe_browsing.ClientInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientInfo

// optional string client_id = 1;
bool ClientInfo::has_client_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientInfo::set_has_client_id()
{
    _has_bits_[0] |= 0x00000001u;
}
void ClientInfo::clear_has_client_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ClientInfo::clear_client_id()
{
    client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_client_id();
}
const ::std::string& ClientInfo::client_id() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ClientInfo.client_id)
    return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientInfo::set_client_id(const ::std::string& value)
{
    set_has_client_id();
    client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ClientInfo.client_id)
}
void ClientInfo::set_client_id(const char* value)
{
    set_has_client_id();
    client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ClientInfo.client_id)
}
void ClientInfo::set_client_id(const char* value, size_t size)
{
    set_has_client_id();
    client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ClientInfo.client_id)
}
::std::string* ClientInfo::mutable_client_id()
{
    set_has_client_id();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ClientInfo.client_id)
    return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientInfo::release_client_id()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ClientInfo.client_id)
    clear_has_client_id();
    return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientInfo::set_allocated_client_id(::std::string* client_id)
{
    if (client_id != NULL) {
        set_has_client_id();
    } else {
        clear_has_client_id();
    }
    client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ClientInfo.client_id)
}

// optional string client_version = 2;
bool ClientInfo::has_client_version() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientInfo::set_has_client_version()
{
    _has_bits_[0] |= 0x00000002u;
}
void ClientInfo::clear_has_client_version()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ClientInfo::clear_client_version()
{
    client_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_client_version();
}
const ::std::string& ClientInfo::client_version() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ClientInfo.client_version)
    return client_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientInfo::set_client_version(const ::std::string& value)
{
    set_has_client_version();
    client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ClientInfo.client_version)
}
void ClientInfo::set_client_version(const char* value)
{
    set_has_client_version();
    client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ClientInfo.client_version)
}
void ClientInfo::set_client_version(const char* value, size_t size)
{
    set_has_client_version();
    client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ClientInfo.client_version)
}
::std::string* ClientInfo::mutable_client_version()
{
    set_has_client_version();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ClientInfo.client_version)
    return client_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientInfo::release_client_version()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ClientInfo.client_version)
    clear_has_client_version();
    return client_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientInfo::set_allocated_client_version(::std::string* client_version)
{
    if (client_version != NULL) {
        set_has_client_version();
    } else {
        clear_has_client_version();
    }
    client_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_version);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ClientInfo.client_version)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForChromeClientInfo(
    ChromeClientInfo* ptr)
{
    return ptr->mutable_unknown_fields();
}

bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::UNSPECIFIED;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::OPT_OUT;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::EXTENDED;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SCOUT;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MIN;
const ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MAX;
const int ChromeClientInfo::SafeBrowsingReportingPopulation_ARRAYSIZE;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChromeClientInfo::kReportingPopulationFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ChromeClientInfo::ChromeClientInfo()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ChromeClientInfo)
}

void ChromeClientInfo::InitAsDefaultInstance()
{
}

ChromeClientInfo::ChromeClientInfo(const ChromeClientInfo& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ChromeClientInfo)
}

void ChromeClientInfo::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    reporting_population_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChromeClientInfo::~ChromeClientInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ChromeClientInfo)
    SharedDtor();
}

void ChromeClientInfo::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ChromeClientInfo::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChromeClientInfo& ChromeClientInfo::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ChromeClientInfo* ChromeClientInfo::default_instance_ = NULL;

ChromeClientInfo* ChromeClientInfo::New(::google::protobuf::Arena* arena) const
{
    ChromeClientInfo* n = new ChromeClientInfo;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ChromeClientInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ChromeClientInfo)
    reporting_population_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ChromeClientInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForChromeClientInfo, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ChromeClientInfo)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
        case 1: {
            if (tag == 8) {
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value)) {
                    set_reporting_population(static_cast<::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(8);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ChromeClientInfo)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ChromeClientInfo)
    return false;
#undef DO_
}

void ChromeClientInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ChromeClientInfo)
    // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
    if (has_reporting_population()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->reporting_population(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ChromeClientInfo)
}

int ChromeClientInfo::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ChromeClientInfo)
    int total_size = 0;

    // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
    if (has_reporting_population()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->reporting_population());
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ChromeClientInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ChromeClientInfo*>(&from));
}

void ChromeClientInfo::MergeFrom(const ChromeClientInfo& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ChromeClientInfo)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_reporting_population()) {
            set_reporting_population(from.reporting_population());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ChromeClientInfo::CopyFrom(const ChromeClientInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ChromeClientInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChromeClientInfo::IsInitialized() const
{

    return true;
}

void ChromeClientInfo::Swap(ChromeClientInfo* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ChromeClientInfo::InternalSwap(ChromeClientInfo* other)
{
    std::swap(reporting_population_, other->reporting_population_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ChromeClientInfo::GetTypeName() const
{
    return "safe_browsing.ChromeClientInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChromeClientInfo

// optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
bool ChromeClientInfo::has_reporting_population() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ChromeClientInfo::set_has_reporting_population()
{
    _has_bits_[0] |= 0x00000001u;
}
void ChromeClientInfo::clear_has_reporting_population()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ChromeClientInfo::clear_reporting_population()
{
    reporting_population_ = 0;
    clear_has_reporting_population();
}
::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::reporting_population() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ChromeClientInfo.reporting_population)
    return static_cast<::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation>(reporting_population_);
}
void ChromeClientInfo::set_reporting_population(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation value)
{
    assert(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value));
    set_has_reporting_population();
    reporting_population_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ChromeClientInfo.reporting_population)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForChecksum(
    Checksum* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Checksum::kSha256FieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

Checksum::Checksum()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.Checksum)
}

void Checksum::InitAsDefaultInstance()
{
}

Checksum::Checksum(const Checksum& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.Checksum)
}

void Checksum::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    sha256_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Checksum::~Checksum()
{
    // @@protoc_insertion_point(destructor:safe_browsing.Checksum)
    SharedDtor();
}

void Checksum::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    sha256_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void Checksum::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Checksum& Checksum::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

Checksum* Checksum::default_instance_ = NULL;

Checksum* Checksum::New(::google::protobuf::Arena* arena) const
{
    Checksum* n = new Checksum;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void Checksum::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.Checksum)
    if (has_sha256()) {
        sha256_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Checksum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForChecksum, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.Checksum)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional bytes sha256 = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_sha256()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.Checksum)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.Checksum)
    return false;
#undef DO_
}

void Checksum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.Checksum)
    // optional bytes sha256 = 1;
    if (has_sha256()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            1, this->sha256(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.Checksum)
}

int Checksum::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.Checksum)
    int total_size = 0;

    // optional bytes sha256 = 1;
    if (has_sha256()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->sha256());
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void Checksum::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const Checksum*>(&from));
}

void Checksum::MergeFrom(const Checksum& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.Checksum)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_sha256()) {
            set_has_sha256();
            sha256_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sha256_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void Checksum::CopyFrom(const Checksum& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.Checksum)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Checksum::IsInitialized() const
{

    return true;
}

void Checksum::Swap(Checksum* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void Checksum::InternalSwap(Checksum* other)
{
    sha256_.Swap(&other->sha256_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string Checksum::GetTypeName() const
{
    return "safe_browsing.Checksum";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Checksum

// optional bytes sha256 = 1;
bool Checksum::has_sha256() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void Checksum::set_has_sha256()
{
    _has_bits_[0] |= 0x00000001u;
}
void Checksum::clear_has_sha256()
{
    _has_bits_[0] &= ~0x00000001u;
}
void Checksum::clear_sha256()
{
    sha256_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_sha256();
}
const ::std::string& Checksum::sha256() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.Checksum.sha256)
    return sha256_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Checksum::set_sha256(const ::std::string& value)
{
    set_has_sha256();
    sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.Checksum.sha256)
}
void Checksum::set_sha256(const char* value)
{
    set_has_sha256();
    sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.Checksum.sha256)
}
void Checksum::set_sha256(const void* value, size_t size)
{
    set_has_sha256();
    sha256_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.Checksum.sha256)
}
::std::string* Checksum::mutable_sha256()
{
    set_has_sha256();
    // @@protoc_insertion_point(field_mutable:safe_browsing.Checksum.sha256)
    return sha256_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Checksum::release_sha256()
{
    // @@protoc_insertion_point(field_release:safe_browsing.Checksum.sha256)
    clear_has_sha256();
    return sha256_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Checksum::set_allocated_sha256(::std::string* sha256)
{
    if (sha256 != NULL) {
        set_has_sha256();
    } else {
        clear_has_sha256();
    }
    sha256_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha256);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.Checksum.sha256)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreatEntry(
    ThreatEntry* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntry::kHashFieldNumber;
const int ThreatEntry::kUrlFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntry::ThreatEntry()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatEntry)
}

void ThreatEntry::InitAsDefaultInstance()
{
}

ThreatEntry::ThreatEntry(const ThreatEntry& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntry)
}

void ThreatEntry::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    url_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatEntry::~ThreatEntry()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntry)
    SharedDtor();
}

void ThreatEntry::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    url_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ThreatEntry::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntry& ThreatEntry::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatEntry* ThreatEntry::default_instance_ = NULL;

ThreatEntry* ThreatEntry::New(::google::protobuf::Arena* arena) const
{
    ThreatEntry* n = new ThreatEntry;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntry)
    if (_has_bits_[0 / 32] & 3u) {
        if (has_hash()) {
            hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_url()) {
            url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatEntry, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatEntry)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional bytes hash = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_hash()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_url;
            break;
        }

        // optional string url = 2;
        case 2: {
            if (tag == 18) {
            parse_url:
                DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                    input, this->mutable_url()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatEntry)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatEntry)
    return false;
#undef DO_
}

void ThreatEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatEntry)
    // optional bytes hash = 1;
    if (has_hash()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            1, this->hash(), output);
    }

    // optional string url = 2;
    if (has_url()) {
        ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
            2, this->url(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatEntry)
}

int ThreatEntry::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntry)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional bytes hash = 1;
        if (has_hash()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->hash());
        }

        // optional string url = 2;
        if (has_url()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(this->url());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatEntry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatEntry*>(&from));
}

void ThreatEntry::MergeFrom(const ThreatEntry& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntry)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_hash()) {
            set_has_hash();
            hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
        }
        if (from.has_url()) {
            set_has_url();
            url_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.url_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatEntry::CopyFrom(const ThreatEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatEntry::IsInitialized() const
{

    return true;
}

void ThreatEntry::Swap(ThreatEntry* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatEntry::InternalSwap(ThreatEntry* other)
{
    hash_.Swap(&other->hash_);
    url_.Swap(&other->url_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntry::GetTypeName() const
{
    return "safe_browsing.ThreatEntry";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatEntry

// optional bytes hash = 1;
bool ThreatEntry::has_hash() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatEntry::set_has_hash()
{
    _has_bits_[0] |= 0x00000001u;
}
void ThreatEntry::clear_has_hash()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ThreatEntry::clear_hash()
{
    hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_hash();
}
const ::std::string& ThreatEntry::hash() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntry.hash)
    return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntry::set_hash(const ::std::string& value)
{
    set_has_hash();
    hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntry.hash)
}
void ThreatEntry::set_hash(const char* value)
{
    set_has_hash();
    hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntry.hash)
}
void ThreatEntry::set_hash(const void* value, size_t size)
{
    set_has_hash();
    hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntry.hash)
}
::std::string* ThreatEntry::mutable_hash()
{
    set_has_hash();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntry.hash)
    return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntry::release_hash()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntry.hash)
    clear_has_hash();
    return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntry::set_allocated_hash(::std::string* hash)
{
    if (hash != NULL) {
        set_has_hash();
    } else {
        clear_has_hash();
    }
    hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntry.hash)
}

// optional string url = 2;
bool ThreatEntry::has_url() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatEntry::set_has_url()
{
    _has_bits_[0] |= 0x00000002u;
}
void ThreatEntry::clear_has_url()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ThreatEntry::clear_url()
{
    url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_url();
}
const ::std::string& ThreatEntry::url() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntry.url)
    return url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntry::set_url(const ::std::string& value)
{
    set_has_url();
    url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntry.url)
}
void ThreatEntry::set_url(const char* value)
{
    set_has_url();
    url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntry.url)
}
void ThreatEntry::set_url(const char* value, size_t size)
{
    set_has_url();
    url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntry.url)
}
::std::string* ThreatEntry::mutable_url()
{
    set_has_url();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntry.url)
    return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntry::release_url()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntry.url)
    clear_has_url();
    return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntry::set_allocated_url(::std::string* url)
{
    if (url != NULL) {
        set_has_url();
    } else {
        clear_has_url();
    }
    url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntry.url)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreatEntrySet(
    ThreatEntrySet* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntrySet::kCompressionTypeFieldNumber;
const int ThreatEntrySet::kRawHashesFieldNumber;
const int ThreatEntrySet::kRawIndicesFieldNumber;
const int ThreatEntrySet::kRiceHashesFieldNumber;
const int ThreatEntrySet::kRiceIndicesFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntrySet::ThreatEntrySet()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatEntrySet)
}

void ThreatEntrySet::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    raw_hashes_ = const_cast<::safe_browsing::RawHashes*>(
        ::safe_browsing::RawHashes::internal_default_instance());
#else
    raw_hashes_ = const_cast<::safe_browsing::RawHashes*>(&::safe_browsing::RawHashes::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    raw_indices_ = const_cast<::safe_browsing::RawIndices*>(
        ::safe_browsing::RawIndices::internal_default_instance());
#else
    raw_indices_ = const_cast<::safe_browsing::RawIndices*>(&::safe_browsing::RawIndices::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    rice_hashes_ = const_cast<::safe_browsing::RiceDeltaEncoding*>(
        ::safe_browsing::RiceDeltaEncoding::internal_default_instance());
#else
    rice_hashes_ = const_cast<::safe_browsing::RiceDeltaEncoding*>(&::safe_browsing::RiceDeltaEncoding::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    rice_indices_ = const_cast<::safe_browsing::RiceDeltaEncoding*>(
        ::safe_browsing::RiceDeltaEncoding::internal_default_instance());
#else
    rice_indices_ = const_cast<::safe_browsing::RiceDeltaEncoding*>(&::safe_browsing::RiceDeltaEncoding::default_instance());
#endif
}

ThreatEntrySet::ThreatEntrySet(const ThreatEntrySet& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntrySet)
}

void ThreatEntrySet::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    compression_type_ = 0;
    raw_hashes_ = NULL;
    raw_indices_ = NULL;
    rice_hashes_ = NULL;
    rice_indices_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatEntrySet::~ThreatEntrySet()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntrySet)
    SharedDtor();
}

void ThreatEntrySet::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
        delete raw_hashes_;
        delete raw_indices_;
        delete rice_hashes_;
        delete rice_indices_;
    }
}

void ThreatEntrySet::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntrySet& ThreatEntrySet::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatEntrySet* ThreatEntrySet::default_instance_ = NULL;

ThreatEntrySet* ThreatEntrySet::New(::google::protobuf::Arena* arena) const
{
    ThreatEntrySet* n = new ThreatEntrySet;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatEntrySet::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntrySet)
    if (_has_bits_[0 / 32] & 31u) {
        compression_type_ = 0;
        if (has_raw_hashes()) {
            if (raw_hashes_ != NULL)
                raw_hashes_->::safe_browsing::RawHashes::Clear();
        }
        if (has_raw_indices()) {
            if (raw_indices_ != NULL)
                raw_indices_->::safe_browsing::RawIndices::Clear();
        }
        if (has_rice_hashes()) {
            if (rice_hashes_ != NULL)
                rice_hashes_->::safe_browsing::RiceDeltaEncoding::Clear();
        }
        if (has_rice_indices()) {
            if (rice_indices_ != NULL)
                rice_indices_->::safe_browsing::RiceDeltaEncoding::Clear();
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatEntrySet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatEntrySet, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatEntrySet)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.CompressionType compression_type = 1;
        case 1: {
            if (tag == 8) {
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::CompressionType_IsValid(value)) {
                    set_compression_type(static_cast<::safe_browsing::CompressionType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(8);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_raw_hashes;
            break;
        }

        // optional .safe_browsing.RawHashes raw_hashes = 2;
        case 2: {
            if (tag == 18) {
            parse_raw_hashes:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_raw_hashes()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(26))
                goto parse_raw_indices;
            break;
        }

        // optional .safe_browsing.RawIndices raw_indices = 3;
        case 3: {
            if (tag == 26) {
            parse_raw_indices:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_raw_indices()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_rice_hashes;
            break;
        }

        // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
        case 4: {
            if (tag == 34) {
            parse_rice_hashes:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_rice_hashes()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(42))
                goto parse_rice_indices;
            break;
        }

        // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
        case 5: {
            if (tag == 42) {
            parse_rice_indices:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                    input, mutable_rice_indices()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatEntrySet)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatEntrySet)
    return false;
#undef DO_
}

void ThreatEntrySet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatEntrySet)
    // optional .safe_browsing.CompressionType compression_type = 1;
    if (has_compression_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->compression_type(), output);
    }

    // optional .safe_browsing.RawHashes raw_hashes = 2;
    if (has_raw_hashes()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, *this->raw_hashes_, output);
    }

    // optional .safe_browsing.RawIndices raw_indices = 3;
    if (has_raw_indices()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, *this->raw_indices_, output);
    }

    // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
    if (has_rice_hashes()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, *this->rice_hashes_, output);
    }

    // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
    if (has_rice_indices()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            5, *this->rice_indices_, output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatEntrySet)
}

int ThreatEntrySet::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntrySet)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 31u) {
        // optional .safe_browsing.CompressionType compression_type = 1;
        if (has_compression_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->compression_type());
        }

        // optional .safe_browsing.RawHashes raw_hashes = 2;
        if (has_raw_hashes()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->raw_hashes_);
        }

        // optional .safe_browsing.RawIndices raw_indices = 3;
        if (has_raw_indices()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->raw_indices_);
        }

        // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
        if (has_rice_hashes()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->rice_hashes_);
        }

        // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
        if (has_rice_indices()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(*this->rice_indices_);
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatEntrySet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatEntrySet*>(&from));
}

void ThreatEntrySet::MergeFrom(const ThreatEntrySet& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntrySet)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_compression_type()) {
            set_compression_type(from.compression_type());
        }
        if (from.has_raw_hashes()) {
            mutable_raw_hashes()->::safe_browsing::RawHashes::MergeFrom(from.raw_hashes());
        }
        if (from.has_raw_indices()) {
            mutable_raw_indices()->::safe_browsing::RawIndices::MergeFrom(from.raw_indices());
        }
        if (from.has_rice_hashes()) {
            mutable_rice_hashes()->::safe_browsing::RiceDeltaEncoding::MergeFrom(from.rice_hashes());
        }
        if (from.has_rice_indices()) {
            mutable_rice_indices()->::safe_browsing::RiceDeltaEncoding::MergeFrom(from.rice_indices());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatEntrySet::CopyFrom(const ThreatEntrySet& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntrySet)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatEntrySet::IsInitialized() const
{

    return true;
}

void ThreatEntrySet::Swap(ThreatEntrySet* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatEntrySet::InternalSwap(ThreatEntrySet* other)
{
    std::swap(compression_type_, other->compression_type_);
    std::swap(raw_hashes_, other->raw_hashes_);
    std::swap(raw_indices_, other->raw_indices_);
    std::swap(rice_hashes_, other->rice_hashes_);
    std::swap(rice_indices_, other->rice_indices_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntrySet::GetTypeName() const
{
    return "safe_browsing.ThreatEntrySet";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatEntrySet

// optional .safe_browsing.CompressionType compression_type = 1;
bool ThreatEntrySet::has_compression_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatEntrySet::set_has_compression_type()
{
    _has_bits_[0] |= 0x00000001u;
}
void ThreatEntrySet::clear_has_compression_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ThreatEntrySet::clear_compression_type()
{
    compression_type_ = 0;
    clear_has_compression_type();
}
::safe_browsing::CompressionType ThreatEntrySet::compression_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.compression_type)
    return static_cast<::safe_browsing::CompressionType>(compression_type_);
}
void ThreatEntrySet::set_compression_type(::safe_browsing::CompressionType value)
{
    assert(::safe_browsing::CompressionType_IsValid(value));
    set_has_compression_type();
    compression_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntrySet.compression_type)
}

// optional .safe_browsing.RawHashes raw_hashes = 2;
bool ThreatEntrySet::has_raw_hashes() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatEntrySet::set_has_raw_hashes()
{
    _has_bits_[0] |= 0x00000002u;
}
void ThreatEntrySet::clear_has_raw_hashes()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ThreatEntrySet::clear_raw_hashes()
{
    if (raw_hashes_ != NULL)
        raw_hashes_->::safe_browsing::RawHashes::Clear();
    clear_has_raw_hashes();
}
const ::safe_browsing::RawHashes& ThreatEntrySet::raw_hashes() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.raw_hashes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return raw_hashes_ != NULL ? *raw_hashes_ : *default_instance().raw_hashes_;
#else
    return raw_hashes_ != NULL ? *raw_hashes_ : *default_instance_->raw_hashes_;
#endif
}
::safe_browsing::RawHashes* ThreatEntrySet::mutable_raw_hashes()
{
    set_has_raw_hashes();
    if (raw_hashes_ == NULL) {
        raw_hashes_ = new ::safe_browsing::RawHashes;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.raw_hashes)
    return raw_hashes_;
}
::safe_browsing::RawHashes* ThreatEntrySet::release_raw_hashes()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.raw_hashes)
    clear_has_raw_hashes();
    ::safe_browsing::RawHashes* temp = raw_hashes_;
    raw_hashes_ = NULL;
    return temp;
}
void ThreatEntrySet::set_allocated_raw_hashes(::safe_browsing::RawHashes* raw_hashes)
{
    delete raw_hashes_;
    raw_hashes_ = raw_hashes;
    if (raw_hashes) {
        set_has_raw_hashes();
    } else {
        clear_has_raw_hashes();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.raw_hashes)
}

// optional .safe_browsing.RawIndices raw_indices = 3;
bool ThreatEntrySet::has_raw_indices() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatEntrySet::set_has_raw_indices()
{
    _has_bits_[0] |= 0x00000004u;
}
void ThreatEntrySet::clear_has_raw_indices()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ThreatEntrySet::clear_raw_indices()
{
    if (raw_indices_ != NULL)
        raw_indices_->::safe_browsing::RawIndices::Clear();
    clear_has_raw_indices();
}
const ::safe_browsing::RawIndices& ThreatEntrySet::raw_indices() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.raw_indices)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return raw_indices_ != NULL ? *raw_indices_ : *default_instance().raw_indices_;
#else
    return raw_indices_ != NULL ? *raw_indices_ : *default_instance_->raw_indices_;
#endif
}
::safe_browsing::RawIndices* ThreatEntrySet::mutable_raw_indices()
{
    set_has_raw_indices();
    if (raw_indices_ == NULL) {
        raw_indices_ = new ::safe_browsing::RawIndices;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.raw_indices)
    return raw_indices_;
}
::safe_browsing::RawIndices* ThreatEntrySet::release_raw_indices()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.raw_indices)
    clear_has_raw_indices();
    ::safe_browsing::RawIndices* temp = raw_indices_;
    raw_indices_ = NULL;
    return temp;
}
void ThreatEntrySet::set_allocated_raw_indices(::safe_browsing::RawIndices* raw_indices)
{
    delete raw_indices_;
    raw_indices_ = raw_indices;
    if (raw_indices) {
        set_has_raw_indices();
    } else {
        clear_has_raw_indices();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.raw_indices)
}

// optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
bool ThreatEntrySet::has_rice_hashes() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void ThreatEntrySet::set_has_rice_hashes()
{
    _has_bits_[0] |= 0x00000008u;
}
void ThreatEntrySet::clear_has_rice_hashes()
{
    _has_bits_[0] &= ~0x00000008u;
}
void ThreatEntrySet::clear_rice_hashes()
{
    if (rice_hashes_ != NULL)
        rice_hashes_->::safe_browsing::RiceDeltaEncoding::Clear();
    clear_has_rice_hashes();
}
const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::rice_hashes() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.rice_hashes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return rice_hashes_ != NULL ? *rice_hashes_ : *default_instance().rice_hashes_;
#else
    return rice_hashes_ != NULL ? *rice_hashes_ : *default_instance_->rice_hashes_;
#endif
}
::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_hashes()
{
    set_has_rice_hashes();
    if (rice_hashes_ == NULL) {
        rice_hashes_ = new ::safe_browsing::RiceDeltaEncoding;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.rice_hashes)
    return rice_hashes_;
}
::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_hashes()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.rice_hashes)
    clear_has_rice_hashes();
    ::safe_browsing::RiceDeltaEncoding* temp = rice_hashes_;
    rice_hashes_ = NULL;
    return temp;
}
void ThreatEntrySet::set_allocated_rice_hashes(::safe_browsing::RiceDeltaEncoding* rice_hashes)
{
    delete rice_hashes_;
    rice_hashes_ = rice_hashes;
    if (rice_hashes) {
        set_has_rice_hashes();
    } else {
        clear_has_rice_hashes();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.rice_hashes)
}

// optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
bool ThreatEntrySet::has_rice_indices() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
void ThreatEntrySet::set_has_rice_indices()
{
    _has_bits_[0] |= 0x00000010u;
}
void ThreatEntrySet::clear_has_rice_indices()
{
    _has_bits_[0] &= ~0x00000010u;
}
void ThreatEntrySet::clear_rice_indices()
{
    if (rice_indices_ != NULL)
        rice_indices_->::safe_browsing::RiceDeltaEncoding::Clear();
    clear_has_rice_indices();
}
const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::rice_indices() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.rice_indices)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return rice_indices_ != NULL ? *rice_indices_ : *default_instance().rice_indices_;
#else
    return rice_indices_ != NULL ? *rice_indices_ : *default_instance_->rice_indices_;
#endif
}
::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_indices()
{
    set_has_rice_indices();
    if (rice_indices_ == NULL) {
        rice_indices_ = new ::safe_browsing::RiceDeltaEncoding;
    }
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.rice_indices)
    return rice_indices_;
}
::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_indices()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.rice_indices)
    clear_has_rice_indices();
    ::safe_browsing::RiceDeltaEncoding* temp = rice_indices_;
    rice_indices_ = NULL;
    return temp;
}
void ThreatEntrySet::set_allocated_rice_indices(::safe_browsing::RiceDeltaEncoding* rice_indices)
{
    delete rice_indices_;
    rice_indices_ = rice_indices;
    if (rice_indices) {
        set_has_rice_indices();
    } else {
        clear_has_rice_indices();
    }
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.rice_indices)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRawIndices(
    RawIndices* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RawIndices::kIndicesFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

RawIndices::RawIndices()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.RawIndices)
}

void RawIndices::InitAsDefaultInstance()
{
}

RawIndices::RawIndices(const RawIndices& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.RawIndices)
}

void RawIndices::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawIndices::~RawIndices()
{
    // @@protoc_insertion_point(destructor:safe_browsing.RawIndices)
    SharedDtor();
}

void RawIndices::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void RawIndices::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RawIndices& RawIndices::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

RawIndices* RawIndices::default_instance_ = NULL;

RawIndices* RawIndices::New(::google::protobuf::Arena* arena) const
{
    RawIndices* n = new RawIndices;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void RawIndices::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.RawIndices)
    indices_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RawIndices::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForRawIndices, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.RawIndices)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // repeated int32 indices = 1;
        case 1: {
            if (tag == 8) {
            parse_indices:
                DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    1, 8, input, this->mutable_indices())));
            } else if (tag == 10) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, this->mutable_indices())));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(8))
                goto parse_indices;
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.RawIndices)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.RawIndices)
    return false;
#undef DO_
}

void RawIndices::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.RawIndices)
    // repeated int32 indices = 1;
    for (int i = 0; i < this->indices_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(
            1, this->indices(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.RawIndices)
}

int RawIndices::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.RawIndices)
    int total_size = 0;

    // repeated int32 indices = 1;
    {
        int data_size = 0;
        for (int i = 0; i < this->indices_size(); i++) {
            data_size += ::google::protobuf::internal::WireFormatLite::
                Int32Size(this->indices(i));
        }
        total_size += 1 * this->indices_size() + data_size;
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void RawIndices::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const RawIndices*>(&from));
}

void RawIndices::MergeFrom(const RawIndices& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RawIndices)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    indices_.MergeFrom(from.indices_);
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void RawIndices::CopyFrom(const RawIndices& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RawIndices)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RawIndices::IsInitialized() const
{

    return true;
}

void RawIndices::Swap(RawIndices* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void RawIndices::InternalSwap(RawIndices* other)
{
    indices_.UnsafeArenaSwap(&other->indices_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string RawIndices::GetTypeName() const
{
    return "safe_browsing.RawIndices";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RawIndices

// repeated int32 indices = 1;
int RawIndices::indices_size() const
{
    return indices_.size();
}
void RawIndices::clear_indices()
{
    indices_.Clear();
}
::google::protobuf::int32 RawIndices::indices(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RawIndices.indices)
    return indices_.Get(index);
}
void RawIndices::set_indices(int index, ::google::protobuf::int32 value)
{
    indices_.Set(index, value);
    // @@protoc_insertion_point(field_set:safe_browsing.RawIndices.indices)
}
void RawIndices::add_indices(::google::protobuf::int32 value)
{
    indices_.Add(value);
    // @@protoc_insertion_point(field_add:safe_browsing.RawIndices.indices)
}
const ::google::protobuf::RepeatedField<::google::protobuf::int32>&
RawIndices::indices() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.RawIndices.indices)
    return indices_;
}
::google::protobuf::RepeatedField<::google::protobuf::int32>*
RawIndices::mutable_indices()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.RawIndices.indices)
    return &indices_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRawHashes(
    RawHashes* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RawHashes::kPrefixSizeFieldNumber;
const int RawHashes::kRawHashesFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

RawHashes::RawHashes()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.RawHashes)
}

void RawHashes::InitAsDefaultInstance()
{
}

RawHashes::RawHashes(const RawHashes& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.RawHashes)
}

void RawHashes::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    prefix_size_ = 0;
    raw_hashes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawHashes::~RawHashes()
{
    // @@protoc_insertion_point(destructor:safe_browsing.RawHashes)
    SharedDtor();
}

void RawHashes::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    raw_hashes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void RawHashes::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RawHashes& RawHashes::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

RawHashes* RawHashes::default_instance_ = NULL;

RawHashes* RawHashes::New(::google::protobuf::Arena* arena) const
{
    RawHashes* n = new RawHashes;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void RawHashes::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.RawHashes)
    if (_has_bits_[0 / 32] & 3u) {
        prefix_size_ = 0;
        if (has_raw_hashes()) {
            raw_hashes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RawHashes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForRawHashes, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.RawHashes)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional int32 prefix_size = 1;
        case 1: {
            if (tag == 8) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &prefix_size_)));
                set_has_prefix_size();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_raw_hashes;
            break;
        }

        // optional bytes raw_hashes = 2;
        case 2: {
            if (tag == 18) {
            parse_raw_hashes:
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_raw_hashes()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.RawHashes)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.RawHashes)
    return false;
#undef DO_
}

void RawHashes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.RawHashes)
    // optional int32 prefix_size = 1;
    if (has_prefix_size()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->prefix_size(), output);
    }

    // optional bytes raw_hashes = 2;
    if (has_raw_hashes()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            2, this->raw_hashes(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.RawHashes)
}

int RawHashes::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.RawHashes)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional int32 prefix_size = 1;
        if (has_prefix_size()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->prefix_size());
        }

        // optional bytes raw_hashes = 2;
        if (has_raw_hashes()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->raw_hashes());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void RawHashes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const RawHashes*>(&from));
}

void RawHashes::MergeFrom(const RawHashes& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RawHashes)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_prefix_size()) {
            set_prefix_size(from.prefix_size());
        }
        if (from.has_raw_hashes()) {
            set_has_raw_hashes();
            raw_hashes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.raw_hashes_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void RawHashes::CopyFrom(const RawHashes& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RawHashes)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RawHashes::IsInitialized() const
{

    return true;
}

void RawHashes::Swap(RawHashes* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void RawHashes::InternalSwap(RawHashes* other)
{
    std::swap(prefix_size_, other->prefix_size_);
    raw_hashes_.Swap(&other->raw_hashes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string RawHashes::GetTypeName() const
{
    return "safe_browsing.RawHashes";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RawHashes

// optional int32 prefix_size = 1;
bool RawHashes::has_prefix_size() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void RawHashes::set_has_prefix_size()
{
    _has_bits_[0] |= 0x00000001u;
}
void RawHashes::clear_has_prefix_size()
{
    _has_bits_[0] &= ~0x00000001u;
}
void RawHashes::clear_prefix_size()
{
    prefix_size_ = 0;
    clear_has_prefix_size();
}
::google::protobuf::int32 RawHashes::prefix_size() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RawHashes.prefix_size)
    return prefix_size_;
}
void RawHashes::set_prefix_size(::google::protobuf::int32 value)
{
    set_has_prefix_size();
    prefix_size_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.RawHashes.prefix_size)
}

// optional bytes raw_hashes = 2;
bool RawHashes::has_raw_hashes() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void RawHashes::set_has_raw_hashes()
{
    _has_bits_[0] |= 0x00000002u;
}
void RawHashes::clear_has_raw_hashes()
{
    _has_bits_[0] &= ~0x00000002u;
}
void RawHashes::clear_raw_hashes()
{
    raw_hashes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_raw_hashes();
}
const ::std::string& RawHashes::raw_hashes() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RawHashes.raw_hashes)
    return raw_hashes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RawHashes::set_raw_hashes(const ::std::string& value)
{
    set_has_raw_hashes();
    raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.RawHashes.raw_hashes)
}
void RawHashes::set_raw_hashes(const char* value)
{
    set_has_raw_hashes();
    raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.RawHashes.raw_hashes)
}
void RawHashes::set_raw_hashes(const void* value, size_t size)
{
    set_has_raw_hashes();
    raw_hashes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.RawHashes.raw_hashes)
}
::std::string* RawHashes::mutable_raw_hashes()
{
    set_has_raw_hashes();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RawHashes.raw_hashes)
    return raw_hashes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RawHashes::release_raw_hashes()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RawHashes.raw_hashes)
    clear_has_raw_hashes();
    return raw_hashes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RawHashes::set_allocated_raw_hashes(::std::string* raw_hashes)
{
    if (raw_hashes != NULL) {
        set_has_raw_hashes();
    } else {
        clear_has_raw_hashes();
    }
    raw_hashes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_hashes);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RawHashes.raw_hashes)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRiceDeltaEncoding(
    RiceDeltaEncoding* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RiceDeltaEncoding::kFirstValueFieldNumber;
const int RiceDeltaEncoding::kRiceParameterFieldNumber;
const int RiceDeltaEncoding::kNumEntriesFieldNumber;
const int RiceDeltaEncoding::kEncodedDataFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

RiceDeltaEncoding::RiceDeltaEncoding()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.RiceDeltaEncoding)
}

void RiceDeltaEncoding::InitAsDefaultInstance()
{
}

RiceDeltaEncoding::RiceDeltaEncoding(const RiceDeltaEncoding& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.RiceDeltaEncoding)
}

void RiceDeltaEncoding::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    first_value_ = GOOGLE_LONGLONG(0);
    rice_parameter_ = 0;
    num_entries_ = 0;
    encoded_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RiceDeltaEncoding::~RiceDeltaEncoding()
{
    // @@protoc_insertion_point(destructor:safe_browsing.RiceDeltaEncoding)
    SharedDtor();
}

void RiceDeltaEncoding::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    encoded_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void RiceDeltaEncoding::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RiceDeltaEncoding& RiceDeltaEncoding::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

RiceDeltaEncoding* RiceDeltaEncoding::default_instance_ = NULL;

RiceDeltaEncoding* RiceDeltaEncoding::New(::google::protobuf::Arena* arena) const
{
    RiceDeltaEncoding* n = new RiceDeltaEncoding;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void RiceDeltaEncoding::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.RiceDeltaEncoding)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                       \
    _Pragma("clang diagnostic push")                                                                        \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(RiceDeltaEncoding, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<RiceDeltaEncoding*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    if (_has_bits_[0 / 32] & 15u) {
        ZR_(first_value_, num_entries_);
        if (has_encoded_data()) {
            encoded_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }

#undef ZR_HELPER_
#undef ZR_

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RiceDeltaEncoding::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForRiceDeltaEncoding, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.RiceDeltaEncoding)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional int64 first_value = 1;
        case 1: {
            if (tag == 8) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                    input, &first_value_)));
                set_has_first_value();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_rice_parameter;
            break;
        }

        // optional int32 rice_parameter = 2;
        case 2: {
            if (tag == 16) {
            parse_rice_parameter:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &rice_parameter_)));
                set_has_rice_parameter();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(24))
                goto parse_num_entries;
            break;
        }

        // optional int32 num_entries = 3;
        case 3: {
            if (tag == 24) {
            parse_num_entries:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &num_entries_)));
                set_has_num_entries();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(34))
                goto parse_encoded_data;
            break;
        }

        // optional bytes encoded_data = 4;
        case 4: {
            if (tag == 34) {
            parse_encoded_data:
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_encoded_data()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.RiceDeltaEncoding)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.RiceDeltaEncoding)
    return false;
#undef DO_
}

void RiceDeltaEncoding::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.RiceDeltaEncoding)
    // optional int64 first_value = 1;
    if (has_first_value()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->first_value(), output);
    }

    // optional int32 rice_parameter = 2;
    if (has_rice_parameter()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rice_parameter(), output);
    }

    // optional int32 num_entries = 3;
    if (has_num_entries()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num_entries(), output);
    }

    // optional bytes encoded_data = 4;
    if (has_encoded_data()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            4, this->encoded_data(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.RiceDeltaEncoding)
}

int RiceDeltaEncoding::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.RiceDeltaEncoding)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 15u) {
        // optional int64 first_value = 1;
        if (has_first_value()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->first_value());
        }

        // optional int32 rice_parameter = 2;
        if (has_rice_parameter()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->rice_parameter());
        }

        // optional int32 num_entries = 3;
        if (has_num_entries()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->num_entries());
        }

        // optional bytes encoded_data = 4;
        if (has_encoded_data()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->encoded_data());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void RiceDeltaEncoding::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const RiceDeltaEncoding*>(&from));
}

void RiceDeltaEncoding::MergeFrom(const RiceDeltaEncoding& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RiceDeltaEncoding)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_first_value()) {
            set_first_value(from.first_value());
        }
        if (from.has_rice_parameter()) {
            set_rice_parameter(from.rice_parameter());
        }
        if (from.has_num_entries()) {
            set_num_entries(from.num_entries());
        }
        if (from.has_encoded_data()) {
            set_has_encoded_data();
            encoded_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.encoded_data_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void RiceDeltaEncoding::CopyFrom(const RiceDeltaEncoding& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RiceDeltaEncoding)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RiceDeltaEncoding::IsInitialized() const
{

    return true;
}

void RiceDeltaEncoding::Swap(RiceDeltaEncoding* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void RiceDeltaEncoding::InternalSwap(RiceDeltaEncoding* other)
{
    std::swap(first_value_, other->first_value_);
    std::swap(rice_parameter_, other->rice_parameter_);
    std::swap(num_entries_, other->num_entries_);
    encoded_data_.Swap(&other->encoded_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string RiceDeltaEncoding::GetTypeName() const
{
    return "safe_browsing.RiceDeltaEncoding";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RiceDeltaEncoding

// optional int64 first_value = 1;
bool RiceDeltaEncoding::has_first_value() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void RiceDeltaEncoding::set_has_first_value()
{
    _has_bits_[0] |= 0x00000001u;
}
void RiceDeltaEncoding::clear_has_first_value()
{
    _has_bits_[0] &= ~0x00000001u;
}
void RiceDeltaEncoding::clear_first_value()
{
    first_value_ = GOOGLE_LONGLONG(0);
    clear_has_first_value();
}
::google::protobuf::int64 RiceDeltaEncoding::first_value() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.first_value)
    return first_value_;
}
void RiceDeltaEncoding::set_first_value(::google::protobuf::int64 value)
{
    set_has_first_value();
    first_value_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.first_value)
}

// optional int32 rice_parameter = 2;
bool RiceDeltaEncoding::has_rice_parameter() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void RiceDeltaEncoding::set_has_rice_parameter()
{
    _has_bits_[0] |= 0x00000002u;
}
void RiceDeltaEncoding::clear_has_rice_parameter()
{
    _has_bits_[0] &= ~0x00000002u;
}
void RiceDeltaEncoding::clear_rice_parameter()
{
    rice_parameter_ = 0;
    clear_has_rice_parameter();
}
::google::protobuf::int32 RiceDeltaEncoding::rice_parameter() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.rice_parameter)
    return rice_parameter_;
}
void RiceDeltaEncoding::set_rice_parameter(::google::protobuf::int32 value)
{
    set_has_rice_parameter();
    rice_parameter_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.rice_parameter)
}

// optional int32 num_entries = 3;
bool RiceDeltaEncoding::has_num_entries() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void RiceDeltaEncoding::set_has_num_entries()
{
    _has_bits_[0] |= 0x00000004u;
}
void RiceDeltaEncoding::clear_has_num_entries()
{
    _has_bits_[0] &= ~0x00000004u;
}
void RiceDeltaEncoding::clear_num_entries()
{
    num_entries_ = 0;
    clear_has_num_entries();
}
::google::protobuf::int32 RiceDeltaEncoding::num_entries() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.num_entries)
    return num_entries_;
}
void RiceDeltaEncoding::set_num_entries(::google::protobuf::int32 value)
{
    set_has_num_entries();
    num_entries_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.num_entries)
}

// optional bytes encoded_data = 4;
bool RiceDeltaEncoding::has_encoded_data() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
void RiceDeltaEncoding::set_has_encoded_data()
{
    _has_bits_[0] |= 0x00000008u;
}
void RiceDeltaEncoding::clear_has_encoded_data()
{
    _has_bits_[0] &= ~0x00000008u;
}
void RiceDeltaEncoding::clear_encoded_data()
{
    encoded_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_encoded_data();
}
const ::std::string& RiceDeltaEncoding::encoded_data() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.encoded_data)
    return encoded_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RiceDeltaEncoding::set_encoded_data(const ::std::string& value)
{
    set_has_encoded_data();
    encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.encoded_data)
}
void RiceDeltaEncoding::set_encoded_data(const char* value)
{
    set_has_encoded_data();
    encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.RiceDeltaEncoding.encoded_data)
}
void RiceDeltaEncoding::set_encoded_data(const void* value, size_t size)
{
    set_has_encoded_data();
    encoded_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.RiceDeltaEncoding.encoded_data)
}
::std::string* RiceDeltaEncoding::mutable_encoded_data()
{
    set_has_encoded_data();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RiceDeltaEncoding.encoded_data)
    return encoded_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RiceDeltaEncoding::release_encoded_data()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RiceDeltaEncoding.encoded_data)
    clear_has_encoded_data();
    return encoded_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RiceDeltaEncoding::set_allocated_encoded_data(::std::string* encoded_data)
{
    if (encoded_data != NULL) {
        set_has_encoded_data();
    } else {
        clear_has_encoded_data();
    }
    encoded_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encoded_data);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RiceDeltaEncoding.encoded_data)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreatEntryMetadata(
    ThreatEntryMetadata* ptr)
{
    return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForThreatEntryMetadata_MetadataEntry(
    ThreatEntryMetadata_MetadataEntry* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntryMetadata_MetadataEntry::kKeyFieldNumber;
const int ThreatEntryMetadata_MetadataEntry::kValueFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatEntryMetadata.MetadataEntry)
}

void ThreatEntryMetadata_MetadataEntry::InitAsDefaultInstance()
{
}

ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntryMetadata.MetadataEntry)
}

void ThreatEntryMetadata_MetadataEntry::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatEntryMetadata_MetadataEntry::~ThreatEntryMetadata_MetadataEntry()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    SharedDtor();
}

void ThreatEntryMetadata_MetadataEntry::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ThreatEntryMetadata_MetadataEntry::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata_MetadataEntry::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata_MetadataEntry::default_instance_ = NULL;

ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata_MetadataEntry::New(::google::protobuf::Arena* arena) const
{
    ThreatEntryMetadata_MetadataEntry* n = new ThreatEntryMetadata_MetadataEntry;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatEntryMetadata_MetadataEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    if (_has_bits_[0 / 32] & 3u) {
        if (has_key()) {
            key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
        if (has_value()) {
            value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }
    }
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatEntryMetadata_MetadataEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatEntryMetadata_MetadataEntry, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional bytes key = 1;
        case 1: {
            if (tag == 10) {
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_key()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(18))
                goto parse_value;
            break;
        }

        // optional bytes value = 2;
        case 2: {
            if (tag == 18) {
            parse_value:
                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                    input, this->mutable_value()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    return false;
#undef DO_
}

void ThreatEntryMetadata_MetadataEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    // optional bytes key = 1;
    if (has_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            1, this->key(), output);
    }

    // optional bytes value = 2;
    if (has_value()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
            2, this->value(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatEntryMetadata.MetadataEntry)
}

int ThreatEntryMetadata_MetadataEntry::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional bytes key = 1;
        if (has_key()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->key());
        }

        // optional bytes value = 2;
        if (has_value()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(this->value());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatEntryMetadata_MetadataEntry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatEntryMetadata_MetadataEntry*>(&from));
}

void ThreatEntryMetadata_MetadataEntry::MergeFrom(const ThreatEntryMetadata_MetadataEntry& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_key()) {
            set_has_key();
            key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
        }
        if (from.has_value()) {
            set_has_value();
            value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatEntryMetadata_MetadataEntry::CopyFrom(const ThreatEntryMetadata_MetadataEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatEntryMetadata_MetadataEntry::IsInitialized() const
{

    return true;
}

void ThreatEntryMetadata_MetadataEntry::Swap(ThreatEntryMetadata_MetadataEntry* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatEntryMetadata_MetadataEntry::InternalSwap(ThreatEntryMetadata_MetadataEntry* other)
{
    key_.Swap(&other->key_);
    value_.Swap(&other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntryMetadata_MetadataEntry::GetTypeName() const
{
    return "safe_browsing.ThreatEntryMetadata.MetadataEntry";
}

// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatEntryMetadata::kEntriesFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatEntryMetadata::ThreatEntryMetadata()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatEntryMetadata)
}

void ThreatEntryMetadata::InitAsDefaultInstance()
{
}

ThreatEntryMetadata::ThreatEntryMetadata(const ThreatEntryMetadata& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntryMetadata)
}

void ThreatEntryMetadata::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatEntryMetadata::~ThreatEntryMetadata()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntryMetadata)
    SharedDtor();
}

void ThreatEntryMetadata::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ThreatEntryMetadata::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatEntryMetadata& ThreatEntryMetadata::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatEntryMetadata* ThreatEntryMetadata::default_instance_ = NULL;

ThreatEntryMetadata* ThreatEntryMetadata::New(::google::protobuf::Arena* arena) const
{
    ThreatEntryMetadata* n = new ThreatEntryMetadata;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatEntryMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntryMetadata)
    entries_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatEntryMetadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatEntryMetadata, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatEntryMetadata)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
        case 1: {
            if (tag == 10) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_entries:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_entries()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(10))
                goto parse_loop_entries;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatEntryMetadata)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatEntryMetadata)
    return false;
#undef DO_
}

void ThreatEntryMetadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatEntryMetadata)
    // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
    for (unsigned int i = 0, n = this->entries_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->entries(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatEntryMetadata)
}

int ThreatEntryMetadata::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntryMetadata)
    int total_size = 0;

    // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
    total_size += 1 * this->entries_size();
    for (int i = 0; i < this->entries_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->entries(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatEntryMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatEntryMetadata*>(&from));
}

void ThreatEntryMetadata::MergeFrom(const ThreatEntryMetadata& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntryMetadata)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    entries_.MergeFrom(from.entries_);
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatEntryMetadata::CopyFrom(const ThreatEntryMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntryMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatEntryMetadata::IsInitialized() const
{

    return true;
}

void ThreatEntryMetadata::Swap(ThreatEntryMetadata* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatEntryMetadata::InternalSwap(ThreatEntryMetadata* other)
{
    entries_.UnsafeArenaSwap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatEntryMetadata::GetTypeName() const
{
    return "safe_browsing.ThreatEntryMetadata";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatEntryMetadata_MetadataEntry

// optional bytes key = 1;
bool ThreatEntryMetadata_MetadataEntry::has_key() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatEntryMetadata_MetadataEntry::set_has_key()
{
    _has_bits_[0] |= 0x00000001u;
}
void ThreatEntryMetadata_MetadataEntry::clear_has_key()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ThreatEntryMetadata_MetadataEntry::clear_key()
{
    key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_key();
}
const ::std::string& ThreatEntryMetadata_MetadataEntry::key() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
    return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntryMetadata_MetadataEntry::set_key(const ::std::string& value)
{
    set_has_key();
    key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
void ThreatEntryMetadata_MetadataEntry::set_key(const char* value)
{
    set_has_key();
    key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
void ThreatEntryMetadata_MetadataEntry::set_key(const void* value, size_t size)
{
    set_has_key();
    key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
::std::string* ThreatEntryMetadata_MetadataEntry::mutable_key()
{
    set_has_key();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
    return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntryMetadata_MetadataEntry::release_key()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
    clear_has_key();
    return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntryMetadata_MetadataEntry::set_allocated_key(::std::string* key)
{
    if (key != NULL) {
        set_has_key();
    } else {
        clear_has_key();
    }
    key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}

// optional bytes value = 2;
bool ThreatEntryMetadata_MetadataEntry::has_value() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatEntryMetadata_MetadataEntry::set_has_value()
{
    _has_bits_[0] |= 0x00000002u;
}
void ThreatEntryMetadata_MetadataEntry::clear_has_value()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ThreatEntryMetadata_MetadataEntry::clear_value()
{
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
}
const ::std::string& ThreatEntryMetadata_MetadataEntry::value() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
    return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntryMetadata_MetadataEntry::set_value(const ::std::string& value)
{
    set_has_value();
    value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
void ThreatEntryMetadata_MetadataEntry::set_value(const char* value)
{
    set_has_value();
    value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
void ThreatEntryMetadata_MetadataEntry::set_value(const void* value, size_t size)
{
    set_has_value();
    value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
::std::string* ThreatEntryMetadata_MetadataEntry::mutable_value()
{
    set_has_value();
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
    return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ThreatEntryMetadata_MetadataEntry::release_value()
{
    // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
    clear_has_value();
    return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ThreatEntryMetadata_MetadataEntry::set_allocated_value(::std::string* value)
{
    if (value != NULL) {
        set_has_value();
    } else {
        clear_has_value();
    }
    value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata

// repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
int ThreatEntryMetadata::entries_size() const
{
    return entries_.size();
}
void ThreatEntryMetadata::clear_entries()
{
    entries_.Clear();
}
const ::safe_browsing::ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata::entries(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.entries)
    return entries_.Get(index);
}
::safe_browsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.entries)
    return entries_.Mutable(index);
}
::safe_browsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::add_entries()
{
    // @@protoc_insertion_point(field_add:safe_browsing.ThreatEntryMetadata.entries)
    return entries_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntryMetadata_MetadataEntry>*
ThreatEntryMetadata::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatEntryMetadata.entries)
    return &entries_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatEntryMetadata_MetadataEntry>&
ThreatEntryMetadata::entries() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.ThreatEntryMetadata.entries)
    return entries_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreatListDescriptor(
    ThreatListDescriptor* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreatListDescriptor::kThreatTypeFieldNumber;
const int ThreatListDescriptor::kPlatformTypeFieldNumber;
const int ThreatListDescriptor::kThreatEntryTypeFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreatListDescriptor::ThreatListDescriptor()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ThreatListDescriptor)
}

void ThreatListDescriptor::InitAsDefaultInstance()
{
}

ThreatListDescriptor::ThreatListDescriptor(const ThreatListDescriptor& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatListDescriptor)
}

void ThreatListDescriptor::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    threat_type_ = 0;
    platform_type_ = 0;
    threat_entry_type_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreatListDescriptor::~ThreatListDescriptor()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ThreatListDescriptor)
    SharedDtor();
}

void ThreatListDescriptor::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ThreatListDescriptor::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreatListDescriptor& ThreatListDescriptor::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ThreatListDescriptor* ThreatListDescriptor::default_instance_ = NULL;

ThreatListDescriptor* ThreatListDescriptor::New(::google::protobuf::Arena* arena) const
{
    ThreatListDescriptor* n = new ThreatListDescriptor;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ThreatListDescriptor::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatListDescriptor)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                                          \
    _Pragma("clang diagnostic push")                                                                           \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(ThreatListDescriptor, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<ThreatListDescriptor*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    ZR_(threat_type_, threat_entry_type_);

#undef ZR_HELPER_
#undef ZR_

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreatListDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForThreatListDescriptor, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ThreatListDescriptor)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        case 1: {
            if (tag == 8) {
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatType_IsValid(value)) {
                    set_threat_type(static_cast<::safe_browsing::ThreatType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(8);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_platform_type;
            break;
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        case 2: {
            if (tag == 16) {
            parse_platform_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::PlatformType_IsValid(value)) {
                    set_platform_type(static_cast<::safe_browsing::PlatformType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(16);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(24))
                goto parse_threat_entry_type;
            break;
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
        case 3: {
            if (tag == 24) {
            parse_threat_entry_type:
                int value;
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                    input, &value)));
                if (::safe_browsing::ThreatEntryType_IsValid(value)) {
                    set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(value));
                } else {
                    unknown_fields_stream.WriteVarint32(24);
                    unknown_fields_stream.WriteVarint32(value);
                }
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ThreatListDescriptor)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ThreatListDescriptor)
    return false;
#undef DO_
}

void ThreatListDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ThreatListDescriptor)
    // optional .safe_browsing.ThreatType threat_type = 1;
    if (has_threat_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->threat_type(), output);
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (has_platform_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->platform_type(), output);
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
    if (has_threat_entry_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            3, this->threat_entry_type(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ThreatListDescriptor)
}

int ThreatListDescriptor::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatListDescriptor)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 7u) {
        // optional .safe_browsing.ThreatType threat_type = 1;
        if (has_threat_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_type());
        }

        // optional .safe_browsing.PlatformType platform_type = 2;
        if (has_platform_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->platform_type());
        }

        // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
        if (has_threat_entry_type()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::EnumSize(this->threat_entry_type());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ThreatListDescriptor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ThreatListDescriptor*>(&from));
}

void ThreatListDescriptor::MergeFrom(const ThreatListDescriptor& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatListDescriptor)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_threat_type()) {
            set_threat_type(from.threat_type());
        }
        if (from.has_platform_type()) {
            set_platform_type(from.platform_type());
        }
        if (from.has_threat_entry_type()) {
            set_threat_entry_type(from.threat_entry_type());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ThreatListDescriptor::CopyFrom(const ThreatListDescriptor& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatListDescriptor)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThreatListDescriptor::IsInitialized() const
{

    return true;
}

void ThreatListDescriptor::Swap(ThreatListDescriptor* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ThreatListDescriptor::InternalSwap(ThreatListDescriptor* other)
{
    std::swap(threat_type_, other->threat_type_);
    std::swap(platform_type_, other->platform_type_);
    std::swap(threat_entry_type_, other->threat_entry_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreatListDescriptor::GetTypeName() const
{
    return "safe_browsing.ThreatListDescriptor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreatListDescriptor

// optional .safe_browsing.ThreatType threat_type = 1;
bool ThreatListDescriptor::has_threat_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreatListDescriptor::set_has_threat_type()
{
    _has_bits_[0] |= 0x00000001u;
}
void ThreatListDescriptor::clear_has_threat_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
void ThreatListDescriptor::clear_threat_type()
{
    threat_type_ = 0;
    clear_has_threat_type();
}
::safe_browsing::ThreatType ThreatListDescriptor::threat_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.threat_type)
    return static_cast<::safe_browsing::ThreatType>(threat_type_);
}
void ThreatListDescriptor::set_threat_type(::safe_browsing::ThreatType value)
{
    assert(::safe_browsing::ThreatType_IsValid(value));
    set_has_threat_type();
    threat_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
bool ThreatListDescriptor::has_platform_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreatListDescriptor::set_has_platform_type()
{
    _has_bits_[0] |= 0x00000002u;
}
void ThreatListDescriptor::clear_has_platform_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
void ThreatListDescriptor::clear_platform_type()
{
    platform_type_ = 0;
    clear_has_platform_type();
}
::safe_browsing::PlatformType ThreatListDescriptor::platform_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.platform_type)
    return static_cast<::safe_browsing::PlatformType>(platform_type_);
}
void ThreatListDescriptor::set_platform_type(::safe_browsing::PlatformType value)
{
    assert(::safe_browsing::PlatformType_IsValid(value));
    set_has_platform_type();
    platform_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
bool ThreatListDescriptor::has_threat_entry_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreatListDescriptor::set_has_threat_entry_type()
{
    _has_bits_[0] |= 0x00000004u;
}
void ThreatListDescriptor::clear_has_threat_entry_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
void ThreatListDescriptor::clear_threat_entry_type()
{
    threat_entry_type_ = 0;
    clear_has_threat_entry_type();
}
::safe_browsing::ThreatEntryType ThreatListDescriptor::threat_entry_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.threat_entry_type)
    return static_cast<::safe_browsing::ThreatEntryType>(threat_entry_type_);
}
void ThreatListDescriptor::set_threat_entry_type(::safe_browsing::ThreatEntryType value)
{
    assert(::safe_browsing::ThreatEntryType_IsValid(value));
    set_has_threat_entry_type();
    threat_entry_type_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.threat_entry_type)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForListThreatListsResponse(
    ListThreatListsResponse* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ListThreatListsResponse::kThreatListsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ListThreatListsResponse::ListThreatListsResponse()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.ListThreatListsResponse)
}

void ListThreatListsResponse::InitAsDefaultInstance()
{
}

ListThreatListsResponse::ListThreatListsResponse(const ListThreatListsResponse& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ListThreatListsResponse)
}

void ListThreatListsResponse::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ListThreatListsResponse::~ListThreatListsResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ListThreatListsResponse)
    SharedDtor();
}

void ListThreatListsResponse::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void ListThreatListsResponse::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ListThreatListsResponse& ListThreatListsResponse::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

ListThreatListsResponse* ListThreatListsResponse::default_instance_ = NULL;

ListThreatListsResponse* ListThreatListsResponse::New(::google::protobuf::Arena* arena) const
{
    ListThreatListsResponse* n = new ListThreatListsResponse;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void ListThreatListsResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ListThreatListsResponse)
    threat_lists_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ListThreatListsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForListThreatListsResponse, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.ListThreatListsResponse)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
        case 1: {
            if (tag == 10) {
                DO_(input->IncrementRecursionDepth());
            parse_loop_threat_lists:
                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                    input, add_threat_lists()));
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(10))
                goto parse_loop_threat_lists;
            input->UnsafeDecrementRecursionDepth();
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.ListThreatListsResponse)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.ListThreatListsResponse)
    return false;
#undef DO_
}

void ListThreatListsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.ListThreatListsResponse)
    // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
    for (unsigned int i = 0, n = this->threat_lists_size(); i < n; i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->threat_lists(i), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.ListThreatListsResponse)
}

int ListThreatListsResponse::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ListThreatListsResponse)
    int total_size = 0;

    // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
    total_size += 1 * this->threat_lists_size();
    for (int i = 0; i < this->threat_lists_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
            this->threat_lists(i));
    }

    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ListThreatListsResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ListThreatListsResponse*>(&from));
}

void ListThreatListsResponse::MergeFrom(const ListThreatListsResponse& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ListThreatListsResponse)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    threat_lists_.MergeFrom(from.threat_lists_);
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void ListThreatListsResponse::CopyFrom(const ListThreatListsResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ListThreatListsResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ListThreatListsResponse::IsInitialized() const
{

    return true;
}

void ListThreatListsResponse::Swap(ListThreatListsResponse* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void ListThreatListsResponse::InternalSwap(ListThreatListsResponse* other)
{
    threat_lists_.UnsafeArenaSwap(&other->threat_lists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string ListThreatListsResponse::GetTypeName() const
{
    return "safe_browsing.ListThreatListsResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ListThreatListsResponse

// repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
int ListThreatListsResponse::threat_lists_size() const
{
    return threat_lists_.size();
}
void ListThreatListsResponse::clear_threat_lists()
{
    threat_lists_.Clear();
}
const ::safe_browsing::ThreatListDescriptor& ListThreatListsResponse::threat_lists(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.ListThreatListsResponse.threat_lists)
    return threat_lists_.Get(index);
}
::safe_browsing::ThreatListDescriptor* ListThreatListsResponse::mutable_threat_lists(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.ListThreatListsResponse.threat_lists)
    return threat_lists_.Mutable(index);
}
::safe_browsing::ThreatListDescriptor* ListThreatListsResponse::add_threat_lists()
{
    // @@protoc_insertion_point(field_add:safe_browsing.ListThreatListsResponse.threat_lists)
    return threat_lists_.Add();
}
::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatListDescriptor>*
ListThreatListsResponse::mutable_threat_lists()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.ListThreatListsResponse.threat_lists)
    return &threat_lists_;
}
const ::google::protobuf::RepeatedPtrField<::safe_browsing::ThreatListDescriptor>&
ListThreatListsResponse::threat_lists() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.ListThreatListsResponse.threat_lists)
    return threat_lists_;
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDuration(
    Duration* ptr)
{
    return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Duration::kSecondsFieldNumber;
const int Duration::kNanosFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

Duration::Duration()
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    // @@protoc_insertion_point(constructor:safe_browsing.Duration)
}

void Duration::InitAsDefaultInstance()
{
}

Duration::Duration(const Duration& from)
    : ::google::protobuf::MessageLite()
    , _arena_ptr_(NULL)
{
    SharedCtor();
    MergeFrom(from);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.Duration)
}

void Duration::SharedCtor()
{
    ::google::protobuf::internal::GetEmptyString();
    _cached_size_ = 0;
    _unknown_fields_.UnsafeSetDefault(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    seconds_ = GOOGLE_LONGLONG(0);
    nanos_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Duration::~Duration()
{
    // @@protoc_insertion_point(destructor:safe_browsing.Duration)
    SharedDtor();
}

void Duration::SharedDtor()
{
    _unknown_fields_.DestroyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    if (this != &default_instance()) {
#else
    if (this != default_instance_) {
#endif
    }
}

void Duration::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Duration& Duration::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_safebrowsing_2eproto();
#else
    if (default_instance_ == NULL)
        protobuf_AddDesc_safebrowsing_2eproto();
#endif
    return *default_instance_;
}

Duration* Duration::default_instance_ = NULL;

Duration* Duration::New(::google::protobuf::Arena* arena) const
{
    Duration* n = new Duration;
    if (arena != NULL) {
        arena->Own(n);
    }
    return n;
}

void Duration::Clear()
{
// @@protoc_insertion_point(message_clear_start:safe_browsing.Duration)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                                              \
    _Pragma("clang diagnostic push")                                                               \
        _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") __builtin_offsetof(Duration, f) \
            _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>( \
    &reinterpret_cast<Duration*>(16)->f)
#endif

#define ZR_(first, last)                                          \
    do {                                                          \
        ::memset(&first, 0,                                       \
            ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last)); \
    } while (0)

    ZR_(seconds_, nanos_);

#undef ZR_HELPER_
#undef ZR_

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
    _unknown_fields_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Duration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION)                   \
    if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) \
    goto failure
    ::google::protobuf::uint32 tag;
    ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
        ::google::protobuf::internal::NewPermanentCallback(
            &MutableUnknownFieldsForDuration, this));
    ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
        &unknown_fields_string, false);
    // @@protoc_insertion_point(parse_start:safe_browsing.Duration)
    for (;;) {
        ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
        tag = p.first;
        if (!p.second)
            goto handle_unusual;
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
        // optional int64 seconds = 1;
        case 1: {
            if (tag == 8) {
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                    input, &seconds_)));
                set_has_seconds();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectTag(16))
                goto parse_nanos;
            break;
        }

        // optional int32 nanos = 2;
        case 2: {
            if (tag == 16) {
            parse_nanos:
                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                    input, &nanos_)));
                set_has_nanos();
            } else {
                goto handle_unusual;
            }
            if (input->ExpectAtEnd())
                goto success;
            break;
        }

        default: {
        handle_unusual:
            if (tag == 0 || ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) == ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                goto success;
            }
            DO_(::google::protobuf::internal::WireFormatLite::SkipField(
                input, tag, &unknown_fields_stream));
            break;
        }
        }
    }
success:
    // @@protoc_insertion_point(parse_success:safe_browsing.Duration)
    return true;
failure:
    // @@protoc_insertion_point(parse_failure:safe_browsing.Duration)
    return false;
#undef DO_
}

void Duration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // @@protoc_insertion_point(serialize_start:safe_browsing.Duration)
    // optional int64 seconds = 1;
    if (has_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->seconds(), output);
    }

    // optional int32 nanos = 2;
    if (has_nanos()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nanos(), output);
    }

    output->WriteRaw(unknown_fields().data(),
        static_cast<int>(unknown_fields().size()));
    // @@protoc_insertion_point(serialize_end:safe_browsing.Duration)
}

int Duration::ByteSize() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.Duration)
    int total_size = 0;

    if (_has_bits_[0 / 32] & 3u) {
        // optional int64 seconds = 1;
        if (has_seconds()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int64Size(this->seconds());
        }

        // optional int32 nanos = 2;
        if (has_nanos()) {
            total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(this->nanos());
        }
    }
    total_size += unknown_fields().size();

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void Duration::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const Duration*>(&from));
}

void Duration::MergeFrom(const Duration& from)
{
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.Duration)
    if (GOOGLE_PREDICT_FALSE(&from == this))
        MergeFromFail(__LINE__);
    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_seconds()) {
            set_seconds(from.seconds());
        }
        if (from.has_nanos()) {
            set_nanos(from.nanos());
        }
    }
    if (!from.unknown_fields().empty()) {
        mutable_unknown_fields()->append(from.unknown_fields());
    }
}

void Duration::CopyFrom(const Duration& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.Duration)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Duration::IsInitialized() const
{

    return true;
}

void Duration::Swap(Duration* other)
{
    if (other == this)
        return;
    InternalSwap(other);
}
void Duration::InternalSwap(Duration* other)
{
    std::swap(seconds_, other->seconds_);
    std::swap(nanos_, other->nanos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
}

::std::string Duration::GetTypeName() const
{
    return "safe_browsing.Duration";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Duration

// optional int64 seconds = 1;
bool Duration::has_seconds() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
void Duration::set_has_seconds()
{
    _has_bits_[0] |= 0x00000001u;
}
void Duration::clear_has_seconds()
{
    _has_bits_[0] &= ~0x00000001u;
}
void Duration::clear_seconds()
{
    seconds_ = GOOGLE_LONGLONG(0);
    clear_has_seconds();
}
::google::protobuf::int64 Duration::seconds() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.Duration.seconds)
    return seconds_;
}
void Duration::set_seconds(::google::protobuf::int64 value)
{
    set_has_seconds();
    seconds_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.Duration.seconds)
}

// optional int32 nanos = 2;
bool Duration::has_nanos() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
void Duration::set_has_nanos()
{
    _has_bits_[0] |= 0x00000002u;
}
void Duration::clear_has_nanos()
{
    _has_bits_[0] &= ~0x00000002u;
}
void Duration::clear_nanos()
{
    nanos_ = 0;
    clear_has_nanos();
}
::google::protobuf::int32 Duration::nanos() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.Duration.nanos)
    return nanos_;
}
void Duration::set_nanos(::google::protobuf::int32 value)
{
    set_has_nanos();
    nanos_ = value;
    // @@protoc_insertion_point(field_set:safe_browsing.Duration.nanos)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

} // namespace safe_browsing

// @@protoc_insertion_point(global_scope)
