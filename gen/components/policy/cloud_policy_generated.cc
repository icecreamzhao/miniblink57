//
// DO NOT MODIFY THIS FILE DIRECTLY!
// IT IS GENERATED BY generate_policy_source.py
// FROM ../../components/policy/resources/policy_templates.json
//

#include <limits>
#include <memory>
#include <string>
#include <utility>

#include "base/callback.h"
#include "base/json/json_reader.h"
#include "base/logging.h"
#include "base/memory/ptr_util.h"
#include "base/memory/weak_ptr.h"
#include "base/values.h"
#include "components/policy/core/common/cloud/cloud_external_data_manager.h"
#include "components/policy/core/common/external_data_fetcher.h"
#include "components/policy/core/common/policy_map.h"
#include "components/policy/core/common/policy_types.h"
#include "components/policy/policy_constants.h"
#include "components/policy/proto/cloud_policy.pb.h"

using google::protobuf::RepeatedPtrField;

namespace policy {

namespace em = enterprise_management;

std::unique_ptr<base::Value> DecodeIntegerValue(
    google::protobuf::int64 value)
{
    if (value < std::numeric_limits<int>::min() || value > std::numeric_limits<int>::max()) {
        LOG(WARNING) << "Integer value " << value
                     << " out of numeric limits, ignoring.";
        return nullptr;
    }

    return base::WrapUnique(
        new base::FundamentalValue(static_cast<int>(value)));
}

std::unique_ptr<base::ListValue> DecodeStringList(
    const em::StringList& string_list)
{
    std::unique_ptr<base::ListValue> list_value(new base::ListValue);
    for (const auto& entry : string_list.entries())
        list_value->AppendString(entry);
    return list_value;
}

std::unique_ptr<base::Value> DecodeJson(const std::string& json)
{
    std::unique_ptr<base::Value> root = base::JSONReader::Read(json, base::JSON_ALLOW_TRAILING_COMMAS);

    if (!root)
        LOG(WARNING) << "Invalid JSON string, ignoring: " << json;

    // Accept any Value type that parsed as JSON, and leave it to the handler to
    // convert and check the concrete type.
    return root;
}

void DecodePolicy(const em::CloudPolicySettings& policy,
    base::WeakPtr<CloudExternalDataManager> external_data_manager,
    PolicyMap* map)
{
    if (policy.has_alternateerrorpagesenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.alternateerrorpagesenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kAlternateErrorPagesEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_searchsuggestenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.searchsuggestenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kSearchSuggestEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_networkpredictionoptions()) {
        const em::IntegerPolicyProto& policy_proto = policy.networkpredictionoptions();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kNetworkPredictionOptions,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_javascriptenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.javascriptenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kJavascriptEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_incognitoenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.incognitoenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kIncognitoEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_incognitomodeavailability()) {
        const em::IntegerPolicyProto& policy_proto = policy.incognitomodeavailability();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kIncognitoModeAvailability,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_savingbrowserhistorydisabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.savingbrowserhistorydisabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kSavingBrowserHistoryDisabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_printingenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.printingenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kPrintingEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_forcesafesearch()) {
        const em::BooleanPolicyProto& policy_proto = policy.forcesafesearch();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kForceSafeSearch,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_forcegooglesafesearch()) {
        const em::BooleanPolicyProto& policy_proto = policy.forcegooglesafesearch();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kForceGoogleSafeSearch,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_forceyoutubesafetymode()) {
        const em::BooleanPolicyProto& policy_proto = policy.forceyoutubesafetymode();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kForceYouTubeSafetyMode,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_forceyoutuberestrict()) {
        const em::IntegerPolicyProto& policy_proto = policy.forceyoutuberestrict();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kForceYouTubeRestrict,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_safebrowsingenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.safebrowsingenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kSafeBrowsingEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_passwordmanagerenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.passwordmanagerenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kPasswordManagerEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_autofillenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.autofillenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kAutoFillEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_signinallowed()) {
        const em::BooleanPolicyProto& policy_proto = policy.signinallowed();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kSigninAllowed,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_proxymode()) {
        const em::StringPolicyProto& policy_proto = policy.proxymode();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kProxyMode,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_proxyservermode()) {
        const em::IntegerPolicyProto& policy_proto = policy.proxyservermode();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kProxyServerMode,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_proxyserver()) {
        const em::StringPolicyProto& policy_proto = policy.proxyserver();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kProxyServer,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_proxypacurl()) {
        const em::StringPolicyProto& policy_proto = policy.proxypacurl();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kProxyPacUrl,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_proxybypasslist()) {
        const em::StringPolicyProto& policy_proto = policy.proxybypasslist();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kProxyBypassList,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_proxysettings()) {
        const em::StringPolicyProto& policy_proto = policy.proxysettings();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kProxySettings,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_authschemes()) {
        const em::StringPolicyProto& policy_proto = policy.authschemes();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kAuthSchemes,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_disableauthnegotiatecnamelookup()) {
        const em::BooleanPolicyProto& policy_proto = policy.disableauthnegotiatecnamelookup();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDisableAuthNegotiateCnameLookup,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_authserverwhitelist()) {
        const em::StringPolicyProto& policy_proto = policy.authserverwhitelist();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kAuthServerWhitelist,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_authnegotiatedelegatewhitelist()) {
        const em::StringPolicyProto& policy_proto = policy.authnegotiatedelegatewhitelist();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kAuthNegotiateDelegateWhitelist,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_authandroidnegotiateaccounttype()) {
        const em::StringPolicyProto& policy_proto = policy.authandroidnegotiateaccounttype();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kAuthAndroidNegotiateAccountType,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchproviderenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.defaultsearchproviderenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidername()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidername();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderName,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchproviderkeyword()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderkeyword();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderKeyword,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidersearchurl()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersearchurl();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderSearchURL,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidersuggesturl()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersuggesturl();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderSuggestURL,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchproviderinstanturl()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderinstanturl();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderInstantURL,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidericonurl()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidericonurl();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderIconURL,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchproviderencodings()) {
        const em::StringListPolicyProto& policy_proto = policy.defaultsearchproviderencodings();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderEncodings,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovideralternateurls()) {
        const em::StringListPolicyProto& policy_proto = policy.defaultsearchprovideralternateurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderAlternateURLs,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidersearchtermsreplacementkey()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersearchtermsreplacementkey();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderSearchTermsReplacementKey,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchproviderimageurl()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderimageurl();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderImageURL,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidernewtaburl()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidernewtaburl();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderNewTabURL,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidersearchurlpostparams()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersearchurlpostparams();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderSearchURLPostParams,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchprovidersuggesturlpostparams()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersuggesturlpostparams();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderSuggestURLPostParams,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchproviderinstanturlpostparams()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderinstanturlpostparams();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderInstantURLPostParams,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultsearchproviderimageurlpostparams()) {
        const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderimageurlpostparams();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultSearchProviderImageURLPostParams,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultcookiessetting()) {
        const em::IntegerPolicyProto& policy_proto = policy.defaultcookiessetting();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultCookiesSetting,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultimagessetting()) {
        const em::IntegerPolicyProto& policy_proto = policy.defaultimagessetting();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultImagesSetting,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultjavascriptsetting()) {
        const em::IntegerPolicyProto& policy_proto = policy.defaultjavascriptsetting();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultJavaScriptSetting,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultpopupssetting()) {
        const em::IntegerPolicyProto& policy_proto = policy.defaultpopupssetting();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultPopupsSetting,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultgeolocationsetting()) {
        const em::IntegerPolicyProto& policy_proto = policy.defaultgeolocationsetting();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultGeolocationSetting,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_defaultwebbluetoothguardsetting()) {
        const em::IntegerPolicyProto& policy_proto = policy.defaultwebbluetoothguardsetting();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDefaultWebBluetoothGuardSetting,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_cookiesallowedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.cookiesallowedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kCookiesAllowedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_cookiesblockedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.cookiesblockedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kCookiesBlockedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_cookiessessiononlyforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.cookiessessiononlyforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kCookiesSessionOnlyForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_imagesallowedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.imagesallowedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kImagesAllowedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_imagesblockedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.imagesblockedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kImagesBlockedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_javascriptallowedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.javascriptallowedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kJavaScriptAllowedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_javascriptblockedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.javascriptblockedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kJavaScriptBlockedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_popupsallowedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.popupsallowedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kPopupsAllowedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_popupsblockedforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.popupsblockedforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kPopupsBlockedForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_translateenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.translateenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kTranslateEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_editbookmarksenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.editbookmarksenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kEditBookmarksEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_urlblacklist()) {
        const em::StringListPolicyProto& policy_proto = policy.urlblacklist();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kURLBlacklist,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_urlwhitelist()) {
        const em::StringListPolicyProto& policy_proto = policy.urlwhitelist();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kURLWhitelist,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_enablesha1forlocalanchors()) {
        const em::BooleanPolicyProto& policy_proto = policy.enablesha1forlocalanchors();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kEnableSha1ForLocalAnchors,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_disablesafebrowsingproceedanyway()) {
        const em::BooleanPolicyProto& policy_proto = policy.disablesafebrowsingproceedanyway();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDisableSafeBrowsingProceedAnyway,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_variationsrestrictparameter()) {
        const em::StringPolicyProto& policy_proto = policy.variationsrestrictparameter();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kVariationsRestrictParameter,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_supervisedusercontentproviderenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.supervisedusercontentproviderenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kSupervisedUserContentProviderEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_managedbookmarks()) {
        const em::StringPolicyProto& policy_proto = policy.managedbookmarks();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kManagedBookmarks,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_datacompressionproxyenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.datacompressionproxyenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDataCompressionProxyEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_enabledeprecatedwebplatformfeatures()) {
        const em::StringListPolicyProto& policy_proto = policy.enabledeprecatedwebplatformfeatures();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kEnableDeprecatedWebPlatformFeatures,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_forcebrowsersignin()) {
        const em::BooleanPolicyProto& policy_proto = policy.forcebrowsersignin();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kForceBrowserSignin,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_certificatetransparencyenforcementdisabledforurls()) {
        const em::StringListPolicyProto& policy_proto = policy.certificatetransparencyenforcementdisabledforurls();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kCertificateTransparencyEnforcementDisabledForUrls,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_dheenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.dheenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kDHEEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_contextualsearchenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.contextualsearchenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kContextualSearchEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_sslerroroverrideallowed()) {
        const em::BooleanPolicyProto& policy_proto = policy.sslerroroverrideallowed();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kSSLErrorOverrideAllowed,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_alloweddomainsforapps()) {
        const em::StringPolicyProto& policy_proto = policy.alloweddomainsforapps();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kAllowedDomainsForApps,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_enablemediarouter()) {
        const em::BooleanPolicyProto& policy_proto = policy.enablemediarouter();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kEnableMediaRouter,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_ntpcontentsuggestionsenabled()) {
        const em::BooleanPolicyProto& policy_proto = policy.ntpcontentsuggestionsenabled();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::FundamentalValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kNTPContentSuggestionsEnabled,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
    if (policy.has_webrtcudpportrange()) {
        const em::StringPolicyProto& policy_proto = policy.webrtcudpportrange();
        if (policy_proto.has_value()) {
            PolicyLevel level = POLICY_LEVEL_MANDATORY;
            bool do_set = true;
            if (policy_proto.has_policy_options()) {
                do_set = false;
                switch (policy_proto.policy_options().mode()) {
                case em::PolicyOptions::MANDATORY:
                    do_set = true;
                    level = POLICY_LEVEL_MANDATORY;
                    break;
                case em::PolicyOptions::RECOMMENDED:
                    do_set = true;
                    level = POLICY_LEVEL_RECOMMENDED;
                    break;
                case em::PolicyOptions::UNSET:
                    break;
                }
            }
            if (do_set) {
                std::unique_ptr<base::Value> value(new base::StringValue(policy_proto.value()));
                if (value) {
                    std::unique_ptr<ExternalDataFetcher>
                        external_data_fetcher(nullptr);
                    map->Set(key::kWebRtcUdpPortRange,
                        level,
                        POLICY_SCOPE_USER,
                        POLICY_SOURCE_CLOUD,
                        std::move(value),
                        std::move(external_data_fetcher));
                }
            }
        }
    }
}

} // namespace policy
