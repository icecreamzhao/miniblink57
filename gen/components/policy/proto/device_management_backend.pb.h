// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_management_backend.proto

#ifndef PROTOBUF_device_5fmanagement_5fbackend_2eproto__INCLUDED
#define PROTOBUF_device_5fmanagement_5fbackend_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)
#include "components/policy/proto/policy_proto_export.h"

namespace enterprise_management {

// Internal implementation detail -- do not call these.
void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

class ActiveTimePeriod;
class AndroidStatus;
class AppStatus;
class CPUTempInfo;
class CertificateBasedDeviceRegisterRequest;
class CertificateBasedDeviceRegistrationData;
class CheckAndroidManagementRequest;
class CheckAndroidManagementResponse;
class CheckDevicePairingRequest;
class CheckDevicePairingResponse;
class DEPRECATEDPolicyPublicKeyAndDomain;
class DeviceAttributeUpdatePermissionRequest;
class DeviceAttributeUpdatePermissionResponse;
class DeviceAttributeUpdateRequest;
class DeviceAttributeUpdateResponse;
class DeviceAutoEnrollmentRequest;
class DeviceAutoEnrollmentResponse;
class DeviceCertUploadRequest;
class DeviceCertUploadResponse;
class DeviceManagementRequest;
class DeviceManagementResponse;
class DevicePairingRequest;
class DevicePairingResponse;
class DevicePolicyRequest;
class DevicePolicyResponse;
class DeviceRegisterRequest;
class DeviceRegisterResponse;
class DeviceRemoteCommandRequest;
class DeviceRemoteCommandResponse;
class DeviceServiceApiAccessRequest;
class DeviceServiceApiAccessResponse;
class DeviceState;
class DeviceStateKeyUpdateRequest;
class DeviceStateRetrievalRequest;
class DeviceStateRetrievalResponse;
class DeviceStatusReportRequest;
class DeviceStatusReportResponse;
class DeviceUnregisterRequest;
class DeviceUnregisterResponse;
class DeviceUser;
class DisabledState;
class GcmIdUpdateRequest;
class GcmIdUpdateResponse;
class InstallableLaunch;
class NetworkInterface;
class NetworkState;
class OBSOLETE_DeviceLocation;
class OsUpdateStatus;
class PolicyData;
class PolicyFetchRequest;
class PolicyFetchResponse;
class PublicKeyVerificationData;
class RemoteCommand;
class RemoteCommandResult;
class SessionStatusReportRequest;
class SessionStatusReportResponse;
class SignedData;
class TimePeriod;
class VolumeInfo;

enum DeviceRegisterRequest_Type {
    DeviceRegisterRequest_Type_TT = 0,
    DeviceRegisterRequest_Type_USER = 1,
    DeviceRegisterRequest_Type_DEVICE = 2,
    DeviceRegisterRequest_Type_BROWSER = 3,
    DeviceRegisterRequest_Type_ANDROID_BROWSER = 4,
    DeviceRegisterRequest_Type_IOS_BROWSER = 5
};
POLICY_PROTO_EXPORT bool DeviceRegisterRequest_Type_IsValid(int value);
const DeviceRegisterRequest_Type DeviceRegisterRequest_Type_Type_MIN = DeviceRegisterRequest_Type_TT;
const DeviceRegisterRequest_Type DeviceRegisterRequest_Type_Type_MAX = DeviceRegisterRequest_Type_IOS_BROWSER;
const int DeviceRegisterRequest_Type_Type_ARRAYSIZE = DeviceRegisterRequest_Type_Type_MAX + 1;

enum DeviceRegisterRequest_Flavor {
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL = 0,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL_RENEW = 1,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_FORCED = 2,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_ADVERTISED = 3,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_FORCED = 4,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_ADVERTISED = 5,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_RECOVERY = 6,
    DeviceRegisterRequest_Flavor_FLAVOR_USER_REGISTRATION = 7,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION = 8,
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_FORCED = 9
};
POLICY_PROTO_EXPORT bool DeviceRegisterRequest_Flavor_IsValid(int value);
const DeviceRegisterRequest_Flavor DeviceRegisterRequest_Flavor_Flavor_MIN = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL;
const DeviceRegisterRequest_Flavor DeviceRegisterRequest_Flavor_Flavor_MAX = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_FORCED;
const int DeviceRegisterRequest_Flavor_Flavor_ARRAYSIZE = DeviceRegisterRequest_Flavor_Flavor_MAX + 1;

enum DeviceRegisterResponse_DeviceMode {
    DeviceRegisterResponse_DeviceMode_ENTERPRISE = 0,
    DeviceRegisterResponse_DeviceMode_RETAIL = 1,
    DeviceRegisterResponse_DeviceMode_CHROME_AD = 2
};
POLICY_PROTO_EXPORT bool DeviceRegisterResponse_DeviceMode_IsValid(int value);
const DeviceRegisterResponse_DeviceMode DeviceRegisterResponse_DeviceMode_DeviceMode_MIN = DeviceRegisterResponse_DeviceMode_ENTERPRISE;
const DeviceRegisterResponse_DeviceMode DeviceRegisterResponse_DeviceMode_DeviceMode_MAX = DeviceRegisterResponse_DeviceMode_CHROME_AD;
const int DeviceRegisterResponse_DeviceMode_DeviceMode_ARRAYSIZE = DeviceRegisterResponse_DeviceMode_DeviceMode_MAX + 1;

enum DeviceServiceApiAccessRequest_DeviceType {
    DeviceServiceApiAccessRequest_DeviceType_CHROME = 0,
    DeviceServiceApiAccessRequest_DeviceType_ANDROIDOS = 1
};
POLICY_PROTO_EXPORT bool DeviceServiceApiAccessRequest_DeviceType_IsValid(int value);
const DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest_DeviceType_DeviceType_MIN = DeviceServiceApiAccessRequest_DeviceType_CHROME;
const DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX = DeviceServiceApiAccessRequest_DeviceType_ANDROIDOS;
const int DeviceServiceApiAccessRequest_DeviceType_DeviceType_ARRAYSIZE = DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX + 1;

enum PolicyFetchRequest_SignatureType {
    PolicyFetchRequest_SignatureType_NONE = 0,
    PolicyFetchRequest_SignatureType_SHA1_RSA = 1
};
POLICY_PROTO_EXPORT bool PolicyFetchRequest_SignatureType_IsValid(int value);
const PolicyFetchRequest_SignatureType PolicyFetchRequest_SignatureType_SignatureType_MIN = PolicyFetchRequest_SignatureType_NONE;
const PolicyFetchRequest_SignatureType PolicyFetchRequest_SignatureType_SignatureType_MAX = PolicyFetchRequest_SignatureType_SHA1_RSA;
const int PolicyFetchRequest_SignatureType_SignatureType_ARRAYSIZE = PolicyFetchRequest_SignatureType_SignatureType_MAX + 1;

enum DeviceState_DeviceMode {
    DeviceState_DeviceMode_DEVICE_MODE_NORMAL = 0,
    DeviceState_DeviceMode_DEVICE_MODE_DISABLED = 1
};
POLICY_PROTO_EXPORT bool DeviceState_DeviceMode_IsValid(int value);
const DeviceState_DeviceMode DeviceState_DeviceMode_DeviceMode_MIN = DeviceState_DeviceMode_DEVICE_MODE_NORMAL;
const DeviceState_DeviceMode DeviceState_DeviceMode_DeviceMode_MAX = DeviceState_DeviceMode_DEVICE_MODE_DISABLED;
const int DeviceState_DeviceMode_DeviceMode_ARRAYSIZE = DeviceState_DeviceMode_DeviceMode_MAX + 1;

enum PolicyData_AssociationState {
    PolicyData_AssociationState_ACTIVE = 0,
    PolicyData_AssociationState_UNMANAGED = 1,
    PolicyData_AssociationState_DEPROVISIONED = 2
};
POLICY_PROTO_EXPORT bool PolicyData_AssociationState_IsValid(int value);
const PolicyData_AssociationState PolicyData_AssociationState_AssociationState_MIN = PolicyData_AssociationState_ACTIVE;
const PolicyData_AssociationState PolicyData_AssociationState_AssociationState_MAX = PolicyData_AssociationState_DEPROVISIONED;
const int PolicyData_AssociationState_AssociationState_ARRAYSIZE = PolicyData_AssociationState_AssociationState_MAX + 1;

enum PolicyData_ManagementMode {
    PolicyData_ManagementMode_LOCAL_OWNER = 0,
    PolicyData_ManagementMode_ENTERPRISE_MANAGED = 1,
    PolicyData_ManagementMode_CONSUMER_MANAGED = 2
};
POLICY_PROTO_EXPORT bool PolicyData_ManagementMode_IsValid(int value);
const PolicyData_ManagementMode PolicyData_ManagementMode_ManagementMode_MIN = PolicyData_ManagementMode_LOCAL_OWNER;
const PolicyData_ManagementMode PolicyData_ManagementMode_ManagementMode_MAX = PolicyData_ManagementMode_CONSUMER_MANAGED;
const int PolicyData_ManagementMode_ManagementMode_ARRAYSIZE = PolicyData_ManagementMode_ManagementMode_MAX + 1;

enum OBSOLETE_DeviceLocation_ErrorCode {
    OBSOLETE_DeviceLocation_ErrorCode_ERROR_CODE_NONE = 0,
    OBSOLETE_DeviceLocation_ErrorCode_ERROR_CODE_POSITION_UNAVAILABLE = 1
};
POLICY_PROTO_EXPORT bool OBSOLETE_DeviceLocation_ErrorCode_IsValid(int value);
const OBSOLETE_DeviceLocation_ErrorCode OBSOLETE_DeviceLocation_ErrorCode_ErrorCode_MIN = OBSOLETE_DeviceLocation_ErrorCode_ERROR_CODE_NONE;
const OBSOLETE_DeviceLocation_ErrorCode OBSOLETE_DeviceLocation_ErrorCode_ErrorCode_MAX = OBSOLETE_DeviceLocation_ErrorCode_ERROR_CODE_POSITION_UNAVAILABLE;
const int OBSOLETE_DeviceLocation_ErrorCode_ErrorCode_ARRAYSIZE = OBSOLETE_DeviceLocation_ErrorCode_ErrorCode_MAX + 1;

enum NetworkInterface_NetworkDeviceType {
    NetworkInterface_NetworkDeviceType_TYPE_ETHERNET = 0,
    NetworkInterface_NetworkDeviceType_TYPE_WIFI = 1,
    NetworkInterface_NetworkDeviceType_TYPE_WIMAX = 2,
    NetworkInterface_NetworkDeviceType_TYPE_BLUETOOTH = 3,
    NetworkInterface_NetworkDeviceType_TYPE_CELLULAR = 4
};
POLICY_PROTO_EXPORT bool NetworkInterface_NetworkDeviceType_IsValid(int value);
const NetworkInterface_NetworkDeviceType NetworkInterface_NetworkDeviceType_NetworkDeviceType_MIN = NetworkInterface_NetworkDeviceType_TYPE_ETHERNET;
const NetworkInterface_NetworkDeviceType NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX = NetworkInterface_NetworkDeviceType_TYPE_CELLULAR;
const int NetworkInterface_NetworkDeviceType_NetworkDeviceType_ARRAYSIZE = NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX + 1;

enum NetworkState_ConnectionState {
    NetworkState_ConnectionState_IDLE = 0,
    NetworkState_ConnectionState_CARRIER = 1,
    NetworkState_ConnectionState_ASSOCIATION = 2,
    NetworkState_ConnectionState_CONFIGURATION = 3,
    NetworkState_ConnectionState_READY = 4,
    NetworkState_ConnectionState_PORTAL = 5,
    NetworkState_ConnectionState_OFFLINE = 6,
    NetworkState_ConnectionState_ONLINE = 7,
    NetworkState_ConnectionState_DISCONNECT = 8,
    NetworkState_ConnectionState_FAILURE = 9,
    NetworkState_ConnectionState_ACTIVATION_FAILURE = 10,
    NetworkState_ConnectionState_UNKNOWN = 11
};
POLICY_PROTO_EXPORT bool NetworkState_ConnectionState_IsValid(int value);
const NetworkState_ConnectionState NetworkState_ConnectionState_ConnectionState_MIN = NetworkState_ConnectionState_IDLE;
const NetworkState_ConnectionState NetworkState_ConnectionState_ConnectionState_MAX = NetworkState_ConnectionState_UNKNOWN;
const int NetworkState_ConnectionState_ConnectionState_ARRAYSIZE = NetworkState_ConnectionState_ConnectionState_MAX + 1;

enum DeviceUser_UserType {
    DeviceUser_UserType_USER_TYPE_MANAGED = 0,
    DeviceUser_UserType_USER_TYPE_UNMANAGED = 1
};
POLICY_PROTO_EXPORT bool DeviceUser_UserType_IsValid(int value);
const DeviceUser_UserType DeviceUser_UserType_UserType_MIN = DeviceUser_UserType_USER_TYPE_MANAGED;
const DeviceUser_UserType DeviceUser_UserType_UserType_MAX = DeviceUser_UserType_USER_TYPE_UNMANAGED;
const int DeviceUser_UserType_UserType_ARRAYSIZE = DeviceUser_UserType_UserType_MAX + 1;

enum OsUpdateStatus_UpdateStatus {
    OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE = 0,
    OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_NOT_STARTED = 1,
    OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_IN_PROGRESS = 2,
    OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT = 3
};
POLICY_PROTO_EXPORT bool OsUpdateStatus_UpdateStatus_IsValid(int value);
const OsUpdateStatus_UpdateStatus OsUpdateStatus_UpdateStatus_UpdateStatus_MIN = OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE;
const OsUpdateStatus_UpdateStatus OsUpdateStatus_UpdateStatus_UpdateStatus_MAX = OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT;
const int OsUpdateStatus_UpdateStatus_UpdateStatus_ARRAYSIZE = OsUpdateStatus_UpdateStatus_UpdateStatus_MAX + 1;

enum DeviceStateRetrievalResponse_RestoreMode {
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE = 0,
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_REQUESTED = 1,
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ENFORCED = 2,
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_DISABLED = 3
};
POLICY_PROTO_EXPORT bool DeviceStateRetrievalResponse_RestoreMode_IsValid(int value);
const DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MIN = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE;
const DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_DISABLED;
const int DeviceStateRetrievalResponse_RestoreMode_RestoreMode_ARRAYSIZE = DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX + 1;

enum DevicePairingResponse_StatusCode {
    DevicePairingResponse_StatusCode_SUCCESS = 0,
    DevicePairingResponse_StatusCode_FAILED = 1,
    DevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND = 2,
    DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND = 3,
    DevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED = 4,
    DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED = 5
};
POLICY_PROTO_EXPORT bool DevicePairingResponse_StatusCode_IsValid(int value);
const DevicePairingResponse_StatusCode DevicePairingResponse_StatusCode_StatusCode_MIN = DevicePairingResponse_StatusCode_SUCCESS;
const DevicePairingResponse_StatusCode DevicePairingResponse_StatusCode_StatusCode_MAX = DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
const int DevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE = DevicePairingResponse_StatusCode_StatusCode_MAX + 1;

enum CheckDevicePairingResponse_StatusCode {
    CheckDevicePairingResponse_StatusCode_PAIRED = 0,
    CheckDevicePairingResponse_StatusCode_NOT_PAIRED = 1,
    CheckDevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND = 2,
    CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND = 3,
    CheckDevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED = 4,
    CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED = 5,
    CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY = 6
};
POLICY_PROTO_EXPORT bool CheckDevicePairingResponse_StatusCode_IsValid(int value);
const CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse_StatusCode_StatusCode_MIN = CheckDevicePairingResponse_StatusCode_PAIRED;
const CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse_StatusCode_StatusCode_MAX = CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY;
const int CheckDevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE = CheckDevicePairingResponse_StatusCode_StatusCode_MAX + 1;

enum RemoteCommand_Type {
    RemoteCommand_Type_COMMAND_ECHO_TEST = -1,
    RemoteCommand_Type_DEVICE_REBOOT = 0,
    RemoteCommand_Type_DEVICE_SCREENSHOT = 1
};
POLICY_PROTO_EXPORT bool RemoteCommand_Type_IsValid(int value);
const RemoteCommand_Type RemoteCommand_Type_Type_MIN = RemoteCommand_Type_COMMAND_ECHO_TEST;
const RemoteCommand_Type RemoteCommand_Type_Type_MAX = RemoteCommand_Type_DEVICE_SCREENSHOT;
const int RemoteCommand_Type_Type_ARRAYSIZE = RemoteCommand_Type_Type_MAX + 1;

enum RemoteCommandResult_ResultType {
    RemoteCommandResult_ResultType_RESULT_IGNORED = 0,
    RemoteCommandResult_ResultType_RESULT_FAILURE = 1,
    RemoteCommandResult_ResultType_RESULT_SUCCESS = 2
};
POLICY_PROTO_EXPORT bool RemoteCommandResult_ResultType_IsValid(int value);
const RemoteCommandResult_ResultType RemoteCommandResult_ResultType_ResultType_MIN = RemoteCommandResult_ResultType_RESULT_IGNORED;
const RemoteCommandResult_ResultType RemoteCommandResult_ResultType_ResultType_MAX = RemoteCommandResult_ResultType_RESULT_SUCCESS;
const int RemoteCommandResult_ResultType_ResultType_ARRAYSIZE = RemoteCommandResult_ResultType_ResultType_MAX + 1;

enum DeviceAttributeUpdatePermissionResponse_ResultType {
    DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED = 0,
    DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED = 1
};
POLICY_PROTO_EXPORT bool DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(int value);
const DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MIN = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED;
const DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED;
const int DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_ARRAYSIZE = DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX + 1;

enum DeviceAttributeUpdateResponse_ResultType {
    DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR = 0,
    DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS = 1
};
POLICY_PROTO_EXPORT bool DeviceAttributeUpdateResponse_ResultType_IsValid(int value);
const DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse_ResultType_ResultType_MIN = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR;
const DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse_ResultType_ResultType_MAX = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS;
const int DeviceAttributeUpdateResponse_ResultType_ResultType_ARRAYSIZE = DeviceAttributeUpdateResponse_ResultType_ResultType_MAX + 1;

enum CertificateBasedDeviceRegistrationData_CertificateType {
    CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN = 0,
    CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE = 1
};
POLICY_PROTO_EXPORT bool CertificateBasedDeviceRegistrationData_CertificateType_IsValid(int value);
const CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MIN = CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN;
const CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX = CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
const int CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_ARRAYSIZE = CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX + 1;

enum DeviceManagementResponse_ErrorCode {
    DeviceManagementResponse_ErrorCode_SUCCESS = 0,
    DeviceManagementResponse_ErrorCode_DEVICE_MANAGEMENT_NOT_SUPPORTED = 1,
    DeviceManagementResponse_ErrorCode_DEVICE_NOT_FOUND = 2,
    DeviceManagementResponse_ErrorCode_DEVICE_MANAGEMENT_TOKEN_INVALID = 3,
    DeviceManagementResponse_ErrorCode_ACTIVATION_PENDING = 4,
    DeviceManagementResponse_ErrorCode_POLICY_NOT_FOUND = 5
};
POLICY_PROTO_EXPORT bool DeviceManagementResponse_ErrorCode_IsValid(int value);
const DeviceManagementResponse_ErrorCode DeviceManagementResponse_ErrorCode_ErrorCode_MIN = DeviceManagementResponse_ErrorCode_SUCCESS;
const DeviceManagementResponse_ErrorCode DeviceManagementResponse_ErrorCode_ErrorCode_MAX = DeviceManagementResponse_ErrorCode_POLICY_NOT_FOUND;
const int DeviceManagementResponse_ErrorCode_ErrorCode_ARRAYSIZE = DeviceManagementResponse_ErrorCode_ErrorCode_MAX + 1;

// ===================================================================

class POLICY_PROTO_EXPORT SignedData : public ::google::protobuf::MessageLite {
public:
    SignedData();
    virtual ~SignedData();

    SignedData(const SignedData& from);

    inline SignedData& operator=(const SignedData& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const SignedData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const SignedData* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(SignedData* other);

    // implements Message ----------------------------------------------

    inline SignedData* New() const { return New(NULL); }

    SignedData* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const SignedData& from);
    void MergeFrom(const SignedData& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SignedData* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes data = 1;
    bool has_data() const;
    void clear_data();
    static const int kDataFieldNumber = 1;
    const ::std::string& data() const;
    void set_data(const ::std::string& value);
    void set_data(const char* value);
    void set_data(const void* value, size_t size);
    ::std::string* mutable_data();
    ::std::string* release_data();
    void set_allocated_data(::std::string* data);

    // optional bytes signature = 2;
    bool has_signature() const;
    void clear_signature();
    static const int kSignatureFieldNumber = 2;
    const ::std::string& signature() const;
    void set_signature(const ::std::string& value);
    void set_signature(const char* value);
    void set_signature(const void* value, size_t size);
    ::std::string* mutable_signature();
    ::std::string* release_signature();
    void set_allocated_signature(::std::string* signature);

    // optional int32 extra_data_bytes = 3;
    bool has_extra_data_bytes() const;
    void clear_extra_data_bytes();
    static const int kExtraDataBytesFieldNumber = 3;
    ::google::protobuf::int32 extra_data_bytes() const;
    void set_extra_data_bytes(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.SignedData)
private:
    inline void set_has_data();
    inline void clear_has_data();
    inline void set_has_signature();
    inline void clear_has_signature();
    inline void set_has_extra_data_bytes();
    inline void clear_has_extra_data_bytes();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::google::protobuf::int32 extra_data_bytes_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static SignedData* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRegisterRequest : public ::google::protobuf::MessageLite {
public:
    DeviceRegisterRequest();
    virtual ~DeviceRegisterRequest();

    DeviceRegisterRequest(const DeviceRegisterRequest& from);

    inline DeviceRegisterRequest& operator=(const DeviceRegisterRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceRegisterRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceRegisterRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceRegisterRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceRegisterRequest* New() const { return New(NULL); }

    DeviceRegisterRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceRegisterRequest& from);
    void MergeFrom(const DeviceRegisterRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceRegisterRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceRegisterRequest_Type Type;
    static const Type TT = DeviceRegisterRequest_Type_TT;
    static const Type USER = DeviceRegisterRequest_Type_USER;
    static const Type DEVICE = DeviceRegisterRequest_Type_DEVICE;
    static const Type BROWSER = DeviceRegisterRequest_Type_BROWSER;
    static const Type ANDROID_BROWSER = DeviceRegisterRequest_Type_ANDROID_BROWSER;
    static const Type IOS_BROWSER = DeviceRegisterRequest_Type_IOS_BROWSER;
    static inline bool Type_IsValid(int value)
    {
        return DeviceRegisterRequest_Type_IsValid(value);
    }
    static const Type Type_MIN = DeviceRegisterRequest_Type_Type_MIN;
    static const Type Type_MAX = DeviceRegisterRequest_Type_Type_MAX;
    static const int Type_ARRAYSIZE = DeviceRegisterRequest_Type_Type_ARRAYSIZE;

    typedef DeviceRegisterRequest_Flavor Flavor;
    static const Flavor FLAVOR_ENROLLMENT_MANUAL = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL;
    static const Flavor FLAVOR_ENROLLMENT_MANUAL_RENEW = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL_RENEW;
    static const Flavor FLAVOR_ENROLLMENT_LOCAL_FORCED = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_FORCED;
    static const Flavor FLAVOR_ENROLLMENT_LOCAL_ADVERTISED = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_ADVERTISED;
    static const Flavor FLAVOR_ENROLLMENT_SERVER_FORCED = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_FORCED;
    static const Flavor FLAVOR_ENROLLMENT_SERVER_ADVERTISED = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_ADVERTISED;
    static const Flavor FLAVOR_ENROLLMENT_RECOVERY = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_RECOVERY;
    static const Flavor FLAVOR_USER_REGISTRATION = DeviceRegisterRequest_Flavor_FLAVOR_USER_REGISTRATION;
    static const Flavor FLAVOR_ENROLLMENT_ATTESTATION = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION;
    static const Flavor FLAVOR_ENROLLMENT_ATTESTATION_FORCED = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_FORCED;
    static inline bool Flavor_IsValid(int value)
    {
        return DeviceRegisterRequest_Flavor_IsValid(value);
    }
    static const Flavor Flavor_MIN = DeviceRegisterRequest_Flavor_Flavor_MIN;
    static const Flavor Flavor_MAX = DeviceRegisterRequest_Flavor_Flavor_MAX;
    static const int Flavor_ARRAYSIZE = DeviceRegisterRequest_Flavor_Flavor_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional bool reregister = 1;
    bool has_reregister() const;
    void clear_reregister();
    static const int kReregisterFieldNumber = 1;
    bool reregister() const;
    void set_reregister(bool value);

    // optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
    bool has_type() const;
    void clear_type();
    static const int kTypeFieldNumber = 2;
    ::enterprise_management::DeviceRegisterRequest_Type type() const;
    void set_type(::enterprise_management::DeviceRegisterRequest_Type value);

    // optional string machine_id = 3;
    bool has_machine_id() const;
    void clear_machine_id();
    static const int kMachineIdFieldNumber = 3;
    const ::std::string& machine_id() const;
    void set_machine_id(const ::std::string& value);
    void set_machine_id(const char* value);
    void set_machine_id(const char* value, size_t size);
    ::std::string* mutable_machine_id();
    ::std::string* release_machine_id();
    void set_allocated_machine_id(::std::string* machine_id);

    // optional string machine_model = 4;
    bool has_machine_model() const;
    void clear_machine_model();
    static const int kMachineModelFieldNumber = 4;
    const ::std::string& machine_model() const;
    void set_machine_model(const ::std::string& value);
    void set_machine_model(const char* value);
    void set_machine_model(const char* value, size_t size);
    ::std::string* mutable_machine_model();
    ::std::string* release_machine_model();
    void set_allocated_machine_model(::std::string* machine_model);

    // optional bool OBSOLETE_auto_enrolled = 5 [deprecated = true];
    PROTOBUF_DEPRECATED_ATTR bool has_obsolete_auto_enrolled() const;
    PROTOBUF_DEPRECATED_ATTR void clear_obsolete_auto_enrolled();
    PROTOBUF_DEPRECATED_ATTR static const int kOBSOLETEAutoEnrolledFieldNumber = 5;
    PROTOBUF_DEPRECATED_ATTR bool obsolete_auto_enrolled() const;
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_auto_enrolled(bool value);

    // optional string requisition = 6;
    bool has_requisition() const;
    void clear_requisition();
    static const int kRequisitionFieldNumber = 6;
    const ::std::string& requisition() const;
    void set_requisition(const ::std::string& value);
    void set_requisition(const char* value);
    void set_requisition(const char* value, size_t size);
    ::std::string* mutable_requisition();
    ::std::string* release_requisition();
    void set_allocated_requisition(::std::string* requisition);

    // optional bytes server_backed_state_key = 7;
    bool has_server_backed_state_key() const;
    void clear_server_backed_state_key();
    static const int kServerBackedStateKeyFieldNumber = 7;
    const ::std::string& server_backed_state_key() const;
    void set_server_backed_state_key(const ::std::string& value);
    void set_server_backed_state_key(const char* value);
    void set_server_backed_state_key(const void* value, size_t size);
    ::std::string* mutable_server_backed_state_key();
    ::std::string* release_server_backed_state_key();
    void set_allocated_server_backed_state_key(::std::string* server_backed_state_key);

    // optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
    bool has_flavor() const;
    void clear_flavor();
    static const int kFlavorFieldNumber = 8;
    ::enterprise_management::DeviceRegisterRequest_Flavor flavor() const;
    void set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterRequest)
private:
    inline void set_has_reregister();
    inline void clear_has_reregister();
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_machine_id();
    inline void clear_has_machine_id();
    inline void set_has_machine_model();
    inline void clear_has_machine_model();
    inline void set_has_obsolete_auto_enrolled();
    inline void clear_has_obsolete_auto_enrolled();
    inline void set_has_requisition();
    inline void clear_has_requisition();
    inline void set_has_server_backed_state_key();
    inline void clear_has_server_backed_state_key();
    inline void set_has_flavor();
    inline void clear_has_flavor();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    int type_;
    bool reregister_;
    bool obsolete_auto_enrolled_;
    ::google::protobuf::internal::ArenaStringPtr machine_id_;
    ::google::protobuf::internal::ArenaStringPtr machine_model_;
    ::google::protobuf::internal::ArenaStringPtr requisition_;
    ::google::protobuf::internal::ArenaStringPtr server_backed_state_key_;
    int flavor_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceRegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRegisterResponse : public ::google::protobuf::MessageLite {
public:
    DeviceRegisterResponse();
    virtual ~DeviceRegisterResponse();

    DeviceRegisterResponse(const DeviceRegisterResponse& from);

    inline DeviceRegisterResponse& operator=(const DeviceRegisterResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceRegisterResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceRegisterResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceRegisterResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceRegisterResponse* New() const { return New(NULL); }

    DeviceRegisterResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceRegisterResponse& from);
    void MergeFrom(const DeviceRegisterResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceRegisterResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceRegisterResponse_DeviceMode DeviceMode;
    static const DeviceMode ENTERPRISE = DeviceRegisterResponse_DeviceMode_ENTERPRISE;
    static const DeviceMode RETAIL = DeviceRegisterResponse_DeviceMode_RETAIL;
    static const DeviceMode CHROME_AD = DeviceRegisterResponse_DeviceMode_CHROME_AD;
    static inline bool DeviceMode_IsValid(int value)
    {
        return DeviceRegisterResponse_DeviceMode_IsValid(value);
    }
    static const DeviceMode DeviceMode_MIN = DeviceRegisterResponse_DeviceMode_DeviceMode_MIN;
    static const DeviceMode DeviceMode_MAX = DeviceRegisterResponse_DeviceMode_DeviceMode_MAX;
    static const int DeviceMode_ARRAYSIZE = DeviceRegisterResponse_DeviceMode_DeviceMode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // required string device_management_token = 1;
    bool has_device_management_token() const;
    void clear_device_management_token();
    static const int kDeviceManagementTokenFieldNumber = 1;
    const ::std::string& device_management_token() const;
    void set_device_management_token(const ::std::string& value);
    void set_device_management_token(const char* value);
    void set_device_management_token(const char* value, size_t size);
    ::std::string* mutable_device_management_token();
    ::std::string* release_device_management_token();
    void set_allocated_device_management_token(::std::string* device_management_token);

    // optional string machine_name = 2;
    bool has_machine_name() const;
    void clear_machine_name();
    static const int kMachineNameFieldNumber = 2;
    const ::std::string& machine_name() const;
    void set_machine_name(const ::std::string& value);
    void set_machine_name(const char* value);
    void set_machine_name(const char* value, size_t size);
    ::std::string* mutable_machine_name();
    ::std::string* release_machine_name();
    void set_allocated_machine_name(::std::string* machine_name);

    // optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
    bool has_enrollment_type() const;
    void clear_enrollment_type();
    static const int kEnrollmentTypeFieldNumber = 3;
    ::enterprise_management::DeviceRegisterResponse_DeviceMode enrollment_type() const;
    void set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value);

    // optional string configuration_seed = 4;
    bool has_configuration_seed() const;
    void clear_configuration_seed();
    static const int kConfigurationSeedFieldNumber = 4;
    const ::std::string& configuration_seed() const;
    void set_configuration_seed(const ::std::string& value);
    void set_configuration_seed(const char* value);
    void set_configuration_seed(const char* value, size_t size);
    ::std::string* mutable_configuration_seed();
    ::std::string* release_configuration_seed();
    void set_allocated_configuration_seed(::std::string* configuration_seed);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterResponse)
private:
    inline void set_has_device_management_token();
    inline void clear_has_device_management_token();
    inline void set_has_machine_name();
    inline void clear_has_machine_name();
    inline void set_has_enrollment_type();
    inline void clear_has_enrollment_type();
    inline void set_has_configuration_seed();
    inline void clear_has_configuration_seed();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr device_management_token_;
    ::google::protobuf::internal::ArenaStringPtr machine_name_;
    ::google::protobuf::internal::ArenaStringPtr configuration_seed_;
    int enrollment_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceRegisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceUnregisterRequest : public ::google::protobuf::MessageLite {
public:
    DeviceUnregisterRequest();
    virtual ~DeviceUnregisterRequest();

    DeviceUnregisterRequest(const DeviceUnregisterRequest& from);

    inline DeviceUnregisterRequest& operator=(const DeviceUnregisterRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceUnregisterRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceUnregisterRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceUnregisterRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceUnregisterRequest* New() const { return New(NULL); }

    DeviceUnregisterRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceUnregisterRequest& from);
    void MergeFrom(const DeviceUnregisterRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceUnregisterRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUnregisterRequest)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceUnregisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceUnregisterResponse : public ::google::protobuf::MessageLite {
public:
    DeviceUnregisterResponse();
    virtual ~DeviceUnregisterResponse();

    DeviceUnregisterResponse(const DeviceUnregisterResponse& from);

    inline DeviceUnregisterResponse& operator=(const DeviceUnregisterResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceUnregisterResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceUnregisterResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceUnregisterResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceUnregisterResponse* New() const { return New(NULL); }

    DeviceUnregisterResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceUnregisterResponse& from);
    void MergeFrom(const DeviceUnregisterResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceUnregisterResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUnregisterResponse)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceUnregisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceCertUploadRequest : public ::google::protobuf::MessageLite {
public:
    DeviceCertUploadRequest();
    virtual ~DeviceCertUploadRequest();

    DeviceCertUploadRequest(const DeviceCertUploadRequest& from);

    inline DeviceCertUploadRequest& operator=(const DeviceCertUploadRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceCertUploadRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceCertUploadRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceCertUploadRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceCertUploadRequest* New() const { return New(NULL); }

    DeviceCertUploadRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceCertUploadRequest& from);
    void MergeFrom(const DeviceCertUploadRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceCertUploadRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes device_certificate = 1;
    bool has_device_certificate() const;
    void clear_device_certificate();
    static const int kDeviceCertificateFieldNumber = 1;
    const ::std::string& device_certificate() const;
    void set_device_certificate(const ::std::string& value);
    void set_device_certificate(const char* value);
    void set_device_certificate(const void* value, size_t size);
    ::std::string* mutable_device_certificate();
    ::std::string* release_device_certificate();
    void set_allocated_device_certificate(::std::string* device_certificate);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceCertUploadRequest)
private:
    inline void set_has_device_certificate();
    inline void clear_has_device_certificate();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr device_certificate_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceCertUploadRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceCertUploadResponse : public ::google::protobuf::MessageLite {
public:
    DeviceCertUploadResponse();
    virtual ~DeviceCertUploadResponse();

    DeviceCertUploadResponse(const DeviceCertUploadResponse& from);

    inline DeviceCertUploadResponse& operator=(const DeviceCertUploadResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceCertUploadResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceCertUploadResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceCertUploadResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceCertUploadResponse* New() const { return New(NULL); }

    DeviceCertUploadResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceCertUploadResponse& from);
    void MergeFrom(const DeviceCertUploadResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceCertUploadResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceCertUploadResponse)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceCertUploadResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceServiceApiAccessRequest : public ::google::protobuf::MessageLite {
public:
    DeviceServiceApiAccessRequest();
    virtual ~DeviceServiceApiAccessRequest();

    DeviceServiceApiAccessRequest(const DeviceServiceApiAccessRequest& from);

    inline DeviceServiceApiAccessRequest& operator=(const DeviceServiceApiAccessRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceServiceApiAccessRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceServiceApiAccessRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceServiceApiAccessRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceServiceApiAccessRequest* New() const { return New(NULL); }

    DeviceServiceApiAccessRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceServiceApiAccessRequest& from);
    void MergeFrom(const DeviceServiceApiAccessRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceServiceApiAccessRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceServiceApiAccessRequest_DeviceType DeviceType;
    static const DeviceType CHROME = DeviceServiceApiAccessRequest_DeviceType_CHROME;
    static const DeviceType ANDROIDOS = DeviceServiceApiAccessRequest_DeviceType_ANDROIDOS;
    static inline bool DeviceType_IsValid(int value)
    {
        return DeviceServiceApiAccessRequest_DeviceType_IsValid(value);
    }
    static const DeviceType DeviceType_MIN = DeviceServiceApiAccessRequest_DeviceType_DeviceType_MIN;
    static const DeviceType DeviceType_MAX = DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX;
    static const int DeviceType_ARRAYSIZE = DeviceServiceApiAccessRequest_DeviceType_DeviceType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // repeated string auth_scope = 1;
    int auth_scope_size() const;
    void clear_auth_scope();
    static const int kAuthScopeFieldNumber = 1;
    const ::std::string& auth_scope(int index) const;
    ::std::string* mutable_auth_scope(int index);
    void set_auth_scope(int index, const ::std::string& value);
    void set_auth_scope(int index, const char* value);
    void set_auth_scope(int index, const char* value, size_t size);
    ::std::string* add_auth_scope();
    void add_auth_scope(const ::std::string& value);
    void add_auth_scope(const char* value);
    void add_auth_scope(const char* value, size_t size);
    const ::google::protobuf::RepeatedPtrField<::std::string>& auth_scope() const;
    ::google::protobuf::RepeatedPtrField<::std::string>* mutable_auth_scope();

    // optional string oauth2_client_id = 2;
    bool has_oauth2_client_id() const;
    void clear_oauth2_client_id();
    static const int kOauth2ClientIdFieldNumber = 2;
    const ::std::string& oauth2_client_id() const;
    void set_oauth2_client_id(const ::std::string& value);
    void set_oauth2_client_id(const char* value);
    void set_oauth2_client_id(const char* value, size_t size);
    ::std::string* mutable_oauth2_client_id();
    ::std::string* release_oauth2_client_id();
    void set_allocated_oauth2_client_id(::std::string* oauth2_client_id);

    // optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
    bool has_device_type() const;
    void clear_device_type();
    static const int kDeviceTypeFieldNumber = 3;
    ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType device_type() const;
    void set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceServiceApiAccessRequest)
private:
    inline void set_has_oauth2_client_id();
    inline void clear_has_oauth2_client_id();
    inline void set_has_device_type();
    inline void clear_has_device_type();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> auth_scope_;
    ::google::protobuf::internal::ArenaStringPtr oauth2_client_id_;
    int device_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceServiceApiAccessRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceServiceApiAccessResponse : public ::google::protobuf::MessageLite {
public:
    DeviceServiceApiAccessResponse();
    virtual ~DeviceServiceApiAccessResponse();

    DeviceServiceApiAccessResponse(const DeviceServiceApiAccessResponse& from);

    inline DeviceServiceApiAccessResponse& operator=(const DeviceServiceApiAccessResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceServiceApiAccessResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceServiceApiAccessResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceServiceApiAccessResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceServiceApiAccessResponse* New() const { return New(NULL); }

    DeviceServiceApiAccessResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceServiceApiAccessResponse& from);
    void MergeFrom(const DeviceServiceApiAccessResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceServiceApiAccessResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string auth_code = 1;
    bool has_auth_code() const;
    void clear_auth_code();
    static const int kAuthCodeFieldNumber = 1;
    const ::std::string& auth_code() const;
    void set_auth_code(const ::std::string& value);
    void set_auth_code(const char* value);
    void set_auth_code(const char* value, size_t size);
    ::std::string* mutable_auth_code();
    ::std::string* release_auth_code();
    void set_allocated_auth_code(::std::string* auth_code);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceServiceApiAccessResponse)
private:
    inline void set_has_auth_code();
    inline void clear_has_auth_code();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr auth_code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceServiceApiAccessResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyFetchRequest : public ::google::protobuf::MessageLite {
public:
    PolicyFetchRequest();
    virtual ~PolicyFetchRequest();

    PolicyFetchRequest(const PolicyFetchRequest& from);

    inline PolicyFetchRequest& operator=(const PolicyFetchRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const PolicyFetchRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const PolicyFetchRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(PolicyFetchRequest* other);

    // implements Message ----------------------------------------------

    inline PolicyFetchRequest* New() const { return New(NULL); }

    PolicyFetchRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const PolicyFetchRequest& from);
    void MergeFrom(const PolicyFetchRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PolicyFetchRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef PolicyFetchRequest_SignatureType SignatureType;
    static const SignatureType NONE = PolicyFetchRequest_SignatureType_NONE;
    static const SignatureType SHA1_RSA = PolicyFetchRequest_SignatureType_SHA1_RSA;
    static inline bool SignatureType_IsValid(int value)
    {
        return PolicyFetchRequest_SignatureType_IsValid(value);
    }
    static const SignatureType SignatureType_MIN = PolicyFetchRequest_SignatureType_SignatureType_MIN;
    static const SignatureType SignatureType_MAX = PolicyFetchRequest_SignatureType_SignatureType_MAX;
    static const int SignatureType_ARRAYSIZE = PolicyFetchRequest_SignatureType_SignatureType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional string policy_type = 1;
    bool has_policy_type() const;
    void clear_policy_type();
    static const int kPolicyTypeFieldNumber = 1;
    const ::std::string& policy_type() const;
    void set_policy_type(const ::std::string& value);
    void set_policy_type(const char* value);
    void set_policy_type(const char* value, size_t size);
    ::std::string* mutable_policy_type();
    ::std::string* release_policy_type();
    void set_allocated_policy_type(::std::string* policy_type);

    // optional int64 timestamp = 2;
    bool has_timestamp() const;
    void clear_timestamp();
    static const int kTimestampFieldNumber = 2;
    ::google::protobuf::int64 timestamp() const;
    void set_timestamp(::google::protobuf::int64 value);

    // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
    bool has_signature_type() const;
    void clear_signature_type();
    static const int kSignatureTypeFieldNumber = 3;
    ::enterprise_management::PolicyFetchRequest_SignatureType signature_type() const;
    void set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);

    // optional int32 public_key_version = 4;
    bool has_public_key_version() const;
    void clear_public_key_version();
    static const int kPublicKeyVersionFieldNumber = 4;
    ::google::protobuf::int32 public_key_version() const;
    void set_public_key_version(::google::protobuf::int32 value);

    // optional string machine_id = 5;
    bool has_machine_id() const;
    void clear_machine_id();
    static const int kMachineIdFieldNumber = 5;
    const ::std::string& machine_id() const;
    void set_machine_id(const ::std::string& value);
    void set_machine_id(const char* value);
    void set_machine_id(const char* value, size_t size);
    ::std::string* mutable_machine_id();
    ::std::string* release_machine_id();
    void set_allocated_machine_id(::std::string* machine_id);

    // optional string settings_entity_id = 6;
    bool has_settings_entity_id() const;
    void clear_settings_entity_id();
    static const int kSettingsEntityIdFieldNumber = 6;
    const ::std::string& settings_entity_id() const;
    void set_settings_entity_id(const ::std::string& value);
    void set_settings_entity_id(const char* value);
    void set_settings_entity_id(const char* value, size_t size);
    ::std::string* mutable_settings_entity_id();
    ::std::string* release_settings_entity_id();
    void set_allocated_settings_entity_id(::std::string* settings_entity_id);

    // optional int64 invalidation_version = 7;
    bool has_invalidation_version() const;
    void clear_invalidation_version();
    static const int kInvalidationVersionFieldNumber = 7;
    ::google::protobuf::int64 invalidation_version() const;
    void set_invalidation_version(::google::protobuf::int64 value);

    // optional bytes invalidation_payload = 8;
    bool has_invalidation_payload() const;
    void clear_invalidation_payload();
    static const int kInvalidationPayloadFieldNumber = 8;
    const ::std::string& invalidation_payload() const;
    void set_invalidation_payload(const ::std::string& value);
    void set_invalidation_payload(const char* value);
    void set_invalidation_payload(const void* value, size_t size);
    ::std::string* mutable_invalidation_payload();
    ::std::string* release_invalidation_payload();
    void set_allocated_invalidation_payload(::std::string* invalidation_payload);

    // optional string verification_key_hash = 9;
    bool has_verification_key_hash() const;
    void clear_verification_key_hash();
    static const int kVerificationKeyHashFieldNumber = 9;
    const ::std::string& verification_key_hash() const;
    void set_verification_key_hash(const ::std::string& value);
    void set_verification_key_hash(const char* value);
    void set_verification_key_hash(const char* value, size_t size);
    ::std::string* mutable_verification_key_hash();
    ::std::string* release_verification_key_hash();
    void set_allocated_verification_key_hash(::std::string* verification_key_hash);

    // @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchRequest)
private:
    inline void set_has_policy_type();
    inline void clear_has_policy_type();
    inline void set_has_timestamp();
    inline void clear_has_timestamp();
    inline void set_has_signature_type();
    inline void clear_has_signature_type();
    inline void set_has_public_key_version();
    inline void clear_has_public_key_version();
    inline void set_has_machine_id();
    inline void clear_has_machine_id();
    inline void set_has_settings_entity_id();
    inline void clear_has_settings_entity_id();
    inline void set_has_invalidation_version();
    inline void clear_has_invalidation_version();
    inline void set_has_invalidation_payload();
    inline void clear_has_invalidation_payload();
    inline void set_has_verification_key_hash();
    inline void clear_has_verification_key_hash();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr policy_type_;
    ::google::protobuf::int64 timestamp_;
    int signature_type_;
    ::google::protobuf::int32 public_key_version_;
    ::google::protobuf::internal::ArenaStringPtr machine_id_;
    ::google::protobuf::internal::ArenaStringPtr settings_entity_id_;
    ::google::protobuf::int64 invalidation_version_;
    ::google::protobuf::internal::ArenaStringPtr invalidation_payload_;
    ::google::protobuf::internal::ArenaStringPtr verification_key_hash_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static PolicyFetchRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DisabledState : public ::google::protobuf::MessageLite {
public:
    DisabledState();
    virtual ~DisabledState();

    DisabledState(const DisabledState& from);

    inline DisabledState& operator=(const DisabledState& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DisabledState& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DisabledState* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DisabledState* other);

    // implements Message ----------------------------------------------

    inline DisabledState* New() const { return New(NULL); }

    DisabledState* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DisabledState& from);
    void MergeFrom(const DisabledState& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DisabledState* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string message = 1;
    bool has_message() const;
    void clear_message();
    static const int kMessageFieldNumber = 1;
    const ::std::string& message() const;
    void set_message(const ::std::string& value);
    void set_message(const char* value);
    void set_message(const char* value, size_t size);
    ::std::string* mutable_message();
    ::std::string* release_message();
    void set_allocated_message(::std::string* message);

    // @@protoc_insertion_point(class_scope:enterprise_management.DisabledState)
private:
    inline void set_has_message();
    inline void clear_has_message();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DisabledState* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceState : public ::google::protobuf::MessageLite {
public:
    DeviceState();
    virtual ~DeviceState();

    DeviceState(const DeviceState& from);

    inline DeviceState& operator=(const DeviceState& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceState& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceState* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceState* other);

    // implements Message ----------------------------------------------

    inline DeviceState* New() const { return New(NULL); }

    DeviceState* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceState& from);
    void MergeFrom(const DeviceState& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceState* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceState_DeviceMode DeviceMode;
    static const DeviceMode DEVICE_MODE_NORMAL = DeviceState_DeviceMode_DEVICE_MODE_NORMAL;
    static const DeviceMode DEVICE_MODE_DISABLED = DeviceState_DeviceMode_DEVICE_MODE_DISABLED;
    static inline bool DeviceMode_IsValid(int value)
    {
        return DeviceState_DeviceMode_IsValid(value);
    }
    static const DeviceMode DeviceMode_MIN = DeviceState_DeviceMode_DeviceMode_MIN;
    static const DeviceMode DeviceMode_MAX = DeviceState_DeviceMode_DeviceMode_MAX;
    static const int DeviceMode_ARRAYSIZE = DeviceState_DeviceMode_DeviceMode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
    bool has_device_mode() const;
    void clear_device_mode();
    static const int kDeviceModeFieldNumber = 1;
    ::enterprise_management::DeviceState_DeviceMode device_mode() const;
    void set_device_mode(::enterprise_management::DeviceState_DeviceMode value);

    // optional .enterprise_management.DisabledState disabled_state = 2;
    bool has_disabled_state() const;
    void clear_disabled_state();
    static const int kDisabledStateFieldNumber = 2;
    const ::enterprise_management::DisabledState& disabled_state() const;
    ::enterprise_management::DisabledState* mutable_disabled_state();
    ::enterprise_management::DisabledState* release_disabled_state();
    void set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceState)
private:
    inline void set_has_device_mode();
    inline void clear_has_device_mode();
    inline void set_has_disabled_state();
    inline void clear_has_disabled_state();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::enterprise_management::DisabledState* disabled_state_;
    int device_mode_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceState* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyData : public ::google::protobuf::MessageLite {
public:
    PolicyData();
    virtual ~PolicyData();

    PolicyData(const PolicyData& from);

    inline PolicyData& operator=(const PolicyData& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const PolicyData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const PolicyData* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(PolicyData* other);

    // implements Message ----------------------------------------------

    inline PolicyData* New() const { return New(NULL); }

    PolicyData* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const PolicyData& from);
    void MergeFrom(const PolicyData& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PolicyData* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef PolicyData_AssociationState AssociationState;
    static const AssociationState ACTIVE = PolicyData_AssociationState_ACTIVE;
    static const AssociationState UNMANAGED = PolicyData_AssociationState_UNMANAGED;
    static const AssociationState DEPROVISIONED = PolicyData_AssociationState_DEPROVISIONED;
    static inline bool AssociationState_IsValid(int value)
    {
        return PolicyData_AssociationState_IsValid(value);
    }
    static const AssociationState AssociationState_MIN = PolicyData_AssociationState_AssociationState_MIN;
    static const AssociationState AssociationState_MAX = PolicyData_AssociationState_AssociationState_MAX;
    static const int AssociationState_ARRAYSIZE = PolicyData_AssociationState_AssociationState_ARRAYSIZE;

    typedef PolicyData_ManagementMode ManagementMode;
    static const ManagementMode LOCAL_OWNER = PolicyData_ManagementMode_LOCAL_OWNER;
    static const ManagementMode ENTERPRISE_MANAGED = PolicyData_ManagementMode_ENTERPRISE_MANAGED;
    static const ManagementMode CONSUMER_MANAGED = PolicyData_ManagementMode_CONSUMER_MANAGED;
    static inline bool ManagementMode_IsValid(int value)
    {
        return PolicyData_ManagementMode_IsValid(value);
    }
    static const ManagementMode ManagementMode_MIN = PolicyData_ManagementMode_ManagementMode_MIN;
    static const ManagementMode ManagementMode_MAX = PolicyData_ManagementMode_ManagementMode_MAX;
    static const int ManagementMode_ARRAYSIZE = PolicyData_ManagementMode_ManagementMode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional string policy_type = 1;
    bool has_policy_type() const;
    void clear_policy_type();
    static const int kPolicyTypeFieldNumber = 1;
    const ::std::string& policy_type() const;
    void set_policy_type(const ::std::string& value);
    void set_policy_type(const char* value);
    void set_policy_type(const char* value, size_t size);
    ::std::string* mutable_policy_type();
    ::std::string* release_policy_type();
    void set_allocated_policy_type(::std::string* policy_type);

    // optional int64 timestamp = 2;
    bool has_timestamp() const;
    void clear_timestamp();
    static const int kTimestampFieldNumber = 2;
    ::google::protobuf::int64 timestamp() const;
    void set_timestamp(::google::protobuf::int64 value);

    // optional string request_token = 3;
    bool has_request_token() const;
    void clear_request_token();
    static const int kRequestTokenFieldNumber = 3;
    const ::std::string& request_token() const;
    void set_request_token(const ::std::string& value);
    void set_request_token(const char* value);
    void set_request_token(const char* value, size_t size);
    ::std::string* mutable_request_token();
    ::std::string* release_request_token();
    void set_allocated_request_token(::std::string* request_token);

    // optional bytes policy_value = 4;
    bool has_policy_value() const;
    void clear_policy_value();
    static const int kPolicyValueFieldNumber = 4;
    const ::std::string& policy_value() const;
    void set_policy_value(const ::std::string& value);
    void set_policy_value(const char* value);
    void set_policy_value(const void* value, size_t size);
    ::std::string* mutable_policy_value();
    ::std::string* release_policy_value();
    void set_allocated_policy_value(::std::string* policy_value);

    // optional string machine_name = 5;
    bool has_machine_name() const;
    void clear_machine_name();
    static const int kMachineNameFieldNumber = 5;
    const ::std::string& machine_name() const;
    void set_machine_name(const ::std::string& value);
    void set_machine_name(const char* value);
    void set_machine_name(const char* value, size_t size);
    ::std::string* mutable_machine_name();
    ::std::string* release_machine_name();
    void set_allocated_machine_name(::std::string* machine_name);

    // optional int32 public_key_version = 6;
    bool has_public_key_version() const;
    void clear_public_key_version();
    static const int kPublicKeyVersionFieldNumber = 6;
    ::google::protobuf::int32 public_key_version() const;
    void set_public_key_version(::google::protobuf::int32 value);

    // optional string username = 7;
    bool has_username() const;
    void clear_username();
    static const int kUsernameFieldNumber = 7;
    const ::std::string& username() const;
    void set_username(const ::std::string& value);
    void set_username(const char* value);
    void set_username(const char* value, size_t size);
    ::std::string* mutable_username();
    ::std::string* release_username();
    void set_allocated_username(::std::string* username);

    // optional string device_id = 8;
    bool has_device_id() const;
    void clear_device_id();
    static const int kDeviceIdFieldNumber = 8;
    const ::std::string& device_id() const;
    void set_device_id(const ::std::string& value);
    void set_device_id(const char* value);
    void set_device_id(const char* value, size_t size);
    ::std::string* mutable_device_id();
    ::std::string* release_device_id();
    void set_allocated_device_id(::std::string* device_id);

    // optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
    bool has_state() const;
    void clear_state();
    static const int kStateFieldNumber = 9;
    ::enterprise_management::PolicyData_AssociationState state() const;
    void set_state(::enterprise_management::PolicyData_AssociationState value);

    // optional bool valid_serial_number_missing = 10;
    bool has_valid_serial_number_missing() const;
    void clear_valid_serial_number_missing();
    static const int kValidSerialNumberMissingFieldNumber = 10;
    bool valid_serial_number_missing() const;
    void set_valid_serial_number_missing(bool value);

    // optional string settings_entity_id = 11;
    bool has_settings_entity_id() const;
    void clear_settings_entity_id();
    static const int kSettingsEntityIdFieldNumber = 11;
    const ::std::string& settings_entity_id() const;
    void set_settings_entity_id(const ::std::string& value);
    void set_settings_entity_id(const char* value);
    void set_settings_entity_id(const char* value, size_t size);
    ::std::string* mutable_settings_entity_id();
    ::std::string* release_settings_entity_id();
    void set_allocated_settings_entity_id(::std::string* settings_entity_id);

    // optional string service_account_identity = 12;
    bool has_service_account_identity() const;
    void clear_service_account_identity();
    static const int kServiceAccountIdentityFieldNumber = 12;
    const ::std::string& service_account_identity() const;
    void set_service_account_identity(const ::std::string& value);
    void set_service_account_identity(const char* value);
    void set_service_account_identity(const char* value, size_t size);
    ::std::string* mutable_service_account_identity();
    ::std::string* release_service_account_identity();
    void set_allocated_service_account_identity(::std::string* service_account_identity);

    // optional int32 invalidation_source = 13;
    bool has_invalidation_source() const;
    void clear_invalidation_source();
    static const int kInvalidationSourceFieldNumber = 13;
    ::google::protobuf::int32 invalidation_source() const;
    void set_invalidation_source(::google::protobuf::int32 value);

    // optional bytes invalidation_name = 14;
    bool has_invalidation_name() const;
    void clear_invalidation_name();
    static const int kInvalidationNameFieldNumber = 14;
    const ::std::string& invalidation_name() const;
    void set_invalidation_name(const ::std::string& value);
    void set_invalidation_name(const char* value);
    void set_invalidation_name(const void* value, size_t size);
    ::std::string* mutable_invalidation_name();
    ::std::string* release_invalidation_name();
    void set_allocated_invalidation_name(::std::string* invalidation_name);

    // optional string policy_token = 15;
    bool has_policy_token() const;
    void clear_policy_token();
    static const int kPolicyTokenFieldNumber = 15;
    const ::std::string& policy_token() const;
    void set_policy_token(const ::std::string& value);
    void set_policy_token(const char* value);
    void set_policy_token(const char* value, size_t size);
    ::std::string* mutable_policy_token();
    ::std::string* release_policy_token();
    void set_allocated_policy_token(::std::string* policy_token);

    // optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
    bool has_management_mode() const;
    void clear_management_mode();
    static const int kManagementModeFieldNumber = 16;
    ::enterprise_management::PolicyData_ManagementMode management_mode() const;
    void set_management_mode(::enterprise_management::PolicyData_ManagementMode value);

    // optional .enterprise_management.DeviceState device_state = 17;
    bool has_device_state() const;
    void clear_device_state();
    static const int kDeviceStateFieldNumber = 17;
    const ::enterprise_management::DeviceState& device_state() const;
    ::enterprise_management::DeviceState* mutable_device_state();
    ::enterprise_management::DeviceState* release_device_state();
    void set_allocated_device_state(::enterprise_management::DeviceState* device_state);

    // optional int32 command_invalidation_source = 18;
    bool has_command_invalidation_source() const;
    void clear_command_invalidation_source();
    static const int kCommandInvalidationSourceFieldNumber = 18;
    ::google::protobuf::int32 command_invalidation_source() const;
    void set_command_invalidation_source(::google::protobuf::int32 value);

    // optional bytes command_invalidation_name = 19;
    bool has_command_invalidation_name() const;
    void clear_command_invalidation_name();
    static const int kCommandInvalidationNameFieldNumber = 19;
    const ::std::string& command_invalidation_name() const;
    void set_command_invalidation_name(const ::std::string& value);
    void set_command_invalidation_name(const char* value);
    void set_command_invalidation_name(const void* value, size_t size);
    ::std::string* mutable_command_invalidation_name();
    ::std::string* release_command_invalidation_name();
    void set_allocated_command_invalidation_name(::std::string* command_invalidation_name);

    // optional string annotated_location = 20;
    bool has_annotated_location() const;
    void clear_annotated_location();
    static const int kAnnotatedLocationFieldNumber = 20;
    const ::std::string& annotated_location() const;
    void set_annotated_location(const ::std::string& value);
    void set_annotated_location(const char* value);
    void set_annotated_location(const char* value, size_t size);
    ::std::string* mutable_annotated_location();
    ::std::string* release_annotated_location();
    void set_allocated_annotated_location(::std::string* annotated_location);

    // optional string annotated_asset_id = 21;
    bool has_annotated_asset_id() const;
    void clear_annotated_asset_id();
    static const int kAnnotatedAssetIdFieldNumber = 21;
    const ::std::string& annotated_asset_id() const;
    void set_annotated_asset_id(const ::std::string& value);
    void set_annotated_asset_id(const char* value);
    void set_annotated_asset_id(const char* value, size_t size);
    ::std::string* mutable_annotated_asset_id();
    ::std::string* release_annotated_asset_id();
    void set_allocated_annotated_asset_id(::std::string* annotated_asset_id);

    // optional string directory_api_id = 22;
    bool has_directory_api_id() const;
    void clear_directory_api_id();
    static const int kDirectoryApiIdFieldNumber = 22;
    const ::std::string& directory_api_id() const;
    void set_directory_api_id(const ::std::string& value);
    void set_directory_api_id(const char* value);
    void set_directory_api_id(const char* value, size_t size);
    ::std::string* mutable_directory_api_id();
    ::std::string* release_directory_api_id();
    void set_allocated_directory_api_id(::std::string* directory_api_id);

    // repeated string device_affiliation_ids = 23;
    int device_affiliation_ids_size() const;
    void clear_device_affiliation_ids();
    static const int kDeviceAffiliationIdsFieldNumber = 23;
    const ::std::string& device_affiliation_ids(int index) const;
    ::std::string* mutable_device_affiliation_ids(int index);
    void set_device_affiliation_ids(int index, const ::std::string& value);
    void set_device_affiliation_ids(int index, const char* value);
    void set_device_affiliation_ids(int index, const char* value, size_t size);
    ::std::string* add_device_affiliation_ids();
    void add_device_affiliation_ids(const ::std::string& value);
    void add_device_affiliation_ids(const char* value);
    void add_device_affiliation_ids(const char* value, size_t size);
    const ::google::protobuf::RepeatedPtrField<::std::string>& device_affiliation_ids() const;
    ::google::protobuf::RepeatedPtrField<::std::string>* mutable_device_affiliation_ids();

    // repeated string user_affiliation_ids = 24;
    int user_affiliation_ids_size() const;
    void clear_user_affiliation_ids();
    static const int kUserAffiliationIdsFieldNumber = 24;
    const ::std::string& user_affiliation_ids(int index) const;
    ::std::string* mutable_user_affiliation_ids(int index);
    void set_user_affiliation_ids(int index, const ::std::string& value);
    void set_user_affiliation_ids(int index, const char* value);
    void set_user_affiliation_ids(int index, const char* value, size_t size);
    ::std::string* add_user_affiliation_ids();
    void add_user_affiliation_ids(const ::std::string& value);
    void add_user_affiliation_ids(const char* value);
    void add_user_affiliation_ids(const char* value, size_t size);
    const ::google::protobuf::RepeatedPtrField<::std::string>& user_affiliation_ids() const;
    ::google::protobuf::RepeatedPtrField<::std::string>* mutable_user_affiliation_ids();

    // @@protoc_insertion_point(class_scope:enterprise_management.PolicyData)
private:
    inline void set_has_policy_type();
    inline void clear_has_policy_type();
    inline void set_has_timestamp();
    inline void clear_has_timestamp();
    inline void set_has_request_token();
    inline void clear_has_request_token();
    inline void set_has_policy_value();
    inline void clear_has_policy_value();
    inline void set_has_machine_name();
    inline void clear_has_machine_name();
    inline void set_has_public_key_version();
    inline void clear_has_public_key_version();
    inline void set_has_username();
    inline void clear_has_username();
    inline void set_has_device_id();
    inline void clear_has_device_id();
    inline void set_has_state();
    inline void clear_has_state();
    inline void set_has_valid_serial_number_missing();
    inline void clear_has_valid_serial_number_missing();
    inline void set_has_settings_entity_id();
    inline void clear_has_settings_entity_id();
    inline void set_has_service_account_identity();
    inline void clear_has_service_account_identity();
    inline void set_has_invalidation_source();
    inline void clear_has_invalidation_source();
    inline void set_has_invalidation_name();
    inline void clear_has_invalidation_name();
    inline void set_has_policy_token();
    inline void clear_has_policy_token();
    inline void set_has_management_mode();
    inline void clear_has_management_mode();
    inline void set_has_device_state();
    inline void clear_has_device_state();
    inline void set_has_command_invalidation_source();
    inline void clear_has_command_invalidation_source();
    inline void set_has_command_invalidation_name();
    inline void clear_has_command_invalidation_name();
    inline void set_has_annotated_location();
    inline void clear_has_annotated_location();
    inline void set_has_annotated_asset_id();
    inline void clear_has_annotated_asset_id();
    inline void set_has_directory_api_id();
    inline void clear_has_directory_api_id();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr policy_type_;
    ::google::protobuf::int64 timestamp_;
    ::google::protobuf::internal::ArenaStringPtr request_token_;
    ::google::protobuf::internal::ArenaStringPtr policy_value_;
    ::google::protobuf::internal::ArenaStringPtr machine_name_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::int32 public_key_version_;
    int state_;
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::google::protobuf::internal::ArenaStringPtr settings_entity_id_;
    bool valid_serial_number_missing_;
    ::google::protobuf::int32 invalidation_source_;
    ::google::protobuf::internal::ArenaStringPtr service_account_identity_;
    ::google::protobuf::internal::ArenaStringPtr invalidation_name_;
    ::google::protobuf::internal::ArenaStringPtr policy_token_;
    ::enterprise_management::DeviceState* device_state_;
    int management_mode_;
    ::google::protobuf::int32 command_invalidation_source_;
    ::google::protobuf::internal::ArenaStringPtr command_invalidation_name_;
    ::google::protobuf::internal::ArenaStringPtr annotated_location_;
    ::google::protobuf::internal::ArenaStringPtr annotated_asset_id_;
    ::google::protobuf::internal::ArenaStringPtr directory_api_id_;
    ::google::protobuf::RepeatedPtrField<::std::string> device_affiliation_ids_;
    ::google::protobuf::RepeatedPtrField<::std::string> user_affiliation_ids_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static PolicyData* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PolicyFetchResponse : public ::google::protobuf::MessageLite {
public:
    PolicyFetchResponse();
    virtual ~PolicyFetchResponse();

    PolicyFetchResponse(const PolicyFetchResponse& from);

    inline PolicyFetchResponse& operator=(const PolicyFetchResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const PolicyFetchResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const PolicyFetchResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(PolicyFetchResponse* other);

    // implements Message ----------------------------------------------

    inline PolicyFetchResponse* New() const { return New(NULL); }

    PolicyFetchResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const PolicyFetchResponse& from);
    void MergeFrom(const PolicyFetchResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PolicyFetchResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional int32 error_code = 1;
    bool has_error_code() const;
    void clear_error_code();
    static const int kErrorCodeFieldNumber = 1;
    ::google::protobuf::int32 error_code() const;
    void set_error_code(::google::protobuf::int32 value);

    // optional string error_message = 2;
    bool has_error_message() const;
    void clear_error_message();
    static const int kErrorMessageFieldNumber = 2;
    const ::std::string& error_message() const;
    void set_error_message(const ::std::string& value);
    void set_error_message(const char* value);
    void set_error_message(const char* value, size_t size);
    ::std::string* mutable_error_message();
    ::std::string* release_error_message();
    void set_allocated_error_message(::std::string* error_message);

    // optional bytes policy_data = 3;
    bool has_policy_data() const;
    void clear_policy_data();
    static const int kPolicyDataFieldNumber = 3;
    const ::std::string& policy_data() const;
    void set_policy_data(const ::std::string& value);
    void set_policy_data(const char* value);
    void set_policy_data(const void* value, size_t size);
    ::std::string* mutable_policy_data();
    ::std::string* release_policy_data();
    void set_allocated_policy_data(::std::string* policy_data);

    // optional bytes policy_data_signature = 4;
    bool has_policy_data_signature() const;
    void clear_policy_data_signature();
    static const int kPolicyDataSignatureFieldNumber = 4;
    const ::std::string& policy_data_signature() const;
    void set_policy_data_signature(const ::std::string& value);
    void set_policy_data_signature(const char* value);
    void set_policy_data_signature(const void* value, size_t size);
    ::std::string* mutable_policy_data_signature();
    ::std::string* release_policy_data_signature();
    void set_allocated_policy_data_signature(::std::string* policy_data_signature);

    // optional bytes new_public_key = 5;
    bool has_new_public_key() const;
    void clear_new_public_key();
    static const int kNewPublicKeyFieldNumber = 5;
    const ::std::string& new_public_key() const;
    void set_new_public_key(const ::std::string& value);
    void set_new_public_key(const char* value);
    void set_new_public_key(const void* value, size_t size);
    ::std::string* mutable_new_public_key();
    ::std::string* release_new_public_key();
    void set_allocated_new_public_key(::std::string* new_public_key);

    // optional bytes new_public_key_signature = 6;
    bool has_new_public_key_signature() const;
    void clear_new_public_key_signature();
    static const int kNewPublicKeySignatureFieldNumber = 6;
    const ::std::string& new_public_key_signature() const;
    void set_new_public_key_signature(const ::std::string& value);
    void set_new_public_key_signature(const char* value);
    void set_new_public_key_signature(const void* value, size_t size);
    ::std::string* mutable_new_public_key_signature();
    ::std::string* release_new_public_key_signature();
    void set_allocated_new_public_key_signature(::std::string* new_public_key_signature);

    // optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
    PROTOBUF_DEPRECATED_ATTR bool has_new_public_key_verification_signature_deprecated() const;
    PROTOBUF_DEPRECATED_ATTR void clear_new_public_key_verification_signature_deprecated();
    PROTOBUF_DEPRECATED_ATTR static const int kNewPublicKeyVerificationSignatureDeprecatedFieldNumber = 7;
    PROTOBUF_DEPRECATED_ATTR const ::std::string& new_public_key_verification_signature_deprecated() const;
    PROTOBUF_DEPRECATED_ATTR void set_new_public_key_verification_signature_deprecated(const ::std::string& value);
    PROTOBUF_DEPRECATED_ATTR void set_new_public_key_verification_signature_deprecated(const char* value);
    PROTOBUF_DEPRECATED_ATTR void set_new_public_key_verification_signature_deprecated(const void* value, size_t size);
    PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_new_public_key_verification_signature_deprecated();
    PROTOBUF_DEPRECATED_ATTR ::std::string* release_new_public_key_verification_signature_deprecated();
    PROTOBUF_DEPRECATED_ATTR void set_allocated_new_public_key_verification_signature_deprecated(::std::string* new_public_key_verification_signature_deprecated);

    // optional bytes new_public_key_verification_data = 8;
    bool has_new_public_key_verification_data() const;
    void clear_new_public_key_verification_data();
    static const int kNewPublicKeyVerificationDataFieldNumber = 8;
    const ::std::string& new_public_key_verification_data() const;
    void set_new_public_key_verification_data(const ::std::string& value);
    void set_new_public_key_verification_data(const char* value);
    void set_new_public_key_verification_data(const void* value, size_t size);
    ::std::string* mutable_new_public_key_verification_data();
    ::std::string* release_new_public_key_verification_data();
    void set_allocated_new_public_key_verification_data(::std::string* new_public_key_verification_data);

    // optional bytes new_public_key_verification_data_signature = 9;
    bool has_new_public_key_verification_data_signature() const;
    void clear_new_public_key_verification_data_signature();
    static const int kNewPublicKeyVerificationDataSignatureFieldNumber = 9;
    const ::std::string& new_public_key_verification_data_signature() const;
    void set_new_public_key_verification_data_signature(const ::std::string& value);
    void set_new_public_key_verification_data_signature(const char* value);
    void set_new_public_key_verification_data_signature(const void* value, size_t size);
    ::std::string* mutable_new_public_key_verification_data_signature();
    ::std::string* release_new_public_key_verification_data_signature();
    void set_allocated_new_public_key_verification_data_signature(::std::string* new_public_key_verification_data_signature);

    // @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchResponse)
private:
    inline void set_has_error_code();
    inline void clear_has_error_code();
    inline void set_has_error_message();
    inline void clear_has_error_message();
    inline void set_has_policy_data();
    inline void clear_has_policy_data();
    inline void set_has_policy_data_signature();
    inline void clear_has_policy_data_signature();
    inline void set_has_new_public_key();
    inline void clear_has_new_public_key();
    inline void set_has_new_public_key_signature();
    inline void clear_has_new_public_key_signature();
    inline void set_has_new_public_key_verification_signature_deprecated();
    inline void clear_has_new_public_key_verification_signature_deprecated();
    inline void set_has_new_public_key_verification_data();
    inline void clear_has_new_public_key_verification_data();
    inline void set_has_new_public_key_verification_data_signature();
    inline void clear_has_new_public_key_verification_data_signature();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr policy_data_;
    ::google::protobuf::internal::ArenaStringPtr policy_data_signature_;
    ::google::protobuf::internal::ArenaStringPtr new_public_key_;
    ::google::protobuf::internal::ArenaStringPtr new_public_key_signature_;
    ::google::protobuf::internal::ArenaStringPtr new_public_key_verification_signature_deprecated_;
    ::google::protobuf::internal::ArenaStringPtr new_public_key_verification_data_;
    ::google::protobuf::internal::ArenaStringPtr new_public_key_verification_data_signature_;
    ::google::protobuf::int32 error_code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static PolicyFetchResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DEPRECATEDPolicyPublicKeyAndDomain : public ::google::protobuf::MessageLite {
public:
    DEPRECATEDPolicyPublicKeyAndDomain();
    virtual ~DEPRECATEDPolicyPublicKeyAndDomain();

    DEPRECATEDPolicyPublicKeyAndDomain(const DEPRECATEDPolicyPublicKeyAndDomain& from);

    inline DEPRECATEDPolicyPublicKeyAndDomain& operator=(const DEPRECATEDPolicyPublicKeyAndDomain& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DEPRECATEDPolicyPublicKeyAndDomain& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DEPRECATEDPolicyPublicKeyAndDomain* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DEPRECATEDPolicyPublicKeyAndDomain* other);

    // implements Message ----------------------------------------------

    inline DEPRECATEDPolicyPublicKeyAndDomain* New() const { return New(NULL); }

    DEPRECATEDPolicyPublicKeyAndDomain* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from);
    void MergeFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DEPRECATEDPolicyPublicKeyAndDomain* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes new_public_key = 1;
    bool has_new_public_key() const;
    void clear_new_public_key();
    static const int kNewPublicKeyFieldNumber = 1;
    const ::std::string& new_public_key() const;
    void set_new_public_key(const ::std::string& value);
    void set_new_public_key(const char* value);
    void set_new_public_key(const void* value, size_t size);
    ::std::string* mutable_new_public_key();
    ::std::string* release_new_public_key();
    void set_allocated_new_public_key(::std::string* new_public_key);

    // optional string domain = 2;
    bool has_domain() const;
    void clear_domain();
    static const int kDomainFieldNumber = 2;
    const ::std::string& domain() const;
    void set_domain(const ::std::string& value);
    void set_domain(const char* value);
    void set_domain(const char* value, size_t size);
    ::std::string* mutable_domain();
    ::std::string* release_domain();
    void set_allocated_domain(::std::string* domain);

    // @@protoc_insertion_point(class_scope:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
private:
    inline void set_has_new_public_key();
    inline void clear_has_new_public_key();
    inline void set_has_domain();
    inline void clear_has_domain();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_public_key_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DEPRECATEDPolicyPublicKeyAndDomain* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT PublicKeyVerificationData : public ::google::protobuf::MessageLite {
public:
    PublicKeyVerificationData();
    virtual ~PublicKeyVerificationData();

    PublicKeyVerificationData(const PublicKeyVerificationData& from);

    inline PublicKeyVerificationData& operator=(const PublicKeyVerificationData& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const PublicKeyVerificationData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const PublicKeyVerificationData* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(PublicKeyVerificationData* other);

    // implements Message ----------------------------------------------

    inline PublicKeyVerificationData* New() const { return New(NULL); }

    PublicKeyVerificationData* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const PublicKeyVerificationData& from);
    void MergeFrom(const PublicKeyVerificationData& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PublicKeyVerificationData* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes new_public_key = 1;
    bool has_new_public_key() const;
    void clear_new_public_key();
    static const int kNewPublicKeyFieldNumber = 1;
    const ::std::string& new_public_key() const;
    void set_new_public_key(const ::std::string& value);
    void set_new_public_key(const char* value);
    void set_new_public_key(const void* value, size_t size);
    ::std::string* mutable_new_public_key();
    ::std::string* release_new_public_key();
    void set_allocated_new_public_key(::std::string* new_public_key);

    // optional string domain = 2;
    bool has_domain() const;
    void clear_domain();
    static const int kDomainFieldNumber = 2;
    const ::std::string& domain() const;
    void set_domain(const ::std::string& value);
    void set_domain(const char* value);
    void set_domain(const char* value, size_t size);
    ::std::string* mutable_domain();
    ::std::string* release_domain();
    void set_allocated_domain(::std::string* domain);

    // optional int32 new_public_key_version = 3;
    bool has_new_public_key_version() const;
    void clear_new_public_key_version();
    static const int kNewPublicKeyVersionFieldNumber = 3;
    ::google::protobuf::int32 new_public_key_version() const;
    void set_new_public_key_version(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.PublicKeyVerificationData)
private:
    inline void set_has_new_public_key();
    inline void clear_has_new_public_key();
    inline void set_has_domain();
    inline void clear_has_domain();
    inline void set_has_new_public_key_version();
    inline void clear_has_new_public_key_version();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_public_key_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::google::protobuf::int32 new_public_key_version_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static PublicKeyVerificationData* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePolicyRequest : public ::google::protobuf::MessageLite {
public:
    DevicePolicyRequest();
    virtual ~DevicePolicyRequest();

    DevicePolicyRequest(const DevicePolicyRequest& from);

    inline DevicePolicyRequest& operator=(const DevicePolicyRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DevicePolicyRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DevicePolicyRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DevicePolicyRequest* other);

    // implements Message ----------------------------------------------

    inline DevicePolicyRequest* New() const { return New(NULL); }

    DevicePolicyRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DevicePolicyRequest& from);
    void MergeFrom(const DevicePolicyRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DevicePolicyRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .enterprise_management.PolicyFetchRequest request = 3;
    int request_size() const;
    void clear_request();
    static const int kRequestFieldNumber = 3;
    const ::enterprise_management::PolicyFetchRequest& request(int index) const;
    ::enterprise_management::PolicyFetchRequest* mutable_request(int index);
    ::enterprise_management::PolicyFetchRequest* add_request();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchRequest>*
    mutable_request();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchRequest>&
    request() const;

    // @@protoc_insertion_point(class_scope:enterprise_management.DevicePolicyRequest)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchRequest> request_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DevicePolicyRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePolicyResponse : public ::google::protobuf::MessageLite {
public:
    DevicePolicyResponse();
    virtual ~DevicePolicyResponse();

    DevicePolicyResponse(const DevicePolicyResponse& from);

    inline DevicePolicyResponse& operator=(const DevicePolicyResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DevicePolicyResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DevicePolicyResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DevicePolicyResponse* other);

    // implements Message ----------------------------------------------

    inline DevicePolicyResponse* New() const { return New(NULL); }

    DevicePolicyResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DevicePolicyResponse& from);
    void MergeFrom(const DevicePolicyResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DevicePolicyResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .enterprise_management.PolicyFetchResponse response = 3;
    int response_size() const;
    void clear_response();
    static const int kResponseFieldNumber = 3;
    const ::enterprise_management::PolicyFetchResponse& response(int index) const;
    ::enterprise_management::PolicyFetchResponse* mutable_response(int index);
    ::enterprise_management::PolicyFetchResponse* add_response();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchResponse>*
    mutable_response();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchResponse>&
    response() const;

    // @@protoc_insertion_point(class_scope:enterprise_management.DevicePolicyResponse)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchResponse> response_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DevicePolicyResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT TimePeriod : public ::google::protobuf::MessageLite {
public:
    TimePeriod();
    virtual ~TimePeriod();

    TimePeriod(const TimePeriod& from);

    inline TimePeriod& operator=(const TimePeriod& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const TimePeriod& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const TimePeriod* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(TimePeriod* other);

    // implements Message ----------------------------------------------

    inline TimePeriod* New() const { return New(NULL); }

    TimePeriod* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const TimePeriod& from);
    void MergeFrom(const TimePeriod& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TimePeriod* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional int64 start_timestamp = 1;
    bool has_start_timestamp() const;
    void clear_start_timestamp();
    static const int kStartTimestampFieldNumber = 1;
    ::google::protobuf::int64 start_timestamp() const;
    void set_start_timestamp(::google::protobuf::int64 value);

    // optional int64 end_timestamp = 2;
    bool has_end_timestamp() const;
    void clear_end_timestamp();
    static const int kEndTimestampFieldNumber = 2;
    ::google::protobuf::int64 end_timestamp() const;
    void set_end_timestamp(::google::protobuf::int64 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.TimePeriod)
private:
    inline void set_has_start_timestamp();
    inline void clear_has_start_timestamp();
    inline void set_has_end_timestamp();
    inline void clear_has_end_timestamp();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::int64 start_timestamp_;
    ::google::protobuf::int64 end_timestamp_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static TimePeriod* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT ActiveTimePeriod : public ::google::protobuf::MessageLite {
public:
    ActiveTimePeriod();
    virtual ~ActiveTimePeriod();

    ActiveTimePeriod(const ActiveTimePeriod& from);

    inline ActiveTimePeriod& operator=(const ActiveTimePeriod& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const ActiveTimePeriod& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ActiveTimePeriod* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(ActiveTimePeriod* other);

    // implements Message ----------------------------------------------

    inline ActiveTimePeriod* New() const { return New(NULL); }

    ActiveTimePeriod* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ActiveTimePeriod& from);
    void MergeFrom(const ActiveTimePeriod& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ActiveTimePeriod* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .enterprise_management.TimePeriod time_period = 1;
    bool has_time_period() const;
    void clear_time_period();
    static const int kTimePeriodFieldNumber = 1;
    const ::enterprise_management::TimePeriod& time_period() const;
    ::enterprise_management::TimePeriod* mutable_time_period();
    ::enterprise_management::TimePeriod* release_time_period();
    void set_allocated_time_period(::enterprise_management::TimePeriod* time_period);

    // optional int32 active_duration = 2;
    bool has_active_duration() const;
    void clear_active_duration();
    static const int kActiveDurationFieldNumber = 2;
    ::google::protobuf::int32 active_duration() const;
    void set_active_duration(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.ActiveTimePeriod)
private:
    inline void set_has_time_period();
    inline void clear_has_time_period();
    inline void set_has_active_duration();
    inline void clear_has_active_duration();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::enterprise_management::TimePeriod* time_period_;
    ::google::protobuf::int32 active_duration_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static ActiveTimePeriod* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT InstallableLaunch : public ::google::protobuf::MessageLite {
public:
    InstallableLaunch();
    virtual ~InstallableLaunch();

    InstallableLaunch(const InstallableLaunch& from);

    inline InstallableLaunch& operator=(const InstallableLaunch& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const InstallableLaunch& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const InstallableLaunch* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(InstallableLaunch* other);

    // implements Message ----------------------------------------------

    inline InstallableLaunch* New() const { return New(NULL); }

    InstallableLaunch* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const InstallableLaunch& from);
    void MergeFrom(const InstallableLaunch& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(InstallableLaunch* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string install_id = 1;
    bool has_install_id() const;
    void clear_install_id();
    static const int kInstallIdFieldNumber = 1;
    const ::std::string& install_id() const;
    void set_install_id(const ::std::string& value);
    void set_install_id(const char* value);
    void set_install_id(const char* value, size_t size);
    ::std::string* mutable_install_id();
    ::std::string* release_install_id();
    void set_allocated_install_id(::std::string* install_id);

    // optional .enterprise_management.TimePeriod duration = 2;
    bool has_duration() const;
    void clear_duration();
    static const int kDurationFieldNumber = 2;
    const ::enterprise_management::TimePeriod& duration() const;
    ::enterprise_management::TimePeriod* mutable_duration();
    ::enterprise_management::TimePeriod* release_duration();
    void set_allocated_duration(::enterprise_management::TimePeriod* duration);

    // repeated int64 timestamp = 3;
    int timestamp_size() const;
    void clear_timestamp();
    static const int kTimestampFieldNumber = 3;
    ::google::protobuf::int64 timestamp(int index) const;
    void set_timestamp(int index, ::google::protobuf::int64 value);
    void add_timestamp(::google::protobuf::int64 value);
    const ::google::protobuf::RepeatedField<::google::protobuf::int64>&
    timestamp() const;
    ::google::protobuf::RepeatedField<::google::protobuf::int64>*
    mutable_timestamp();

    // optional int64 total_count = 4;
    bool has_total_count() const;
    void clear_total_count();
    static const int kTotalCountFieldNumber = 4;
    ::google::protobuf::int64 total_count() const;
    void set_total_count(::google::protobuf::int64 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.InstallableLaunch)
private:
    inline void set_has_install_id();
    inline void clear_has_install_id();
    inline void set_has_duration();
    inline void clear_has_duration();
    inline void set_has_total_count();
    inline void clear_has_total_count();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr install_id_;
    ::enterprise_management::TimePeriod* duration_;
    ::google::protobuf::RepeatedField<::google::protobuf::int64> timestamp_;
    ::google::protobuf::int64 total_count_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static InstallableLaunch* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT OBSOLETE_DeviceLocation : public ::google::protobuf::MessageLite {
public:
    OBSOLETE_DeviceLocation();
    virtual ~OBSOLETE_DeviceLocation();

    OBSOLETE_DeviceLocation(const OBSOLETE_DeviceLocation& from);

    inline OBSOLETE_DeviceLocation& operator=(const OBSOLETE_DeviceLocation& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const OBSOLETE_DeviceLocation& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const OBSOLETE_DeviceLocation* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(OBSOLETE_DeviceLocation* other);

    // implements Message ----------------------------------------------

    inline OBSOLETE_DeviceLocation* New() const { return New(NULL); }

    OBSOLETE_DeviceLocation* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const OBSOLETE_DeviceLocation& from);
    void MergeFrom(const OBSOLETE_DeviceLocation& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(OBSOLETE_DeviceLocation* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef OBSOLETE_DeviceLocation_ErrorCode ErrorCode;
    static const ErrorCode ERROR_CODE_NONE = OBSOLETE_DeviceLocation_ErrorCode_ERROR_CODE_NONE;
    static const ErrorCode ERROR_CODE_POSITION_UNAVAILABLE = OBSOLETE_DeviceLocation_ErrorCode_ERROR_CODE_POSITION_UNAVAILABLE;
    static inline bool ErrorCode_IsValid(int value)
    {
        return OBSOLETE_DeviceLocation_ErrorCode_IsValid(value);
    }
    static const ErrorCode ErrorCode_MIN = OBSOLETE_DeviceLocation_ErrorCode_ErrorCode_MIN;
    static const ErrorCode ErrorCode_MAX = OBSOLETE_DeviceLocation_ErrorCode_ErrorCode_MAX;
    static const int ErrorCode_ARRAYSIZE = OBSOLETE_DeviceLocation_ErrorCode_ErrorCode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional double latitude = 1;
    bool has_latitude() const;
    void clear_latitude();
    static const int kLatitudeFieldNumber = 1;
    double latitude() const;
    void set_latitude(double value);

    // optional double longitude = 2;
    bool has_longitude() const;
    void clear_longitude();
    static const int kLongitudeFieldNumber = 2;
    double longitude() const;
    void set_longitude(double value);

    // optional double altitude = 3;
    bool has_altitude() const;
    void clear_altitude();
    static const int kAltitudeFieldNumber = 3;
    double altitude() const;
    void set_altitude(double value);

    // optional double accuracy = 4;
    bool has_accuracy() const;
    void clear_accuracy();
    static const int kAccuracyFieldNumber = 4;
    double accuracy() const;
    void set_accuracy(double value);

    // optional double altitude_accuracy = 5;
    bool has_altitude_accuracy() const;
    void clear_altitude_accuracy();
    static const int kAltitudeAccuracyFieldNumber = 5;
    double altitude_accuracy() const;
    void set_altitude_accuracy(double value);

    // optional double heading = 6;
    bool has_heading() const;
    void clear_heading();
    static const int kHeadingFieldNumber = 6;
    double heading() const;
    void set_heading(double value);

    // optional double speed = 7;
    bool has_speed() const;
    void clear_speed();
    static const int kSpeedFieldNumber = 7;
    double speed() const;
    void set_speed(double value);

    // optional int64 timestamp = 8;
    bool has_timestamp() const;
    void clear_timestamp();
    static const int kTimestampFieldNumber = 8;
    ::google::protobuf::int64 timestamp() const;
    void set_timestamp(::google::protobuf::int64 value);

    // optional .enterprise_management.OBSOLETE_DeviceLocation.ErrorCode error_code = 9;
    bool has_error_code() const;
    void clear_error_code();
    static const int kErrorCodeFieldNumber = 9;
    ::enterprise_management::OBSOLETE_DeviceLocation_ErrorCode error_code() const;
    void set_error_code(::enterprise_management::OBSOLETE_DeviceLocation_ErrorCode value);

    // optional string error_message = 10;
    bool has_error_message() const;
    void clear_error_message();
    static const int kErrorMessageFieldNumber = 10;
    const ::std::string& error_message() const;
    void set_error_message(const ::std::string& value);
    void set_error_message(const char* value);
    void set_error_message(const char* value, size_t size);
    ::std::string* mutable_error_message();
    ::std::string* release_error_message();
    void set_allocated_error_message(::std::string* error_message);

    // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_DeviceLocation)
private:
    inline void set_has_latitude();
    inline void clear_has_latitude();
    inline void set_has_longitude();
    inline void clear_has_longitude();
    inline void set_has_altitude();
    inline void clear_has_altitude();
    inline void set_has_accuracy();
    inline void clear_has_accuracy();
    inline void set_has_altitude_accuracy();
    inline void clear_has_altitude_accuracy();
    inline void set_has_heading();
    inline void clear_has_heading();
    inline void set_has_speed();
    inline void clear_has_speed();
    inline void set_has_timestamp();
    inline void clear_has_timestamp();
    inline void set_has_error_code();
    inline void clear_has_error_code();
    inline void set_has_error_message();
    inline void clear_has_error_message();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    double latitude_;
    double longitude_;
    double altitude_;
    double accuracy_;
    double altitude_accuracy_;
    double heading_;
    double speed_;
    ::google::protobuf::int64 timestamp_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    int error_code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static OBSOLETE_DeviceLocation* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT NetworkInterface : public ::google::protobuf::MessageLite {
public:
    NetworkInterface();
    virtual ~NetworkInterface();

    NetworkInterface(const NetworkInterface& from);

    inline NetworkInterface& operator=(const NetworkInterface& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const NetworkInterface& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const NetworkInterface* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(NetworkInterface* other);

    // implements Message ----------------------------------------------

    inline NetworkInterface* New() const { return New(NULL); }

    NetworkInterface* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const NetworkInterface& from);
    void MergeFrom(const NetworkInterface& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NetworkInterface* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef NetworkInterface_NetworkDeviceType NetworkDeviceType;
    static const NetworkDeviceType TYPE_ETHERNET = NetworkInterface_NetworkDeviceType_TYPE_ETHERNET;
    static const NetworkDeviceType TYPE_WIFI = NetworkInterface_NetworkDeviceType_TYPE_WIFI;
    static const NetworkDeviceType TYPE_WIMAX = NetworkInterface_NetworkDeviceType_TYPE_WIMAX;
    static const NetworkDeviceType TYPE_BLUETOOTH = NetworkInterface_NetworkDeviceType_TYPE_BLUETOOTH;
    static const NetworkDeviceType TYPE_CELLULAR = NetworkInterface_NetworkDeviceType_TYPE_CELLULAR;
    static inline bool NetworkDeviceType_IsValid(int value)
    {
        return NetworkInterface_NetworkDeviceType_IsValid(value);
    }
    static const NetworkDeviceType NetworkDeviceType_MIN = NetworkInterface_NetworkDeviceType_NetworkDeviceType_MIN;
    static const NetworkDeviceType NetworkDeviceType_MAX = NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX;
    static const int NetworkDeviceType_ARRAYSIZE = NetworkInterface_NetworkDeviceType_NetworkDeviceType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
    bool has_type() const;
    void clear_type();
    static const int kTypeFieldNumber = 1;
    ::enterprise_management::NetworkInterface_NetworkDeviceType type() const;
    void set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value);

    // optional string mac_address = 2;
    bool has_mac_address() const;
    void clear_mac_address();
    static const int kMacAddressFieldNumber = 2;
    const ::std::string& mac_address() const;
    void set_mac_address(const ::std::string& value);
    void set_mac_address(const char* value);
    void set_mac_address(const char* value, size_t size);
    ::std::string* mutable_mac_address();
    ::std::string* release_mac_address();
    void set_allocated_mac_address(::std::string* mac_address);

    // optional string meid = 3;
    bool has_meid() const;
    void clear_meid();
    static const int kMeidFieldNumber = 3;
    const ::std::string& meid() const;
    void set_meid(const ::std::string& value);
    void set_meid(const char* value);
    void set_meid(const char* value, size_t size);
    ::std::string* mutable_meid();
    ::std::string* release_meid();
    void set_allocated_meid(::std::string* meid);

    // optional string imei = 4;
    bool has_imei() const;
    void clear_imei();
    static const int kImeiFieldNumber = 4;
    const ::std::string& imei() const;
    void set_imei(const ::std::string& value);
    void set_imei(const char* value);
    void set_imei(const char* value, size_t size);
    ::std::string* mutable_imei();
    ::std::string* release_imei();
    void set_allocated_imei(::std::string* imei);

    // optional string device_path = 5;
    bool has_device_path() const;
    void clear_device_path();
    static const int kDevicePathFieldNumber = 5;
    const ::std::string& device_path() const;
    void set_device_path(const ::std::string& value);
    void set_device_path(const char* value);
    void set_device_path(const char* value, size_t size);
    ::std::string* mutable_device_path();
    ::std::string* release_device_path();
    void set_allocated_device_path(::std::string* device_path);

    // @@protoc_insertion_point(class_scope:enterprise_management.NetworkInterface)
private:
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_mac_address();
    inline void clear_has_mac_address();
    inline void set_has_meid();
    inline void clear_has_meid();
    inline void set_has_imei();
    inline void clear_has_imei();
    inline void set_has_device_path();
    inline void clear_has_device_path();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr mac_address_;
    ::google::protobuf::internal::ArenaStringPtr meid_;
    ::google::protobuf::internal::ArenaStringPtr imei_;
    ::google::protobuf::internal::ArenaStringPtr device_path_;
    int type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static NetworkInterface* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT NetworkState : public ::google::protobuf::MessageLite {
public:
    NetworkState();
    virtual ~NetworkState();

    NetworkState(const NetworkState& from);

    inline NetworkState& operator=(const NetworkState& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const NetworkState& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const NetworkState* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(NetworkState* other);

    // implements Message ----------------------------------------------

    inline NetworkState* New() const { return New(NULL); }

    NetworkState* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const NetworkState& from);
    void MergeFrom(const NetworkState& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NetworkState* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef NetworkState_ConnectionState ConnectionState;
    static const ConnectionState IDLE = NetworkState_ConnectionState_IDLE;
    static const ConnectionState CARRIER = NetworkState_ConnectionState_CARRIER;
    static const ConnectionState ASSOCIATION = NetworkState_ConnectionState_ASSOCIATION;
    static const ConnectionState CONFIGURATION = NetworkState_ConnectionState_CONFIGURATION;
    static const ConnectionState READY = NetworkState_ConnectionState_READY;
    static const ConnectionState PORTAL = NetworkState_ConnectionState_PORTAL;
    static const ConnectionState OFFLINE = NetworkState_ConnectionState_OFFLINE;
    static const ConnectionState ONLINE = NetworkState_ConnectionState_ONLINE;
    static const ConnectionState DISCONNECT = NetworkState_ConnectionState_DISCONNECT;
    static const ConnectionState FAILURE = NetworkState_ConnectionState_FAILURE;
    static const ConnectionState ACTIVATION_FAILURE = NetworkState_ConnectionState_ACTIVATION_FAILURE;
    static const ConnectionState UNKNOWN = NetworkState_ConnectionState_UNKNOWN;
    static inline bool ConnectionState_IsValid(int value)
    {
        return NetworkState_ConnectionState_IsValid(value);
    }
    static const ConnectionState ConnectionState_MIN = NetworkState_ConnectionState_ConnectionState_MIN;
    static const ConnectionState ConnectionState_MAX = NetworkState_ConnectionState_ConnectionState_MAX;
    static const int ConnectionState_ARRAYSIZE = NetworkState_ConnectionState_ConnectionState_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional string device_path = 1;
    bool has_device_path() const;
    void clear_device_path();
    static const int kDevicePathFieldNumber = 1;
    const ::std::string& device_path() const;
    void set_device_path(const ::std::string& value);
    void set_device_path(const char* value);
    void set_device_path(const char* value, size_t size);
    ::std::string* mutable_device_path();
    ::std::string* release_device_path();
    void set_allocated_device_path(::std::string* device_path);

    // optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
    bool has_connection_state() const;
    void clear_connection_state();
    static const int kConnectionStateFieldNumber = 2;
    ::enterprise_management::NetworkState_ConnectionState connection_state() const;
    void set_connection_state(::enterprise_management::NetworkState_ConnectionState value);

    // optional int32 signal_strength = 3;
    bool has_signal_strength() const;
    void clear_signal_strength();
    static const int kSignalStrengthFieldNumber = 3;
    ::google::protobuf::int32 signal_strength() const;
    void set_signal_strength(::google::protobuf::int32 value);

    // optional string ip_address = 4;
    bool has_ip_address() const;
    void clear_ip_address();
    static const int kIpAddressFieldNumber = 4;
    const ::std::string& ip_address() const;
    void set_ip_address(const ::std::string& value);
    void set_ip_address(const char* value);
    void set_ip_address(const char* value, size_t size);
    ::std::string* mutable_ip_address();
    ::std::string* release_ip_address();
    void set_allocated_ip_address(::std::string* ip_address);

    // optional string gateway = 5;
    bool has_gateway() const;
    void clear_gateway();
    static const int kGatewayFieldNumber = 5;
    const ::std::string& gateway() const;
    void set_gateway(const ::std::string& value);
    void set_gateway(const char* value);
    void set_gateway(const char* value, size_t size);
    ::std::string* mutable_gateway();
    ::std::string* release_gateway();
    void set_allocated_gateway(::std::string* gateway);

    // @@protoc_insertion_point(class_scope:enterprise_management.NetworkState)
private:
    inline void set_has_device_path();
    inline void clear_has_device_path();
    inline void set_has_connection_state();
    inline void clear_has_connection_state();
    inline void set_has_signal_strength();
    inline void clear_has_signal_strength();
    inline void set_has_ip_address();
    inline void clear_has_ip_address();
    inline void set_has_gateway();
    inline void clear_has_gateway();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr device_path_;
    int connection_state_;
    ::google::protobuf::int32 signal_strength_;
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr gateway_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static NetworkState* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceUser : public ::google::protobuf::MessageLite {
public:
    DeviceUser();
    virtual ~DeviceUser();

    DeviceUser(const DeviceUser& from);

    inline DeviceUser& operator=(const DeviceUser& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceUser& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceUser* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceUser* other);

    // implements Message ----------------------------------------------

    inline DeviceUser* New() const { return New(NULL); }

    DeviceUser* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceUser& from);
    void MergeFrom(const DeviceUser& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceUser* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceUser_UserType UserType;
    static const UserType USER_TYPE_MANAGED = DeviceUser_UserType_USER_TYPE_MANAGED;
    static const UserType USER_TYPE_UNMANAGED = DeviceUser_UserType_USER_TYPE_UNMANAGED;
    static inline bool UserType_IsValid(int value)
    {
        return DeviceUser_UserType_IsValid(value);
    }
    static const UserType UserType_MIN = DeviceUser_UserType_UserType_MIN;
    static const UserType UserType_MAX = DeviceUser_UserType_UserType_MAX;
    static const int UserType_ARRAYSIZE = DeviceUser_UserType_UserType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // required .enterprise_management.DeviceUser.UserType type = 1;
    bool has_type() const;
    void clear_type();
    static const int kTypeFieldNumber = 1;
    ::enterprise_management::DeviceUser_UserType type() const;
    void set_type(::enterprise_management::DeviceUser_UserType value);

    // optional string email = 2;
    bool has_email() const;
    void clear_email();
    static const int kEmailFieldNumber = 2;
    const ::std::string& email() const;
    void set_email(const ::std::string& value);
    void set_email(const char* value);
    void set_email(const char* value, size_t size);
    ::std::string* mutable_email();
    ::std::string* release_email();
    void set_allocated_email(::std::string* email);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUser)
private:
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_email();
    inline void clear_has_email();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    int type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceUser* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT VolumeInfo : public ::google::protobuf::MessageLite {
public:
    VolumeInfo();
    virtual ~VolumeInfo();

    VolumeInfo(const VolumeInfo& from);

    inline VolumeInfo& operator=(const VolumeInfo& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const VolumeInfo& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const VolumeInfo* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(VolumeInfo* other);

    // implements Message ----------------------------------------------

    inline VolumeInfo* New() const { return New(NULL); }

    VolumeInfo* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const VolumeInfo& from);
    void MergeFrom(const VolumeInfo& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(VolumeInfo* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string volume_id = 1;
    bool has_volume_id() const;
    void clear_volume_id();
    static const int kVolumeIdFieldNumber = 1;
    const ::std::string& volume_id() const;
    void set_volume_id(const ::std::string& value);
    void set_volume_id(const char* value);
    void set_volume_id(const char* value, size_t size);
    ::std::string* mutable_volume_id();
    ::std::string* release_volume_id();
    void set_allocated_volume_id(::std::string* volume_id);

    // optional int64 storage_total = 2;
    bool has_storage_total() const;
    void clear_storage_total();
    static const int kStorageTotalFieldNumber = 2;
    ::google::protobuf::int64 storage_total() const;
    void set_storage_total(::google::protobuf::int64 value);

    // optional int64 storage_free = 3;
    bool has_storage_free() const;
    void clear_storage_free();
    static const int kStorageFreeFieldNumber = 3;
    ::google::protobuf::int64 storage_free() const;
    void set_storage_free(::google::protobuf::int64 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.VolumeInfo)
private:
    inline void set_has_volume_id();
    inline void clear_has_volume_id();
    inline void set_has_storage_total();
    inline void clear_has_storage_total();
    inline void set_has_storage_free();
    inline void clear_has_storage_free();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::int64 storage_total_;
    ::google::protobuf::int64 storage_free_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static VolumeInfo* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CPUTempInfo : public ::google::protobuf::MessageLite {
public:
    CPUTempInfo();
    virtual ~CPUTempInfo();

    CPUTempInfo(const CPUTempInfo& from);

    inline CPUTempInfo& operator=(const CPUTempInfo& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const CPUTempInfo& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const CPUTempInfo* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(CPUTempInfo* other);

    // implements Message ----------------------------------------------

    inline CPUTempInfo* New() const { return New(NULL); }

    CPUTempInfo* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const CPUTempInfo& from);
    void MergeFrom(const CPUTempInfo& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CPUTempInfo* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string cpu_label = 1;
    bool has_cpu_label() const;
    void clear_cpu_label();
    static const int kCpuLabelFieldNumber = 1;
    const ::std::string& cpu_label() const;
    void set_cpu_label(const ::std::string& value);
    void set_cpu_label(const char* value);
    void set_cpu_label(const char* value, size_t size);
    ::std::string* mutable_cpu_label();
    ::std::string* release_cpu_label();
    void set_allocated_cpu_label(::std::string* cpu_label);

    // optional int32 cpu_temp = 2;
    bool has_cpu_temp() const;
    void clear_cpu_temp();
    static const int kCpuTempFieldNumber = 2;
    ::google::protobuf::int32 cpu_temp() const;
    void set_cpu_temp(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.CPUTempInfo)
private:
    inline void set_has_cpu_label();
    inline void clear_has_cpu_label();
    inline void set_has_cpu_temp();
    inline void clear_has_cpu_temp();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr cpu_label_;
    ::google::protobuf::int32 cpu_temp_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static CPUTempInfo* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStatusReportRequest : public ::google::protobuf::MessageLite {
public:
    DeviceStatusReportRequest();
    virtual ~DeviceStatusReportRequest();

    DeviceStatusReportRequest(const DeviceStatusReportRequest& from);

    inline DeviceStatusReportRequest& operator=(const DeviceStatusReportRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceStatusReportRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceStatusReportRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceStatusReportRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceStatusReportRequest* New() const { return New(NULL); }

    DeviceStatusReportRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceStatusReportRequest& from);
    void MergeFrom(const DeviceStatusReportRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceStatusReportRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string os_version = 1;
    bool has_os_version() const;
    void clear_os_version();
    static const int kOsVersionFieldNumber = 1;
    const ::std::string& os_version() const;
    void set_os_version(const ::std::string& value);
    void set_os_version(const char* value);
    void set_os_version(const char* value, size_t size);
    ::std::string* mutable_os_version();
    ::std::string* release_os_version();
    void set_allocated_os_version(::std::string* os_version);

    // optional string firmware_version = 2;
    bool has_firmware_version() const;
    void clear_firmware_version();
    static const int kFirmwareVersionFieldNumber = 2;
    const ::std::string& firmware_version() const;
    void set_firmware_version(const ::std::string& value);
    void set_firmware_version(const char* value);
    void set_firmware_version(const char* value, size_t size);
    ::std::string* mutable_firmware_version();
    ::std::string* release_firmware_version();
    void set_allocated_firmware_version(::std::string* firmware_version);

    // optional string boot_mode = 3;
    bool has_boot_mode() const;
    void clear_boot_mode();
    static const int kBootModeFieldNumber = 3;
    const ::std::string& boot_mode() const;
    void set_boot_mode(const ::std::string& value);
    void set_boot_mode(const char* value);
    void set_boot_mode(const char* value, size_t size);
    ::std::string* mutable_boot_mode();
    ::std::string* release_boot_mode();
    void set_allocated_boot_mode(::std::string* boot_mode);

    // repeated .enterprise_management.TimePeriod OBSOLETE_active_time = 4 [deprecated = true];
    PROTOBUF_DEPRECATED_ATTR int obsolete_active_time_size() const;
    PROTOBUF_DEPRECATED_ATTR void clear_obsolete_active_time();
    PROTOBUF_DEPRECATED_ATTR static const int kOBSOLETEActiveTimeFieldNumber = 4;
    PROTOBUF_DEPRECATED_ATTR const ::enterprise_management::TimePeriod& obsolete_active_time(int index) const;
    PROTOBUF_DEPRECATED_ATTR ::enterprise_management::TimePeriod* mutable_obsolete_active_time(int index);
    PROTOBUF_DEPRECATED_ATTR ::enterprise_management::TimePeriod* add_obsolete_active_time();
    PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField<::enterprise_management::TimePeriod>*
    mutable_obsolete_active_time();
    PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField<::enterprise_management::TimePeriod>&
    obsolete_active_time() const;

    // optional string browser_version = 5;
    bool has_browser_version() const;
    void clear_browser_version();
    static const int kBrowserVersionFieldNumber = 5;
    const ::std::string& browser_version() const;
    void set_browser_version(const ::std::string& value);
    void set_browser_version(const char* value);
    void set_browser_version(const char* value, size_t size);
    ::std::string* mutable_browser_version();
    ::std::string* release_browser_version();
    void set_allocated_browser_version(::std::string* browser_version);

    // repeated .enterprise_management.ActiveTimePeriod active_period = 6;
    int active_period_size() const;
    void clear_active_period();
    static const int kActivePeriodFieldNumber = 6;
    const ::enterprise_management::ActiveTimePeriod& active_period(int index) const;
    ::enterprise_management::ActiveTimePeriod* mutable_active_period(int index);
    ::enterprise_management::ActiveTimePeriod* add_active_period();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::ActiveTimePeriod>*
    mutable_active_period();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::ActiveTimePeriod>&
    active_period() const;

    // optional .enterprise_management.OBSOLETE_DeviceLocation OBSOLETE_device_location = 7 [deprecated = true];
    PROTOBUF_DEPRECATED_ATTR bool has_obsolete_device_location() const;
    PROTOBUF_DEPRECATED_ATTR void clear_obsolete_device_location();
    PROTOBUF_DEPRECATED_ATTR static const int kOBSOLETEDeviceLocationFieldNumber = 7;
    PROTOBUF_DEPRECATED_ATTR const ::enterprise_management::OBSOLETE_DeviceLocation& obsolete_device_location() const;
    PROTOBUF_DEPRECATED_ATTR ::enterprise_management::OBSOLETE_DeviceLocation* mutable_obsolete_device_location();
    PROTOBUF_DEPRECATED_ATTR ::enterprise_management::OBSOLETE_DeviceLocation* release_obsolete_device_location();
    PROTOBUF_DEPRECATED_ATTR void set_allocated_obsolete_device_location(::enterprise_management::OBSOLETE_DeviceLocation* obsolete_device_location);

    // repeated .enterprise_management.NetworkInterface network_interface = 8;
    int network_interface_size() const;
    void clear_network_interface();
    static const int kNetworkInterfaceFieldNumber = 8;
    const ::enterprise_management::NetworkInterface& network_interface(int index) const;
    ::enterprise_management::NetworkInterface* mutable_network_interface(int index);
    ::enterprise_management::NetworkInterface* add_network_interface();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkInterface>*
    mutable_network_interface();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkInterface>&
    network_interface() const;

    // repeated .enterprise_management.DeviceUser user = 9;
    int user_size() const;
    void clear_user();
    static const int kUserFieldNumber = 9;
    const ::enterprise_management::DeviceUser& user(int index) const;
    ::enterprise_management::DeviceUser* mutable_user(int index);
    ::enterprise_management::DeviceUser* add_user();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::DeviceUser>*
    mutable_user();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::DeviceUser>&
    user() const;

    // repeated .enterprise_management.VolumeInfo volume_info = 10;
    int volume_info_size() const;
    void clear_volume_info();
    static const int kVolumeInfoFieldNumber = 10;
    const ::enterprise_management::VolumeInfo& volume_info(int index) const;
    ::enterprise_management::VolumeInfo* mutable_volume_info(int index);
    ::enterprise_management::VolumeInfo* add_volume_info();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::VolumeInfo>*
    mutable_volume_info();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::VolumeInfo>&
    volume_info() const;

    // repeated .enterprise_management.NetworkState network_state = 11;
    int network_state_size() const;
    void clear_network_state();
    static const int kNetworkStateFieldNumber = 11;
    const ::enterprise_management::NetworkState& network_state(int index) const;
    ::enterprise_management::NetworkState* mutable_network_state(int index);
    ::enterprise_management::NetworkState* add_network_state();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkState>*
    mutable_network_state();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkState>&
    network_state() const;

    // repeated int32 cpu_utilization_pct = 12;
    int cpu_utilization_pct_size() const;
    void clear_cpu_utilization_pct();
    static const int kCpuUtilizationPctFieldNumber = 12;
    ::google::protobuf::int32 cpu_utilization_pct(int index) const;
    void set_cpu_utilization_pct(int index, ::google::protobuf::int32 value);
    void add_cpu_utilization_pct(::google::protobuf::int32 value);
    const ::google::protobuf::RepeatedField<::google::protobuf::int32>&
    cpu_utilization_pct() const;
    ::google::protobuf::RepeatedField<::google::protobuf::int32>*
    mutable_cpu_utilization_pct();

    // optional int64 OBSOLETE_system_ram_free = 13 [deprecated = true];
    PROTOBUF_DEPRECATED_ATTR bool has_obsolete_system_ram_free() const;
    PROTOBUF_DEPRECATED_ATTR void clear_obsolete_system_ram_free();
    PROTOBUF_DEPRECATED_ATTR static const int kOBSOLETESystemRamFreeFieldNumber = 13;
    PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int64 obsolete_system_ram_free() const;
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_system_ram_free(::google::protobuf::int64 value);

    // optional int64 system_ram_total = 14;
    bool has_system_ram_total() const;
    void clear_system_ram_total();
    static const int kSystemRamTotalFieldNumber = 14;
    ::google::protobuf::int64 system_ram_total() const;
    void set_system_ram_total(::google::protobuf::int64 value);

    // repeated int64 system_ram_free = 15;
    int system_ram_free_size() const;
    void clear_system_ram_free();
    static const int kSystemRamFreeFieldNumber = 15;
    ::google::protobuf::int64 system_ram_free(int index) const;
    void set_system_ram_free(int index, ::google::protobuf::int64 value);
    void add_system_ram_free(::google::protobuf::int64 value);
    const ::google::protobuf::RepeatedField<::google::protobuf::int64>&
    system_ram_free() const;
    ::google::protobuf::RepeatedField<::google::protobuf::int64>*
    mutable_system_ram_free();

    // repeated .enterprise_management.CPUTempInfo cpu_temp_info = 16;
    int cpu_temp_info_size() const;
    void clear_cpu_temp_info();
    static const int kCpuTempInfoFieldNumber = 16;
    const ::enterprise_management::CPUTempInfo& cpu_temp_info(int index) const;
    ::enterprise_management::CPUTempInfo* mutable_cpu_temp_info(int index);
    ::enterprise_management::CPUTempInfo* add_cpu_temp_info();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::CPUTempInfo>*
    mutable_cpu_temp_info();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::CPUTempInfo>&
    cpu_temp_info() const;

    // optional .enterprise_management.OsUpdateStatus os_update_status = 17;
    bool has_os_update_status() const;
    void clear_os_update_status();
    static const int kOsUpdateStatusFieldNumber = 17;
    const ::enterprise_management::OsUpdateStatus& os_update_status() const;
    ::enterprise_management::OsUpdateStatus* mutable_os_update_status();
    ::enterprise_management::OsUpdateStatus* release_os_update_status();
    void set_allocated_os_update_status(::enterprise_management::OsUpdateStatus* os_update_status);

    // optional .enterprise_management.AppStatus running_kiosk_app = 18;
    bool has_running_kiosk_app() const;
    void clear_running_kiosk_app();
    static const int kRunningKioskAppFieldNumber = 18;
    const ::enterprise_management::AppStatus& running_kiosk_app() const;
    ::enterprise_management::AppStatus* mutable_running_kiosk_app();
    ::enterprise_management::AppStatus* release_running_kiosk_app();
    void set_allocated_running_kiosk_app(::enterprise_management::AppStatus* running_kiosk_app);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStatusReportRequest)
private:
    inline void set_has_os_version();
    inline void clear_has_os_version();
    inline void set_has_firmware_version();
    inline void clear_has_firmware_version();
    inline void set_has_boot_mode();
    inline void clear_has_boot_mode();
    inline void set_has_browser_version();
    inline void clear_has_browser_version();
    inline void set_has_obsolete_device_location();
    inline void clear_has_obsolete_device_location();
    inline void set_has_obsolete_system_ram_free();
    inline void clear_has_obsolete_system_ram_free();
    inline void set_has_system_ram_total();
    inline void clear_has_system_ram_total();
    inline void set_has_os_update_status();
    inline void clear_has_os_update_status();
    inline void set_has_running_kiosk_app();
    inline void clear_has_running_kiosk_app();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr os_version_;
    ::google::protobuf::internal::ArenaStringPtr firmware_version_;
    ::google::protobuf::internal::ArenaStringPtr boot_mode_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::TimePeriod> obsolete_active_time_;
    ::google::protobuf::internal::ArenaStringPtr browser_version_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::ActiveTimePeriod> active_period_;
    ::enterprise_management::OBSOLETE_DeviceLocation* obsolete_device_location_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkInterface> network_interface_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::DeviceUser> user_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::VolumeInfo> volume_info_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkState> network_state_;
    ::google::protobuf::RepeatedField<::google::protobuf::int32> cpu_utilization_pct_;
    ::google::protobuf::int64 obsolete_system_ram_free_;
    ::google::protobuf::int64 system_ram_total_;
    ::google::protobuf::RepeatedField<::google::protobuf::int64> system_ram_free_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::CPUTempInfo> cpu_temp_info_;
    ::enterprise_management::OsUpdateStatus* os_update_status_;
    ::enterprise_management::AppStatus* running_kiosk_app_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceStatusReportRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT OsUpdateStatus : public ::google::protobuf::MessageLite {
public:
    OsUpdateStatus();
    virtual ~OsUpdateStatus();

    OsUpdateStatus(const OsUpdateStatus& from);

    inline OsUpdateStatus& operator=(const OsUpdateStatus& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const OsUpdateStatus& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const OsUpdateStatus* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(OsUpdateStatus* other);

    // implements Message ----------------------------------------------

    inline OsUpdateStatus* New() const { return New(NULL); }

    OsUpdateStatus* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const OsUpdateStatus& from);
    void MergeFrom(const OsUpdateStatus& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(OsUpdateStatus* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef OsUpdateStatus_UpdateStatus UpdateStatus;
    static const UpdateStatus OS_UP_TO_DATE = OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE;
    static const UpdateStatus OS_IMAGE_DOWNLOAD_NOT_STARTED = OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_NOT_STARTED;
    static const UpdateStatus OS_IMAGE_DOWNLOAD_IN_PROGRESS = OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_IN_PROGRESS;
    static const UpdateStatus OS_UPDATE_NEED_REBOOT = OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT;
    static inline bool UpdateStatus_IsValid(int value)
    {
        return OsUpdateStatus_UpdateStatus_IsValid(value);
    }
    static const UpdateStatus UpdateStatus_MIN = OsUpdateStatus_UpdateStatus_UpdateStatus_MIN;
    static const UpdateStatus UpdateStatus_MAX = OsUpdateStatus_UpdateStatus_UpdateStatus_MAX;
    static const int UpdateStatus_ARRAYSIZE = OsUpdateStatus_UpdateStatus_UpdateStatus_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
    bool has_update_status() const;
    void clear_update_status();
    static const int kUpdateStatusFieldNumber = 1;
    ::enterprise_management::OsUpdateStatus_UpdateStatus update_status() const;
    void set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value);

    // optional string new_platform_version = 2;
    bool has_new_platform_version() const;
    void clear_new_platform_version();
    static const int kNewPlatformVersionFieldNumber = 2;
    const ::std::string& new_platform_version() const;
    void set_new_platform_version(const ::std::string& value);
    void set_new_platform_version(const char* value);
    void set_new_platform_version(const char* value, size_t size);
    ::std::string* mutable_new_platform_version();
    ::std::string* release_new_platform_version();
    void set_allocated_new_platform_version(::std::string* new_platform_version);

    // optional string new_required_platform_version = 3;
    bool has_new_required_platform_version() const;
    void clear_new_required_platform_version();
    static const int kNewRequiredPlatformVersionFieldNumber = 3;
    const ::std::string& new_required_platform_version() const;
    void set_new_required_platform_version(const ::std::string& value);
    void set_new_required_platform_version(const char* value);
    void set_new_required_platform_version(const char* value, size_t size);
    ::std::string* mutable_new_required_platform_version();
    ::std::string* release_new_required_platform_version();
    void set_allocated_new_required_platform_version(::std::string* new_required_platform_version);

    // @@protoc_insertion_point(class_scope:enterprise_management.OsUpdateStatus)
private:
    inline void set_has_update_status();
    inline void clear_has_update_status();
    inline void set_has_new_platform_version();
    inline void clear_has_new_platform_version();
    inline void set_has_new_required_platform_version();
    inline void clear_has_new_required_platform_version();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_platform_version_;
    ::google::protobuf::internal::ArenaStringPtr new_required_platform_version_;
    int update_status_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static OsUpdateStatus* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AppStatus : public ::google::protobuf::MessageLite {
public:
    AppStatus();
    virtual ~AppStatus();

    AppStatus(const AppStatus& from);

    inline AppStatus& operator=(const AppStatus& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const AppStatus& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const AppStatus* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(AppStatus* other);

    // implements Message ----------------------------------------------

    inline AppStatus* New() const { return New(NULL); }

    AppStatus* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const AppStatus& from);
    void MergeFrom(const AppStatus& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppStatus* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string app_id = 1;
    bool has_app_id() const;
    void clear_app_id();
    static const int kAppIdFieldNumber = 1;
    const ::std::string& app_id() const;
    void set_app_id(const ::std::string& value);
    void set_app_id(const char* value);
    void set_app_id(const char* value, size_t size);
    ::std::string* mutable_app_id();
    ::std::string* release_app_id();
    void set_allocated_app_id(::std::string* app_id);

    // optional string extension_version = 2;
    bool has_extension_version() const;
    void clear_extension_version();
    static const int kExtensionVersionFieldNumber = 2;
    const ::std::string& extension_version() const;
    void set_extension_version(const ::std::string& value);
    void set_extension_version(const char* value);
    void set_extension_version(const char* value, size_t size);
    ::std::string* mutable_extension_version();
    ::std::string* release_extension_version();
    void set_allocated_extension_version(::std::string* extension_version);

    // optional string status = 3;
    bool has_status() const;
    void clear_status();
    static const int kStatusFieldNumber = 3;
    const ::std::string& status() const;
    void set_status(const ::std::string& value);
    void set_status(const char* value);
    void set_status(const char* value, size_t size);
    ::std::string* mutable_status();
    ::std::string* release_status();
    void set_allocated_status(::std::string* status);

    // optional bool error = 4;
    bool has_error() const;
    void clear_error();
    static const int kErrorFieldNumber = 4;
    bool error() const;
    void set_error(bool value);

    // optional string required_platform_version = 5;
    bool has_required_platform_version() const;
    void clear_required_platform_version();
    static const int kRequiredPlatformVersionFieldNumber = 5;
    const ::std::string& required_platform_version() const;
    void set_required_platform_version(const ::std::string& value);
    void set_required_platform_version(const char* value);
    void set_required_platform_version(const char* value, size_t size);
    ::std::string* mutable_required_platform_version();
    ::std::string* release_required_platform_version();
    void set_allocated_required_platform_version(::std::string* required_platform_version);

    // @@protoc_insertion_point(class_scope:enterprise_management.AppStatus)
private:
    inline void set_has_app_id();
    inline void clear_has_app_id();
    inline void set_has_extension_version();
    inline void clear_has_extension_version();
    inline void set_has_status();
    inline void clear_has_status();
    inline void set_has_error();
    inline void clear_has_error();
    inline void set_has_required_platform_version();
    inline void clear_has_required_platform_version();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr extension_version_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr required_platform_version_;
    bool error_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static AppStatus* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT AndroidStatus : public ::google::protobuf::MessageLite {
public:
    AndroidStatus();
    virtual ~AndroidStatus();

    AndroidStatus(const AndroidStatus& from);

    inline AndroidStatus& operator=(const AndroidStatus& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const AndroidStatus& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const AndroidStatus* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(AndroidStatus* other);

    // implements Message ----------------------------------------------

    inline AndroidStatus* New() const { return New(NULL); }

    AndroidStatus* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const AndroidStatus& from);
    void MergeFrom(const AndroidStatus& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AndroidStatus* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string status_payload = 1;
    bool has_status_payload() const;
    void clear_status_payload();
    static const int kStatusPayloadFieldNumber = 1;
    const ::std::string& status_payload() const;
    void set_status_payload(const ::std::string& value);
    void set_status_payload(const char* value);
    void set_status_payload(const char* value, size_t size);
    ::std::string* mutable_status_payload();
    ::std::string* release_status_payload();
    void set_allocated_status_payload(::std::string* status_payload);

    // optional string droid_guard_info = 2;
    bool has_droid_guard_info() const;
    void clear_droid_guard_info();
    static const int kDroidGuardInfoFieldNumber = 2;
    const ::std::string& droid_guard_info() const;
    void set_droid_guard_info(const ::std::string& value);
    void set_droid_guard_info(const char* value);
    void set_droid_guard_info(const char* value, size_t size);
    ::std::string* mutable_droid_guard_info();
    ::std::string* release_droid_guard_info();
    void set_allocated_droid_guard_info(::std::string* droid_guard_info);

    // @@protoc_insertion_point(class_scope:enterprise_management.AndroidStatus)
private:
    inline void set_has_status_payload();
    inline void clear_has_status_payload();
    inline void set_has_droid_guard_info();
    inline void clear_has_droid_guard_info();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr status_payload_;
    ::google::protobuf::internal::ArenaStringPtr droid_guard_info_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static AndroidStatus* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SessionStatusReportRequest : public ::google::protobuf::MessageLite {
public:
    SessionStatusReportRequest();
    virtual ~SessionStatusReportRequest();

    SessionStatusReportRequest(const SessionStatusReportRequest& from);

    inline SessionStatusReportRequest& operator=(const SessionStatusReportRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const SessionStatusReportRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const SessionStatusReportRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(SessionStatusReportRequest* other);

    // implements Message ----------------------------------------------

    inline SessionStatusReportRequest* New() const { return New(NULL); }

    SessionStatusReportRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const SessionStatusReportRequest& from);
    void MergeFrom(const SessionStatusReportRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SessionStatusReportRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated string OBSOLETE_installed_app_id = 1 [deprecated = true];
    PROTOBUF_DEPRECATED_ATTR int obsolete_installed_app_id_size() const;
    PROTOBUF_DEPRECATED_ATTR void clear_obsolete_installed_app_id();
    PROTOBUF_DEPRECATED_ATTR static const int kOBSOLETEInstalledAppIdFieldNumber = 1;
    PROTOBUF_DEPRECATED_ATTR const ::std::string& obsolete_installed_app_id(int index) const;
    PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_obsolete_installed_app_id(int index);
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_installed_app_id(int index, const ::std::string& value);
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_installed_app_id(int index, const char* value);
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_installed_app_id(int index, const char* value, size_t size);
    PROTOBUF_DEPRECATED_ATTR ::std::string* add_obsolete_installed_app_id();
    PROTOBUF_DEPRECATED_ATTR void add_obsolete_installed_app_id(const ::std::string& value);
    PROTOBUF_DEPRECATED_ATTR void add_obsolete_installed_app_id(const char* value);
    PROTOBUF_DEPRECATED_ATTR void add_obsolete_installed_app_id(const char* value, size_t size);
    PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField<::std::string>& obsolete_installed_app_id() const;
    PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField<::std::string>* mutable_obsolete_installed_app_id();

    // repeated string OBSOLETE_installed_extension_id = 2 [deprecated = true];
    PROTOBUF_DEPRECATED_ATTR int obsolete_installed_extension_id_size() const;
    PROTOBUF_DEPRECATED_ATTR void clear_obsolete_installed_extension_id();
    PROTOBUF_DEPRECATED_ATTR static const int kOBSOLETEInstalledExtensionIdFieldNumber = 2;
    PROTOBUF_DEPRECATED_ATTR const ::std::string& obsolete_installed_extension_id(int index) const;
    PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_obsolete_installed_extension_id(int index);
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_installed_extension_id(int index, const ::std::string& value);
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_installed_extension_id(int index, const char* value);
    PROTOBUF_DEPRECATED_ATTR void set_obsolete_installed_extension_id(int index, const char* value, size_t size);
    PROTOBUF_DEPRECATED_ATTR ::std::string* add_obsolete_installed_extension_id();
    PROTOBUF_DEPRECATED_ATTR void add_obsolete_installed_extension_id(const ::std::string& value);
    PROTOBUF_DEPRECATED_ATTR void add_obsolete_installed_extension_id(const char* value);
    PROTOBUF_DEPRECATED_ATTR void add_obsolete_installed_extension_id(const char* value, size_t size);
    PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField<::std::string>& obsolete_installed_extension_id() const;
    PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField<::std::string>* mutable_obsolete_installed_extension_id();

    // repeated .enterprise_management.InstallableLaunch app_launch_stat = 3;
    int app_launch_stat_size() const;
    void clear_app_launch_stat();
    static const int kAppLaunchStatFieldNumber = 3;
    const ::enterprise_management::InstallableLaunch& app_launch_stat(int index) const;
    ::enterprise_management::InstallableLaunch* mutable_app_launch_stat(int index);
    ::enterprise_management::InstallableLaunch* add_app_launch_stat();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::InstallableLaunch>*
    mutable_app_launch_stat();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::InstallableLaunch>&
    app_launch_stat() const;

    // optional string device_local_account_id = 4;
    bool has_device_local_account_id() const;
    void clear_device_local_account_id();
    static const int kDeviceLocalAccountIdFieldNumber = 4;
    const ::std::string& device_local_account_id() const;
    void set_device_local_account_id(const ::std::string& value);
    void set_device_local_account_id(const char* value);
    void set_device_local_account_id(const char* value, size_t size);
    ::std::string* mutable_device_local_account_id();
    ::std::string* release_device_local_account_id();
    void set_allocated_device_local_account_id(::std::string* device_local_account_id);

    // repeated .enterprise_management.AppStatus installed_apps = 5;
    int installed_apps_size() const;
    void clear_installed_apps();
    static const int kInstalledAppsFieldNumber = 5;
    const ::enterprise_management::AppStatus& installed_apps(int index) const;
    ::enterprise_management::AppStatus* mutable_installed_apps(int index);
    ::enterprise_management::AppStatus* add_installed_apps();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>*
    mutable_installed_apps();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>&
    installed_apps() const;

    // repeated .enterprise_management.AppStatus installed_extensions = 6;
    int installed_extensions_size() const;
    void clear_installed_extensions();
    static const int kInstalledExtensionsFieldNumber = 6;
    const ::enterprise_management::AppStatus& installed_extensions(int index) const;
    ::enterprise_management::AppStatus* mutable_installed_extensions(int index);
    ::enterprise_management::AppStatus* add_installed_extensions();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>*
    mutable_installed_extensions();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>&
    installed_extensions() const;

    // optional .enterprise_management.AndroidStatus android_status = 7;
    bool has_android_status() const;
    void clear_android_status();
    static const int kAndroidStatusFieldNumber = 7;
    const ::enterprise_management::AndroidStatus& android_status() const;
    ::enterprise_management::AndroidStatus* mutable_android_status();
    ::enterprise_management::AndroidStatus* release_android_status();
    void set_allocated_android_status(::enterprise_management::AndroidStatus* android_status);

    // @@protoc_insertion_point(class_scope:enterprise_management.SessionStatusReportRequest)
private:
    inline void set_has_device_local_account_id();
    inline void clear_has_device_local_account_id();
    inline void set_has_android_status();
    inline void clear_has_android_status();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> obsolete_installed_app_id_;
    ::google::protobuf::RepeatedPtrField<::std::string> obsolete_installed_extension_id_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::InstallableLaunch> app_launch_stat_;
    ::google::protobuf::internal::ArenaStringPtr device_local_account_id_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus> installed_apps_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus> installed_extensions_;
    ::enterprise_management::AndroidStatus* android_status_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static SessionStatusReportRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStatusReportResponse : public ::google::protobuf::MessageLite {
public:
    DeviceStatusReportResponse();
    virtual ~DeviceStatusReportResponse();

    DeviceStatusReportResponse(const DeviceStatusReportResponse& from);

    inline DeviceStatusReportResponse& operator=(const DeviceStatusReportResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceStatusReportResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceStatusReportResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceStatusReportResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceStatusReportResponse* New() const { return New(NULL); }

    DeviceStatusReportResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceStatusReportResponse& from);
    void MergeFrom(const DeviceStatusReportResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceStatusReportResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional int32 error_code = 1;
    bool has_error_code() const;
    void clear_error_code();
    static const int kErrorCodeFieldNumber = 1;
    ::google::protobuf::int32 error_code() const;
    void set_error_code(::google::protobuf::int32 value);

    // optional string error_message = 2;
    bool has_error_message() const;
    void clear_error_message();
    static const int kErrorMessageFieldNumber = 2;
    const ::std::string& error_message() const;
    void set_error_message(const ::std::string& value);
    void set_error_message(const char* value);
    void set_error_message(const char* value, size_t size);
    ::std::string* mutable_error_message();
    ::std::string* release_error_message();
    void set_allocated_error_message(::std::string* error_message);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStatusReportResponse)
private:
    inline void set_has_error_code();
    inline void clear_has_error_code();
    inline void set_has_error_message();
    inline void clear_has_error_message();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::int32 error_code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceStatusReportResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT SessionStatusReportResponse : public ::google::protobuf::MessageLite {
public:
    SessionStatusReportResponse();
    virtual ~SessionStatusReportResponse();

    SessionStatusReportResponse(const SessionStatusReportResponse& from);

    inline SessionStatusReportResponse& operator=(const SessionStatusReportResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const SessionStatusReportResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const SessionStatusReportResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(SessionStatusReportResponse* other);

    // implements Message ----------------------------------------------

    inline SessionStatusReportResponse* New() const { return New(NULL); }

    SessionStatusReportResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const SessionStatusReportResponse& from);
    void MergeFrom(const SessionStatusReportResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SessionStatusReportResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional int32 error_code = 1;
    bool has_error_code() const;
    void clear_error_code();
    static const int kErrorCodeFieldNumber = 1;
    ::google::protobuf::int32 error_code() const;
    void set_error_code(::google::protobuf::int32 value);

    // optional string error_message = 2;
    bool has_error_message() const;
    void clear_error_message();
    static const int kErrorMessageFieldNumber = 2;
    const ::std::string& error_message() const;
    void set_error_message(const ::std::string& value);
    void set_error_message(const char* value);
    void set_error_message(const char* value, size_t size);
    ::std::string* mutable_error_message();
    ::std::string* release_error_message();
    void set_allocated_error_message(::std::string* error_message);

    // @@protoc_insertion_point(class_scope:enterprise_management.SessionStatusReportResponse)
private:
    inline void set_has_error_code();
    inline void clear_has_error_code();
    inline void set_has_error_message();
    inline void clear_has_error_message();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::int32 error_code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static SessionStatusReportResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAutoEnrollmentRequest : public ::google::protobuf::MessageLite {
public:
    DeviceAutoEnrollmentRequest();
    virtual ~DeviceAutoEnrollmentRequest();

    DeviceAutoEnrollmentRequest(const DeviceAutoEnrollmentRequest& from);

    inline DeviceAutoEnrollmentRequest& operator=(const DeviceAutoEnrollmentRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceAutoEnrollmentRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceAutoEnrollmentRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceAutoEnrollmentRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceAutoEnrollmentRequest* New() const { return New(NULL); }

    DeviceAutoEnrollmentRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceAutoEnrollmentRequest& from);
    void MergeFrom(const DeviceAutoEnrollmentRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceAutoEnrollmentRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional int64 remainder = 1;
    bool has_remainder() const;
    void clear_remainder();
    static const int kRemainderFieldNumber = 1;
    ::google::protobuf::int64 remainder() const;
    void set_remainder(::google::protobuf::int64 value);

    // optional int64 modulus = 2;
    bool has_modulus() const;
    void clear_modulus();
    static const int kModulusFieldNumber = 2;
    ::google::protobuf::int64 modulus() const;
    void set_modulus(::google::protobuf::int64 value);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAutoEnrollmentRequest)
private:
    inline void set_has_remainder();
    inline void clear_has_remainder();
    inline void set_has_modulus();
    inline void clear_has_modulus();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::int64 remainder_;
    ::google::protobuf::int64 modulus_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceAutoEnrollmentRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAutoEnrollmentResponse : public ::google::protobuf::MessageLite {
public:
    DeviceAutoEnrollmentResponse();
    virtual ~DeviceAutoEnrollmentResponse();

    DeviceAutoEnrollmentResponse(const DeviceAutoEnrollmentResponse& from);

    inline DeviceAutoEnrollmentResponse& operator=(const DeviceAutoEnrollmentResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceAutoEnrollmentResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceAutoEnrollmentResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceAutoEnrollmentResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceAutoEnrollmentResponse* New() const { return New(NULL); }

    DeviceAutoEnrollmentResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceAutoEnrollmentResponse& from);
    void MergeFrom(const DeviceAutoEnrollmentResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceAutoEnrollmentResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional int64 expected_modulus = 1;
    bool has_expected_modulus() const;
    void clear_expected_modulus();
    static const int kExpectedModulusFieldNumber = 1;
    ::google::protobuf::int64 expected_modulus() const;
    void set_expected_modulus(::google::protobuf::int64 value);

    // repeated bytes hash = 2;
    int hash_size() const;
    void clear_hash();
    static const int kHashFieldNumber = 2;
    const ::std::string& hash(int index) const;
    ::std::string* mutable_hash(int index);
    void set_hash(int index, const ::std::string& value);
    void set_hash(int index, const char* value);
    void set_hash(int index, const void* value, size_t size);
    ::std::string* add_hash();
    void add_hash(const ::std::string& value);
    void add_hash(const char* value);
    void add_hash(const void* value, size_t size);
    const ::google::protobuf::RepeatedPtrField<::std::string>& hash() const;
    ::google::protobuf::RepeatedPtrField<::std::string>* mutable_hash();

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAutoEnrollmentResponse)
private:
    inline void set_has_expected_modulus();
    inline void clear_has_expected_modulus();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::int64 expected_modulus_;
    ::google::protobuf::RepeatedPtrField<::std::string> hash_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceAutoEnrollmentResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStateRetrievalRequest : public ::google::protobuf::MessageLite {
public:
    DeviceStateRetrievalRequest();
    virtual ~DeviceStateRetrievalRequest();

    DeviceStateRetrievalRequest(const DeviceStateRetrievalRequest& from);

    inline DeviceStateRetrievalRequest& operator=(const DeviceStateRetrievalRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceStateRetrievalRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceStateRetrievalRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceStateRetrievalRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceStateRetrievalRequest* New() const { return New(NULL); }

    DeviceStateRetrievalRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceStateRetrievalRequest& from);
    void MergeFrom(const DeviceStateRetrievalRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceStateRetrievalRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes server_backed_state_key = 1;
    bool has_server_backed_state_key() const;
    void clear_server_backed_state_key();
    static const int kServerBackedStateKeyFieldNumber = 1;
    const ::std::string& server_backed_state_key() const;
    void set_server_backed_state_key(const ::std::string& value);
    void set_server_backed_state_key(const char* value);
    void set_server_backed_state_key(const void* value, size_t size);
    ::std::string* mutable_server_backed_state_key();
    ::std::string* release_server_backed_state_key();
    void set_allocated_server_backed_state_key(::std::string* server_backed_state_key);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalRequest)
private:
    inline void set_has_server_backed_state_key();
    inline void clear_has_server_backed_state_key();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr server_backed_state_key_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceStateRetrievalRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStateKeyUpdateRequest : public ::google::protobuf::MessageLite {
public:
    DeviceStateKeyUpdateRequest();
    virtual ~DeviceStateKeyUpdateRequest();

    DeviceStateKeyUpdateRequest(const DeviceStateKeyUpdateRequest& from);

    inline DeviceStateKeyUpdateRequest& operator=(const DeviceStateKeyUpdateRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceStateKeyUpdateRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceStateKeyUpdateRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceStateKeyUpdateRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceStateKeyUpdateRequest* New() const { return New(NULL); }

    DeviceStateKeyUpdateRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceStateKeyUpdateRequest& from);
    void MergeFrom(const DeviceStateKeyUpdateRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceStateKeyUpdateRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated bytes server_backed_state_key = 1;
    int server_backed_state_key_size() const;
    void clear_server_backed_state_key();
    static const int kServerBackedStateKeyFieldNumber = 1;
    const ::std::string& server_backed_state_key(int index) const;
    ::std::string* mutable_server_backed_state_key(int index);
    void set_server_backed_state_key(int index, const ::std::string& value);
    void set_server_backed_state_key(int index, const char* value);
    void set_server_backed_state_key(int index, const void* value, size_t size);
    ::std::string* add_server_backed_state_key();
    void add_server_backed_state_key(const ::std::string& value);
    void add_server_backed_state_key(const char* value);
    void add_server_backed_state_key(const void* value, size_t size);
    const ::google::protobuf::RepeatedPtrField<::std::string>& server_backed_state_key() const;
    ::google::protobuf::RepeatedPtrField<::std::string>* mutable_server_backed_state_key();

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateKeyUpdateRequest)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> server_backed_state_key_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceStateKeyUpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceStateRetrievalResponse : public ::google::protobuf::MessageLite {
public:
    DeviceStateRetrievalResponse();
    virtual ~DeviceStateRetrievalResponse();

    DeviceStateRetrievalResponse(const DeviceStateRetrievalResponse& from);

    inline DeviceStateRetrievalResponse& operator=(const DeviceStateRetrievalResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceStateRetrievalResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceStateRetrievalResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceStateRetrievalResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceStateRetrievalResponse* New() const { return New(NULL); }

    DeviceStateRetrievalResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceStateRetrievalResponse& from);
    void MergeFrom(const DeviceStateRetrievalResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceStateRetrievalResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceStateRetrievalResponse_RestoreMode RestoreMode;
    static const RestoreMode RESTORE_MODE_NONE = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE;
    static const RestoreMode RESTORE_MODE_REENROLLMENT_REQUESTED = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_REQUESTED;
    static const RestoreMode RESTORE_MODE_REENROLLMENT_ENFORCED = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ENFORCED;
    static const RestoreMode RESTORE_MODE_DISABLED = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_DISABLED;
    static inline bool RestoreMode_IsValid(int value)
    {
        return DeviceStateRetrievalResponse_RestoreMode_IsValid(value);
    }
    static const RestoreMode RestoreMode_MIN = DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MIN;
    static const RestoreMode RestoreMode_MAX = DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX;
    static const int RestoreMode_ARRAYSIZE = DeviceStateRetrievalResponse_RestoreMode_RestoreMode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
    bool has_restore_mode() const;
    void clear_restore_mode();
    static const int kRestoreModeFieldNumber = 1;
    ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode restore_mode() const;
    void set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value);

    // optional string management_domain = 2;
    bool has_management_domain() const;
    void clear_management_domain();
    static const int kManagementDomainFieldNumber = 2;
    const ::std::string& management_domain() const;
    void set_management_domain(const ::std::string& value);
    void set_management_domain(const char* value);
    void set_management_domain(const char* value, size_t size);
    ::std::string* mutable_management_domain();
    ::std::string* release_management_domain();
    void set_allocated_management_domain(::std::string* management_domain);

    // optional .enterprise_management.DisabledState disabled_state = 3;
    bool has_disabled_state() const;
    void clear_disabled_state();
    static const int kDisabledStateFieldNumber = 3;
    const ::enterprise_management::DisabledState& disabled_state() const;
    ::enterprise_management::DisabledState* mutable_disabled_state();
    ::enterprise_management::DisabledState* release_disabled_state();
    void set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalResponse)
private:
    inline void set_has_restore_mode();
    inline void clear_has_restore_mode();
    inline void set_has_management_domain();
    inline void clear_has_management_domain();
    inline void set_has_disabled_state();
    inline void clear_has_disabled_state();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr management_domain_;
    ::enterprise_management::DisabledState* disabled_state_;
    int restore_mode_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceStateRetrievalResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePairingRequest : public ::google::protobuf::MessageLite {
public:
    DevicePairingRequest();
    virtual ~DevicePairingRequest();

    DevicePairingRequest(const DevicePairingRequest& from);

    inline DevicePairingRequest& operator=(const DevicePairingRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DevicePairingRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DevicePairingRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DevicePairingRequest* other);

    // implements Message ----------------------------------------------

    inline DevicePairingRequest* New() const { return New(NULL); }

    DevicePairingRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DevicePairingRequest& from);
    void MergeFrom(const DevicePairingRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DevicePairingRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string host_device_id = 1;
    bool has_host_device_id() const;
    void clear_host_device_id();
    static const int kHostDeviceIdFieldNumber = 1;
    const ::std::string& host_device_id() const;
    void set_host_device_id(const ::std::string& value);
    void set_host_device_id(const char* value);
    void set_host_device_id(const char* value, size_t size);
    ::std::string* mutable_host_device_id();
    ::std::string* release_host_device_id();
    void set_allocated_host_device_id(::std::string* host_device_id);

    // optional string controller_device_id = 2;
    bool has_controller_device_id() const;
    void clear_controller_device_id();
    static const int kControllerDeviceIdFieldNumber = 2;
    const ::std::string& controller_device_id() const;
    void set_controller_device_id(const ::std::string& value);
    void set_controller_device_id(const char* value);
    void set_controller_device_id(const char* value, size_t size);
    ::std::string* mutable_controller_device_id();
    ::std::string* release_controller_device_id();
    void set_allocated_controller_device_id(::std::string* controller_device_id);

    // @@protoc_insertion_point(class_scope:enterprise_management.DevicePairingRequest)
private:
    inline void set_has_host_device_id();
    inline void clear_has_host_device_id();
    inline void set_has_controller_device_id();
    inline void clear_has_controller_device_id();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr host_device_id_;
    ::google::protobuf::internal::ArenaStringPtr controller_device_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DevicePairingRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DevicePairingResponse : public ::google::protobuf::MessageLite {
public:
    DevicePairingResponse();
    virtual ~DevicePairingResponse();

    DevicePairingResponse(const DevicePairingResponse& from);

    inline DevicePairingResponse& operator=(const DevicePairingResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DevicePairingResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DevicePairingResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DevicePairingResponse* other);

    // implements Message ----------------------------------------------

    inline DevicePairingResponse* New() const { return New(NULL); }

    DevicePairingResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DevicePairingResponse& from);
    void MergeFrom(const DevicePairingResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DevicePairingResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DevicePairingResponse_StatusCode StatusCode;
    static const StatusCode SUCCESS = DevicePairingResponse_StatusCode_SUCCESS;
    static const StatusCode FAILED = DevicePairingResponse_StatusCode_FAILED;
    static const StatusCode HOST_DEVICE_NOT_FOUND = DevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND;
    static const StatusCode CONTROLLER_DEVICE_NOT_FOUND = DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND;
    static const StatusCode HOST_DEVICE_DEPROVISIONED = DevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED;
    static const StatusCode CONTROLLER_DEVICE_DEPROVISIONED = DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
    static inline bool StatusCode_IsValid(int value)
    {
        return DevicePairingResponse_StatusCode_IsValid(value);
    }
    static const StatusCode StatusCode_MIN = DevicePairingResponse_StatusCode_StatusCode_MIN;
    static const StatusCode StatusCode_MAX = DevicePairingResponse_StatusCode_StatusCode_MAX;
    static const int StatusCode_ARRAYSIZE = DevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
    bool has_status_code() const;
    void clear_status_code();
    static const int kStatusCodeFieldNumber = 1;
    ::enterprise_management::DevicePairingResponse_StatusCode status_code() const;
    void set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value);

    // @@protoc_insertion_point(class_scope:enterprise_management.DevicePairingResponse)
private:
    inline void set_has_status_code();
    inline void clear_has_status_code();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    int status_code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DevicePairingResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckDevicePairingRequest : public ::google::protobuf::MessageLite {
public:
    CheckDevicePairingRequest();
    virtual ~CheckDevicePairingRequest();

    CheckDevicePairingRequest(const CheckDevicePairingRequest& from);

    inline CheckDevicePairingRequest& operator=(const CheckDevicePairingRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const CheckDevicePairingRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const CheckDevicePairingRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(CheckDevicePairingRequest* other);

    // implements Message ----------------------------------------------

    inline CheckDevicePairingRequest* New() const { return New(NULL); }

    CheckDevicePairingRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const CheckDevicePairingRequest& from);
    void MergeFrom(const CheckDevicePairingRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CheckDevicePairingRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string host_device_id = 1;
    bool has_host_device_id() const;
    void clear_host_device_id();
    static const int kHostDeviceIdFieldNumber = 1;
    const ::std::string& host_device_id() const;
    void set_host_device_id(const ::std::string& value);
    void set_host_device_id(const char* value);
    void set_host_device_id(const char* value, size_t size);
    ::std::string* mutable_host_device_id();
    ::std::string* release_host_device_id();
    void set_allocated_host_device_id(::std::string* host_device_id);

    // optional string controller_device_id = 2;
    bool has_controller_device_id() const;
    void clear_controller_device_id();
    static const int kControllerDeviceIdFieldNumber = 2;
    const ::std::string& controller_device_id() const;
    void set_controller_device_id(const ::std::string& value);
    void set_controller_device_id(const char* value);
    void set_controller_device_id(const char* value, size_t size);
    ::std::string* mutable_controller_device_id();
    ::std::string* release_controller_device_id();
    void set_allocated_controller_device_id(::std::string* controller_device_id);

    // @@protoc_insertion_point(class_scope:enterprise_management.CheckDevicePairingRequest)
private:
    inline void set_has_host_device_id();
    inline void clear_has_host_device_id();
    inline void set_has_controller_device_id();
    inline void clear_has_controller_device_id();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr host_device_id_;
    ::google::protobuf::internal::ArenaStringPtr controller_device_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static CheckDevicePairingRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckDevicePairingResponse : public ::google::protobuf::MessageLite {
public:
    CheckDevicePairingResponse();
    virtual ~CheckDevicePairingResponse();

    CheckDevicePairingResponse(const CheckDevicePairingResponse& from);

    inline CheckDevicePairingResponse& operator=(const CheckDevicePairingResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const CheckDevicePairingResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const CheckDevicePairingResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(CheckDevicePairingResponse* other);

    // implements Message ----------------------------------------------

    inline CheckDevicePairingResponse* New() const { return New(NULL); }

    CheckDevicePairingResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const CheckDevicePairingResponse& from);
    void MergeFrom(const CheckDevicePairingResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CheckDevicePairingResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef CheckDevicePairingResponse_StatusCode StatusCode;
    static const StatusCode PAIRED = CheckDevicePairingResponse_StatusCode_PAIRED;
    static const StatusCode NOT_PAIRED = CheckDevicePairingResponse_StatusCode_NOT_PAIRED;
    static const StatusCode HOST_DEVICE_NOT_FOUND = CheckDevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND;
    static const StatusCode CONTROLLER_DEVICE_NOT_FOUND = CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND;
    static const StatusCode HOST_DEVICE_DEPROVISIONED = CheckDevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED;
    static const StatusCode CONTROLLER_DEVICE_DEPROVISIONED = CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
    static const StatusCode INVALID_CONTROLLER_DEVICE_IDENTITY = CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY;
    static inline bool StatusCode_IsValid(int value)
    {
        return CheckDevicePairingResponse_StatusCode_IsValid(value);
    }
    static const StatusCode StatusCode_MIN = CheckDevicePairingResponse_StatusCode_StatusCode_MIN;
    static const StatusCode StatusCode_MAX = CheckDevicePairingResponse_StatusCode_StatusCode_MAX;
    static const int StatusCode_ARRAYSIZE = CheckDevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
    bool has_status_code() const;
    void clear_status_code();
    static const int kStatusCodeFieldNumber = 1;
    ::enterprise_management::CheckDevicePairingResponse_StatusCode status_code() const;
    void set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value);

    // @@protoc_insertion_point(class_scope:enterprise_management.CheckDevicePairingResponse)
private:
    inline void set_has_status_code();
    inline void clear_has_status_code();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    int status_code_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static CheckDevicePairingResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RemoteCommand : public ::google::protobuf::MessageLite {
public:
    RemoteCommand();
    virtual ~RemoteCommand();

    RemoteCommand(const RemoteCommand& from);

    inline RemoteCommand& operator=(const RemoteCommand& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const RemoteCommand& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const RemoteCommand* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(RemoteCommand* other);

    // implements Message ----------------------------------------------

    inline RemoteCommand* New() const { return New(NULL); }

    RemoteCommand* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const RemoteCommand& from);
    void MergeFrom(const RemoteCommand& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RemoteCommand* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef RemoteCommand_Type Type;
    static const Type COMMAND_ECHO_TEST = RemoteCommand_Type_COMMAND_ECHO_TEST;
    static const Type DEVICE_REBOOT = RemoteCommand_Type_DEVICE_REBOOT;
    static const Type DEVICE_SCREENSHOT = RemoteCommand_Type_DEVICE_SCREENSHOT;
    static inline bool Type_IsValid(int value)
    {
        return RemoteCommand_Type_IsValid(value);
    }
    static const Type Type_MIN = RemoteCommand_Type_Type_MIN;
    static const Type Type_MAX = RemoteCommand_Type_Type_MAX;
    static const int Type_ARRAYSIZE = RemoteCommand_Type_Type_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.RemoteCommand.Type type = 1;
    bool has_type() const;
    void clear_type();
    static const int kTypeFieldNumber = 1;
    ::enterprise_management::RemoteCommand_Type type() const;
    void set_type(::enterprise_management::RemoteCommand_Type value);

    // optional int64 command_id = 2;
    bool has_command_id() const;
    void clear_command_id();
    static const int kCommandIdFieldNumber = 2;
    ::google::protobuf::int64 command_id() const;
    void set_command_id(::google::protobuf::int64 value);

    // optional int64 age_of_command = 3;
    bool has_age_of_command() const;
    void clear_age_of_command();
    static const int kAgeOfCommandFieldNumber = 3;
    ::google::protobuf::int64 age_of_command() const;
    void set_age_of_command(::google::protobuf::int64 value);

    // optional string payload = 4;
    bool has_payload() const;
    void clear_payload();
    static const int kPayloadFieldNumber = 4;
    const ::std::string& payload() const;
    void set_payload(const ::std::string& value);
    void set_payload(const char* value);
    void set_payload(const char* value, size_t size);
    ::std::string* mutable_payload();
    ::std::string* release_payload();
    void set_allocated_payload(::std::string* payload);

    // @@protoc_insertion_point(class_scope:enterprise_management.RemoteCommand)
private:
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_command_id();
    inline void clear_has_command_id();
    inline void set_has_age_of_command();
    inline void clear_has_age_of_command();
    inline void set_has_payload();
    inline void clear_has_payload();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::int64 command_id_;
    ::google::protobuf::int64 age_of_command_;
    ::google::protobuf::internal::ArenaStringPtr payload_;
    int type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static RemoteCommand* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT RemoteCommandResult : public ::google::protobuf::MessageLite {
public:
    RemoteCommandResult();
    virtual ~RemoteCommandResult();

    RemoteCommandResult(const RemoteCommandResult& from);

    inline RemoteCommandResult& operator=(const RemoteCommandResult& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const RemoteCommandResult& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const RemoteCommandResult* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(RemoteCommandResult* other);

    // implements Message ----------------------------------------------

    inline RemoteCommandResult* New() const { return New(NULL); }

    RemoteCommandResult* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const RemoteCommandResult& from);
    void MergeFrom(const RemoteCommandResult& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RemoteCommandResult* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef RemoteCommandResult_ResultType ResultType;
    static const ResultType RESULT_IGNORED = RemoteCommandResult_ResultType_RESULT_IGNORED;
    static const ResultType RESULT_FAILURE = RemoteCommandResult_ResultType_RESULT_FAILURE;
    static const ResultType RESULT_SUCCESS = RemoteCommandResult_ResultType_RESULT_SUCCESS;
    static inline bool ResultType_IsValid(int value)
    {
        return RemoteCommandResult_ResultType_IsValid(value);
    }
    static const ResultType ResultType_MIN = RemoteCommandResult_ResultType_ResultType_MIN;
    static const ResultType ResultType_MAX = RemoteCommandResult_ResultType_ResultType_MAX;
    static const int ResultType_ARRAYSIZE = RemoteCommandResult_ResultType_ResultType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
    bool has_result() const;
    void clear_result();
    static const int kResultFieldNumber = 1;
    ::enterprise_management::RemoteCommandResult_ResultType result() const;
    void set_result(::enterprise_management::RemoteCommandResult_ResultType value);

    // optional int64 command_id = 2;
    bool has_command_id() const;
    void clear_command_id();
    static const int kCommandIdFieldNumber = 2;
    ::google::protobuf::int64 command_id() const;
    void set_command_id(::google::protobuf::int64 value);

    // optional int64 timestamp = 3;
    bool has_timestamp() const;
    void clear_timestamp();
    static const int kTimestampFieldNumber = 3;
    ::google::protobuf::int64 timestamp() const;
    void set_timestamp(::google::protobuf::int64 value);

    // optional string payload = 4;
    bool has_payload() const;
    void clear_payload();
    static const int kPayloadFieldNumber = 4;
    const ::std::string& payload() const;
    void set_payload(const ::std::string& value);
    void set_payload(const char* value);
    void set_payload(const char* value, size_t size);
    ::std::string* mutable_payload();
    ::std::string* release_payload();
    void set_allocated_payload(::std::string* payload);

    // @@protoc_insertion_point(class_scope:enterprise_management.RemoteCommandResult)
private:
    inline void set_has_result();
    inline void clear_has_result();
    inline void set_has_command_id();
    inline void clear_has_command_id();
    inline void set_has_timestamp();
    inline void clear_has_timestamp();
    inline void set_has_payload();
    inline void clear_has_payload();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::int64 command_id_;
    ::google::protobuf::int64 timestamp_;
    ::google::protobuf::internal::ArenaStringPtr payload_;
    int result_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static RemoteCommandResult* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRemoteCommandRequest : public ::google::protobuf::MessageLite {
public:
    DeviceRemoteCommandRequest();
    virtual ~DeviceRemoteCommandRequest();

    DeviceRemoteCommandRequest(const DeviceRemoteCommandRequest& from);

    inline DeviceRemoteCommandRequest& operator=(const DeviceRemoteCommandRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceRemoteCommandRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceRemoteCommandRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceRemoteCommandRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceRemoteCommandRequest* New() const { return New(NULL); }

    DeviceRemoteCommandRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceRemoteCommandRequest& from);
    void MergeFrom(const DeviceRemoteCommandRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceRemoteCommandRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional int64 last_command_unique_id = 1;
    bool has_last_command_unique_id() const;
    void clear_last_command_unique_id();
    static const int kLastCommandUniqueIdFieldNumber = 1;
    ::google::protobuf::int64 last_command_unique_id() const;
    void set_last_command_unique_id(::google::protobuf::int64 value);

    // repeated .enterprise_management.RemoteCommandResult command_results = 2;
    int command_results_size() const;
    void clear_command_results();
    static const int kCommandResultsFieldNumber = 2;
    const ::enterprise_management::RemoteCommandResult& command_results(int index) const;
    ::enterprise_management::RemoteCommandResult* mutable_command_results(int index);
    ::enterprise_management::RemoteCommandResult* add_command_results();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommandResult>*
    mutable_command_results();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommandResult>&
    command_results() const;

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRemoteCommandRequest)
private:
    inline void set_has_last_command_unique_id();
    inline void clear_has_last_command_unique_id();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::int64 last_command_unique_id_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommandResult> command_results_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceRemoteCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceRemoteCommandResponse : public ::google::protobuf::MessageLite {
public:
    DeviceRemoteCommandResponse();
    virtual ~DeviceRemoteCommandResponse();

    DeviceRemoteCommandResponse(const DeviceRemoteCommandResponse& from);

    inline DeviceRemoteCommandResponse& operator=(const DeviceRemoteCommandResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceRemoteCommandResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceRemoteCommandResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceRemoteCommandResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceRemoteCommandResponse* New() const { return New(NULL); }

    DeviceRemoteCommandResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceRemoteCommandResponse& from);
    void MergeFrom(const DeviceRemoteCommandResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceRemoteCommandResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .enterprise_management.RemoteCommand commands = 1;
    int commands_size() const;
    void clear_commands();
    static const int kCommandsFieldNumber = 1;
    const ::enterprise_management::RemoteCommand& commands(int index) const;
    ::enterprise_management::RemoteCommand* mutable_commands(int index);
    ::enterprise_management::RemoteCommand* add_commands();
    ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommand>*
    mutable_commands();
    const ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommand>&
    commands() const;

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRemoteCommandResponse)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommand> commands_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceRemoteCommandResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdatePermissionRequest : public ::google::protobuf::MessageLite {
public:
    DeviceAttributeUpdatePermissionRequest();
    virtual ~DeviceAttributeUpdatePermissionRequest();

    DeviceAttributeUpdatePermissionRequest(const DeviceAttributeUpdatePermissionRequest& from);

    inline DeviceAttributeUpdatePermissionRequest& operator=(const DeviceAttributeUpdatePermissionRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceAttributeUpdatePermissionRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceAttributeUpdatePermissionRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceAttributeUpdatePermissionRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceAttributeUpdatePermissionRequest* New() const { return New(NULL); }

    DeviceAttributeUpdatePermissionRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceAttributeUpdatePermissionRequest& from);
    void MergeFrom(const DeviceAttributeUpdatePermissionRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceAttributeUpdatePermissionRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdatePermissionRequest)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceAttributeUpdatePermissionRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdatePermissionResponse : public ::google::protobuf::MessageLite {
public:
    DeviceAttributeUpdatePermissionResponse();
    virtual ~DeviceAttributeUpdatePermissionResponse();

    DeviceAttributeUpdatePermissionResponse(const DeviceAttributeUpdatePermissionResponse& from);

    inline DeviceAttributeUpdatePermissionResponse& operator=(const DeviceAttributeUpdatePermissionResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceAttributeUpdatePermissionResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceAttributeUpdatePermissionResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceAttributeUpdatePermissionResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceAttributeUpdatePermissionResponse* New() const { return New(NULL); }

    DeviceAttributeUpdatePermissionResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceAttributeUpdatePermissionResponse& from);
    void MergeFrom(const DeviceAttributeUpdatePermissionResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceAttributeUpdatePermissionResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceAttributeUpdatePermissionResponse_ResultType ResultType;
    static const ResultType ATTRIBUTE_UPDATE_DISALLOWED = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED;
    static const ResultType ATTRIBUTE_UPDATE_ALLOWED = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED;
    static inline bool ResultType_IsValid(int value)
    {
        return DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(value);
    }
    static const ResultType ResultType_MIN = DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MIN;
    static const ResultType ResultType_MAX = DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX;
    static const int ResultType_ARRAYSIZE = DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
    bool has_result() const;
    void clear_result();
    static const int kResultFieldNumber = 1;
    ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType result() const;
    void set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdatePermissionResponse)
private:
    inline void set_has_result();
    inline void clear_has_result();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    int result_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceAttributeUpdatePermissionResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdateRequest : public ::google::protobuf::MessageLite {
public:
    DeviceAttributeUpdateRequest();
    virtual ~DeviceAttributeUpdateRequest();

    DeviceAttributeUpdateRequest(const DeviceAttributeUpdateRequest& from);

    inline DeviceAttributeUpdateRequest& operator=(const DeviceAttributeUpdateRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceAttributeUpdateRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceAttributeUpdateRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceAttributeUpdateRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceAttributeUpdateRequest* New() const { return New(NULL); }

    DeviceAttributeUpdateRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceAttributeUpdateRequest& from);
    void MergeFrom(const DeviceAttributeUpdateRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceAttributeUpdateRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string asset_id = 1;
    bool has_asset_id() const;
    void clear_asset_id();
    static const int kAssetIdFieldNumber = 1;
    const ::std::string& asset_id() const;
    void set_asset_id(const ::std::string& value);
    void set_asset_id(const char* value);
    void set_asset_id(const char* value, size_t size);
    ::std::string* mutable_asset_id();
    ::std::string* release_asset_id();
    void set_allocated_asset_id(::std::string* asset_id);

    // optional string location = 2;
    bool has_location() const;
    void clear_location();
    static const int kLocationFieldNumber = 2;
    const ::std::string& location() const;
    void set_location(const ::std::string& value);
    void set_location(const char* value);
    void set_location(const char* value, size_t size);
    ::std::string* mutable_location();
    ::std::string* release_location();
    void set_allocated_location(::std::string* location);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdateRequest)
private:
    inline void set_has_asset_id();
    inline void clear_has_asset_id();
    inline void set_has_location();
    inline void clear_has_location();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr asset_id_;
    ::google::protobuf::internal::ArenaStringPtr location_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceAttributeUpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceAttributeUpdateResponse : public ::google::protobuf::MessageLite {
public:
    DeviceAttributeUpdateResponse();
    virtual ~DeviceAttributeUpdateResponse();

    DeviceAttributeUpdateResponse(const DeviceAttributeUpdateResponse& from);

    inline DeviceAttributeUpdateResponse& operator=(const DeviceAttributeUpdateResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceAttributeUpdateResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceAttributeUpdateResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceAttributeUpdateResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceAttributeUpdateResponse* New() const { return New(NULL); }

    DeviceAttributeUpdateResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceAttributeUpdateResponse& from);
    void MergeFrom(const DeviceAttributeUpdateResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceAttributeUpdateResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceAttributeUpdateResponse_ResultType ResultType;
    static const ResultType ATTRIBUTE_UPDATE_ERROR = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR;
    static const ResultType ATTRIBUTE_UPDATE_SUCCESS = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS;
    static inline bool ResultType_IsValid(int value)
    {
        return DeviceAttributeUpdateResponse_ResultType_IsValid(value);
    }
    static const ResultType ResultType_MIN = DeviceAttributeUpdateResponse_ResultType_ResultType_MIN;
    static const ResultType ResultType_MAX = DeviceAttributeUpdateResponse_ResultType_ResultType_MAX;
    static const int ResultType_ARRAYSIZE = DeviceAttributeUpdateResponse_ResultType_ResultType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
    bool has_result() const;
    void clear_result();
    static const int kResultFieldNumber = 1;
    ::enterprise_management::DeviceAttributeUpdateResponse_ResultType result() const;
    void set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdateResponse)
private:
    inline void set_has_result();
    inline void clear_has_result();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    int result_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceAttributeUpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT GcmIdUpdateRequest : public ::google::protobuf::MessageLite {
public:
    GcmIdUpdateRequest();
    virtual ~GcmIdUpdateRequest();

    GcmIdUpdateRequest(const GcmIdUpdateRequest& from);

    inline GcmIdUpdateRequest& operator=(const GcmIdUpdateRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const GcmIdUpdateRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const GcmIdUpdateRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(GcmIdUpdateRequest* other);

    // implements Message ----------------------------------------------

    inline GcmIdUpdateRequest* New() const { return New(NULL); }

    GcmIdUpdateRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const GcmIdUpdateRequest& from);
    void MergeFrom(const GcmIdUpdateRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GcmIdUpdateRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string gcm_id = 1;
    bool has_gcm_id() const;
    void clear_gcm_id();
    static const int kGcmIdFieldNumber = 1;
    const ::std::string& gcm_id() const;
    void set_gcm_id(const ::std::string& value);
    void set_gcm_id(const char* value);
    void set_gcm_id(const char* value, size_t size);
    ::std::string* mutable_gcm_id();
    ::std::string* release_gcm_id();
    void set_allocated_gcm_id(::std::string* gcm_id);

    // @@protoc_insertion_point(class_scope:enterprise_management.GcmIdUpdateRequest)
private:
    inline void set_has_gcm_id();
    inline void clear_has_gcm_id();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr gcm_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static GcmIdUpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT GcmIdUpdateResponse : public ::google::protobuf::MessageLite {
public:
    GcmIdUpdateResponse();
    virtual ~GcmIdUpdateResponse();

    GcmIdUpdateResponse(const GcmIdUpdateResponse& from);

    inline GcmIdUpdateResponse& operator=(const GcmIdUpdateResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const GcmIdUpdateResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const GcmIdUpdateResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(GcmIdUpdateResponse* other);

    // implements Message ----------------------------------------------

    inline GcmIdUpdateResponse* New() const { return New(NULL); }

    GcmIdUpdateResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const GcmIdUpdateResponse& from);
    void MergeFrom(const GcmIdUpdateResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GcmIdUpdateResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:enterprise_management.GcmIdUpdateResponse)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static GcmIdUpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckAndroidManagementRequest : public ::google::protobuf::MessageLite {
public:
    CheckAndroidManagementRequest();
    virtual ~CheckAndroidManagementRequest();

    CheckAndroidManagementRequest(const CheckAndroidManagementRequest& from);

    inline CheckAndroidManagementRequest& operator=(const CheckAndroidManagementRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const CheckAndroidManagementRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const CheckAndroidManagementRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(CheckAndroidManagementRequest* other);

    // implements Message ----------------------------------------------

    inline CheckAndroidManagementRequest* New() const { return New(NULL); }

    CheckAndroidManagementRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const CheckAndroidManagementRequest& from);
    void MergeFrom(const CheckAndroidManagementRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CheckAndroidManagementRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:enterprise_management.CheckAndroidManagementRequest)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static CheckAndroidManagementRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CheckAndroidManagementResponse : public ::google::protobuf::MessageLite {
public:
    CheckAndroidManagementResponse();
    virtual ~CheckAndroidManagementResponse();

    CheckAndroidManagementResponse(const CheckAndroidManagementResponse& from);

    inline CheckAndroidManagementResponse& operator=(const CheckAndroidManagementResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const CheckAndroidManagementResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const CheckAndroidManagementResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(CheckAndroidManagementResponse* other);

    // implements Message ----------------------------------------------

    inline CheckAndroidManagementResponse* New() const { return New(NULL); }

    CheckAndroidManagementResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const CheckAndroidManagementResponse& from);
    void MergeFrom(const CheckAndroidManagementResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CheckAndroidManagementResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:enterprise_management.CheckAndroidManagementResponse)
private:
    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static CheckAndroidManagementResponse* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CertificateBasedDeviceRegisterRequest : public ::google::protobuf::MessageLite {
public:
    CertificateBasedDeviceRegisterRequest();
    virtual ~CertificateBasedDeviceRegisterRequest();

    CertificateBasedDeviceRegisterRequest(const CertificateBasedDeviceRegisterRequest& from);

    inline CertificateBasedDeviceRegisterRequest& operator=(const CertificateBasedDeviceRegisterRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const CertificateBasedDeviceRegisterRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const CertificateBasedDeviceRegisterRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(CertificateBasedDeviceRegisterRequest* other);

    // implements Message ----------------------------------------------

    inline CertificateBasedDeviceRegisterRequest* New() const { return New(NULL); }

    CertificateBasedDeviceRegisterRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const CertificateBasedDeviceRegisterRequest& from);
    void MergeFrom(const CertificateBasedDeviceRegisterRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CertificateBasedDeviceRegisterRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .enterprise_management.SignedData signed_request = 1;
    bool has_signed_request() const;
    void clear_signed_request();
    static const int kSignedRequestFieldNumber = 1;
    const ::enterprise_management::SignedData& signed_request() const;
    ::enterprise_management::SignedData* mutable_signed_request();
    ::enterprise_management::SignedData* release_signed_request();
    void set_allocated_signed_request(::enterprise_management::SignedData* signed_request);

    // @@protoc_insertion_point(class_scope:enterprise_management.CertificateBasedDeviceRegisterRequest)
private:
    inline void set_has_signed_request();
    inline void clear_has_signed_request();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::enterprise_management::SignedData* signed_request_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static CertificateBasedDeviceRegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT CertificateBasedDeviceRegistrationData : public ::google::protobuf::MessageLite {
public:
    CertificateBasedDeviceRegistrationData();
    virtual ~CertificateBasedDeviceRegistrationData();

    CertificateBasedDeviceRegistrationData(const CertificateBasedDeviceRegistrationData& from);

    inline CertificateBasedDeviceRegistrationData& operator=(const CertificateBasedDeviceRegistrationData& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const CertificateBasedDeviceRegistrationData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const CertificateBasedDeviceRegistrationData* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(CertificateBasedDeviceRegistrationData* other);

    // implements Message ----------------------------------------------

    inline CertificateBasedDeviceRegistrationData* New() const { return New(NULL); }

    CertificateBasedDeviceRegistrationData* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const CertificateBasedDeviceRegistrationData& from);
    void MergeFrom(const CertificateBasedDeviceRegistrationData& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CertificateBasedDeviceRegistrationData* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef CertificateBasedDeviceRegistrationData_CertificateType CertificateType;
    static const CertificateType UNKNOWN = CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN;
    static const CertificateType ENTERPRISE_ENROLLMENT_CERTIFICATE = CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
    static inline bool CertificateType_IsValid(int value)
    {
        return CertificateBasedDeviceRegistrationData_CertificateType_IsValid(value);
    }
    static const CertificateType CertificateType_MIN = CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MIN;
    static const CertificateType CertificateType_MAX = CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX;
    static const int CertificateType_ARRAYSIZE = CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
    bool has_certificate_type() const;
    void clear_certificate_type();
    static const int kCertificateTypeFieldNumber = 1;
    ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType certificate_type() const;
    void set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value);

    // optional bytes device_certificate = 2;
    bool has_device_certificate() const;
    void clear_device_certificate();
    static const int kDeviceCertificateFieldNumber = 2;
    const ::std::string& device_certificate() const;
    void set_device_certificate(const ::std::string& value);
    void set_device_certificate(const char* value);
    void set_device_certificate(const void* value, size_t size);
    ::std::string* mutable_device_certificate();
    ::std::string* release_device_certificate();
    void set_allocated_device_certificate(::std::string* device_certificate);

    // optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
    bool has_device_register_request() const;
    void clear_device_register_request();
    static const int kDeviceRegisterRequestFieldNumber = 3;
    const ::enterprise_management::DeviceRegisterRequest& device_register_request() const;
    ::enterprise_management::DeviceRegisterRequest* mutable_device_register_request();
    ::enterprise_management::DeviceRegisterRequest* release_device_register_request();
    void set_allocated_device_register_request(::enterprise_management::DeviceRegisterRequest* device_register_request);

    // @@protoc_insertion_point(class_scope:enterprise_management.CertificateBasedDeviceRegistrationData)
private:
    inline void set_has_certificate_type();
    inline void clear_has_certificate_type();
    inline void set_has_device_certificate();
    inline void clear_has_device_certificate();
    inline void set_has_device_register_request();
    inline void clear_has_device_register_request();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr device_certificate_;
    ::enterprise_management::DeviceRegisterRequest* device_register_request_;
    int certificate_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static CertificateBasedDeviceRegistrationData* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceManagementRequest : public ::google::protobuf::MessageLite {
public:
    DeviceManagementRequest();
    virtual ~DeviceManagementRequest();

    DeviceManagementRequest(const DeviceManagementRequest& from);

    inline DeviceManagementRequest& operator=(const DeviceManagementRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceManagementRequest& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceManagementRequest* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceManagementRequest* other);

    // implements Message ----------------------------------------------

    inline DeviceManagementRequest* New() const { return New(NULL); }

    DeviceManagementRequest* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceManagementRequest& from);
    void MergeFrom(const DeviceManagementRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceManagementRequest* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .enterprise_management.DeviceRegisterRequest register_request = 1;
    bool has_register_request() const;
    void clear_register_request();
    static const int kRegisterRequestFieldNumber = 1;
    const ::enterprise_management::DeviceRegisterRequest& register_request() const;
    ::enterprise_management::DeviceRegisterRequest* mutable_register_request();
    ::enterprise_management::DeviceRegisterRequest* release_register_request();
    void set_allocated_register_request(::enterprise_management::DeviceRegisterRequest* register_request);

    // optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
    bool has_unregister_request() const;
    void clear_unregister_request();
    static const int kUnregisterRequestFieldNumber = 2;
    const ::enterprise_management::DeviceUnregisterRequest& unregister_request() const;
    ::enterprise_management::DeviceUnregisterRequest* mutable_unregister_request();
    ::enterprise_management::DeviceUnregisterRequest* release_unregister_request();
    void set_allocated_unregister_request(::enterprise_management::DeviceUnregisterRequest* unregister_request);

    // optional .enterprise_management.DevicePolicyRequest policy_request = 3;
    bool has_policy_request() const;
    void clear_policy_request();
    static const int kPolicyRequestFieldNumber = 3;
    const ::enterprise_management::DevicePolicyRequest& policy_request() const;
    ::enterprise_management::DevicePolicyRequest* mutable_policy_request();
    ::enterprise_management::DevicePolicyRequest* release_policy_request();
    void set_allocated_policy_request(::enterprise_management::DevicePolicyRequest* policy_request);

    // optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
    bool has_device_status_report_request() const;
    void clear_device_status_report_request();
    static const int kDeviceStatusReportRequestFieldNumber = 4;
    const ::enterprise_management::DeviceStatusReportRequest& device_status_report_request() const;
    ::enterprise_management::DeviceStatusReportRequest* mutable_device_status_report_request();
    ::enterprise_management::DeviceStatusReportRequest* release_device_status_report_request();
    void set_allocated_device_status_report_request(::enterprise_management::DeviceStatusReportRequest* device_status_report_request);

    // optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
    bool has_session_status_report_request() const;
    void clear_session_status_report_request();
    static const int kSessionStatusReportRequestFieldNumber = 5;
    const ::enterprise_management::SessionStatusReportRequest& session_status_report_request() const;
    ::enterprise_management::SessionStatusReportRequest* mutable_session_status_report_request();
    ::enterprise_management::SessionStatusReportRequest* release_session_status_report_request();
    void set_allocated_session_status_report_request(::enterprise_management::SessionStatusReportRequest* session_status_report_request);

    // optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
    bool has_auto_enrollment_request() const;
    void clear_auto_enrollment_request();
    static const int kAutoEnrollmentRequestFieldNumber = 6;
    const ::enterprise_management::DeviceAutoEnrollmentRequest& auto_enrollment_request() const;
    ::enterprise_management::DeviceAutoEnrollmentRequest* mutable_auto_enrollment_request();
    ::enterprise_management::DeviceAutoEnrollmentRequest* release_auto_enrollment_request();
    void set_allocated_auto_enrollment_request(::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request);

    // optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
    bool has_cert_upload_request() const;
    void clear_cert_upload_request();
    static const int kCertUploadRequestFieldNumber = 7;
    const ::enterprise_management::DeviceCertUploadRequest& cert_upload_request() const;
    ::enterprise_management::DeviceCertUploadRequest* mutable_cert_upload_request();
    ::enterprise_management::DeviceCertUploadRequest* release_cert_upload_request();
    void set_allocated_cert_upload_request(::enterprise_management::DeviceCertUploadRequest* cert_upload_request);

    // optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
    bool has_service_api_access_request() const;
    void clear_service_api_access_request();
    static const int kServiceApiAccessRequestFieldNumber = 8;
    const ::enterprise_management::DeviceServiceApiAccessRequest& service_api_access_request() const;
    ::enterprise_management::DeviceServiceApiAccessRequest* mutable_service_api_access_request();
    ::enterprise_management::DeviceServiceApiAccessRequest* release_service_api_access_request();
    void set_allocated_service_api_access_request(::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request);

    // optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
    bool has_device_state_retrieval_request() const;
    void clear_device_state_retrieval_request();
    static const int kDeviceStateRetrievalRequestFieldNumber = 9;
    const ::enterprise_management::DeviceStateRetrievalRequest& device_state_retrieval_request() const;
    ::enterprise_management::DeviceStateRetrievalRequest* mutable_device_state_retrieval_request();
    ::enterprise_management::DeviceStateRetrievalRequest* release_device_state_retrieval_request();
    void set_allocated_device_state_retrieval_request(::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request);

    // optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
    bool has_device_state_key_update_request() const;
    void clear_device_state_key_update_request();
    static const int kDeviceStateKeyUpdateRequestFieldNumber = 10;
    const ::enterprise_management::DeviceStateKeyUpdateRequest& device_state_key_update_request() const;
    ::enterprise_management::DeviceStateKeyUpdateRequest* mutable_device_state_key_update_request();
    ::enterprise_management::DeviceStateKeyUpdateRequest* release_device_state_key_update_request();
    void set_allocated_device_state_key_update_request(::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request);

    // optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
    bool has_device_pairing_request() const;
    void clear_device_pairing_request();
    static const int kDevicePairingRequestFieldNumber = 11;
    const ::enterprise_management::DevicePairingRequest& device_pairing_request() const;
    ::enterprise_management::DevicePairingRequest* mutable_device_pairing_request();
    ::enterprise_management::DevicePairingRequest* release_device_pairing_request();
    void set_allocated_device_pairing_request(::enterprise_management::DevicePairingRequest* device_pairing_request);

    // optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
    bool has_check_device_pairing_request() const;
    void clear_check_device_pairing_request();
    static const int kCheckDevicePairingRequestFieldNumber = 12;
    const ::enterprise_management::CheckDevicePairingRequest& check_device_pairing_request() const;
    ::enterprise_management::CheckDevicePairingRequest* mutable_check_device_pairing_request();
    ::enterprise_management::CheckDevicePairingRequest* release_check_device_pairing_request();
    void set_allocated_check_device_pairing_request(::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request);

    // optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
    bool has_remote_command_request() const;
    void clear_remote_command_request();
    static const int kRemoteCommandRequestFieldNumber = 13;
    const ::enterprise_management::DeviceRemoteCommandRequest& remote_command_request() const;
    ::enterprise_management::DeviceRemoteCommandRequest* mutable_remote_command_request();
    ::enterprise_management::DeviceRemoteCommandRequest* release_remote_command_request();
    void set_allocated_remote_command_request(::enterprise_management::DeviceRemoteCommandRequest* remote_command_request);

    // optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
    bool has_device_attribute_update_permission_request() const;
    void clear_device_attribute_update_permission_request();
    static const int kDeviceAttributeUpdatePermissionRequestFieldNumber = 14;
    const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& device_attribute_update_permission_request() const;
    ::enterprise_management::DeviceAttributeUpdatePermissionRequest* mutable_device_attribute_update_permission_request();
    ::enterprise_management::DeviceAttributeUpdatePermissionRequest* release_device_attribute_update_permission_request();
    void set_allocated_device_attribute_update_permission_request(::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request);

    // optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
    bool has_device_attribute_update_request() const;
    void clear_device_attribute_update_request();
    static const int kDeviceAttributeUpdateRequestFieldNumber = 15;
    const ::enterprise_management::DeviceAttributeUpdateRequest& device_attribute_update_request() const;
    ::enterprise_management::DeviceAttributeUpdateRequest* mutable_device_attribute_update_request();
    ::enterprise_management::DeviceAttributeUpdateRequest* release_device_attribute_update_request();
    void set_allocated_device_attribute_update_request(::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request);

    // optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
    bool has_gcm_id_update_request() const;
    void clear_gcm_id_update_request();
    static const int kGcmIdUpdateRequestFieldNumber = 16;
    const ::enterprise_management::GcmIdUpdateRequest& gcm_id_update_request() const;
    ::enterprise_management::GcmIdUpdateRequest* mutable_gcm_id_update_request();
    ::enterprise_management::GcmIdUpdateRequest* release_gcm_id_update_request();
    void set_allocated_gcm_id_update_request(::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request);

    // optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
    bool has_check_android_management_request() const;
    void clear_check_android_management_request();
    static const int kCheckAndroidManagementRequestFieldNumber = 17;
    const ::enterprise_management::CheckAndroidManagementRequest& check_android_management_request() const;
    ::enterprise_management::CheckAndroidManagementRequest* mutable_check_android_management_request();
    ::enterprise_management::CheckAndroidManagementRequest* release_check_android_management_request();
    void set_allocated_check_android_management_request(::enterprise_management::CheckAndroidManagementRequest* check_android_management_request);

    // optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
    bool has_certificate_based_register_request() const;
    void clear_certificate_based_register_request();
    static const int kCertificateBasedRegisterRequestFieldNumber = 18;
    const ::enterprise_management::CertificateBasedDeviceRegisterRequest& certificate_based_register_request() const;
    ::enterprise_management::CertificateBasedDeviceRegisterRequest* mutable_certificate_based_register_request();
    ::enterprise_management::CertificateBasedDeviceRegisterRequest* release_certificate_based_register_request();
    void set_allocated_certificate_based_register_request(::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceManagementRequest)
private:
    inline void set_has_register_request();
    inline void clear_has_register_request();
    inline void set_has_unregister_request();
    inline void clear_has_unregister_request();
    inline void set_has_policy_request();
    inline void clear_has_policy_request();
    inline void set_has_device_status_report_request();
    inline void clear_has_device_status_report_request();
    inline void set_has_session_status_report_request();
    inline void clear_has_session_status_report_request();
    inline void set_has_auto_enrollment_request();
    inline void clear_has_auto_enrollment_request();
    inline void set_has_cert_upload_request();
    inline void clear_has_cert_upload_request();
    inline void set_has_service_api_access_request();
    inline void clear_has_service_api_access_request();
    inline void set_has_device_state_retrieval_request();
    inline void clear_has_device_state_retrieval_request();
    inline void set_has_device_state_key_update_request();
    inline void clear_has_device_state_key_update_request();
    inline void set_has_device_pairing_request();
    inline void clear_has_device_pairing_request();
    inline void set_has_check_device_pairing_request();
    inline void clear_has_check_device_pairing_request();
    inline void set_has_remote_command_request();
    inline void clear_has_remote_command_request();
    inline void set_has_device_attribute_update_permission_request();
    inline void clear_has_device_attribute_update_permission_request();
    inline void set_has_device_attribute_update_request();
    inline void clear_has_device_attribute_update_request();
    inline void set_has_gcm_id_update_request();
    inline void clear_has_gcm_id_update_request();
    inline void set_has_check_android_management_request();
    inline void clear_has_check_android_management_request();
    inline void set_has_certificate_based_register_request();
    inline void clear_has_certificate_based_register_request();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::enterprise_management::DeviceRegisterRequest* register_request_;
    ::enterprise_management::DeviceUnregisterRequest* unregister_request_;
    ::enterprise_management::DevicePolicyRequest* policy_request_;
    ::enterprise_management::DeviceStatusReportRequest* device_status_report_request_;
    ::enterprise_management::SessionStatusReportRequest* session_status_report_request_;
    ::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request_;
    ::enterprise_management::DeviceCertUploadRequest* cert_upload_request_;
    ::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request_;
    ::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request_;
    ::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request_;
    ::enterprise_management::DevicePairingRequest* device_pairing_request_;
    ::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request_;
    ::enterprise_management::DeviceRemoteCommandRequest* remote_command_request_;
    ::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request_;
    ::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request_;
    ::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request_;
    ::enterprise_management::CheckAndroidManagementRequest* check_android_management_request_;
    ::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceManagementRequest* default_instance_;
};
// -------------------------------------------------------------------

class POLICY_PROTO_EXPORT DeviceManagementResponse : public ::google::protobuf::MessageLite {
public:
    DeviceManagementResponse();
    virtual ~DeviceManagementResponse();

    DeviceManagementResponse(const DeviceManagementResponse& from);

    inline DeviceManagementResponse& operator=(const DeviceManagementResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::std::string& unknown_fields() const
    {
        return _unknown_fields_.GetNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    inline ::std::string* mutable_unknown_fields()
    {
        return _unknown_fields_.MutableNoArena(
            &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }

    static const DeviceManagementResponse& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const DeviceManagementResponse* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceManagementResponse* other);

    // implements Message ----------------------------------------------

    inline DeviceManagementResponse* New() const { return New(NULL); }

    DeviceManagementResponse* New(::google::protobuf::Arena* arena) const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const DeviceManagementResponse& from);
    void MergeFrom(const DeviceManagementResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    void DiscardUnknownFields();
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceManagementResponse* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return _arena_ptr_;
    }
    inline ::google::protobuf::Arena* MaybeArenaPtr() const
    {
        return _arena_ptr_;
    }

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    typedef DeviceManagementResponse_ErrorCode ErrorCode;
    static const ErrorCode SUCCESS = DeviceManagementResponse_ErrorCode_SUCCESS;
    static const ErrorCode DEVICE_MANAGEMENT_NOT_SUPPORTED = DeviceManagementResponse_ErrorCode_DEVICE_MANAGEMENT_NOT_SUPPORTED;
    static const ErrorCode DEVICE_NOT_FOUND = DeviceManagementResponse_ErrorCode_DEVICE_NOT_FOUND;
    static const ErrorCode DEVICE_MANAGEMENT_TOKEN_INVALID = DeviceManagementResponse_ErrorCode_DEVICE_MANAGEMENT_TOKEN_INVALID;
    static const ErrorCode ACTIVATION_PENDING = DeviceManagementResponse_ErrorCode_ACTIVATION_PENDING;
    static const ErrorCode POLICY_NOT_FOUND = DeviceManagementResponse_ErrorCode_POLICY_NOT_FOUND;
    static inline bool ErrorCode_IsValid(int value)
    {
        return DeviceManagementResponse_ErrorCode_IsValid(value);
    }
    static const ErrorCode ErrorCode_MIN = DeviceManagementResponse_ErrorCode_ErrorCode_MIN;
    static const ErrorCode ErrorCode_MAX = DeviceManagementResponse_ErrorCode_ErrorCode_MAX;
    static const int ErrorCode_ARRAYSIZE = DeviceManagementResponse_ErrorCode_ErrorCode_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // optional .enterprise_management.DeviceManagementResponse.ErrorCode error = 1 [default = SUCCESS];
    bool has_error() const;
    void clear_error();
    static const int kErrorFieldNumber = 1;
    ::enterprise_management::DeviceManagementResponse_ErrorCode error() const;
    void set_error(::enterprise_management::DeviceManagementResponse_ErrorCode value);

    // optional string error_message = 2;
    bool has_error_message() const;
    void clear_error_message();
    static const int kErrorMessageFieldNumber = 2;
    const ::std::string& error_message() const;
    void set_error_message(const ::std::string& value);
    void set_error_message(const char* value);
    void set_error_message(const char* value, size_t size);
    ::std::string* mutable_error_message();
    ::std::string* release_error_message();
    void set_allocated_error_message(::std::string* error_message);

    // optional .enterprise_management.DeviceRegisterResponse register_response = 3;
    bool has_register_response() const;
    void clear_register_response();
    static const int kRegisterResponseFieldNumber = 3;
    const ::enterprise_management::DeviceRegisterResponse& register_response() const;
    ::enterprise_management::DeviceRegisterResponse* mutable_register_response();
    ::enterprise_management::DeviceRegisterResponse* release_register_response();
    void set_allocated_register_response(::enterprise_management::DeviceRegisterResponse* register_response);

    // optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
    bool has_unregister_response() const;
    void clear_unregister_response();
    static const int kUnregisterResponseFieldNumber = 4;
    const ::enterprise_management::DeviceUnregisterResponse& unregister_response() const;
    ::enterprise_management::DeviceUnregisterResponse* mutable_unregister_response();
    ::enterprise_management::DeviceUnregisterResponse* release_unregister_response();
    void set_allocated_unregister_response(::enterprise_management::DeviceUnregisterResponse* unregister_response);

    // optional .enterprise_management.DevicePolicyResponse policy_response = 5;
    bool has_policy_response() const;
    void clear_policy_response();
    static const int kPolicyResponseFieldNumber = 5;
    const ::enterprise_management::DevicePolicyResponse& policy_response() const;
    ::enterprise_management::DevicePolicyResponse* mutable_policy_response();
    ::enterprise_management::DevicePolicyResponse* release_policy_response();
    void set_allocated_policy_response(::enterprise_management::DevicePolicyResponse* policy_response);

    // optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
    bool has_device_status_report_response() const;
    void clear_device_status_report_response();
    static const int kDeviceStatusReportResponseFieldNumber = 6;
    const ::enterprise_management::DeviceStatusReportResponse& device_status_report_response() const;
    ::enterprise_management::DeviceStatusReportResponse* mutable_device_status_report_response();
    ::enterprise_management::DeviceStatusReportResponse* release_device_status_report_response();
    void set_allocated_device_status_report_response(::enterprise_management::DeviceStatusReportResponse* device_status_report_response);

    // optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
    bool has_session_status_report_response() const;
    void clear_session_status_report_response();
    static const int kSessionStatusReportResponseFieldNumber = 7;
    const ::enterprise_management::SessionStatusReportResponse& session_status_report_response() const;
    ::enterprise_management::SessionStatusReportResponse* mutable_session_status_report_response();
    ::enterprise_management::SessionStatusReportResponse* release_session_status_report_response();
    void set_allocated_session_status_report_response(::enterprise_management::SessionStatusReportResponse* session_status_report_response);

    // optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
    bool has_auto_enrollment_response() const;
    void clear_auto_enrollment_response();
    static const int kAutoEnrollmentResponseFieldNumber = 8;
    const ::enterprise_management::DeviceAutoEnrollmentResponse& auto_enrollment_response() const;
    ::enterprise_management::DeviceAutoEnrollmentResponse* mutable_auto_enrollment_response();
    ::enterprise_management::DeviceAutoEnrollmentResponse* release_auto_enrollment_response();
    void set_allocated_auto_enrollment_response(::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response);

    // optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
    bool has_cert_upload_response() const;
    void clear_cert_upload_response();
    static const int kCertUploadResponseFieldNumber = 9;
    const ::enterprise_management::DeviceCertUploadResponse& cert_upload_response() const;
    ::enterprise_management::DeviceCertUploadResponse* mutable_cert_upload_response();
    ::enterprise_management::DeviceCertUploadResponse* release_cert_upload_response();
    void set_allocated_cert_upload_response(::enterprise_management::DeviceCertUploadResponse* cert_upload_response);

    // optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
    bool has_service_api_access_response() const;
    void clear_service_api_access_response();
    static const int kServiceApiAccessResponseFieldNumber = 10;
    const ::enterprise_management::DeviceServiceApiAccessResponse& service_api_access_response() const;
    ::enterprise_management::DeviceServiceApiAccessResponse* mutable_service_api_access_response();
    ::enterprise_management::DeviceServiceApiAccessResponse* release_service_api_access_response();
    void set_allocated_service_api_access_response(::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response);

    // optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
    bool has_device_state_retrieval_response() const;
    void clear_device_state_retrieval_response();
    static const int kDeviceStateRetrievalResponseFieldNumber = 11;
    const ::enterprise_management::DeviceStateRetrievalResponse& device_state_retrieval_response() const;
    ::enterprise_management::DeviceStateRetrievalResponse* mutable_device_state_retrieval_response();
    ::enterprise_management::DeviceStateRetrievalResponse* release_device_state_retrieval_response();
    void set_allocated_device_state_retrieval_response(::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response);

    // optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
    bool has_device_pairing_response() const;
    void clear_device_pairing_response();
    static const int kDevicePairingResponseFieldNumber = 12;
    const ::enterprise_management::DevicePairingResponse& device_pairing_response() const;
    ::enterprise_management::DevicePairingResponse* mutable_device_pairing_response();
    ::enterprise_management::DevicePairingResponse* release_device_pairing_response();
    void set_allocated_device_pairing_response(::enterprise_management::DevicePairingResponse* device_pairing_response);

    // optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
    bool has_check_device_pairing_response() const;
    void clear_check_device_pairing_response();
    static const int kCheckDevicePairingResponseFieldNumber = 13;
    const ::enterprise_management::CheckDevicePairingResponse& check_device_pairing_response() const;
    ::enterprise_management::CheckDevicePairingResponse* mutable_check_device_pairing_response();
    ::enterprise_management::CheckDevicePairingResponse* release_check_device_pairing_response();
    void set_allocated_check_device_pairing_response(::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response);

    // optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
    bool has_remote_command_response() const;
    void clear_remote_command_response();
    static const int kRemoteCommandResponseFieldNumber = 14;
    const ::enterprise_management::DeviceRemoteCommandResponse& remote_command_response() const;
    ::enterprise_management::DeviceRemoteCommandResponse* mutable_remote_command_response();
    ::enterprise_management::DeviceRemoteCommandResponse* release_remote_command_response();
    void set_allocated_remote_command_response(::enterprise_management::DeviceRemoteCommandResponse* remote_command_response);

    // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
    bool has_device_attribute_update_permission_response() const;
    void clear_device_attribute_update_permission_response();
    static const int kDeviceAttributeUpdatePermissionResponseFieldNumber = 15;
    const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& device_attribute_update_permission_response() const;
    ::enterprise_management::DeviceAttributeUpdatePermissionResponse* mutable_device_attribute_update_permission_response();
    ::enterprise_management::DeviceAttributeUpdatePermissionResponse* release_device_attribute_update_permission_response();
    void set_allocated_device_attribute_update_permission_response(::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response);

    // optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
    bool has_device_attribute_update_response() const;
    void clear_device_attribute_update_response();
    static const int kDeviceAttributeUpdateResponseFieldNumber = 16;
    const ::enterprise_management::DeviceAttributeUpdateResponse& device_attribute_update_response() const;
    ::enterprise_management::DeviceAttributeUpdateResponse* mutable_device_attribute_update_response();
    ::enterprise_management::DeviceAttributeUpdateResponse* release_device_attribute_update_response();
    void set_allocated_device_attribute_update_response(::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response);

    // optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
    bool has_gcm_id_update_response() const;
    void clear_gcm_id_update_response();
    static const int kGcmIdUpdateResponseFieldNumber = 17;
    const ::enterprise_management::GcmIdUpdateResponse& gcm_id_update_response() const;
    ::enterprise_management::GcmIdUpdateResponse* mutable_gcm_id_update_response();
    ::enterprise_management::GcmIdUpdateResponse* release_gcm_id_update_response();
    void set_allocated_gcm_id_update_response(::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response);

    // optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
    bool has_check_android_management_response() const;
    void clear_check_android_management_response();
    static const int kCheckAndroidManagementResponseFieldNumber = 18;
    const ::enterprise_management::CheckAndroidManagementResponse& check_android_management_response() const;
    ::enterprise_management::CheckAndroidManagementResponse* mutable_check_android_management_response();
    ::enterprise_management::CheckAndroidManagementResponse* release_check_android_management_response();
    void set_allocated_check_android_management_response(::enterprise_management::CheckAndroidManagementResponse* check_android_management_response);

    // @@protoc_insertion_point(class_scope:enterprise_management.DeviceManagementResponse)
private:
    inline void set_has_error();
    inline void clear_has_error();
    inline void set_has_error_message();
    inline void clear_has_error_message();
    inline void set_has_register_response();
    inline void clear_has_register_response();
    inline void set_has_unregister_response();
    inline void clear_has_unregister_response();
    inline void set_has_policy_response();
    inline void clear_has_policy_response();
    inline void set_has_device_status_report_response();
    inline void clear_has_device_status_report_response();
    inline void set_has_session_status_report_response();
    inline void clear_has_session_status_report_response();
    inline void set_has_auto_enrollment_response();
    inline void clear_has_auto_enrollment_response();
    inline void set_has_cert_upload_response();
    inline void clear_has_cert_upload_response();
    inline void set_has_service_api_access_response();
    inline void clear_has_service_api_access_response();
    inline void set_has_device_state_retrieval_response();
    inline void clear_has_device_state_retrieval_response();
    inline void set_has_device_pairing_response();
    inline void clear_has_device_pairing_response();
    inline void set_has_check_device_pairing_response();
    inline void clear_has_check_device_pairing_response();
    inline void set_has_remote_command_response();
    inline void clear_has_remote_command_response();
    inline void set_has_device_attribute_update_permission_response();
    inline void clear_has_device_attribute_update_permission_response();
    inline void set_has_device_attribute_update_response();
    inline void clear_has_device_attribute_update_response();
    inline void set_has_gcm_id_update_response();
    inline void clear_has_gcm_id_update_response();
    inline void set_has_check_android_management_response();
    inline void clear_has_check_android_management_response();

    ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
    ::google::protobuf::Arena* _arena_ptr_;

    ::google::protobuf::uint32 _has_bits_[1];
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::enterprise_management::DeviceRegisterResponse* register_response_;
    ::enterprise_management::DeviceUnregisterResponse* unregister_response_;
    ::enterprise_management::DevicePolicyResponse* policy_response_;
    ::enterprise_management::DeviceStatusReportResponse* device_status_report_response_;
    ::enterprise_management::SessionStatusReportResponse* session_status_report_response_;
    ::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response_;
    ::enterprise_management::DeviceCertUploadResponse* cert_upload_response_;
    ::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response_;
    ::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response_;
    ::enterprise_management::DevicePairingResponse* device_pairing_response_;
    ::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response_;
    ::enterprise_management::DeviceRemoteCommandResponse* remote_command_response_;
    ::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response_;
    ::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response_;
    ::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response_;
    ::enterprise_management::CheckAndroidManagementResponse* check_android_management_response_;
    int error_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto_impl();
#else
    friend void POLICY_PROTO_EXPORT protobuf_AddDesc_device_5fmanagement_5fbackend_2eproto();
#endif
    friend void protobuf_AssignDesc_device_5fmanagement_5fbackend_2eproto();
    friend void protobuf_ShutdownFile_device_5fmanagement_5fbackend_2eproto();

    void InitAsDefaultInstance();
    static DeviceManagementResponse* default_instance_;
};
// ===================================================================

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SignedData

// optional bytes data = 1;
inline bool SignedData::has_data() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedData::set_has_data()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void SignedData::clear_has_data()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void SignedData::clear_data()
{
    data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_data();
}
inline const ::std::string& SignedData::data() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SignedData.data)
    return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedData::set_data(const ::std::string& value)
{
    set_has_data();
    data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.SignedData.data)
}
inline void SignedData::set_data(const char* value)
{
    set_has_data();
    data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.SignedData.data)
}
inline void SignedData::set_data(const void* value, size_t size)
{
    set_has_data();
    data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.SignedData.data)
}
inline ::std::string* SignedData::mutable_data()
{
    set_has_data();
    // @@protoc_insertion_point(field_mutable:enterprise_management.SignedData.data)
    return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedData::release_data()
{
    // @@protoc_insertion_point(field_release:enterprise_management.SignedData.data)
    clear_has_data();
    return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedData::set_allocated_data(::std::string* data)
{
    if (data != NULL) {
        set_has_data();
    } else {
        clear_has_data();
    }
    data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.SignedData.data)
}

// optional bytes signature = 2;
inline bool SignedData::has_signature() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedData::set_has_signature()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void SignedData::clear_has_signature()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void SignedData::clear_signature()
{
    signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_signature();
}
inline const ::std::string& SignedData::signature() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SignedData.signature)
    return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedData::set_signature(const ::std::string& value)
{
    set_has_signature();
    signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.SignedData.signature)
}
inline void SignedData::set_signature(const char* value)
{
    set_has_signature();
    signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.SignedData.signature)
}
inline void SignedData::set_signature(const void* value, size_t size)
{
    set_has_signature();
    signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.SignedData.signature)
}
inline ::std::string* SignedData::mutable_signature()
{
    set_has_signature();
    // @@protoc_insertion_point(field_mutable:enterprise_management.SignedData.signature)
    return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedData::release_signature()
{
    // @@protoc_insertion_point(field_release:enterprise_management.SignedData.signature)
    clear_has_signature();
    return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedData::set_allocated_signature(::std::string* signature)
{
    if (signature != NULL) {
        set_has_signature();
    } else {
        clear_has_signature();
    }
    signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.SignedData.signature)
}

// optional int32 extra_data_bytes = 3;
inline bool SignedData::has_extra_data_bytes() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedData::set_has_extra_data_bytes()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void SignedData::clear_has_extra_data_bytes()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void SignedData::clear_extra_data_bytes()
{
    extra_data_bytes_ = 0;
    clear_has_extra_data_bytes();
}
inline ::google::protobuf::int32 SignedData::extra_data_bytes() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SignedData.extra_data_bytes)
    return extra_data_bytes_;
}
inline void SignedData::set_extra_data_bytes(::google::protobuf::int32 value)
{
    set_has_extra_data_bytes();
    extra_data_bytes_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.SignedData.extra_data_bytes)
}

// -------------------------------------------------------------------

// DeviceRegisterRequest

// optional bool reregister = 1;
inline bool DeviceRegisterRequest::has_reregister() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRegisterRequest::set_has_reregister()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceRegisterRequest::clear_has_reregister()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceRegisterRequest::clear_reregister()
{
    reregister_ = false;
    clear_has_reregister();
}
inline bool DeviceRegisterRequest::reregister() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.reregister)
    return reregister_;
}
inline void DeviceRegisterRequest::set_reregister(bool value)
{
    set_has_reregister();
    reregister_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.reregister)
}

// optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
inline bool DeviceRegisterRequest::has_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceRegisterRequest::set_has_type()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceRegisterRequest::clear_has_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceRegisterRequest::clear_type()
{
    type_ = 0;
    clear_has_type();
}
inline ::enterprise_management::DeviceRegisterRequest_Type DeviceRegisterRequest::type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.type)
    return static_cast<::enterprise_management::DeviceRegisterRequest_Type>(type_);
}
inline void DeviceRegisterRequest::set_type(::enterprise_management::DeviceRegisterRequest_Type value)
{
    assert(::enterprise_management::DeviceRegisterRequest_Type_IsValid(value));
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.type)
}

// optional string machine_id = 3;
inline bool DeviceRegisterRequest::has_machine_id() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceRegisterRequest::set_has_machine_id()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void DeviceRegisterRequest::clear_has_machine_id()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceRegisterRequest::clear_machine_id()
{
    machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_machine_id();
}
inline const ::std::string& DeviceRegisterRequest::machine_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.machine_id)
    return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_machine_id(const ::std::string& value)
{
    set_has_machine_id();
    machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline void DeviceRegisterRequest::set_machine_id(const char* value)
{
    set_has_machine_id();
    machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline void DeviceRegisterRequest::set_machine_id(const char* value, size_t size)
{
    set_has_machine_id();
    machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline ::std::string* DeviceRegisterRequest::mutable_machine_id()
{
    set_has_machine_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.machine_id)
    return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceRegisterRequest::release_machine_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.machine_id)
    clear_has_machine_id();
    return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_machine_id(::std::string* machine_id)
{
    if (machine_id != NULL) {
        set_has_machine_id();
    } else {
        clear_has_machine_id();
    }
    machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.machine_id)
}

// optional string machine_model = 4;
inline bool DeviceRegisterRequest::has_machine_model() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceRegisterRequest::set_has_machine_model()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void DeviceRegisterRequest::clear_has_machine_model()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceRegisterRequest::clear_machine_model()
{
    machine_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_machine_model();
}
inline const ::std::string& DeviceRegisterRequest::machine_model() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.machine_model)
    return machine_model_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_machine_model(const ::std::string& value)
{
    set_has_machine_model();
    machine_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline void DeviceRegisterRequest::set_machine_model(const char* value)
{
    set_has_machine_model();
    machine_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline void DeviceRegisterRequest::set_machine_model(const char* value, size_t size)
{
    set_has_machine_model();
    machine_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline ::std::string* DeviceRegisterRequest::mutable_machine_model()
{
    set_has_machine_model();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.machine_model)
    return machine_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceRegisterRequest::release_machine_model()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.machine_model)
    clear_has_machine_model();
    return machine_model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_machine_model(::std::string* machine_model)
{
    if (machine_model != NULL) {
        set_has_machine_model();
    } else {
        clear_has_machine_model();
    }
    machine_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_model);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.machine_model)
}

// optional bool OBSOLETE_auto_enrolled = 5 [deprecated = true];
inline bool DeviceRegisterRequest::has_obsolete_auto_enrolled() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceRegisterRequest::set_has_obsolete_auto_enrolled()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void DeviceRegisterRequest::clear_has_obsolete_auto_enrolled()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceRegisterRequest::clear_obsolete_auto_enrolled()
{
    obsolete_auto_enrolled_ = false;
    clear_has_obsolete_auto_enrolled();
}
inline bool DeviceRegisterRequest::obsolete_auto_enrolled() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.OBSOLETE_auto_enrolled)
    return obsolete_auto_enrolled_;
}
inline void DeviceRegisterRequest::set_obsolete_auto_enrolled(bool value)
{
    set_has_obsolete_auto_enrolled();
    obsolete_auto_enrolled_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.OBSOLETE_auto_enrolled)
}

// optional string requisition = 6;
inline bool DeviceRegisterRequest::has_requisition() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceRegisterRequest::set_has_requisition()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void DeviceRegisterRequest::clear_has_requisition()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceRegisterRequest::clear_requisition()
{
    requisition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_requisition();
}
inline const ::std::string& DeviceRegisterRequest::requisition() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.requisition)
    return requisition_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_requisition(const ::std::string& value)
{
    set_has_requisition();
    requisition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.requisition)
}
inline void DeviceRegisterRequest::set_requisition(const char* value)
{
    set_has_requisition();
    requisition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.requisition)
}
inline void DeviceRegisterRequest::set_requisition(const char* value, size_t size)
{
    set_has_requisition();
    requisition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.requisition)
}
inline ::std::string* DeviceRegisterRequest::mutable_requisition()
{
    set_has_requisition();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.requisition)
    return requisition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceRegisterRequest::release_requisition()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.requisition)
    clear_has_requisition();
    return requisition_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_requisition(::std::string* requisition)
{
    if (requisition != NULL) {
        set_has_requisition();
    } else {
        clear_has_requisition();
    }
    requisition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requisition);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.requisition)
}

// optional bytes server_backed_state_key = 7;
inline bool DeviceRegisterRequest::has_server_backed_state_key() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceRegisterRequest::set_has_server_backed_state_key()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void DeviceRegisterRequest::clear_has_server_backed_state_key()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceRegisterRequest::clear_server_backed_state_key()
{
    server_backed_state_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_backed_state_key();
}
inline const ::std::string& DeviceRegisterRequest::server_backed_state_key() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
    return server_backed_state_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_server_backed_state_key(const ::std::string& value)
{
    set_has_server_backed_state_key();
    server_backed_state_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline void DeviceRegisterRequest::set_server_backed_state_key(const char* value)
{
    set_has_server_backed_state_key();
    server_backed_state_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline void DeviceRegisterRequest::set_server_backed_state_key(const void* value, size_t size)
{
    set_has_server_backed_state_key();
    server_backed_state_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline ::std::string* DeviceRegisterRequest::mutable_server_backed_state_key()
{
    set_has_server_backed_state_key();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
    return server_backed_state_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceRegisterRequest::release_server_backed_state_key()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
    clear_has_server_backed_state_key();
    return server_backed_state_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterRequest::set_allocated_server_backed_state_key(::std::string* server_backed_state_key)
{
    if (server_backed_state_key != NULL) {
        set_has_server_backed_state_key();
    } else {
        clear_has_server_backed_state_key();
    }
    server_backed_state_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_backed_state_key);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}

// optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
inline bool DeviceRegisterRequest::has_flavor() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceRegisterRequest::set_has_flavor()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void DeviceRegisterRequest::clear_has_flavor()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceRegisterRequest::clear_flavor()
{
    flavor_ = 0;
    clear_has_flavor();
}
inline ::enterprise_management::DeviceRegisterRequest_Flavor DeviceRegisterRequest::flavor() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.flavor)
    return static_cast<::enterprise_management::DeviceRegisterRequest_Flavor>(flavor_);
}
inline void DeviceRegisterRequest::set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value)
{
    assert(::enterprise_management::DeviceRegisterRequest_Flavor_IsValid(value));
    set_has_flavor();
    flavor_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.flavor)
}

// -------------------------------------------------------------------

// DeviceRegisterResponse

// required string device_management_token = 1;
inline bool DeviceRegisterResponse::has_device_management_token() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRegisterResponse::set_has_device_management_token()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceRegisterResponse::clear_has_device_management_token()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceRegisterResponse::clear_device_management_token()
{
    device_management_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_device_management_token();
}
inline const ::std::string& DeviceRegisterResponse::device_management_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.device_management_token)
    return device_management_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_device_management_token(const ::std::string& value)
{
    set_has_device_management_token();
    device_management_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline void DeviceRegisterResponse::set_device_management_token(const char* value)
{
    set_has_device_management_token();
    device_management_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline void DeviceRegisterResponse::set_device_management_token(const char* value, size_t size)
{
    set_has_device_management_token();
    device_management_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline ::std::string* DeviceRegisterResponse::mutable_device_management_token()
{
    set_has_device_management_token();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.device_management_token)
    return device_management_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceRegisterResponse::release_device_management_token()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.device_management_token)
    clear_has_device_management_token();
    return device_management_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_allocated_device_management_token(::std::string* device_management_token)
{
    if (device_management_token != NULL) {
        set_has_device_management_token();
    } else {
        clear_has_device_management_token();
    }
    device_management_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_management_token);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.device_management_token)
}

// optional string machine_name = 2;
inline bool DeviceRegisterResponse::has_machine_name() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceRegisterResponse::set_has_machine_name()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceRegisterResponse::clear_has_machine_name()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceRegisterResponse::clear_machine_name()
{
    machine_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_machine_name();
}
inline const ::std::string& DeviceRegisterResponse::machine_name() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.machine_name)
    return machine_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_machine_name(const ::std::string& value)
{
    set_has_machine_name();
    machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline void DeviceRegisterResponse::set_machine_name(const char* value)
{
    set_has_machine_name();
    machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline void DeviceRegisterResponse::set_machine_name(const char* value, size_t size)
{
    set_has_machine_name();
    machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline ::std::string* DeviceRegisterResponse::mutable_machine_name()
{
    set_has_machine_name();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.machine_name)
    return machine_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceRegisterResponse::release_machine_name()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.machine_name)
    clear_has_machine_name();
    return machine_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_allocated_machine_name(::std::string* machine_name)
{
    if (machine_name != NULL) {
        set_has_machine_name();
    } else {
        clear_has_machine_name();
    }
    machine_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_name);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.machine_name)
}

// optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
inline bool DeviceRegisterResponse::has_enrollment_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceRegisterResponse::set_has_enrollment_type()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void DeviceRegisterResponse::clear_has_enrollment_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceRegisterResponse::clear_enrollment_type()
{
    enrollment_type_ = 0;
    clear_has_enrollment_type();
}
inline ::enterprise_management::DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::enrollment_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.enrollment_type)
    return static_cast<::enterprise_management::DeviceRegisterResponse_DeviceMode>(enrollment_type_);
}
inline void DeviceRegisterResponse::set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value)
{
    assert(::enterprise_management::DeviceRegisterResponse_DeviceMode_IsValid(value));
    set_has_enrollment_type();
    enrollment_type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.enrollment_type)
}

// optional string configuration_seed = 4;
inline bool DeviceRegisterResponse::has_configuration_seed() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceRegisterResponse::set_has_configuration_seed()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void DeviceRegisterResponse::clear_has_configuration_seed()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceRegisterResponse::clear_configuration_seed()
{
    configuration_seed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_configuration_seed();
}
inline const ::std::string& DeviceRegisterResponse::configuration_seed() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.configuration_seed)
    return configuration_seed_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_configuration_seed(const ::std::string& value)
{
    set_has_configuration_seed();
    configuration_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline void DeviceRegisterResponse::set_configuration_seed(const char* value)
{
    set_has_configuration_seed();
    configuration_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline void DeviceRegisterResponse::set_configuration_seed(const char* value, size_t size)
{
    set_has_configuration_seed();
    configuration_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline ::std::string* DeviceRegisterResponse::mutable_configuration_seed()
{
    set_has_configuration_seed();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.configuration_seed)
    return configuration_seed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceRegisterResponse::release_configuration_seed()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.configuration_seed)
    clear_has_configuration_seed();
    return configuration_seed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceRegisterResponse::set_allocated_configuration_seed(::std::string* configuration_seed)
{
    if (configuration_seed != NULL) {
        set_has_configuration_seed();
    } else {
        clear_has_configuration_seed();
    }
    configuration_seed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), configuration_seed);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.configuration_seed)
}

// -------------------------------------------------------------------

// DeviceUnregisterRequest

// -------------------------------------------------------------------

// DeviceUnregisterResponse

// -------------------------------------------------------------------

// DeviceCertUploadRequest

// optional bytes device_certificate = 1;
inline bool DeviceCertUploadRequest::has_device_certificate() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCertUploadRequest::set_has_device_certificate()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceCertUploadRequest::clear_has_device_certificate()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceCertUploadRequest::clear_device_certificate()
{
    device_certificate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_device_certificate();
}
inline const ::std::string& DeviceCertUploadRequest::device_certificate() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceCertUploadRequest.device_certificate)
    return device_certificate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceCertUploadRequest::set_device_certificate(const ::std::string& value)
{
    set_has_device_certificate();
    device_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline void DeviceCertUploadRequest::set_device_certificate(const char* value)
{
    set_has_device_certificate();
    device_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline void DeviceCertUploadRequest::set_device_certificate(const void* value, size_t size)
{
    set_has_device_certificate();
    device_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline ::std::string* DeviceCertUploadRequest::mutable_device_certificate()
{
    set_has_device_certificate();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceCertUploadRequest.device_certificate)
    return device_certificate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceCertUploadRequest::release_device_certificate()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceCertUploadRequest.device_certificate)
    clear_has_device_certificate();
    return device_certificate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceCertUploadRequest::set_allocated_device_certificate(::std::string* device_certificate)
{
    if (device_certificate != NULL) {
        set_has_device_certificate();
    } else {
        clear_has_device_certificate();
    }
    device_certificate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_certificate);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceCertUploadRequest.device_certificate)
}

// -------------------------------------------------------------------

// DeviceCertUploadResponse

// -------------------------------------------------------------------

// DeviceServiceApiAccessRequest

// repeated string auth_scope = 1;
inline int DeviceServiceApiAccessRequest::auth_scope_size() const
{
    return auth_scope_.size();
}
inline void DeviceServiceApiAccessRequest::clear_auth_scope()
{
    auth_scope_.Clear();
}
inline const ::std::string& DeviceServiceApiAccessRequest::auth_scope(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
    return auth_scope_.Get(index);
}
inline ::std::string* DeviceServiceApiAccessRequest::mutable_auth_scope(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
    return auth_scope_.Mutable(index);
}
inline void DeviceServiceApiAccessRequest::set_auth_scope(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
    auth_scope_.Mutable(index)->assign(value);
}
inline void DeviceServiceApiAccessRequest::set_auth_scope(int index, const char* value)
{
    auth_scope_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
}
inline void DeviceServiceApiAccessRequest::set_auth_scope(int index, const char* value, size_t size)
{
    auth_scope_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
}
inline ::std::string* DeviceServiceApiAccessRequest::add_auth_scope()
{
    // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
    return auth_scope_.Add();
}
inline void DeviceServiceApiAccessRequest::add_auth_scope(const ::std::string& value)
{
    auth_scope_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
}
inline void DeviceServiceApiAccessRequest::add_auth_scope(const char* value)
{
    auth_scope_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
}
inline void DeviceServiceApiAccessRequest::add_auth_scope(const char* value, size_t size)
{
    auth_scope_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DeviceServiceApiAccessRequest::auth_scope() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
    return auth_scope_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DeviceServiceApiAccessRequest::mutable_auth_scope()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceServiceApiAccessRequest.auth_scope)
    return &auth_scope_;
}

// optional string oauth2_client_id = 2;
inline bool DeviceServiceApiAccessRequest::has_oauth2_client_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceServiceApiAccessRequest::set_has_oauth2_client_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceServiceApiAccessRequest::clear_has_oauth2_client_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceServiceApiAccessRequest::clear_oauth2_client_id()
{
    oauth2_client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_oauth2_client_id();
}
inline const ::std::string& DeviceServiceApiAccessRequest::oauth2_client_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
    return oauth2_client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceServiceApiAccessRequest::set_oauth2_client_id(const ::std::string& value)
{
    set_has_oauth2_client_id();
    oauth2_client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline void DeviceServiceApiAccessRequest::set_oauth2_client_id(const char* value)
{
    set_has_oauth2_client_id();
    oauth2_client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline void DeviceServiceApiAccessRequest::set_oauth2_client_id(const char* value, size_t size)
{
    set_has_oauth2_client_id();
    oauth2_client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline ::std::string* DeviceServiceApiAccessRequest::mutable_oauth2_client_id()
{
    set_has_oauth2_client_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
    return oauth2_client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceServiceApiAccessRequest::release_oauth2_client_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
    clear_has_oauth2_client_id();
    return oauth2_client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceServiceApiAccessRequest::set_allocated_oauth2_client_id(::std::string* oauth2_client_id)
{
    if (oauth2_client_id != NULL) {
        set_has_oauth2_client_id();
    } else {
        clear_has_oauth2_client_id();
    }
    oauth2_client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oauth2_client_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}

// optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
inline bool DeviceServiceApiAccessRequest::has_device_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceServiceApiAccessRequest::set_has_device_type()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void DeviceServiceApiAccessRequest::clear_has_device_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceServiceApiAccessRequest::clear_device_type()
{
    device_type_ = 0;
    clear_has_device_type();
}
inline ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::device_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.device_type)
    return static_cast<::enterprise_management::DeviceServiceApiAccessRequest_DeviceType>(device_type_);
}
inline void DeviceServiceApiAccessRequest::set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value)
{
    assert(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType_IsValid(value));
    set_has_device_type();
    device_type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.device_type)
}

// -------------------------------------------------------------------

// DeviceServiceApiAccessResponse

// optional string auth_code = 1;
inline bool DeviceServiceApiAccessResponse::has_auth_code() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceServiceApiAccessResponse::set_has_auth_code()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceServiceApiAccessResponse::clear_has_auth_code()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceServiceApiAccessResponse::clear_auth_code()
{
    auth_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_auth_code();
}
inline const ::std::string& DeviceServiceApiAccessResponse::auth_code() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
    return auth_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceServiceApiAccessResponse::set_auth_code(const ::std::string& value)
{
    set_has_auth_code();
    auth_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline void DeviceServiceApiAccessResponse::set_auth_code(const char* value)
{
    set_has_auth_code();
    auth_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline void DeviceServiceApiAccessResponse::set_auth_code(const char* value, size_t size)
{
    set_has_auth_code();
    auth_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline ::std::string* DeviceServiceApiAccessResponse::mutable_auth_code()
{
    set_has_auth_code();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
    return auth_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceServiceApiAccessResponse::release_auth_code()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
    clear_has_auth_code();
    return auth_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceServiceApiAccessResponse::set_allocated_auth_code(::std::string* auth_code)
{
    if (auth_code != NULL) {
        set_has_auth_code();
    } else {
        clear_has_auth_code();
    }
    auth_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth_code);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}

// -------------------------------------------------------------------

// PolicyFetchRequest

// optional string policy_type = 1;
inline bool PolicyFetchRequest::has_policy_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyFetchRequest::set_has_policy_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void PolicyFetchRequest::clear_has_policy_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void PolicyFetchRequest::clear_policy_type()
{
    policy_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_policy_type();
}
inline const ::std::string& PolicyFetchRequest::policy_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.policy_type)
    return policy_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_policy_type(const ::std::string& value)
{
    set_has_policy_type();
    policy_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.policy_type)
}
inline void PolicyFetchRequest::set_policy_type(const char* value)
{
    set_has_policy_type();
    policy_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.policy_type)
}
inline void PolicyFetchRequest::set_policy_type(const char* value, size_t size)
{
    set_has_policy_type();
    policy_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.policy_type)
}
inline ::std::string* PolicyFetchRequest::mutable_policy_type()
{
    set_has_policy_type();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.policy_type)
    return policy_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchRequest::release_policy_type()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.policy_type)
    clear_has_policy_type();
    return policy_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_policy_type(::std::string* policy_type)
{
    if (policy_type != NULL) {
        set_has_policy_type();
    } else {
        clear_has_policy_type();
    }
    policy_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), policy_type);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.policy_type)
}

// optional int64 timestamp = 2;
inline bool PolicyFetchRequest::has_timestamp() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyFetchRequest::set_has_timestamp()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void PolicyFetchRequest::clear_has_timestamp()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void PolicyFetchRequest::clear_timestamp()
{
    timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_timestamp();
}
inline ::google::protobuf::int64 PolicyFetchRequest::timestamp() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.timestamp)
    return timestamp_;
}
inline void PolicyFetchRequest::set_timestamp(::google::protobuf::int64 value)
{
    set_has_timestamp();
    timestamp_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.timestamp)
}

// optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
inline bool PolicyFetchRequest::has_signature_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyFetchRequest::set_has_signature_type()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void PolicyFetchRequest::clear_has_signature_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void PolicyFetchRequest::clear_signature_type()
{
    signature_type_ = 0;
    clear_has_signature_type();
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType PolicyFetchRequest::signature_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.signature_type)
    return static_cast<::enterprise_management::PolicyFetchRequest_SignatureType>(signature_type_);
}
inline void PolicyFetchRequest::set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value)
{
    assert(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(value));
    set_has_signature_type();
    signature_type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.signature_type)
}

// optional int32 public_key_version = 4;
inline bool PolicyFetchRequest::has_public_key_version() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PolicyFetchRequest::set_has_public_key_version()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void PolicyFetchRequest::clear_has_public_key_version()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void PolicyFetchRequest::clear_public_key_version()
{
    public_key_version_ = 0;
    clear_has_public_key_version();
}
inline ::google::protobuf::int32 PolicyFetchRequest::public_key_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.public_key_version)
    return public_key_version_;
}
inline void PolicyFetchRequest::set_public_key_version(::google::protobuf::int32 value)
{
    set_has_public_key_version();
    public_key_version_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.public_key_version)
}

// optional string machine_id = 5;
inline bool PolicyFetchRequest::has_machine_id() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PolicyFetchRequest::set_has_machine_id()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void PolicyFetchRequest::clear_has_machine_id()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void PolicyFetchRequest::clear_machine_id()
{
    machine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_machine_id();
}
inline const ::std::string& PolicyFetchRequest::machine_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.machine_id)
    return machine_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_machine_id(const ::std::string& value)
{
    set_has_machine_id();
    machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.machine_id)
}
inline void PolicyFetchRequest::set_machine_id(const char* value)
{
    set_has_machine_id();
    machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.machine_id)
}
inline void PolicyFetchRequest::set_machine_id(const char* value, size_t size)
{
    set_has_machine_id();
    machine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.machine_id)
}
inline ::std::string* PolicyFetchRequest::mutable_machine_id()
{
    set_has_machine_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.machine_id)
    return machine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchRequest::release_machine_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.machine_id)
    clear_has_machine_id();
    return machine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_machine_id(::std::string* machine_id)
{
    if (machine_id != NULL) {
        set_has_machine_id();
    } else {
        clear_has_machine_id();
    }
    machine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.machine_id)
}

// optional string settings_entity_id = 6;
inline bool PolicyFetchRequest::has_settings_entity_id() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PolicyFetchRequest::set_has_settings_entity_id()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void PolicyFetchRequest::clear_has_settings_entity_id()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void PolicyFetchRequest::clear_settings_entity_id()
{
    settings_entity_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_settings_entity_id();
}
inline const ::std::string& PolicyFetchRequest::settings_entity_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.settings_entity_id)
    return settings_entity_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_settings_entity_id(const ::std::string& value)
{
    set_has_settings_entity_id();
    settings_entity_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline void PolicyFetchRequest::set_settings_entity_id(const char* value)
{
    set_has_settings_entity_id();
    settings_entity_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline void PolicyFetchRequest::set_settings_entity_id(const char* value, size_t size)
{
    set_has_settings_entity_id();
    settings_entity_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline ::std::string* PolicyFetchRequest::mutable_settings_entity_id()
{
    set_has_settings_entity_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.settings_entity_id)
    return settings_entity_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchRequest::release_settings_entity_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.settings_entity_id)
    clear_has_settings_entity_id();
    return settings_entity_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_settings_entity_id(::std::string* settings_entity_id)
{
    if (settings_entity_id != NULL) {
        set_has_settings_entity_id();
    } else {
        clear_has_settings_entity_id();
    }
    settings_entity_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), settings_entity_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.settings_entity_id)
}

// optional int64 invalidation_version = 7;
inline bool PolicyFetchRequest::has_invalidation_version() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PolicyFetchRequest::set_has_invalidation_version()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void PolicyFetchRequest::clear_has_invalidation_version()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void PolicyFetchRequest::clear_invalidation_version()
{
    invalidation_version_ = GOOGLE_LONGLONG(0);
    clear_has_invalidation_version();
}
inline ::google::protobuf::int64 PolicyFetchRequest::invalidation_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_version)
    return invalidation_version_;
}
inline void PolicyFetchRequest::set_invalidation_version(::google::protobuf::int64 value)
{
    set_has_invalidation_version();
    invalidation_version_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_version)
}

// optional bytes invalidation_payload = 8;
inline bool PolicyFetchRequest::has_invalidation_payload() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PolicyFetchRequest::set_has_invalidation_payload()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void PolicyFetchRequest::clear_has_invalidation_payload()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void PolicyFetchRequest::clear_invalidation_payload()
{
    invalidation_payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_invalidation_payload();
}
inline const ::std::string& PolicyFetchRequest::invalidation_payload() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_payload)
    return invalidation_payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_invalidation_payload(const ::std::string& value)
{
    set_has_invalidation_payload();
    invalidation_payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline void PolicyFetchRequest::set_invalidation_payload(const char* value)
{
    set_has_invalidation_payload();
    invalidation_payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline void PolicyFetchRequest::set_invalidation_payload(const void* value, size_t size)
{
    set_has_invalidation_payload();
    invalidation_payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline ::std::string* PolicyFetchRequest::mutable_invalidation_payload()
{
    set_has_invalidation_payload();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.invalidation_payload)
    return invalidation_payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchRequest::release_invalidation_payload()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.invalidation_payload)
    clear_has_invalidation_payload();
    return invalidation_payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_invalidation_payload(::std::string* invalidation_payload)
{
    if (invalidation_payload != NULL) {
        set_has_invalidation_payload();
    } else {
        clear_has_invalidation_payload();
    }
    invalidation_payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), invalidation_payload);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.invalidation_payload)
}

// optional string verification_key_hash = 9;
inline bool PolicyFetchRequest::has_verification_key_hash() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PolicyFetchRequest::set_has_verification_key_hash()
{
    _has_bits_[0] |= 0x00000100u;
}
inline void PolicyFetchRequest::clear_has_verification_key_hash()
{
    _has_bits_[0] &= ~0x00000100u;
}
inline void PolicyFetchRequest::clear_verification_key_hash()
{
    verification_key_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_verification_key_hash();
}
inline const ::std::string& PolicyFetchRequest::verification_key_hash() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.verification_key_hash)
    return verification_key_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_verification_key_hash(const ::std::string& value)
{
    set_has_verification_key_hash();
    verification_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline void PolicyFetchRequest::set_verification_key_hash(const char* value)
{
    set_has_verification_key_hash();
    verification_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline void PolicyFetchRequest::set_verification_key_hash(const char* value, size_t size)
{
    set_has_verification_key_hash();
    verification_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline ::std::string* PolicyFetchRequest::mutable_verification_key_hash()
{
    set_has_verification_key_hash();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.verification_key_hash)
    return verification_key_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchRequest::release_verification_key_hash()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.verification_key_hash)
    clear_has_verification_key_hash();
    return verification_key_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchRequest::set_allocated_verification_key_hash(::std::string* verification_key_hash)
{
    if (verification_key_hash != NULL) {
        set_has_verification_key_hash();
    } else {
        clear_has_verification_key_hash();
    }
    verification_key_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verification_key_hash);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.verification_key_hash)
}

// -------------------------------------------------------------------

// DisabledState

// optional string message = 1;
inline bool DisabledState::has_message() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisabledState::set_has_message()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DisabledState::clear_has_message()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DisabledState::clear_message()
{
    message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_message();
}
inline const ::std::string& DisabledState::message() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DisabledState.message)
    return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisabledState::set_message(const ::std::string& value)
{
    set_has_message();
    message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DisabledState.message)
}
inline void DisabledState::set_message(const char* value)
{
    set_has_message();
    message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DisabledState.message)
}
inline void DisabledState::set_message(const char* value, size_t size)
{
    set_has_message();
    message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DisabledState.message)
}
inline ::std::string* DisabledState::mutable_message()
{
    set_has_message();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DisabledState.message)
    return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisabledState::release_message()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DisabledState.message)
    clear_has_message();
    return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisabledState::set_allocated_message(::std::string* message)
{
    if (message != NULL) {
        set_has_message();
    } else {
        clear_has_message();
    }
    message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DisabledState.message)
}

// -------------------------------------------------------------------

// DeviceState

// optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
inline bool DeviceState::has_device_mode() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceState::set_has_device_mode()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceState::clear_has_device_mode()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceState::clear_device_mode()
{
    device_mode_ = 0;
    clear_has_device_mode();
}
inline ::enterprise_management::DeviceState_DeviceMode DeviceState::device_mode() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceState.device_mode)
    return static_cast<::enterprise_management::DeviceState_DeviceMode>(device_mode_);
}
inline void DeviceState::set_device_mode(::enterprise_management::DeviceState_DeviceMode value)
{
    assert(::enterprise_management::DeviceState_DeviceMode_IsValid(value));
    set_has_device_mode();
    device_mode_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceState.device_mode)
}

// optional .enterprise_management.DisabledState disabled_state = 2;
inline bool DeviceState::has_disabled_state() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceState::set_has_disabled_state()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceState::clear_has_disabled_state()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceState::clear_disabled_state()
{
    if (disabled_state_ != NULL)
        disabled_state_->::enterprise_management::DisabledState::Clear();
    clear_has_disabled_state();
}
inline const ::enterprise_management::DisabledState& DeviceState::disabled_state() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceState.disabled_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return disabled_state_ != NULL ? *disabled_state_ : *default_instance().disabled_state_;
#else
    return disabled_state_ != NULL ? *disabled_state_ : *default_instance_->disabled_state_;
#endif
}
inline ::enterprise_management::DisabledState* DeviceState::mutable_disabled_state()
{
    set_has_disabled_state();
    if (disabled_state_ == NULL) {
        disabled_state_ = new ::enterprise_management::DisabledState;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceState.disabled_state)
    return disabled_state_;
}
inline ::enterprise_management::DisabledState* DeviceState::release_disabled_state()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceState.disabled_state)
    clear_has_disabled_state();
    ::enterprise_management::DisabledState* temp = disabled_state_;
    disabled_state_ = NULL;
    return temp;
}
inline void DeviceState::set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state)
{
    delete disabled_state_;
    disabled_state_ = disabled_state;
    if (disabled_state) {
        set_has_disabled_state();
    } else {
        clear_has_disabled_state();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceState.disabled_state)
}

// -------------------------------------------------------------------

// PolicyData

// optional string policy_type = 1;
inline bool PolicyData::has_policy_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyData::set_has_policy_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void PolicyData::clear_has_policy_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void PolicyData::clear_policy_type()
{
    policy_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_policy_type();
}
inline const ::std::string& PolicyData::policy_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_type)
    return policy_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_policy_type(const ::std::string& value)
{
    set_has_policy_type();
    policy_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_type)
}
inline void PolicyData::set_policy_type(const char* value)
{
    set_has_policy_type();
    policy_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.policy_type)
}
inline void PolicyData::set_policy_type(const char* value, size_t size)
{
    set_has_policy_type();
    policy_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.policy_type)
}
inline ::std::string* PolicyData::mutable_policy_type()
{
    set_has_policy_type();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_type)
    return policy_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_policy_type()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_type)
    clear_has_policy_type();
    return policy_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_policy_type(::std::string* policy_type)
{
    if (policy_type != NULL) {
        set_has_policy_type();
    } else {
        clear_has_policy_type();
    }
    policy_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), policy_type);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_type)
}

// optional int64 timestamp = 2;
inline bool PolicyData::has_timestamp() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyData::set_has_timestamp()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void PolicyData::clear_has_timestamp()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void PolicyData::clear_timestamp()
{
    timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_timestamp();
}
inline ::google::protobuf::int64 PolicyData::timestamp() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.timestamp)
    return timestamp_;
}
inline void PolicyData::set_timestamp(::google::protobuf::int64 value)
{
    set_has_timestamp();
    timestamp_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.timestamp)
}

// optional string request_token = 3;
inline bool PolicyData::has_request_token() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyData::set_has_request_token()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void PolicyData::clear_has_request_token()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void PolicyData::clear_request_token()
{
    request_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_request_token();
}
inline const ::std::string& PolicyData::request_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.request_token)
    return request_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_request_token(const ::std::string& value)
{
    set_has_request_token();
    request_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.request_token)
}
inline void PolicyData::set_request_token(const char* value)
{
    set_has_request_token();
    request_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.request_token)
}
inline void PolicyData::set_request_token(const char* value, size_t size)
{
    set_has_request_token();
    request_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.request_token)
}
inline ::std::string* PolicyData::mutable_request_token()
{
    set_has_request_token();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.request_token)
    return request_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_request_token()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.request_token)
    clear_has_request_token();
    return request_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_request_token(::std::string* request_token)
{
    if (request_token != NULL) {
        set_has_request_token();
    } else {
        clear_has_request_token();
    }
    request_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_token);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.request_token)
}

// optional bytes policy_value = 4;
inline bool PolicyData::has_policy_value() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PolicyData::set_has_policy_value()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void PolicyData::clear_has_policy_value()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void PolicyData::clear_policy_value()
{
    policy_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_policy_value();
}
inline const ::std::string& PolicyData::policy_value() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_value)
    return policy_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_policy_value(const ::std::string& value)
{
    set_has_policy_value();
    policy_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_value)
}
inline void PolicyData::set_policy_value(const char* value)
{
    set_has_policy_value();
    policy_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.policy_value)
}
inline void PolicyData::set_policy_value(const void* value, size_t size)
{
    set_has_policy_value();
    policy_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.policy_value)
}
inline ::std::string* PolicyData::mutable_policy_value()
{
    set_has_policy_value();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_value)
    return policy_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_policy_value()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_value)
    clear_has_policy_value();
    return policy_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_policy_value(::std::string* policy_value)
{
    if (policy_value != NULL) {
        set_has_policy_value();
    } else {
        clear_has_policy_value();
    }
    policy_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), policy_value);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_value)
}

// optional string machine_name = 5;
inline bool PolicyData::has_machine_name() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PolicyData::set_has_machine_name()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void PolicyData::clear_has_machine_name()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void PolicyData::clear_machine_name()
{
    machine_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_machine_name();
}
inline const ::std::string& PolicyData::machine_name() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.machine_name)
    return machine_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_machine_name(const ::std::string& value)
{
    set_has_machine_name();
    machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.machine_name)
}
inline void PolicyData::set_machine_name(const char* value)
{
    set_has_machine_name();
    machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.machine_name)
}
inline void PolicyData::set_machine_name(const char* value, size_t size)
{
    set_has_machine_name();
    machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.machine_name)
}
inline ::std::string* PolicyData::mutable_machine_name()
{
    set_has_machine_name();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.machine_name)
    return machine_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_machine_name()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.machine_name)
    clear_has_machine_name();
    return machine_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_machine_name(::std::string* machine_name)
{
    if (machine_name != NULL) {
        set_has_machine_name();
    } else {
        clear_has_machine_name();
    }
    machine_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_name);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.machine_name)
}

// optional int32 public_key_version = 6;
inline bool PolicyData::has_public_key_version() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PolicyData::set_has_public_key_version()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void PolicyData::clear_has_public_key_version()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void PolicyData::clear_public_key_version()
{
    public_key_version_ = 0;
    clear_has_public_key_version();
}
inline ::google::protobuf::int32 PolicyData::public_key_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.public_key_version)
    return public_key_version_;
}
inline void PolicyData::set_public_key_version(::google::protobuf::int32 value)
{
    set_has_public_key_version();
    public_key_version_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.public_key_version)
}

// optional string username = 7;
inline bool PolicyData::has_username() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PolicyData::set_has_username()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void PolicyData::clear_has_username()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void PolicyData::clear_username()
{
    username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_username();
}
inline const ::std::string& PolicyData::username() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.username)
    return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_username(const ::std::string& value)
{
    set_has_username();
    username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.username)
}
inline void PolicyData::set_username(const char* value)
{
    set_has_username();
    username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.username)
}
inline void PolicyData::set_username(const char* value, size_t size)
{
    set_has_username();
    username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.username)
}
inline ::std::string* PolicyData::mutable_username()
{
    set_has_username();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.username)
    return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_username()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.username)
    clear_has_username();
    return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_username(::std::string* username)
{
    if (username != NULL) {
        set_has_username();
    } else {
        clear_has_username();
    }
    username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.username)
}

// optional string device_id = 8;
inline bool PolicyData::has_device_id() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PolicyData::set_has_device_id()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void PolicyData::clear_has_device_id()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void PolicyData::clear_device_id()
{
    device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_device_id();
}
inline const ::std::string& PolicyData::device_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_id)
    return device_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_device_id(const ::std::string& value)
{
    set_has_device_id();
    device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_id)
}
inline void PolicyData::set_device_id(const char* value)
{
    set_has_device_id();
    device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.device_id)
}
inline void PolicyData::set_device_id(const char* value, size_t size)
{
    set_has_device_id();
    device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.device_id)
}
inline ::std::string* PolicyData::mutable_device_id()
{
    set_has_device_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_id)
    return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_device_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.device_id)
    clear_has_device_id();
    return device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_device_id(::std::string* device_id)
{
    if (device_id != NULL) {
        set_has_device_id();
    } else {
        clear_has_device_id();
    }
    device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.device_id)
}

// optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
inline bool PolicyData::has_state() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PolicyData::set_has_state()
{
    _has_bits_[0] |= 0x00000100u;
}
inline void PolicyData::clear_has_state()
{
    _has_bits_[0] &= ~0x00000100u;
}
inline void PolicyData::clear_state()
{
    state_ = 0;
    clear_has_state();
}
inline ::enterprise_management::PolicyData_AssociationState PolicyData::state() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.state)
    return static_cast<::enterprise_management::PolicyData_AssociationState>(state_);
}
inline void PolicyData::set_state(::enterprise_management::PolicyData_AssociationState value)
{
    assert(::enterprise_management::PolicyData_AssociationState_IsValid(value));
    set_has_state();
    state_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.state)
}

// optional bool valid_serial_number_missing = 10;
inline bool PolicyData::has_valid_serial_number_missing() const
{
    return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PolicyData::set_has_valid_serial_number_missing()
{
    _has_bits_[0] |= 0x00000200u;
}
inline void PolicyData::clear_has_valid_serial_number_missing()
{
    _has_bits_[0] &= ~0x00000200u;
}
inline void PolicyData::clear_valid_serial_number_missing()
{
    valid_serial_number_missing_ = false;
    clear_has_valid_serial_number_missing();
}
inline bool PolicyData::valid_serial_number_missing() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.valid_serial_number_missing)
    return valid_serial_number_missing_;
}
inline void PolicyData::set_valid_serial_number_missing(bool value)
{
    set_has_valid_serial_number_missing();
    valid_serial_number_missing_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.valid_serial_number_missing)
}

// optional string settings_entity_id = 11;
inline bool PolicyData::has_settings_entity_id() const
{
    return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PolicyData::set_has_settings_entity_id()
{
    _has_bits_[0] |= 0x00000400u;
}
inline void PolicyData::clear_has_settings_entity_id()
{
    _has_bits_[0] &= ~0x00000400u;
}
inline void PolicyData::clear_settings_entity_id()
{
    settings_entity_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_settings_entity_id();
}
inline const ::std::string& PolicyData::settings_entity_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.settings_entity_id)
    return settings_entity_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_settings_entity_id(const ::std::string& value)
{
    set_has_settings_entity_id();
    settings_entity_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.settings_entity_id)
}
inline void PolicyData::set_settings_entity_id(const char* value)
{
    set_has_settings_entity_id();
    settings_entity_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.settings_entity_id)
}
inline void PolicyData::set_settings_entity_id(const char* value, size_t size)
{
    set_has_settings_entity_id();
    settings_entity_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.settings_entity_id)
}
inline ::std::string* PolicyData::mutable_settings_entity_id()
{
    set_has_settings_entity_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.settings_entity_id)
    return settings_entity_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_settings_entity_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.settings_entity_id)
    clear_has_settings_entity_id();
    return settings_entity_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_settings_entity_id(::std::string* settings_entity_id)
{
    if (settings_entity_id != NULL) {
        set_has_settings_entity_id();
    } else {
        clear_has_settings_entity_id();
    }
    settings_entity_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), settings_entity_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.settings_entity_id)
}

// optional string service_account_identity = 12;
inline bool PolicyData::has_service_account_identity() const
{
    return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PolicyData::set_has_service_account_identity()
{
    _has_bits_[0] |= 0x00000800u;
}
inline void PolicyData::clear_has_service_account_identity()
{
    _has_bits_[0] &= ~0x00000800u;
}
inline void PolicyData::clear_service_account_identity()
{
    service_account_identity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_service_account_identity();
}
inline const ::std::string& PolicyData::service_account_identity() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.service_account_identity)
    return service_account_identity_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_service_account_identity(const ::std::string& value)
{
    set_has_service_account_identity();
    service_account_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.service_account_identity)
}
inline void PolicyData::set_service_account_identity(const char* value)
{
    set_has_service_account_identity();
    service_account_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.service_account_identity)
}
inline void PolicyData::set_service_account_identity(const char* value, size_t size)
{
    set_has_service_account_identity();
    service_account_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.service_account_identity)
}
inline ::std::string* PolicyData::mutable_service_account_identity()
{
    set_has_service_account_identity();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.service_account_identity)
    return service_account_identity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_service_account_identity()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.service_account_identity)
    clear_has_service_account_identity();
    return service_account_identity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_service_account_identity(::std::string* service_account_identity)
{
    if (service_account_identity != NULL) {
        set_has_service_account_identity();
    } else {
        clear_has_service_account_identity();
    }
    service_account_identity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_account_identity);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.service_account_identity)
}

// optional int32 invalidation_source = 13;
inline bool PolicyData::has_invalidation_source() const
{
    return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PolicyData::set_has_invalidation_source()
{
    _has_bits_[0] |= 0x00001000u;
}
inline void PolicyData::clear_has_invalidation_source()
{
    _has_bits_[0] &= ~0x00001000u;
}
inline void PolicyData::clear_invalidation_source()
{
    invalidation_source_ = 0;
    clear_has_invalidation_source();
}
inline ::google::protobuf::int32 PolicyData::invalidation_source() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.invalidation_source)
    return invalidation_source_;
}
inline void PolicyData::set_invalidation_source(::google::protobuf::int32 value)
{
    set_has_invalidation_source();
    invalidation_source_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.invalidation_source)
}

// optional bytes invalidation_name = 14;
inline bool PolicyData::has_invalidation_name() const
{
    return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PolicyData::set_has_invalidation_name()
{
    _has_bits_[0] |= 0x00002000u;
}
inline void PolicyData::clear_has_invalidation_name()
{
    _has_bits_[0] &= ~0x00002000u;
}
inline void PolicyData::clear_invalidation_name()
{
    invalidation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_invalidation_name();
}
inline const ::std::string& PolicyData::invalidation_name() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.invalidation_name)
    return invalidation_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_invalidation_name(const ::std::string& value)
{
    set_has_invalidation_name();
    invalidation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.invalidation_name)
}
inline void PolicyData::set_invalidation_name(const char* value)
{
    set_has_invalidation_name();
    invalidation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.invalidation_name)
}
inline void PolicyData::set_invalidation_name(const void* value, size_t size)
{
    set_has_invalidation_name();
    invalidation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.invalidation_name)
}
inline ::std::string* PolicyData::mutable_invalidation_name()
{
    set_has_invalidation_name();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.invalidation_name)
    return invalidation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_invalidation_name()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.invalidation_name)
    clear_has_invalidation_name();
    return invalidation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_invalidation_name(::std::string* invalidation_name)
{
    if (invalidation_name != NULL) {
        set_has_invalidation_name();
    } else {
        clear_has_invalidation_name();
    }
    invalidation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), invalidation_name);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.invalidation_name)
}

// optional string policy_token = 15;
inline bool PolicyData::has_policy_token() const
{
    return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PolicyData::set_has_policy_token()
{
    _has_bits_[0] |= 0x00004000u;
}
inline void PolicyData::clear_has_policy_token()
{
    _has_bits_[0] &= ~0x00004000u;
}
inline void PolicyData::clear_policy_token()
{
    policy_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_policy_token();
}
inline const ::std::string& PolicyData::policy_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_token)
    return policy_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_policy_token(const ::std::string& value)
{
    set_has_policy_token();
    policy_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_token)
}
inline void PolicyData::set_policy_token(const char* value)
{
    set_has_policy_token();
    policy_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.policy_token)
}
inline void PolicyData::set_policy_token(const char* value, size_t size)
{
    set_has_policy_token();
    policy_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.policy_token)
}
inline ::std::string* PolicyData::mutable_policy_token()
{
    set_has_policy_token();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_token)
    return policy_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_policy_token()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_token)
    clear_has_policy_token();
    return policy_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_policy_token(::std::string* policy_token)
{
    if (policy_token != NULL) {
        set_has_policy_token();
    } else {
        clear_has_policy_token();
    }
    policy_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), policy_token);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_token)
}

// optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
inline bool PolicyData::has_management_mode() const
{
    return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PolicyData::set_has_management_mode()
{
    _has_bits_[0] |= 0x00008000u;
}
inline void PolicyData::clear_has_management_mode()
{
    _has_bits_[0] &= ~0x00008000u;
}
inline void PolicyData::clear_management_mode()
{
    management_mode_ = 0;
    clear_has_management_mode();
}
inline ::enterprise_management::PolicyData_ManagementMode PolicyData::management_mode() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.management_mode)
    return static_cast<::enterprise_management::PolicyData_ManagementMode>(management_mode_);
}
inline void PolicyData::set_management_mode(::enterprise_management::PolicyData_ManagementMode value)
{
    assert(::enterprise_management::PolicyData_ManagementMode_IsValid(value));
    set_has_management_mode();
    management_mode_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.management_mode)
}

// optional .enterprise_management.DeviceState device_state = 17;
inline bool PolicyData::has_device_state() const
{
    return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PolicyData::set_has_device_state()
{
    _has_bits_[0] |= 0x00010000u;
}
inline void PolicyData::clear_has_device_state()
{
    _has_bits_[0] &= ~0x00010000u;
}
inline void PolicyData::clear_device_state()
{
    if (device_state_ != NULL)
        device_state_->::enterprise_management::DeviceState::Clear();
    clear_has_device_state();
}
inline const ::enterprise_management::DeviceState& PolicyData::device_state() const
{
// @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_state_ != NULL ? *device_state_ : *default_instance().device_state_;
#else
    return device_state_ != NULL ? *device_state_ : *default_instance_->device_state_;
#endif
}
inline ::enterprise_management::DeviceState* PolicyData::mutable_device_state()
{
    set_has_device_state();
    if (device_state_ == NULL) {
        device_state_ = new ::enterprise_management::DeviceState;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_state)
    return device_state_;
}
inline ::enterprise_management::DeviceState* PolicyData::release_device_state()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.device_state)
    clear_has_device_state();
    ::enterprise_management::DeviceState* temp = device_state_;
    device_state_ = NULL;
    return temp;
}
inline void PolicyData::set_allocated_device_state(::enterprise_management::DeviceState* device_state)
{
    delete device_state_;
    device_state_ = device_state;
    if (device_state) {
        set_has_device_state();
    } else {
        clear_has_device_state();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.device_state)
}

// optional int32 command_invalidation_source = 18;
inline bool PolicyData::has_command_invalidation_source() const
{
    return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PolicyData::set_has_command_invalidation_source()
{
    _has_bits_[0] |= 0x00020000u;
}
inline void PolicyData::clear_has_command_invalidation_source()
{
    _has_bits_[0] &= ~0x00020000u;
}
inline void PolicyData::clear_command_invalidation_source()
{
    command_invalidation_source_ = 0;
    clear_has_command_invalidation_source();
}
inline ::google::protobuf::int32 PolicyData::command_invalidation_source() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.command_invalidation_source)
    return command_invalidation_source_;
}
inline void PolicyData::set_command_invalidation_source(::google::protobuf::int32 value)
{
    set_has_command_invalidation_source();
    command_invalidation_source_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.command_invalidation_source)
}

// optional bytes command_invalidation_name = 19;
inline bool PolicyData::has_command_invalidation_name() const
{
    return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PolicyData::set_has_command_invalidation_name()
{
    _has_bits_[0] |= 0x00040000u;
}
inline void PolicyData::clear_has_command_invalidation_name()
{
    _has_bits_[0] &= ~0x00040000u;
}
inline void PolicyData::clear_command_invalidation_name()
{
    command_invalidation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_command_invalidation_name();
}
inline const ::std::string& PolicyData::command_invalidation_name() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.command_invalidation_name)
    return command_invalidation_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_command_invalidation_name(const ::std::string& value)
{
    set_has_command_invalidation_name();
    command_invalidation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.command_invalidation_name)
}
inline void PolicyData::set_command_invalidation_name(const char* value)
{
    set_has_command_invalidation_name();
    command_invalidation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.command_invalidation_name)
}
inline void PolicyData::set_command_invalidation_name(const void* value, size_t size)
{
    set_has_command_invalidation_name();
    command_invalidation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.command_invalidation_name)
}
inline ::std::string* PolicyData::mutable_command_invalidation_name()
{
    set_has_command_invalidation_name();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.command_invalidation_name)
    return command_invalidation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_command_invalidation_name()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.command_invalidation_name)
    clear_has_command_invalidation_name();
    return command_invalidation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_command_invalidation_name(::std::string* command_invalidation_name)
{
    if (command_invalidation_name != NULL) {
        set_has_command_invalidation_name();
    } else {
        clear_has_command_invalidation_name();
    }
    command_invalidation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command_invalidation_name);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.command_invalidation_name)
}

// optional string annotated_location = 20;
inline bool PolicyData::has_annotated_location() const
{
    return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PolicyData::set_has_annotated_location()
{
    _has_bits_[0] |= 0x00080000u;
}
inline void PolicyData::clear_has_annotated_location()
{
    _has_bits_[0] &= ~0x00080000u;
}
inline void PolicyData::clear_annotated_location()
{
    annotated_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_annotated_location();
}
inline const ::std::string& PolicyData::annotated_location() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.annotated_location)
    return annotated_location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_annotated_location(const ::std::string& value)
{
    set_has_annotated_location();
    annotated_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.annotated_location)
}
inline void PolicyData::set_annotated_location(const char* value)
{
    set_has_annotated_location();
    annotated_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.annotated_location)
}
inline void PolicyData::set_annotated_location(const char* value, size_t size)
{
    set_has_annotated_location();
    annotated_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.annotated_location)
}
inline ::std::string* PolicyData::mutable_annotated_location()
{
    set_has_annotated_location();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.annotated_location)
    return annotated_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_annotated_location()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.annotated_location)
    clear_has_annotated_location();
    return annotated_location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_annotated_location(::std::string* annotated_location)
{
    if (annotated_location != NULL) {
        set_has_annotated_location();
    } else {
        clear_has_annotated_location();
    }
    annotated_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), annotated_location);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.annotated_location)
}

// optional string annotated_asset_id = 21;
inline bool PolicyData::has_annotated_asset_id() const
{
    return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PolicyData::set_has_annotated_asset_id()
{
    _has_bits_[0] |= 0x00100000u;
}
inline void PolicyData::clear_has_annotated_asset_id()
{
    _has_bits_[0] &= ~0x00100000u;
}
inline void PolicyData::clear_annotated_asset_id()
{
    annotated_asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_annotated_asset_id();
}
inline const ::std::string& PolicyData::annotated_asset_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.annotated_asset_id)
    return annotated_asset_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_annotated_asset_id(const ::std::string& value)
{
    set_has_annotated_asset_id();
    annotated_asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.annotated_asset_id)
}
inline void PolicyData::set_annotated_asset_id(const char* value)
{
    set_has_annotated_asset_id();
    annotated_asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.annotated_asset_id)
}
inline void PolicyData::set_annotated_asset_id(const char* value, size_t size)
{
    set_has_annotated_asset_id();
    annotated_asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.annotated_asset_id)
}
inline ::std::string* PolicyData::mutable_annotated_asset_id()
{
    set_has_annotated_asset_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.annotated_asset_id)
    return annotated_asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_annotated_asset_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.annotated_asset_id)
    clear_has_annotated_asset_id();
    return annotated_asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_annotated_asset_id(::std::string* annotated_asset_id)
{
    if (annotated_asset_id != NULL) {
        set_has_annotated_asset_id();
    } else {
        clear_has_annotated_asset_id();
    }
    annotated_asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), annotated_asset_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.annotated_asset_id)
}

// optional string directory_api_id = 22;
inline bool PolicyData::has_directory_api_id() const
{
    return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PolicyData::set_has_directory_api_id()
{
    _has_bits_[0] |= 0x00200000u;
}
inline void PolicyData::clear_has_directory_api_id()
{
    _has_bits_[0] &= ~0x00200000u;
}
inline void PolicyData::clear_directory_api_id()
{
    directory_api_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_directory_api_id();
}
inline const ::std::string& PolicyData::directory_api_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.directory_api_id)
    return directory_api_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_directory_api_id(const ::std::string& value)
{
    set_has_directory_api_id();
    directory_api_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.directory_api_id)
}
inline void PolicyData::set_directory_api_id(const char* value)
{
    set_has_directory_api_id();
    directory_api_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.directory_api_id)
}
inline void PolicyData::set_directory_api_id(const char* value, size_t size)
{
    set_has_directory_api_id();
    directory_api_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.directory_api_id)
}
inline ::std::string* PolicyData::mutable_directory_api_id()
{
    set_has_directory_api_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.directory_api_id)
    return directory_api_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyData::release_directory_api_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.directory_api_id)
    clear_has_directory_api_id();
    return directory_api_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyData::set_allocated_directory_api_id(::std::string* directory_api_id)
{
    if (directory_api_id != NULL) {
        set_has_directory_api_id();
    } else {
        clear_has_directory_api_id();
    }
    directory_api_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), directory_api_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.directory_api_id)
}

// repeated string device_affiliation_ids = 23;
inline int PolicyData::device_affiliation_ids_size() const
{
    return device_affiliation_ids_.size();
}
inline void PolicyData::clear_device_affiliation_ids()
{
    device_affiliation_ids_.Clear();
}
inline const ::std::string& PolicyData::device_affiliation_ids(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_affiliation_ids)
    return device_affiliation_ids_.Get(index);
}
inline ::std::string* PolicyData::mutable_device_affiliation_ids(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_affiliation_ids)
    return device_affiliation_ids_.Mutable(index);
}
inline void PolicyData::set_device_affiliation_ids(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_affiliation_ids)
    device_affiliation_ids_.Mutable(index)->assign(value);
}
inline void PolicyData::set_device_affiliation_ids(int index, const char* value)
{
    device_affiliation_ids_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::set_device_affiliation_ids(int index, const char* value, size_t size)
{
    device_affiliation_ids_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.device_affiliation_ids)
}
inline ::std::string* PolicyData::add_device_affiliation_ids()
{
    // @@protoc_insertion_point(field_add_mutable:enterprise_management.PolicyData.device_affiliation_ids)
    return device_affiliation_ids_.Add();
}
inline void PolicyData::add_device_affiliation_ids(const ::std::string& value)
{
    device_affiliation_ids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(const char* value)
{
    device_affiliation_ids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(const char* value, size_t size)
{
    device_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_management.PolicyData.device_affiliation_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PolicyData::device_affiliation_ids() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.PolicyData.device_affiliation_ids)
    return device_affiliation_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PolicyData::mutable_device_affiliation_ids()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyData.device_affiliation_ids)
    return &device_affiliation_ids_;
}

// repeated string user_affiliation_ids = 24;
inline int PolicyData::user_affiliation_ids_size() const
{
    return user_affiliation_ids_.size();
}
inline void PolicyData::clear_user_affiliation_ids()
{
    user_affiliation_ids_.Clear();
}
inline const ::std::string& PolicyData::user_affiliation_ids(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.user_affiliation_ids)
    return user_affiliation_ids_.Get(index);
}
inline ::std::string* PolicyData::mutable_user_affiliation_ids(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.user_affiliation_ids)
    return user_affiliation_ids_.Mutable(index);
}
inline void PolicyData::set_user_affiliation_ids(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.user_affiliation_ids)
    user_affiliation_ids_.Mutable(index)->assign(value);
}
inline void PolicyData::set_user_affiliation_ids(int index, const char* value)
{
    user_affiliation_ids_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::set_user_affiliation_ids(int index, const char* value, size_t size)
{
    user_affiliation_ids_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.user_affiliation_ids)
}
inline ::std::string* PolicyData::add_user_affiliation_ids()
{
    // @@protoc_insertion_point(field_add_mutable:enterprise_management.PolicyData.user_affiliation_ids)
    return user_affiliation_ids_.Add();
}
inline void PolicyData::add_user_affiliation_ids(const ::std::string& value)
{
    user_affiliation_ids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(const char* value)
{
    user_affiliation_ids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(const char* value, size_t size)
{
    user_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_management.PolicyData.user_affiliation_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PolicyData::user_affiliation_ids() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.PolicyData.user_affiliation_ids)
    return user_affiliation_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PolicyData::mutable_user_affiliation_ids()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyData.user_affiliation_ids)
    return &user_affiliation_ids_;
}

// -------------------------------------------------------------------

// PolicyFetchResponse

// optional int32 error_code = 1;
inline bool PolicyFetchResponse::has_error_code() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolicyFetchResponse::set_has_error_code()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void PolicyFetchResponse::clear_has_error_code()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void PolicyFetchResponse::clear_error_code()
{
    error_code_ = 0;
    clear_has_error_code();
}
inline ::google::protobuf::int32 PolicyFetchResponse::error_code() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.error_code)
    return error_code_;
}
inline void PolicyFetchResponse::set_error_code(::google::protobuf::int32 value)
{
    set_has_error_code();
    error_code_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.error_code)
}

// optional string error_message = 2;
inline bool PolicyFetchResponse::has_error_message() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolicyFetchResponse::set_has_error_message()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void PolicyFetchResponse::clear_has_error_message()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void PolicyFetchResponse::clear_error_message()
{
    error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_error_message();
}
inline const ::std::string& PolicyFetchResponse::error_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.error_message)
    return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_error_message(const ::std::string& value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.error_message)
}
inline void PolicyFetchResponse::set_error_message(const char* value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.error_message)
}
inline void PolicyFetchResponse::set_error_message(const char* value, size_t size)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.error_message)
}
inline ::std::string* PolicyFetchResponse::mutable_error_message()
{
    set_has_error_message();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.error_message)
    return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_error_message()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.error_message)
    clear_has_error_message();
    return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_error_message(::std::string* error_message)
{
    if (error_message != NULL) {
        set_has_error_message();
    } else {
        clear_has_error_message();
    }
    error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.error_message)
}

// optional bytes policy_data = 3;
inline bool PolicyFetchResponse::has_policy_data() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolicyFetchResponse::set_has_policy_data()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void PolicyFetchResponse::clear_has_policy_data()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void PolicyFetchResponse::clear_policy_data()
{
    policy_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_policy_data();
}
inline const ::std::string& PolicyFetchResponse::policy_data() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data)
    return policy_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_policy_data(const ::std::string& value)
{
    set_has_policy_data();
    policy_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data)
}
inline void PolicyFetchResponse::set_policy_data(const char* value)
{
    set_has_policy_data();
    policy_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.policy_data)
}
inline void PolicyFetchResponse::set_policy_data(const void* value, size_t size)
{
    set_has_policy_data();
    policy_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.policy_data)
}
inline ::std::string* PolicyFetchResponse::mutable_policy_data()
{
    set_has_policy_data();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_data)
    return policy_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_policy_data()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_data)
    clear_has_policy_data();
    return policy_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_policy_data(::std::string* policy_data)
{
    if (policy_data != NULL) {
        set_has_policy_data();
    } else {
        clear_has_policy_data();
    }
    policy_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), policy_data);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_data)
}

// optional bytes policy_data_signature = 4;
inline bool PolicyFetchResponse::has_policy_data_signature() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PolicyFetchResponse::set_has_policy_data_signature()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void PolicyFetchResponse::clear_has_policy_data_signature()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void PolicyFetchResponse::clear_policy_data_signature()
{
    policy_data_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_policy_data_signature();
}
inline const ::std::string& PolicyFetchResponse::policy_data_signature() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data_signature)
    return policy_data_signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_policy_data_signature(const ::std::string& value)
{
    set_has_policy_data_signature();
    policy_data_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline void PolicyFetchResponse::set_policy_data_signature(const char* value)
{
    set_has_policy_data_signature();
    policy_data_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline void PolicyFetchResponse::set_policy_data_signature(const void* value, size_t size)
{
    set_has_policy_data_signature();
    policy_data_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline ::std::string* PolicyFetchResponse::mutable_policy_data_signature()
{
    set_has_policy_data_signature();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_data_signature)
    return policy_data_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_policy_data_signature()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_data_signature)
    clear_has_policy_data_signature();
    return policy_data_signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_policy_data_signature(::std::string* policy_data_signature)
{
    if (policy_data_signature != NULL) {
        set_has_policy_data_signature();
    } else {
        clear_has_policy_data_signature();
    }
    policy_data_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), policy_data_signature);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_data_signature)
}

// optional bytes new_public_key = 5;
inline bool PolicyFetchResponse::has_new_public_key() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PolicyFetchResponse::set_has_new_public_key()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void PolicyFetchResponse::clear_has_new_public_key()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void PolicyFetchResponse::clear_new_public_key()
{
    new_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_public_key();
}
inline const ::std::string& PolicyFetchResponse::new_public_key() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key)
    return new_public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_new_public_key(const ::std::string& value)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline void PolicyFetchResponse::set_new_public_key(const char* value)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline void PolicyFetchResponse::set_new_public_key(const void* value, size_t size)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline ::std::string* PolicyFetchResponse::mutable_new_public_key()
{
    set_has_new_public_key();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key)
    return new_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_new_public_key()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key)
    clear_has_new_public_key();
    return new_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key(::std::string* new_public_key)
{
    if (new_public_key != NULL) {
        set_has_new_public_key();
    } else {
        clear_has_new_public_key();
    }
    new_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_public_key);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key)
}

// optional bytes new_public_key_signature = 6;
inline bool PolicyFetchResponse::has_new_public_key_signature() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PolicyFetchResponse::set_has_new_public_key_signature()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void PolicyFetchResponse::clear_has_new_public_key_signature()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void PolicyFetchResponse::clear_new_public_key_signature()
{
    new_public_key_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_public_key_signature();
}
inline const ::std::string& PolicyFetchResponse::new_public_key_signature() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_signature)
    return new_public_key_signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_new_public_key_signature(const ::std::string& value)
{
    set_has_new_public_key_signature();
    new_public_key_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline void PolicyFetchResponse::set_new_public_key_signature(const char* value)
{
    set_has_new_public_key_signature();
    new_public_key_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline void PolicyFetchResponse::set_new_public_key_signature(const void* value, size_t size)
{
    set_has_new_public_key_signature();
    new_public_key_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline ::std::string* PolicyFetchResponse::mutable_new_public_key_signature()
{
    set_has_new_public_key_signature();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_signature)
    return new_public_key_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_new_public_key_signature()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_signature)
    clear_has_new_public_key_signature();
    return new_public_key_signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_signature(::std::string* new_public_key_signature)
{
    if (new_public_key_signature != NULL) {
        set_has_new_public_key_signature();
    } else {
        clear_has_new_public_key_signature();
    }
    new_public_key_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_public_key_signature);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}

// optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
inline bool PolicyFetchResponse::has_new_public_key_verification_signature_deprecated() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PolicyFetchResponse::set_has_new_public_key_verification_signature_deprecated()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void PolicyFetchResponse::clear_has_new_public_key_verification_signature_deprecated()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void PolicyFetchResponse::clear_new_public_key_verification_signature_deprecated()
{
    new_public_key_verification_signature_deprecated_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_public_key_verification_signature_deprecated();
}
inline const ::std::string& PolicyFetchResponse::new_public_key_verification_signature_deprecated() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
    return new_public_key_verification_signature_deprecated_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(const ::std::string& value)
{
    set_has_new_public_key_verification_signature_deprecated();
    new_public_key_verification_signature_deprecated_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(const char* value)
{
    set_has_new_public_key_verification_signature_deprecated();
    new_public_key_verification_signature_deprecated_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(const void* value, size_t size)
{
    set_has_new_public_key_verification_signature_deprecated();
    new_public_key_verification_signature_deprecated_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline ::std::string* PolicyFetchResponse::mutable_new_public_key_verification_signature_deprecated()
{
    set_has_new_public_key_verification_signature_deprecated();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
    return new_public_key_verification_signature_deprecated_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_new_public_key_verification_signature_deprecated()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
    clear_has_new_public_key_verification_signature_deprecated();
    return new_public_key_verification_signature_deprecated_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_signature_deprecated(::std::string* new_public_key_verification_signature_deprecated)
{
    if (new_public_key_verification_signature_deprecated != NULL) {
        set_has_new_public_key_verification_signature_deprecated();
    } else {
        clear_has_new_public_key_verification_signature_deprecated();
    }
    new_public_key_verification_signature_deprecated_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_public_key_verification_signature_deprecated);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}

// optional bytes new_public_key_verification_data = 8;
inline bool PolicyFetchResponse::has_new_public_key_verification_data() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PolicyFetchResponse::set_has_new_public_key_verification_data()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void PolicyFetchResponse::clear_has_new_public_key_verification_data()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void PolicyFetchResponse::clear_new_public_key_verification_data()
{
    new_public_key_verification_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_public_key_verification_data();
}
inline const ::std::string& PolicyFetchResponse::new_public_key_verification_data() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
    return new_public_key_verification_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_new_public_key_verification_data(const ::std::string& value)
{
    set_has_new_public_key_verification_data();
    new_public_key_verification_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data(const char* value)
{
    set_has_new_public_key_verification_data();
    new_public_key_verification_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data(const void* value, size_t size)
{
    set_has_new_public_key_verification_data();
    new_public_key_verification_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline ::std::string* PolicyFetchResponse::mutable_new_public_key_verification_data()
{
    set_has_new_public_key_verification_data();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
    return new_public_key_verification_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_new_public_key_verification_data()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
    clear_has_new_public_key_verification_data();
    return new_public_key_verification_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_data(::std::string* new_public_key_verification_data)
{
    if (new_public_key_verification_data != NULL) {
        set_has_new_public_key_verification_data();
    } else {
        clear_has_new_public_key_verification_data();
    }
    new_public_key_verification_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_public_key_verification_data);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}

// optional bytes new_public_key_verification_data_signature = 9;
inline bool PolicyFetchResponse::has_new_public_key_verification_data_signature() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PolicyFetchResponse::set_has_new_public_key_verification_data_signature()
{
    _has_bits_[0] |= 0x00000100u;
}
inline void PolicyFetchResponse::clear_has_new_public_key_verification_data_signature()
{
    _has_bits_[0] &= ~0x00000100u;
}
inline void PolicyFetchResponse::clear_new_public_key_verification_data_signature()
{
    new_public_key_verification_data_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_public_key_verification_data_signature();
}
inline const ::std::string& PolicyFetchResponse::new_public_key_verification_data_signature() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
    return new_public_key_verification_data_signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_new_public_key_verification_data_signature(const ::std::string& value)
{
    set_has_new_public_key_verification_data_signature();
    new_public_key_verification_data_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data_signature(const char* value)
{
    set_has_new_public_key_verification_data_signature();
    new_public_key_verification_data_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline void PolicyFetchResponse::set_new_public_key_verification_data_signature(const void* value, size_t size)
{
    set_has_new_public_key_verification_data_signature();
    new_public_key_verification_data_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline ::std::string* PolicyFetchResponse::mutable_new_public_key_verification_data_signature()
{
    set_has_new_public_key_verification_data_signature();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
    return new_public_key_verification_data_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolicyFetchResponse::release_new_public_key_verification_data_signature()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
    clear_has_new_public_key_verification_data_signature();
    return new_public_key_verification_data_signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_data_signature(::std::string* new_public_key_verification_data_signature)
{
    if (new_public_key_verification_data_signature != NULL) {
        set_has_new_public_key_verification_data_signature();
    } else {
        clear_has_new_public_key_verification_data_signature();
    }
    new_public_key_verification_data_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_public_key_verification_data_signature);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}

// -------------------------------------------------------------------

// DEPRECATEDPolicyPublicKeyAndDomain

// optional bytes new_public_key = 1;
inline bool DEPRECATEDPolicyPublicKeyAndDomain::has_new_public_key() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_has_new_public_key()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_has_new_public_key()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_new_public_key()
{
    new_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_public_key();
}
inline const ::std::string& DEPRECATEDPolicyPublicKeyAndDomain::new_public_key() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
    return new_public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(const ::std::string& value)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(const char* value)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(const void* value, size_t size)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline ::std::string* DEPRECATEDPolicyPublicKeyAndDomain::mutable_new_public_key()
{
    set_has_new_public_key();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
    return new_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DEPRECATEDPolicyPublicKeyAndDomain::release_new_public_key()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
    clear_has_new_public_key();
    return new_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_allocated_new_public_key(::std::string* new_public_key)
{
    if (new_public_key != NULL) {
        set_has_new_public_key();
    } else {
        clear_has_new_public_key();
    }
    new_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_public_key);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}

// optional string domain = 2;
inline bool DEPRECATEDPolicyPublicKeyAndDomain::has_domain() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_has_domain()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_has_domain()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_domain()
{
    domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_domain();
}
inline const ::std::string& DEPRECATEDPolicyPublicKeyAndDomain::domain() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
    return domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(const ::std::string& value)
{
    set_has_domain();
    domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(const char* value)
{
    set_has_domain();
    domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(const char* value, size_t size)
{
    set_has_domain();
    domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline ::std::string* DEPRECATEDPolicyPublicKeyAndDomain::mutable_domain()
{
    set_has_domain();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
    return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DEPRECATEDPolicyPublicKeyAndDomain::release_domain()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
    clear_has_domain();
    return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_allocated_domain(::std::string* domain)
{
    if (domain != NULL) {
        set_has_domain();
    } else {
        clear_has_domain();
    }
    domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}

// -------------------------------------------------------------------

// PublicKeyVerificationData

// optional bytes new_public_key = 1;
inline bool PublicKeyVerificationData::has_new_public_key() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicKeyVerificationData::set_has_new_public_key()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void PublicKeyVerificationData::clear_has_new_public_key()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void PublicKeyVerificationData::clear_new_public_key()
{
    new_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_public_key();
}
inline const ::std::string& PublicKeyVerificationData::new_public_key() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.new_public_key)
    return new_public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyVerificationData::set_new_public_key(const ::std::string& value)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline void PublicKeyVerificationData::set_new_public_key(const char* value)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline void PublicKeyVerificationData::set_new_public_key(const void* value, size_t size)
{
    set_has_new_public_key();
    new_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline ::std::string* PublicKeyVerificationData::mutable_new_public_key()
{
    set_has_new_public_key();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PublicKeyVerificationData.new_public_key)
    return new_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKeyVerificationData::release_new_public_key()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PublicKeyVerificationData.new_public_key)
    clear_has_new_public_key();
    return new_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyVerificationData::set_allocated_new_public_key(::std::string* new_public_key)
{
    if (new_public_key != NULL) {
        set_has_new_public_key();
    } else {
        clear_has_new_public_key();
    }
    new_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_public_key);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicKeyVerificationData.new_public_key)
}

// optional string domain = 2;
inline bool PublicKeyVerificationData::has_domain() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicKeyVerificationData::set_has_domain()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void PublicKeyVerificationData::clear_has_domain()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void PublicKeyVerificationData::clear_domain()
{
    domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_domain();
}
inline const ::std::string& PublicKeyVerificationData::domain() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.domain)
    return domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyVerificationData::set_domain(const ::std::string& value)
{
    set_has_domain();
    domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.domain)
}
inline void PublicKeyVerificationData::set_domain(const char* value)
{
    set_has_domain();
    domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.PublicKeyVerificationData.domain)
}
inline void PublicKeyVerificationData::set_domain(const char* value, size_t size)
{
    set_has_domain();
    domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.PublicKeyVerificationData.domain)
}
inline ::std::string* PublicKeyVerificationData::mutable_domain()
{
    set_has_domain();
    // @@protoc_insertion_point(field_mutable:enterprise_management.PublicKeyVerificationData.domain)
    return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKeyVerificationData::release_domain()
{
    // @@protoc_insertion_point(field_release:enterprise_management.PublicKeyVerificationData.domain)
    clear_has_domain();
    return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyVerificationData::set_allocated_domain(::std::string* domain)
{
    if (domain != NULL) {
        set_has_domain();
    } else {
        clear_has_domain();
    }
    domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicKeyVerificationData.domain)
}

// optional int32 new_public_key_version = 3;
inline bool PublicKeyVerificationData::has_new_public_key_version() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublicKeyVerificationData::set_has_new_public_key_version()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void PublicKeyVerificationData::clear_has_new_public_key_version()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void PublicKeyVerificationData::clear_new_public_key_version()
{
    new_public_key_version_ = 0;
    clear_has_new_public_key_version();
}
inline ::google::protobuf::int32 PublicKeyVerificationData::new_public_key_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.new_public_key_version)
    return new_public_key_version_;
}
inline void PublicKeyVerificationData::set_new_public_key_version(::google::protobuf::int32 value)
{
    set_has_new_public_key_version();
    new_public_key_version_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.new_public_key_version)
}

// -------------------------------------------------------------------

// DevicePolicyRequest

// repeated .enterprise_management.PolicyFetchRequest request = 3;
inline int DevicePolicyRequest::request_size() const
{
    return request_.size();
}
inline void DevicePolicyRequest::clear_request()
{
    request_.Clear();
}
inline const ::enterprise_management::PolicyFetchRequest& DevicePolicyRequest::request(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DevicePolicyRequest.request)
    return request_.Get(index);
}
inline ::enterprise_management::PolicyFetchRequest* DevicePolicyRequest::mutable_request(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePolicyRequest.request)
    return request_.Mutable(index);
}
inline ::enterprise_management::PolicyFetchRequest* DevicePolicyRequest::add_request()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DevicePolicyRequest.request)
    return request_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchRequest>*
DevicePolicyRequest::mutable_request()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePolicyRequest.request)
    return &request_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchRequest>&
DevicePolicyRequest::request() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DevicePolicyRequest.request)
    return request_;
}

// -------------------------------------------------------------------

// DevicePolicyResponse

// repeated .enterprise_management.PolicyFetchResponse response = 3;
inline int DevicePolicyResponse::response_size() const
{
    return response_.size();
}
inline void DevicePolicyResponse::clear_response()
{
    response_.Clear();
}
inline const ::enterprise_management::PolicyFetchResponse& DevicePolicyResponse::response(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DevicePolicyResponse.response)
    return response_.Get(index);
}
inline ::enterprise_management::PolicyFetchResponse* DevicePolicyResponse::mutable_response(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePolicyResponse.response)
    return response_.Mutable(index);
}
inline ::enterprise_management::PolicyFetchResponse* DevicePolicyResponse::add_response()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DevicePolicyResponse.response)
    return response_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchResponse>*
DevicePolicyResponse::mutable_response()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePolicyResponse.response)
    return &response_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::PolicyFetchResponse>&
DevicePolicyResponse::response() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DevicePolicyResponse.response)
    return response_;
}

// -------------------------------------------------------------------

// TimePeriod

// optional int64 start_timestamp = 1;
inline bool TimePeriod::has_start_timestamp() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimePeriod::set_has_start_timestamp()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void TimePeriod::clear_has_start_timestamp()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void TimePeriod::clear_start_timestamp()
{
    start_timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_start_timestamp();
}
inline ::google::protobuf::int64 TimePeriod::start_timestamp() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.TimePeriod.start_timestamp)
    return start_timestamp_;
}
inline void TimePeriod::set_start_timestamp(::google::protobuf::int64 value)
{
    set_has_start_timestamp();
    start_timestamp_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.TimePeriod.start_timestamp)
}

// optional int64 end_timestamp = 2;
inline bool TimePeriod::has_end_timestamp() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimePeriod::set_has_end_timestamp()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void TimePeriod::clear_has_end_timestamp()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void TimePeriod::clear_end_timestamp()
{
    end_timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_end_timestamp();
}
inline ::google::protobuf::int64 TimePeriod::end_timestamp() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.TimePeriod.end_timestamp)
    return end_timestamp_;
}
inline void TimePeriod::set_end_timestamp(::google::protobuf::int64 value)
{
    set_has_end_timestamp();
    end_timestamp_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.TimePeriod.end_timestamp)
}

// -------------------------------------------------------------------

// ActiveTimePeriod

// optional .enterprise_management.TimePeriod time_period = 1;
inline bool ActiveTimePeriod::has_time_period() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveTimePeriod::set_has_time_period()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ActiveTimePeriod::clear_has_time_period()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveTimePeriod::clear_time_period()
{
    if (time_period_ != NULL)
        time_period_->::enterprise_management::TimePeriod::Clear();
    clear_has_time_period();
}
inline const ::enterprise_management::TimePeriod& ActiveTimePeriod::time_period() const
{
// @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.time_period)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return time_period_ != NULL ? *time_period_ : *default_instance().time_period_;
#else
    return time_period_ != NULL ? *time_period_ : *default_instance_->time_period_;
#endif
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::mutable_time_period()
{
    set_has_time_period();
    if (time_period_ == NULL) {
        time_period_ = new ::enterprise_management::TimePeriod;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveTimePeriod.time_period)
    return time_period_;
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::release_time_period()
{
    // @@protoc_insertion_point(field_release:enterprise_management.ActiveTimePeriod.time_period)
    clear_has_time_period();
    ::enterprise_management::TimePeriod* temp = time_period_;
    time_period_ = NULL;
    return temp;
}
inline void ActiveTimePeriod::set_allocated_time_period(::enterprise_management::TimePeriod* time_period)
{
    delete time_period_;
    time_period_ = time_period;
    if (time_period) {
        set_has_time_period();
    } else {
        clear_has_time_period();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveTimePeriod.time_period)
}

// optional int32 active_duration = 2;
inline bool ActiveTimePeriod::has_active_duration() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveTimePeriod::set_has_active_duration()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ActiveTimePeriod::clear_has_active_duration()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ActiveTimePeriod::clear_active_duration()
{
    active_duration_ = 0;
    clear_has_active_duration();
}
inline ::google::protobuf::int32 ActiveTimePeriod::active_duration() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.active_duration)
    return active_duration_;
}
inline void ActiveTimePeriod::set_active_duration(::google::protobuf::int32 value)
{
    set_has_active_duration();
    active_duration_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.ActiveTimePeriod.active_duration)
}

// -------------------------------------------------------------------

// InstallableLaunch

// optional string install_id = 1;
inline bool InstallableLaunch::has_install_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstallableLaunch::set_has_install_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void InstallableLaunch::clear_has_install_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void InstallableLaunch::clear_install_id()
{
    install_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_install_id();
}
inline const ::std::string& InstallableLaunch::install_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.InstallableLaunch.install_id)
    return install_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallableLaunch::set_install_id(const ::std::string& value)
{
    set_has_install_id();
    install_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.InstallableLaunch.install_id)
}
inline void InstallableLaunch::set_install_id(const char* value)
{
    set_has_install_id();
    install_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.InstallableLaunch.install_id)
}
inline void InstallableLaunch::set_install_id(const char* value, size_t size)
{
    set_has_install_id();
    install_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.InstallableLaunch.install_id)
}
inline ::std::string* InstallableLaunch::mutable_install_id()
{
    set_has_install_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.InstallableLaunch.install_id)
    return install_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallableLaunch::release_install_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.InstallableLaunch.install_id)
    clear_has_install_id();
    return install_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallableLaunch::set_allocated_install_id(::std::string* install_id)
{
    if (install_id != NULL) {
        set_has_install_id();
    } else {
        clear_has_install_id();
    }
    install_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.InstallableLaunch.install_id)
}

// optional .enterprise_management.TimePeriod duration = 2;
inline bool InstallableLaunch::has_duration() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstallableLaunch::set_has_duration()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void InstallableLaunch::clear_has_duration()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void InstallableLaunch::clear_duration()
{
    if (duration_ != NULL)
        duration_->::enterprise_management::TimePeriod::Clear();
    clear_has_duration();
}
inline const ::enterprise_management::TimePeriod& InstallableLaunch::duration() const
{
// @@protoc_insertion_point(field_get:enterprise_management.InstallableLaunch.duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return duration_ != NULL ? *duration_ : *default_instance().duration_;
#else
    return duration_ != NULL ? *duration_ : *default_instance_->duration_;
#endif
}
inline ::enterprise_management::TimePeriod* InstallableLaunch::mutable_duration()
{
    set_has_duration();
    if (duration_ == NULL) {
        duration_ = new ::enterprise_management::TimePeriod;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.InstallableLaunch.duration)
    return duration_;
}
inline ::enterprise_management::TimePeriod* InstallableLaunch::release_duration()
{
    // @@protoc_insertion_point(field_release:enterprise_management.InstallableLaunch.duration)
    clear_has_duration();
    ::enterprise_management::TimePeriod* temp = duration_;
    duration_ = NULL;
    return temp;
}
inline void InstallableLaunch::set_allocated_duration(::enterprise_management::TimePeriod* duration)
{
    delete duration_;
    duration_ = duration;
    if (duration) {
        set_has_duration();
    } else {
        clear_has_duration();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.InstallableLaunch.duration)
}

// repeated int64 timestamp = 3;
inline int InstallableLaunch::timestamp_size() const
{
    return timestamp_.size();
}
inline void InstallableLaunch::clear_timestamp()
{
    timestamp_.Clear();
}
inline ::google::protobuf::int64 InstallableLaunch::timestamp(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.InstallableLaunch.timestamp)
    return timestamp_.Get(index);
}
inline void InstallableLaunch::set_timestamp(int index, ::google::protobuf::int64 value)
{
    timestamp_.Set(index, value);
    // @@protoc_insertion_point(field_set:enterprise_management.InstallableLaunch.timestamp)
}
inline void InstallableLaunch::add_timestamp(::google::protobuf::int64 value)
{
    timestamp_.Add(value);
    // @@protoc_insertion_point(field_add:enterprise_management.InstallableLaunch.timestamp)
}
inline const ::google::protobuf::RepeatedField<::google::protobuf::int64>&
InstallableLaunch::timestamp() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.InstallableLaunch.timestamp)
    return timestamp_;
}
inline ::google::protobuf::RepeatedField<::google::protobuf::int64>*
InstallableLaunch::mutable_timestamp()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.InstallableLaunch.timestamp)
    return &timestamp_;
}

// optional int64 total_count = 4;
inline bool InstallableLaunch::has_total_count() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstallableLaunch::set_has_total_count()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void InstallableLaunch::clear_has_total_count()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void InstallableLaunch::clear_total_count()
{
    total_count_ = GOOGLE_LONGLONG(0);
    clear_has_total_count();
}
inline ::google::protobuf::int64 InstallableLaunch::total_count() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.InstallableLaunch.total_count)
    return total_count_;
}
inline void InstallableLaunch::set_total_count(::google::protobuf::int64 value)
{
    set_has_total_count();
    total_count_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.InstallableLaunch.total_count)
}

// -------------------------------------------------------------------

// OBSOLETE_DeviceLocation

// optional double latitude = 1;
inline bool OBSOLETE_DeviceLocation::has_latitude() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_latitude()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void OBSOLETE_DeviceLocation::clear_has_latitude()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void OBSOLETE_DeviceLocation::clear_latitude()
{
    latitude_ = 0;
    clear_has_latitude();
}
inline double OBSOLETE_DeviceLocation::latitude() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.latitude)
    return latitude_;
}
inline void OBSOLETE_DeviceLocation::set_latitude(double value)
{
    set_has_latitude();
    latitude_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.latitude)
}

// optional double longitude = 2;
inline bool OBSOLETE_DeviceLocation::has_longitude() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_longitude()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void OBSOLETE_DeviceLocation::clear_has_longitude()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void OBSOLETE_DeviceLocation::clear_longitude()
{
    longitude_ = 0;
    clear_has_longitude();
}
inline double OBSOLETE_DeviceLocation::longitude() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.longitude)
    return longitude_;
}
inline void OBSOLETE_DeviceLocation::set_longitude(double value)
{
    set_has_longitude();
    longitude_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.longitude)
}

// optional double altitude = 3;
inline bool OBSOLETE_DeviceLocation::has_altitude() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_altitude()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void OBSOLETE_DeviceLocation::clear_has_altitude()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void OBSOLETE_DeviceLocation::clear_altitude()
{
    altitude_ = 0;
    clear_has_altitude();
}
inline double OBSOLETE_DeviceLocation::altitude() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.altitude)
    return altitude_;
}
inline void OBSOLETE_DeviceLocation::set_altitude(double value)
{
    set_has_altitude();
    altitude_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.altitude)
}

// optional double accuracy = 4;
inline bool OBSOLETE_DeviceLocation::has_accuracy() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_accuracy()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void OBSOLETE_DeviceLocation::clear_has_accuracy()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void OBSOLETE_DeviceLocation::clear_accuracy()
{
    accuracy_ = 0;
    clear_has_accuracy();
}
inline double OBSOLETE_DeviceLocation::accuracy() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.accuracy)
    return accuracy_;
}
inline void OBSOLETE_DeviceLocation::set_accuracy(double value)
{
    set_has_accuracy();
    accuracy_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.accuracy)
}

// optional double altitude_accuracy = 5;
inline bool OBSOLETE_DeviceLocation::has_altitude_accuracy() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_altitude_accuracy()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void OBSOLETE_DeviceLocation::clear_has_altitude_accuracy()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void OBSOLETE_DeviceLocation::clear_altitude_accuracy()
{
    altitude_accuracy_ = 0;
    clear_has_altitude_accuracy();
}
inline double OBSOLETE_DeviceLocation::altitude_accuracy() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.altitude_accuracy)
    return altitude_accuracy_;
}
inline void OBSOLETE_DeviceLocation::set_altitude_accuracy(double value)
{
    set_has_altitude_accuracy();
    altitude_accuracy_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.altitude_accuracy)
}

// optional double heading = 6;
inline bool OBSOLETE_DeviceLocation::has_heading() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_heading()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void OBSOLETE_DeviceLocation::clear_has_heading()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void OBSOLETE_DeviceLocation::clear_heading()
{
    heading_ = 0;
    clear_has_heading();
}
inline double OBSOLETE_DeviceLocation::heading() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.heading)
    return heading_;
}
inline void OBSOLETE_DeviceLocation::set_heading(double value)
{
    set_has_heading();
    heading_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.heading)
}

// optional double speed = 7;
inline bool OBSOLETE_DeviceLocation::has_speed() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_speed()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void OBSOLETE_DeviceLocation::clear_has_speed()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void OBSOLETE_DeviceLocation::clear_speed()
{
    speed_ = 0;
    clear_has_speed();
}
inline double OBSOLETE_DeviceLocation::speed() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.speed)
    return speed_;
}
inline void OBSOLETE_DeviceLocation::set_speed(double value)
{
    set_has_speed();
    speed_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.speed)
}

// optional int64 timestamp = 8;
inline bool OBSOLETE_DeviceLocation::has_timestamp() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_timestamp()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void OBSOLETE_DeviceLocation::clear_has_timestamp()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void OBSOLETE_DeviceLocation::clear_timestamp()
{
    timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_timestamp();
}
inline ::google::protobuf::int64 OBSOLETE_DeviceLocation::timestamp() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.timestamp)
    return timestamp_;
}
inline void OBSOLETE_DeviceLocation::set_timestamp(::google::protobuf::int64 value)
{
    set_has_timestamp();
    timestamp_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.timestamp)
}

// optional .enterprise_management.OBSOLETE_DeviceLocation.ErrorCode error_code = 9;
inline bool OBSOLETE_DeviceLocation::has_error_code() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_error_code()
{
    _has_bits_[0] |= 0x00000100u;
}
inline void OBSOLETE_DeviceLocation::clear_has_error_code()
{
    _has_bits_[0] &= ~0x00000100u;
}
inline void OBSOLETE_DeviceLocation::clear_error_code()
{
    error_code_ = 0;
    clear_has_error_code();
}
inline ::enterprise_management::OBSOLETE_DeviceLocation_ErrorCode OBSOLETE_DeviceLocation::error_code() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.error_code)
    return static_cast<::enterprise_management::OBSOLETE_DeviceLocation_ErrorCode>(error_code_);
}
inline void OBSOLETE_DeviceLocation::set_error_code(::enterprise_management::OBSOLETE_DeviceLocation_ErrorCode value)
{
    assert(::enterprise_management::OBSOLETE_DeviceLocation_ErrorCode_IsValid(value));
    set_has_error_code();
    error_code_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.error_code)
}

// optional string error_message = 10;
inline bool OBSOLETE_DeviceLocation::has_error_message() const
{
    return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OBSOLETE_DeviceLocation::set_has_error_message()
{
    _has_bits_[0] |= 0x00000200u;
}
inline void OBSOLETE_DeviceLocation::clear_has_error_message()
{
    _has_bits_[0] &= ~0x00000200u;
}
inline void OBSOLETE_DeviceLocation::clear_error_message()
{
    error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_error_message();
}
inline const ::std::string& OBSOLETE_DeviceLocation::error_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLocation.error_message)
    return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OBSOLETE_DeviceLocation::set_error_message(const ::std::string& value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLocation.error_message)
}
inline void OBSOLETE_DeviceLocation::set_error_message(const char* value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.OBSOLETE_DeviceLocation.error_message)
}
inline void OBSOLETE_DeviceLocation::set_error_message(const char* value, size_t size)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.OBSOLETE_DeviceLocation.error_message)
}
inline ::std::string* OBSOLETE_DeviceLocation::mutable_error_message()
{
    set_has_error_message();
    // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_DeviceLocation.error_message)
    return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OBSOLETE_DeviceLocation::release_error_message()
{
    // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_DeviceLocation.error_message)
    clear_has_error_message();
    return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OBSOLETE_DeviceLocation::set_allocated_error_message(::std::string* error_message)
{
    if (error_message != NULL) {
        set_has_error_message();
    } else {
        clear_has_error_message();
    }
    error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_DeviceLocation.error_message)
}

// -------------------------------------------------------------------

// NetworkInterface

// optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
inline bool NetworkInterface::has_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInterface::set_has_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void NetworkInterface::clear_has_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkInterface::clear_type()
{
    type_ = 0;
    clear_has_type();
}
inline ::enterprise_management::NetworkInterface_NetworkDeviceType NetworkInterface::type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.type)
    return static_cast<::enterprise_management::NetworkInterface_NetworkDeviceType>(type_);
}
inline void NetworkInterface::set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value)
{
    assert(::enterprise_management::NetworkInterface_NetworkDeviceType_IsValid(value));
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.type)
}

// optional string mac_address = 2;
inline bool NetworkInterface::has_mac_address() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInterface::set_has_mac_address()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void NetworkInterface::clear_has_mac_address()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkInterface::clear_mac_address()
{
    mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_mac_address();
}
inline const ::std::string& NetworkInterface::mac_address() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.mac_address)
    return mac_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_mac_address(const ::std::string& value)
{
    set_has_mac_address();
    mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.mac_address)
}
inline void NetworkInterface::set_mac_address(const char* value)
{
    set_has_mac_address();
    mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.mac_address)
}
inline void NetworkInterface::set_mac_address(const char* value, size_t size)
{
    set_has_mac_address();
    mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.mac_address)
}
inline ::std::string* NetworkInterface::mutable_mac_address()
{
    set_has_mac_address();
    // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.mac_address)
    return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkInterface::release_mac_address()
{
    // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.mac_address)
    clear_has_mac_address();
    return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_mac_address(::std::string* mac_address)
{
    if (mac_address != NULL) {
        set_has_mac_address();
    } else {
        clear_has_mac_address();
    }
    mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.mac_address)
}

// optional string meid = 3;
inline bool NetworkInterface::has_meid() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkInterface::set_has_meid()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void NetworkInterface::clear_has_meid()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkInterface::clear_meid()
{
    meid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_meid();
}
inline const ::std::string& NetworkInterface::meid() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.meid)
    return meid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_meid(const ::std::string& value)
{
    set_has_meid();
    meid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.meid)
}
inline void NetworkInterface::set_meid(const char* value)
{
    set_has_meid();
    meid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.meid)
}
inline void NetworkInterface::set_meid(const char* value, size_t size)
{
    set_has_meid();
    meid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.meid)
}
inline ::std::string* NetworkInterface::mutable_meid()
{
    set_has_meid();
    // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.meid)
    return meid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkInterface::release_meid()
{
    // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.meid)
    clear_has_meid();
    return meid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_meid(::std::string* meid)
{
    if (meid != NULL) {
        set_has_meid();
    } else {
        clear_has_meid();
    }
    meid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meid);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.meid)
}

// optional string imei = 4;
inline bool NetworkInterface::has_imei() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkInterface::set_has_imei()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void NetworkInterface::clear_has_imei()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void NetworkInterface::clear_imei()
{
    imei_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_imei();
}
inline const ::std::string& NetworkInterface::imei() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.imei)
    return imei_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_imei(const ::std::string& value)
{
    set_has_imei();
    imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.imei)
}
inline void NetworkInterface::set_imei(const char* value)
{
    set_has_imei();
    imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.imei)
}
inline void NetworkInterface::set_imei(const char* value, size_t size)
{
    set_has_imei();
    imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.imei)
}
inline ::std::string* NetworkInterface::mutable_imei()
{
    set_has_imei();
    // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.imei)
    return imei_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkInterface::release_imei()
{
    // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.imei)
    clear_has_imei();
    return imei_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_imei(::std::string* imei)
{
    if (imei != NULL) {
        set_has_imei();
    } else {
        clear_has_imei();
    }
    imei_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imei);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.imei)
}

// optional string device_path = 5;
inline bool NetworkInterface::has_device_path() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkInterface::set_has_device_path()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void NetworkInterface::clear_has_device_path()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void NetworkInterface::clear_device_path()
{
    device_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_device_path();
}
inline const ::std::string& NetworkInterface::device_path() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.device_path)
    return device_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_device_path(const ::std::string& value)
{
    set_has_device_path();
    device_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.device_path)
}
inline void NetworkInterface::set_device_path(const char* value)
{
    set_has_device_path();
    device_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.device_path)
}
inline void NetworkInterface::set_device_path(const char* value, size_t size)
{
    set_has_device_path();
    device_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.device_path)
}
inline ::std::string* NetworkInterface::mutable_device_path()
{
    set_has_device_path();
    // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.device_path)
    return device_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkInterface::release_device_path()
{
    // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.device_path)
    clear_has_device_path();
    return device_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInterface::set_allocated_device_path(::std::string* device_path)
{
    if (device_path != NULL) {
        set_has_device_path();
    } else {
        clear_has_device_path();
    }
    device_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_path);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.device_path)
}

// -------------------------------------------------------------------

// NetworkState

// optional string device_path = 1;
inline bool NetworkState::has_device_path() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkState::set_has_device_path()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void NetworkState::clear_has_device_path()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkState::clear_device_path()
{
    device_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_device_path();
}
inline const ::std::string& NetworkState::device_path() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.device_path)
    return device_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_device_path(const ::std::string& value)
{
    set_has_device_path();
    device_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.device_path)
}
inline void NetworkState::set_device_path(const char* value)
{
    set_has_device_path();
    device_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkState.device_path)
}
inline void NetworkState::set_device_path(const char* value, size_t size)
{
    set_has_device_path();
    device_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkState.device_path)
}
inline ::std::string* NetworkState::mutable_device_path()
{
    set_has_device_path();
    // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.device_path)
    return device_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkState::release_device_path()
{
    // @@protoc_insertion_point(field_release:enterprise_management.NetworkState.device_path)
    clear_has_device_path();
    return device_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_allocated_device_path(::std::string* device_path)
{
    if (device_path != NULL) {
        set_has_device_path();
    } else {
        clear_has_device_path();
    }
    device_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_path);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.device_path)
}

// optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
inline bool NetworkState::has_connection_state() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkState::set_has_connection_state()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void NetworkState::clear_has_connection_state()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkState::clear_connection_state()
{
    connection_state_ = 0;
    clear_has_connection_state();
}
inline ::enterprise_management::NetworkState_ConnectionState NetworkState::connection_state() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.connection_state)
    return static_cast<::enterprise_management::NetworkState_ConnectionState>(connection_state_);
}
inline void NetworkState::set_connection_state(::enterprise_management::NetworkState_ConnectionState value)
{
    assert(::enterprise_management::NetworkState_ConnectionState_IsValid(value));
    set_has_connection_state();
    connection_state_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.connection_state)
}

// optional int32 signal_strength = 3;
inline bool NetworkState::has_signal_strength() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkState::set_has_signal_strength()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void NetworkState::clear_has_signal_strength()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkState::clear_signal_strength()
{
    signal_strength_ = 0;
    clear_has_signal_strength();
}
inline ::google::protobuf::int32 NetworkState::signal_strength() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.signal_strength)
    return signal_strength_;
}
inline void NetworkState::set_signal_strength(::google::protobuf::int32 value)
{
    set_has_signal_strength();
    signal_strength_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.signal_strength)
}

// optional string ip_address = 4;
inline bool NetworkState::has_ip_address() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkState::set_has_ip_address()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void NetworkState::clear_has_ip_address()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void NetworkState::clear_ip_address()
{
    ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_ip_address();
}
inline const ::std::string& NetworkState::ip_address() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.ip_address)
    return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_ip_address(const ::std::string& value)
{
    set_has_ip_address();
    ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.ip_address)
}
inline void NetworkState::set_ip_address(const char* value)
{
    set_has_ip_address();
    ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkState.ip_address)
}
inline void NetworkState::set_ip_address(const char* value, size_t size)
{
    set_has_ip_address();
    ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkState.ip_address)
}
inline ::std::string* NetworkState::mutable_ip_address()
{
    set_has_ip_address();
    // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.ip_address)
    return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkState::release_ip_address()
{
    // @@protoc_insertion_point(field_release:enterprise_management.NetworkState.ip_address)
    clear_has_ip_address();
    return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_allocated_ip_address(::std::string* ip_address)
{
    if (ip_address != NULL) {
        set_has_ip_address();
    } else {
        clear_has_ip_address();
    }
    ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.ip_address)
}

// optional string gateway = 5;
inline bool NetworkState::has_gateway() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkState::set_has_gateway()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void NetworkState::clear_has_gateway()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void NetworkState::clear_gateway()
{
    gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_gateway();
}
inline const ::std::string& NetworkState::gateway() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.gateway)
    return gateway_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_gateway(const ::std::string& value)
{
    set_has_gateway();
    gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.gateway)
}
inline void NetworkState::set_gateway(const char* value)
{
    set_has_gateway();
    gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkState.gateway)
}
inline void NetworkState::set_gateway(const char* value, size_t size)
{
    set_has_gateway();
    gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkState.gateway)
}
inline ::std::string* NetworkState::mutable_gateway()
{
    set_has_gateway();
    // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.gateway)
    return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkState::release_gateway()
{
    // @@protoc_insertion_point(field_release:enterprise_management.NetworkState.gateway)
    clear_has_gateway();
    return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkState::set_allocated_gateway(::std::string* gateway)
{
    if (gateway != NULL) {
        set_has_gateway();
    } else {
        clear_has_gateway();
    }
    gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.gateway)
}

// -------------------------------------------------------------------

// DeviceUser

// required .enterprise_management.DeviceUser.UserType type = 1;
inline bool DeviceUser::has_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceUser::set_has_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceUser::clear_has_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceUser::clear_type()
{
    type_ = 0;
    clear_has_type();
}
inline ::enterprise_management::DeviceUser_UserType DeviceUser::type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceUser.type)
    return static_cast<::enterprise_management::DeviceUser_UserType>(type_);
}
inline void DeviceUser::set_type(::enterprise_management::DeviceUser_UserType value)
{
    assert(::enterprise_management::DeviceUser_UserType_IsValid(value));
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceUser.type)
}

// optional string email = 2;
inline bool DeviceUser::has_email() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceUser::set_has_email()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceUser::clear_has_email()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceUser::clear_email()
{
    email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_email();
}
inline const ::std::string& DeviceUser::email() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceUser.email)
    return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceUser::set_email(const ::std::string& value)
{
    set_has_email();
    email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceUser.email)
}
inline void DeviceUser::set_email(const char* value)
{
    set_has_email();
    email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceUser.email)
}
inline void DeviceUser::set_email(const char* value, size_t size)
{
    set_has_email();
    email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceUser.email)
}
inline ::std::string* DeviceUser::mutable_email()
{
    set_has_email();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceUser.email)
    return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceUser::release_email()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceUser.email)
    clear_has_email();
    return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceUser::set_allocated_email(::std::string* email)
{
    if (email != NULL) {
        set_has_email();
    } else {
        clear_has_email();
    }
    email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceUser.email)
}

// -------------------------------------------------------------------

// VolumeInfo

// optional string volume_id = 1;
inline bool VolumeInfo::has_volume_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VolumeInfo::set_has_volume_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void VolumeInfo::clear_has_volume_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void VolumeInfo::clear_volume_id()
{
    volume_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_volume_id();
}
inline const ::std::string& VolumeInfo::volume_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.volume_id)
    return volume_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VolumeInfo::set_volume_id(const ::std::string& value)
{
    set_has_volume_id();
    volume_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.volume_id)
}
inline void VolumeInfo::set_volume_id(const char* value)
{
    set_has_volume_id();
    volume_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.VolumeInfo.volume_id)
}
inline void VolumeInfo::set_volume_id(const char* value, size_t size)
{
    set_has_volume_id();
    volume_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.VolumeInfo.volume_id)
}
inline ::std::string* VolumeInfo::mutable_volume_id()
{
    set_has_volume_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.VolumeInfo.volume_id)
    return volume_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VolumeInfo::release_volume_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.VolumeInfo.volume_id)
    clear_has_volume_id();
    return volume_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VolumeInfo::set_allocated_volume_id(::std::string* volume_id)
{
    if (volume_id != NULL) {
        set_has_volume_id();
    } else {
        clear_has_volume_id();
    }
    volume_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), volume_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.VolumeInfo.volume_id)
}

// optional int64 storage_total = 2;
inline bool VolumeInfo::has_storage_total() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VolumeInfo::set_has_storage_total()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void VolumeInfo::clear_has_storage_total()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void VolumeInfo::clear_storage_total()
{
    storage_total_ = GOOGLE_LONGLONG(0);
    clear_has_storage_total();
}
inline ::google::protobuf::int64 VolumeInfo::storage_total() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.storage_total)
    return storage_total_;
}
inline void VolumeInfo::set_storage_total(::google::protobuf::int64 value)
{
    set_has_storage_total();
    storage_total_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.storage_total)
}

// optional int64 storage_free = 3;
inline bool VolumeInfo::has_storage_free() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VolumeInfo::set_has_storage_free()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void VolumeInfo::clear_has_storage_free()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void VolumeInfo::clear_storage_free()
{
    storage_free_ = GOOGLE_LONGLONG(0);
    clear_has_storage_free();
}
inline ::google::protobuf::int64 VolumeInfo::storage_free() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.storage_free)
    return storage_free_;
}
inline void VolumeInfo::set_storage_free(::google::protobuf::int64 value)
{
    set_has_storage_free();
    storage_free_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.storage_free)
}

// -------------------------------------------------------------------

// CPUTempInfo

// optional string cpu_label = 1;
inline bool CPUTempInfo::has_cpu_label() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPUTempInfo::set_has_cpu_label()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void CPUTempInfo::clear_has_cpu_label()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void CPUTempInfo::clear_cpu_label()
{
    cpu_label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_cpu_label();
}
inline const ::std::string& CPUTempInfo::cpu_label() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.cpu_label)
    return cpu_label_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPUTempInfo::set_cpu_label(const ::std::string& value)
{
    set_has_cpu_label();
    cpu_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.cpu_label)
}
inline void CPUTempInfo::set_cpu_label(const char* value)
{
    set_has_cpu_label();
    cpu_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.CPUTempInfo.cpu_label)
}
inline void CPUTempInfo::set_cpu_label(const char* value, size_t size)
{
    set_has_cpu_label();
    cpu_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.CPUTempInfo.cpu_label)
}
inline ::std::string* CPUTempInfo::mutable_cpu_label()
{
    set_has_cpu_label();
    // @@protoc_insertion_point(field_mutable:enterprise_management.CPUTempInfo.cpu_label)
    return cpu_label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CPUTempInfo::release_cpu_label()
{
    // @@protoc_insertion_point(field_release:enterprise_management.CPUTempInfo.cpu_label)
    clear_has_cpu_label();
    return cpu_label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPUTempInfo::set_allocated_cpu_label(::std::string* cpu_label)
{
    if (cpu_label != NULL) {
        set_has_cpu_label();
    } else {
        clear_has_cpu_label();
    }
    cpu_label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpu_label);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.CPUTempInfo.cpu_label)
}

// optional int32 cpu_temp = 2;
inline bool CPUTempInfo::has_cpu_temp() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPUTempInfo::set_has_cpu_temp()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void CPUTempInfo::clear_has_cpu_temp()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void CPUTempInfo::clear_cpu_temp()
{
    cpu_temp_ = 0;
    clear_has_cpu_temp();
}
inline ::google::protobuf::int32 CPUTempInfo::cpu_temp() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.cpu_temp)
    return cpu_temp_;
}
inline void CPUTempInfo::set_cpu_temp(::google::protobuf::int32 value)
{
    set_has_cpu_temp();
    cpu_temp_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.cpu_temp)
}

// -------------------------------------------------------------------

// DeviceStatusReportRequest

// optional string os_version = 1;
inline bool DeviceStatusReportRequest::has_os_version() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStatusReportRequest::set_has_os_version()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceStatusReportRequest::clear_has_os_version()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceStatusReportRequest::clear_os_version()
{
    os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_os_version();
}
inline const ::std::string& DeviceStatusReportRequest::os_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.os_version)
    return os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_os_version(const ::std::string& value)
{
    set_has_os_version();
    os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline void DeviceStatusReportRequest::set_os_version(const char* value)
{
    set_has_os_version();
    os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline void DeviceStatusReportRequest::set_os_version(const char* value, size_t size)
{
    set_has_os_version();
    os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline ::std::string* DeviceStatusReportRequest::mutable_os_version()
{
    set_has_os_version();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.os_version)
    return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceStatusReportRequest::release_os_version()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.os_version)
    clear_has_os_version();
    return os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_os_version(::std::string* os_version)
{
    if (os_version != NULL) {
        set_has_os_version();
    } else {
        clear_has_os_version();
    }
    os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.os_version)
}

// optional string firmware_version = 2;
inline bool DeviceStatusReportRequest::has_firmware_version() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStatusReportRequest::set_has_firmware_version()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceStatusReportRequest::clear_has_firmware_version()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceStatusReportRequest::clear_firmware_version()
{
    firmware_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_firmware_version();
}
inline const ::std::string& DeviceStatusReportRequest::firmware_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.firmware_version)
    return firmware_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_firmware_version(const ::std::string& value)
{
    set_has_firmware_version();
    firmware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline void DeviceStatusReportRequest::set_firmware_version(const char* value)
{
    set_has_firmware_version();
    firmware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline void DeviceStatusReportRequest::set_firmware_version(const char* value, size_t size)
{
    set_has_firmware_version();
    firmware_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline ::std::string* DeviceStatusReportRequest::mutable_firmware_version()
{
    set_has_firmware_version();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.firmware_version)
    return firmware_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceStatusReportRequest::release_firmware_version()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.firmware_version)
    clear_has_firmware_version();
    return firmware_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_firmware_version(::std::string* firmware_version)
{
    if (firmware_version != NULL) {
        set_has_firmware_version();
    } else {
        clear_has_firmware_version();
    }
    firmware_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_version);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.firmware_version)
}

// optional string boot_mode = 3;
inline bool DeviceStatusReportRequest::has_boot_mode() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceStatusReportRequest::set_has_boot_mode()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void DeviceStatusReportRequest::clear_has_boot_mode()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceStatusReportRequest::clear_boot_mode()
{
    boot_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_boot_mode();
}
inline const ::std::string& DeviceStatusReportRequest::boot_mode() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.boot_mode)
    return boot_mode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_boot_mode(const ::std::string& value)
{
    set_has_boot_mode();
    boot_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline void DeviceStatusReportRequest::set_boot_mode(const char* value)
{
    set_has_boot_mode();
    boot_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline void DeviceStatusReportRequest::set_boot_mode(const char* value, size_t size)
{
    set_has_boot_mode();
    boot_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline ::std::string* DeviceStatusReportRequest::mutable_boot_mode()
{
    set_has_boot_mode();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.boot_mode)
    return boot_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceStatusReportRequest::release_boot_mode()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.boot_mode)
    clear_has_boot_mode();
    return boot_mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_boot_mode(::std::string* boot_mode)
{
    if (boot_mode != NULL) {
        set_has_boot_mode();
    } else {
        clear_has_boot_mode();
    }
    boot_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), boot_mode);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.boot_mode)
}

// repeated .enterprise_management.TimePeriod OBSOLETE_active_time = 4 [deprecated = true];
inline int DeviceStatusReportRequest::obsolete_active_time_size() const
{
    return obsolete_active_time_.size();
}
inline void DeviceStatusReportRequest::clear_obsolete_active_time()
{
    obsolete_active_time_.Clear();
}
inline const ::enterprise_management::TimePeriod& DeviceStatusReportRequest::obsolete_active_time(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.OBSOLETE_active_time)
    return obsolete_active_time_.Get(index);
}
inline ::enterprise_management::TimePeriod* DeviceStatusReportRequest::mutable_obsolete_active_time(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.OBSOLETE_active_time)
    return obsolete_active_time_.Mutable(index);
}
inline ::enterprise_management::TimePeriod* DeviceStatusReportRequest::add_obsolete_active_time()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.OBSOLETE_active_time)
    return obsolete_active_time_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::TimePeriod>*
DeviceStatusReportRequest::mutable_obsolete_active_time()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.OBSOLETE_active_time)
    return &obsolete_active_time_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::TimePeriod>&
DeviceStatusReportRequest::obsolete_active_time() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.OBSOLETE_active_time)
    return obsolete_active_time_;
}

// optional string browser_version = 5;
inline bool DeviceStatusReportRequest::has_browser_version() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceStatusReportRequest::set_has_browser_version()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void DeviceStatusReportRequest::clear_has_browser_version()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceStatusReportRequest::clear_browser_version()
{
    browser_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_browser_version();
}
inline const ::std::string& DeviceStatusReportRequest::browser_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.browser_version)
    return browser_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_browser_version(const ::std::string& value)
{
    set_has_browser_version();
    browser_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline void DeviceStatusReportRequest::set_browser_version(const char* value)
{
    set_has_browser_version();
    browser_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline void DeviceStatusReportRequest::set_browser_version(const char* value, size_t size)
{
    set_has_browser_version();
    browser_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline ::std::string* DeviceStatusReportRequest::mutable_browser_version()
{
    set_has_browser_version();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.browser_version)
    return browser_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceStatusReportRequest::release_browser_version()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.browser_version)
    clear_has_browser_version();
    return browser_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportRequest::set_allocated_browser_version(::std::string* browser_version)
{
    if (browser_version != NULL) {
        set_has_browser_version();
    } else {
        clear_has_browser_version();
    }
    browser_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), browser_version);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.browser_version)
}

// repeated .enterprise_management.ActiveTimePeriod active_period = 6;
inline int DeviceStatusReportRequest::active_period_size() const
{
    return active_period_.size();
}
inline void DeviceStatusReportRequest::clear_active_period()
{
    active_period_.Clear();
}
inline const ::enterprise_management::ActiveTimePeriod& DeviceStatusReportRequest::active_period(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.active_period)
    return active_period_.Get(index);
}
inline ::enterprise_management::ActiveTimePeriod* DeviceStatusReportRequest::mutable_active_period(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.active_period)
    return active_period_.Mutable(index);
}
inline ::enterprise_management::ActiveTimePeriod* DeviceStatusReportRequest::add_active_period()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.active_period)
    return active_period_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::ActiveTimePeriod>*
DeviceStatusReportRequest::mutable_active_period()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.active_period)
    return &active_period_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::ActiveTimePeriod>&
DeviceStatusReportRequest::active_period() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.active_period)
    return active_period_;
}

// optional .enterprise_management.OBSOLETE_DeviceLocation OBSOLETE_device_location = 7 [deprecated = true];
inline bool DeviceStatusReportRequest::has_obsolete_device_location() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceStatusReportRequest::set_has_obsolete_device_location()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void DeviceStatusReportRequest::clear_has_obsolete_device_location()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceStatusReportRequest::clear_obsolete_device_location()
{
    if (obsolete_device_location_ != NULL)
        obsolete_device_location_->::enterprise_management::OBSOLETE_DeviceLocation::Clear();
    clear_has_obsolete_device_location();
}
inline const ::enterprise_management::OBSOLETE_DeviceLocation& DeviceStatusReportRequest::obsolete_device_location() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.OBSOLETE_device_location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return obsolete_device_location_ != NULL ? *obsolete_device_location_ : *default_instance().obsolete_device_location_;
#else
    return obsolete_device_location_ != NULL ? *obsolete_device_location_ : *default_instance_->obsolete_device_location_;
#endif
}
inline ::enterprise_management::OBSOLETE_DeviceLocation* DeviceStatusReportRequest::mutable_obsolete_device_location()
{
    set_has_obsolete_device_location();
    if (obsolete_device_location_ == NULL) {
        obsolete_device_location_ = new ::enterprise_management::OBSOLETE_DeviceLocation;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.OBSOLETE_device_location)
    return obsolete_device_location_;
}
inline ::enterprise_management::OBSOLETE_DeviceLocation* DeviceStatusReportRequest::release_obsolete_device_location()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.OBSOLETE_device_location)
    clear_has_obsolete_device_location();
    ::enterprise_management::OBSOLETE_DeviceLocation* temp = obsolete_device_location_;
    obsolete_device_location_ = NULL;
    return temp;
}
inline void DeviceStatusReportRequest::set_allocated_obsolete_device_location(::enterprise_management::OBSOLETE_DeviceLocation* obsolete_device_location)
{
    delete obsolete_device_location_;
    obsolete_device_location_ = obsolete_device_location;
    if (obsolete_device_location) {
        set_has_obsolete_device_location();
    } else {
        clear_has_obsolete_device_location();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.OBSOLETE_device_location)
}

// repeated .enterprise_management.NetworkInterface network_interface = 8;
inline int DeviceStatusReportRequest::network_interface_size() const
{
    return network_interface_.size();
}
inline void DeviceStatusReportRequest::clear_network_interface()
{
    network_interface_.Clear();
}
inline const ::enterprise_management::NetworkInterface& DeviceStatusReportRequest::network_interface(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.network_interface)
    return network_interface_.Get(index);
}
inline ::enterprise_management::NetworkInterface* DeviceStatusReportRequest::mutable_network_interface(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.network_interface)
    return network_interface_.Mutable(index);
}
inline ::enterprise_management::NetworkInterface* DeviceStatusReportRequest::add_network_interface()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.network_interface)
    return network_interface_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkInterface>*
DeviceStatusReportRequest::mutable_network_interface()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.network_interface)
    return &network_interface_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkInterface>&
DeviceStatusReportRequest::network_interface() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.network_interface)
    return network_interface_;
}

// repeated .enterprise_management.DeviceUser user = 9;
inline int DeviceStatusReportRequest::user_size() const
{
    return user_.size();
}
inline void DeviceStatusReportRequest::clear_user()
{
    user_.Clear();
}
inline const ::enterprise_management::DeviceUser& DeviceStatusReportRequest::user(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.user)
    return user_.Get(index);
}
inline ::enterprise_management::DeviceUser* DeviceStatusReportRequest::mutable_user(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.user)
    return user_.Mutable(index);
}
inline ::enterprise_management::DeviceUser* DeviceStatusReportRequest::add_user()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.user)
    return user_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::DeviceUser>*
DeviceStatusReportRequest::mutable_user()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.user)
    return &user_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::DeviceUser>&
DeviceStatusReportRequest::user() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.user)
    return user_;
}

// repeated .enterprise_management.VolumeInfo volume_info = 10;
inline int DeviceStatusReportRequest::volume_info_size() const
{
    return volume_info_.size();
}
inline void DeviceStatusReportRequest::clear_volume_info()
{
    volume_info_.Clear();
}
inline const ::enterprise_management::VolumeInfo& DeviceStatusReportRequest::volume_info(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.volume_info)
    return volume_info_.Get(index);
}
inline ::enterprise_management::VolumeInfo* DeviceStatusReportRequest::mutable_volume_info(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.volume_info)
    return volume_info_.Mutable(index);
}
inline ::enterprise_management::VolumeInfo* DeviceStatusReportRequest::add_volume_info()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.volume_info)
    return volume_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::VolumeInfo>*
DeviceStatusReportRequest::mutable_volume_info()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.volume_info)
    return &volume_info_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::VolumeInfo>&
DeviceStatusReportRequest::volume_info() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.volume_info)
    return volume_info_;
}

// repeated .enterprise_management.NetworkState network_state = 11;
inline int DeviceStatusReportRequest::network_state_size() const
{
    return network_state_.size();
}
inline void DeviceStatusReportRequest::clear_network_state()
{
    network_state_.Clear();
}
inline const ::enterprise_management::NetworkState& DeviceStatusReportRequest::network_state(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.network_state)
    return network_state_.Get(index);
}
inline ::enterprise_management::NetworkState* DeviceStatusReportRequest::mutable_network_state(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.network_state)
    return network_state_.Mutable(index);
}
inline ::enterprise_management::NetworkState* DeviceStatusReportRequest::add_network_state()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.network_state)
    return network_state_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkState>*
DeviceStatusReportRequest::mutable_network_state()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.network_state)
    return &network_state_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::NetworkState>&
DeviceStatusReportRequest::network_state() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.network_state)
    return network_state_;
}

// repeated int32 cpu_utilization_pct = 12;
inline int DeviceStatusReportRequest::cpu_utilization_pct_size() const
{
    return cpu_utilization_pct_.size();
}
inline void DeviceStatusReportRequest::clear_cpu_utilization_pct()
{
    cpu_utilization_pct_.Clear();
}
inline ::google::protobuf::int32 DeviceStatusReportRequest::cpu_utilization_pct(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct)
    return cpu_utilization_pct_.Get(index);
}
inline void DeviceStatusReportRequest::set_cpu_utilization_pct(int index, ::google::protobuf::int32 value)
{
    cpu_utilization_pct_.Set(index, value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct)
}
inline void DeviceStatusReportRequest::add_cpu_utilization_pct(::google::protobuf::int32 value)
{
    cpu_utilization_pct_.Add(value);
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct)
}
inline const ::google::protobuf::RepeatedField<::google::protobuf::int32>&
DeviceStatusReportRequest::cpu_utilization_pct() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct)
    return cpu_utilization_pct_;
}
inline ::google::protobuf::RepeatedField<::google::protobuf::int32>*
DeviceStatusReportRequest::mutable_cpu_utilization_pct()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct)
    return &cpu_utilization_pct_;
}

// optional int64 OBSOLETE_system_ram_free = 13 [deprecated = true];
inline bool DeviceStatusReportRequest::has_obsolete_system_ram_free() const
{
    return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceStatusReportRequest::set_has_obsolete_system_ram_free()
{
    _has_bits_[0] |= 0x00001000u;
}
inline void DeviceStatusReportRequest::clear_has_obsolete_system_ram_free()
{
    _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceStatusReportRequest::clear_obsolete_system_ram_free()
{
    obsolete_system_ram_free_ = GOOGLE_LONGLONG(0);
    clear_has_obsolete_system_ram_free();
}
inline ::google::protobuf::int64 DeviceStatusReportRequest::obsolete_system_ram_free() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.OBSOLETE_system_ram_free)
    return obsolete_system_ram_free_;
}
inline void DeviceStatusReportRequest::set_obsolete_system_ram_free(::google::protobuf::int64 value)
{
    set_has_obsolete_system_ram_free();
    obsolete_system_ram_free_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.OBSOLETE_system_ram_free)
}

// optional int64 system_ram_total = 14;
inline bool DeviceStatusReportRequest::has_system_ram_total() const
{
    return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceStatusReportRequest::set_has_system_ram_total()
{
    _has_bits_[0] |= 0x00002000u;
}
inline void DeviceStatusReportRequest::clear_has_system_ram_total()
{
    _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceStatusReportRequest::clear_system_ram_total()
{
    system_ram_total_ = GOOGLE_LONGLONG(0);
    clear_has_system_ram_total();
}
inline ::google::protobuf::int64 DeviceStatusReportRequest::system_ram_total() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_total)
    return system_ram_total_;
}
inline void DeviceStatusReportRequest::set_system_ram_total(::google::protobuf::int64 value)
{
    set_has_system_ram_total();
    system_ram_total_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.system_ram_total)
}

// repeated int64 system_ram_free = 15;
inline int DeviceStatusReportRequest::system_ram_free_size() const
{
    return system_ram_free_.size();
}
inline void DeviceStatusReportRequest::clear_system_ram_free()
{
    system_ram_free_.Clear();
}
inline ::google::protobuf::int64 DeviceStatusReportRequest::system_ram_free(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_free)
    return system_ram_free_.Get(index);
}
inline void DeviceStatusReportRequest::set_system_ram_free(int index, ::google::protobuf::int64 value)
{
    system_ram_free_.Set(index, value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.system_ram_free)
}
inline void DeviceStatusReportRequest::add_system_ram_free(::google::protobuf::int64 value)
{
    system_ram_free_.Add(value);
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.system_ram_free)
}
inline const ::google::protobuf::RepeatedField<::google::protobuf::int64>&
DeviceStatusReportRequest::system_ram_free() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.system_ram_free)
    return system_ram_free_;
}
inline ::google::protobuf::RepeatedField<::google::protobuf::int64>*
DeviceStatusReportRequest::mutable_system_ram_free()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.system_ram_free)
    return &system_ram_free_;
}

// repeated .enterprise_management.CPUTempInfo cpu_temp_info = 16;
inline int DeviceStatusReportRequest::cpu_temp_info_size() const
{
    return cpu_temp_info_.size();
}
inline void DeviceStatusReportRequest::clear_cpu_temp_info()
{
    cpu_temp_info_.Clear();
}
inline const ::enterprise_management::CPUTempInfo& DeviceStatusReportRequest::cpu_temp_info(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_temp_info)
    return cpu_temp_info_.Get(index);
}
inline ::enterprise_management::CPUTempInfo* DeviceStatusReportRequest::mutable_cpu_temp_info(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.cpu_temp_info)
    return cpu_temp_info_.Mutable(index);
}
inline ::enterprise_management::CPUTempInfo* DeviceStatusReportRequest::add_cpu_temp_info()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_temp_info)
    return cpu_temp_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::CPUTempInfo>*
DeviceStatusReportRequest::mutable_cpu_temp_info()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_temp_info)
    return &cpu_temp_info_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::CPUTempInfo>&
DeviceStatusReportRequest::cpu_temp_info() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_temp_info)
    return cpu_temp_info_;
}

// optional .enterprise_management.OsUpdateStatus os_update_status = 17;
inline bool DeviceStatusReportRequest::has_os_update_status() const
{
    return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceStatusReportRequest::set_has_os_update_status()
{
    _has_bits_[0] |= 0x00010000u;
}
inline void DeviceStatusReportRequest::clear_has_os_update_status()
{
    _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceStatusReportRequest::clear_os_update_status()
{
    if (os_update_status_ != NULL)
        os_update_status_->::enterprise_management::OsUpdateStatus::Clear();
    clear_has_os_update_status();
}
inline const ::enterprise_management::OsUpdateStatus& DeviceStatusReportRequest::os_update_status() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.os_update_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return os_update_status_ != NULL ? *os_update_status_ : *default_instance().os_update_status_;
#else
    return os_update_status_ != NULL ? *os_update_status_ : *default_instance_->os_update_status_;
#endif
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::mutable_os_update_status()
{
    set_has_os_update_status();
    if (os_update_status_ == NULL) {
        os_update_status_ = new ::enterprise_management::OsUpdateStatus;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.os_update_status)
    return os_update_status_;
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::release_os_update_status()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.os_update_status)
    clear_has_os_update_status();
    ::enterprise_management::OsUpdateStatus* temp = os_update_status_;
    os_update_status_ = NULL;
    return temp;
}
inline void DeviceStatusReportRequest::set_allocated_os_update_status(::enterprise_management::OsUpdateStatus* os_update_status)
{
    delete os_update_status_;
    os_update_status_ = os_update_status;
    if (os_update_status) {
        set_has_os_update_status();
    } else {
        clear_has_os_update_status();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.os_update_status)
}

// optional .enterprise_management.AppStatus running_kiosk_app = 18;
inline bool DeviceStatusReportRequest::has_running_kiosk_app() const
{
    return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceStatusReportRequest::set_has_running_kiosk_app()
{
    _has_bits_[0] |= 0x00020000u;
}
inline void DeviceStatusReportRequest::clear_has_running_kiosk_app()
{
    _has_bits_[0] &= ~0x00020000u;
}
inline void DeviceStatusReportRequest::clear_running_kiosk_app()
{
    if (running_kiosk_app_ != NULL)
        running_kiosk_app_->::enterprise_management::AppStatus::Clear();
    clear_has_running_kiosk_app();
}
inline const ::enterprise_management::AppStatus& DeviceStatusReportRequest::running_kiosk_app() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return running_kiosk_app_ != NULL ? *running_kiosk_app_ : *default_instance().running_kiosk_app_;
#else
    return running_kiosk_app_ != NULL ? *running_kiosk_app_ : *default_instance_->running_kiosk_app_;
#endif
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::mutable_running_kiosk_app()
{
    set_has_running_kiosk_app();
    if (running_kiosk_app_ == NULL) {
        running_kiosk_app_ = new ::enterprise_management::AppStatus;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
    return running_kiosk_app_;
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::release_running_kiosk_app()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
    clear_has_running_kiosk_app();
    ::enterprise_management::AppStatus* temp = running_kiosk_app_;
    running_kiosk_app_ = NULL;
    return temp;
}
inline void DeviceStatusReportRequest::set_allocated_running_kiosk_app(::enterprise_management::AppStatus* running_kiosk_app)
{
    delete running_kiosk_app_;
    running_kiosk_app_ = running_kiosk_app;
    if (running_kiosk_app) {
        set_has_running_kiosk_app();
    } else {
        clear_has_running_kiosk_app();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
}

// -------------------------------------------------------------------

// OsUpdateStatus

// optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
inline bool OsUpdateStatus::has_update_status() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsUpdateStatus::set_has_update_status()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void OsUpdateStatus::clear_has_update_status()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void OsUpdateStatus::clear_update_status()
{
    update_status_ = 0;
    clear_has_update_status();
}
inline ::enterprise_management::OsUpdateStatus_UpdateStatus OsUpdateStatus::update_status() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.update_status)
    return static_cast<::enterprise_management::OsUpdateStatus_UpdateStatus>(update_status_);
}
inline void OsUpdateStatus::set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value)
{
    assert(::enterprise_management::OsUpdateStatus_UpdateStatus_IsValid(value));
    set_has_update_status();
    update_status_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.update_status)
}

// optional string new_platform_version = 2;
inline bool OsUpdateStatus::has_new_platform_version() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsUpdateStatus::set_has_new_platform_version()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void OsUpdateStatus::clear_has_new_platform_version()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void OsUpdateStatus::clear_new_platform_version()
{
    new_platform_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_platform_version();
}
inline const ::std::string& OsUpdateStatus::new_platform_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.new_platform_version)
    return new_platform_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OsUpdateStatus::set_new_platform_version(const ::std::string& value)
{
    set_has_new_platform_version();
    new_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline void OsUpdateStatus::set_new_platform_version(const char* value)
{
    set_has_new_platform_version();
    new_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline void OsUpdateStatus::set_new_platform_version(const char* value, size_t size)
{
    set_has_new_platform_version();
    new_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline ::std::string* OsUpdateStatus::mutable_new_platform_version()
{
    set_has_new_platform_version();
    // @@protoc_insertion_point(field_mutable:enterprise_management.OsUpdateStatus.new_platform_version)
    return new_platform_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OsUpdateStatus::release_new_platform_version()
{
    // @@protoc_insertion_point(field_release:enterprise_management.OsUpdateStatus.new_platform_version)
    clear_has_new_platform_version();
    return new_platform_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OsUpdateStatus::set_allocated_new_platform_version(::std::string* new_platform_version)
{
    if (new_platform_version != NULL) {
        set_has_new_platform_version();
    } else {
        clear_has_new_platform_version();
    }
    new_platform_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_platform_version);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.OsUpdateStatus.new_platform_version)
}

// optional string new_required_platform_version = 3;
inline bool OsUpdateStatus::has_new_required_platform_version() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsUpdateStatus::set_has_new_required_platform_version()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void OsUpdateStatus::clear_has_new_required_platform_version()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void OsUpdateStatus::clear_new_required_platform_version()
{
    new_required_platform_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_new_required_platform_version();
}
inline const ::std::string& OsUpdateStatus::new_required_platform_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.new_required_platform_version)
    return new_required_platform_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OsUpdateStatus::set_new_required_platform_version(const ::std::string& value)
{
    set_has_new_required_platform_version();
    new_required_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline void OsUpdateStatus::set_new_required_platform_version(const char* value)
{
    set_has_new_required_platform_version();
    new_required_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline void OsUpdateStatus::set_new_required_platform_version(const char* value, size_t size)
{
    set_has_new_required_platform_version();
    new_required_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline ::std::string* OsUpdateStatus::mutable_new_required_platform_version()
{
    set_has_new_required_platform_version();
    // @@protoc_insertion_point(field_mutable:enterprise_management.OsUpdateStatus.new_required_platform_version)
    return new_required_platform_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OsUpdateStatus::release_new_required_platform_version()
{
    // @@protoc_insertion_point(field_release:enterprise_management.OsUpdateStatus.new_required_platform_version)
    clear_has_new_required_platform_version();
    return new_required_platform_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OsUpdateStatus::set_allocated_new_required_platform_version(::std::string* new_required_platform_version)
{
    if (new_required_platform_version != NULL) {
        set_has_new_required_platform_version();
    } else {
        clear_has_new_required_platform_version();
    }
    new_required_platform_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_required_platform_version);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.OsUpdateStatus.new_required_platform_version)
}

// -------------------------------------------------------------------

// AppStatus

// optional string app_id = 1;
inline bool AppStatus::has_app_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppStatus::set_has_app_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void AppStatus::clear_has_app_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void AppStatus::clear_app_id()
{
    app_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_app_id();
}
inline const ::std::string& AppStatus::app_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.app_id)
    return app_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_app_id(const ::std::string& value)
{
    set_has_app_id();
    app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.app_id)
}
inline void AppStatus::set_app_id(const char* value)
{
    set_has_app_id();
    app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.app_id)
}
inline void AppStatus::set_app_id(const char* value, size_t size)
{
    set_has_app_id();
    app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.app_id)
}
inline ::std::string* AppStatus::mutable_app_id()
{
    set_has_app_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.app_id)
    return app_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppStatus::release_app_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.app_id)
    clear_has_app_id();
    return app_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_app_id(::std::string* app_id)
{
    if (app_id != NULL) {
        set_has_app_id();
    } else {
        clear_has_app_id();
    }
    app_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.app_id)
}

// optional string extension_version = 2;
inline bool AppStatus::has_extension_version() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppStatus::set_has_extension_version()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void AppStatus::clear_has_extension_version()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void AppStatus::clear_extension_version()
{
    extension_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_extension_version();
}
inline const ::std::string& AppStatus::extension_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.extension_version)
    return extension_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_extension_version(const ::std::string& value)
{
    set_has_extension_version();
    extension_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.extension_version)
}
inline void AppStatus::set_extension_version(const char* value)
{
    set_has_extension_version();
    extension_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.extension_version)
}
inline void AppStatus::set_extension_version(const char* value, size_t size)
{
    set_has_extension_version();
    extension_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.extension_version)
}
inline ::std::string* AppStatus::mutable_extension_version()
{
    set_has_extension_version();
    // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.extension_version)
    return extension_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppStatus::release_extension_version()
{
    // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.extension_version)
    clear_has_extension_version();
    return extension_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_extension_version(::std::string* extension_version)
{
    if (extension_version != NULL) {
        set_has_extension_version();
    } else {
        clear_has_extension_version();
    }
    extension_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extension_version);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.extension_version)
}

// optional string status = 3;
inline bool AppStatus::has_status() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppStatus::set_has_status()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void AppStatus::clear_has_status()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void AppStatus::clear_status()
{
    status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_status();
}
inline const ::std::string& AppStatus::status() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.status)
    return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_status(const ::std::string& value)
{
    set_has_status();
    status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.status)
}
inline void AppStatus::set_status(const char* value)
{
    set_has_status();
    status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.status)
}
inline void AppStatus::set_status(const char* value, size_t size)
{
    set_has_status();
    status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.status)
}
inline ::std::string* AppStatus::mutable_status()
{
    set_has_status();
    // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.status)
    return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppStatus::release_status()
{
    // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.status)
    clear_has_status();
    return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_status(::std::string* status)
{
    if (status != NULL) {
        set_has_status();
    } else {
        clear_has_status();
    }
    status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.status)
}

// optional bool error = 4;
inline bool AppStatus::has_error() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppStatus::set_has_error()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void AppStatus::clear_has_error()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void AppStatus::clear_error()
{
    error_ = false;
    clear_has_error();
}
inline bool AppStatus::error() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.error)
    return error_;
}
inline void AppStatus::set_error(bool value)
{
    set_has_error();
    error_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.error)
}

// optional string required_platform_version = 5;
inline bool AppStatus::has_required_platform_version() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppStatus::set_has_required_platform_version()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void AppStatus::clear_has_required_platform_version()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void AppStatus::clear_required_platform_version()
{
    required_platform_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_required_platform_version();
}
inline const ::std::string& AppStatus::required_platform_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.required_platform_version)
    return required_platform_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_required_platform_version(const ::std::string& value)
{
    set_has_required_platform_version();
    required_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.required_platform_version)
}
inline void AppStatus::set_required_platform_version(const char* value)
{
    set_has_required_platform_version();
    required_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.AppStatus.required_platform_version)
}
inline void AppStatus::set_required_platform_version(const char* value, size_t size)
{
    set_has_required_platform_version();
    required_platform_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.AppStatus.required_platform_version)
}
inline ::std::string* AppStatus::mutable_required_platform_version()
{
    set_has_required_platform_version();
    // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.required_platform_version)
    return required_platform_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppStatus::release_required_platform_version()
{
    // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.required_platform_version)
    clear_has_required_platform_version();
    return required_platform_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppStatus::set_allocated_required_platform_version(::std::string* required_platform_version)
{
    if (required_platform_version != NULL) {
        set_has_required_platform_version();
    } else {
        clear_has_required_platform_version();
    }
    required_platform_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), required_platform_version);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.required_platform_version)
}

// -------------------------------------------------------------------

// AndroidStatus

// optional string status_payload = 1;
inline bool AndroidStatus::has_status_payload() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidStatus::set_has_status_payload()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void AndroidStatus::clear_has_status_payload()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidStatus::clear_status_payload()
{
    status_payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_status_payload();
}
inline const ::std::string& AndroidStatus::status_payload() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.AndroidStatus.status_payload)
    return status_payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidStatus::set_status_payload(const ::std::string& value)
{
    set_has_status_payload();
    status_payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.AndroidStatus.status_payload)
}
inline void AndroidStatus::set_status_payload(const char* value)
{
    set_has_status_payload();
    status_payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.AndroidStatus.status_payload)
}
inline void AndroidStatus::set_status_payload(const char* value, size_t size)
{
    set_has_status_payload();
    status_payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidStatus.status_payload)
}
inline ::std::string* AndroidStatus::mutable_status_payload()
{
    set_has_status_payload();
    // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidStatus.status_payload)
    return status_payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AndroidStatus::release_status_payload()
{
    // @@protoc_insertion_point(field_release:enterprise_management.AndroidStatus.status_payload)
    clear_has_status_payload();
    return status_payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidStatus::set_allocated_status_payload(::std::string* status_payload)
{
    if (status_payload != NULL) {
        set_has_status_payload();
    } else {
        clear_has_status_payload();
    }
    status_payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status_payload);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidStatus.status_payload)
}

// optional string droid_guard_info = 2;
inline bool AndroidStatus::has_droid_guard_info() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidStatus::set_has_droid_guard_info()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void AndroidStatus::clear_has_droid_guard_info()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void AndroidStatus::clear_droid_guard_info()
{
    droid_guard_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_droid_guard_info();
}
inline const ::std::string& AndroidStatus::droid_guard_info() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.AndroidStatus.droid_guard_info)
    return droid_guard_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidStatus::set_droid_guard_info(const ::std::string& value)
{
    set_has_droid_guard_info();
    droid_guard_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.AndroidStatus.droid_guard_info)
}
inline void AndroidStatus::set_droid_guard_info(const char* value)
{
    set_has_droid_guard_info();
    droid_guard_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.AndroidStatus.droid_guard_info)
}
inline void AndroidStatus::set_droid_guard_info(const char* value, size_t size)
{
    set_has_droid_guard_info();
    droid_guard_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.AndroidStatus.droid_guard_info)
}
inline ::std::string* AndroidStatus::mutable_droid_guard_info()
{
    set_has_droid_guard_info();
    // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidStatus.droid_guard_info)
    return droid_guard_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AndroidStatus::release_droid_guard_info()
{
    // @@protoc_insertion_point(field_release:enterprise_management.AndroidStatus.droid_guard_info)
    clear_has_droid_guard_info();
    return droid_guard_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidStatus::set_allocated_droid_guard_info(::std::string* droid_guard_info)
{
    if (droid_guard_info != NULL) {
        set_has_droid_guard_info();
    } else {
        clear_has_droid_guard_info();
    }
    droid_guard_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), droid_guard_info);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidStatus.droid_guard_info)
}

// -------------------------------------------------------------------

// SessionStatusReportRequest

// repeated string OBSOLETE_installed_app_id = 1 [deprecated = true];
inline int SessionStatusReportRequest::obsolete_installed_app_id_size() const
{
    return obsolete_installed_app_id_.size();
}
inline void SessionStatusReportRequest::clear_obsolete_installed_app_id()
{
    obsolete_installed_app_id_.Clear();
}
inline const ::std::string& SessionStatusReportRequest::obsolete_installed_app_id(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
    return obsolete_installed_app_id_.Get(index);
}
inline ::std::string* SessionStatusReportRequest::mutable_obsolete_installed_app_id(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
    return obsolete_installed_app_id_.Mutable(index);
}
inline void SessionStatusReportRequest::set_obsolete_installed_app_id(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
    obsolete_installed_app_id_.Mutable(index)->assign(value);
}
inline void SessionStatusReportRequest::set_obsolete_installed_app_id(int index, const char* value)
{
    obsolete_installed_app_id_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
}
inline void SessionStatusReportRequest::set_obsolete_installed_app_id(int index, const char* value, size_t size)
{
    obsolete_installed_app_id_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
}
inline ::std::string* SessionStatusReportRequest::add_obsolete_installed_app_id()
{
    // @@protoc_insertion_point(field_add_mutable:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
    return obsolete_installed_app_id_.Add();
}
inline void SessionStatusReportRequest::add_obsolete_installed_app_id(const ::std::string& value)
{
    obsolete_installed_app_id_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
}
inline void SessionStatusReportRequest::add_obsolete_installed_app_id(const char* value)
{
    obsolete_installed_app_id_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
}
inline void SessionStatusReportRequest::add_obsolete_installed_app_id(const char* value, size_t size)
{
    obsolete_installed_app_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SessionStatusReportRequest::obsolete_installed_app_id() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
    return obsolete_installed_app_id_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
SessionStatusReportRequest::mutable_obsolete_installed_app_id()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_app_id)
    return &obsolete_installed_app_id_;
}

// repeated string OBSOLETE_installed_extension_id = 2 [deprecated = true];
inline int SessionStatusReportRequest::obsolete_installed_extension_id_size() const
{
    return obsolete_installed_extension_id_.size();
}
inline void SessionStatusReportRequest::clear_obsolete_installed_extension_id()
{
    obsolete_installed_extension_id_.Clear();
}
inline const ::std::string& SessionStatusReportRequest::obsolete_installed_extension_id(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
    return obsolete_installed_extension_id_.Get(index);
}
inline ::std::string* SessionStatusReportRequest::mutable_obsolete_installed_extension_id(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
    return obsolete_installed_extension_id_.Mutable(index);
}
inline void SessionStatusReportRequest::set_obsolete_installed_extension_id(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
    obsolete_installed_extension_id_.Mutable(index)->assign(value);
}
inline void SessionStatusReportRequest::set_obsolete_installed_extension_id(int index, const char* value)
{
    obsolete_installed_extension_id_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
}
inline void SessionStatusReportRequest::set_obsolete_installed_extension_id(int index, const char* value, size_t size)
{
    obsolete_installed_extension_id_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
}
inline ::std::string* SessionStatusReportRequest::add_obsolete_installed_extension_id()
{
    // @@protoc_insertion_point(field_add_mutable:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
    return obsolete_installed_extension_id_.Add();
}
inline void SessionStatusReportRequest::add_obsolete_installed_extension_id(const ::std::string& value)
{
    obsolete_installed_extension_id_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
}
inline void SessionStatusReportRequest::add_obsolete_installed_extension_id(const char* value)
{
    obsolete_installed_extension_id_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
}
inline void SessionStatusReportRequest::add_obsolete_installed_extension_id(const char* value, size_t size)
{
    obsolete_installed_extension_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SessionStatusReportRequest::obsolete_installed_extension_id() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
    return obsolete_installed_extension_id_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
SessionStatusReportRequest::mutable_obsolete_installed_extension_id()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.OBSOLETE_installed_extension_id)
    return &obsolete_installed_extension_id_;
}

// repeated .enterprise_management.InstallableLaunch app_launch_stat = 3;
inline int SessionStatusReportRequest::app_launch_stat_size() const
{
    return app_launch_stat_.size();
}
inline void SessionStatusReportRequest::clear_app_launch_stat()
{
    app_launch_stat_.Clear();
}
inline const ::enterprise_management::InstallableLaunch& SessionStatusReportRequest::app_launch_stat(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.app_launch_stat)
    return app_launch_stat_.Get(index);
}
inline ::enterprise_management::InstallableLaunch* SessionStatusReportRequest::mutable_app_launch_stat(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.app_launch_stat)
    return app_launch_stat_.Mutable(index);
}
inline ::enterprise_management::InstallableLaunch* SessionStatusReportRequest::add_app_launch_stat()
{
    // @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.app_launch_stat)
    return app_launch_stat_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::InstallableLaunch>*
SessionStatusReportRequest::mutable_app_launch_stat()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.app_launch_stat)
    return &app_launch_stat_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::InstallableLaunch>&
SessionStatusReportRequest::app_launch_stat() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.app_launch_stat)
    return app_launch_stat_;
}

// optional string device_local_account_id = 4;
inline bool SessionStatusReportRequest::has_device_local_account_id() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionStatusReportRequest::set_has_device_local_account_id()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void SessionStatusReportRequest::clear_has_device_local_account_id()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void SessionStatusReportRequest::clear_device_local_account_id()
{
    device_local_account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_device_local_account_id();
}
inline const ::std::string& SessionStatusReportRequest::device_local_account_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.device_local_account_id)
    return device_local_account_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportRequest::set_device_local_account_id(const ::std::string& value)
{
    set_has_device_local_account_id();
    device_local_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline void SessionStatusReportRequest::set_device_local_account_id(const char* value)
{
    set_has_device_local_account_id();
    device_local_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline void SessionStatusReportRequest::set_device_local_account_id(const char* value, size_t size)
{
    set_has_device_local_account_id();
    device_local_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline ::std::string* SessionStatusReportRequest::mutable_device_local_account_id()
{
    set_has_device_local_account_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.device_local_account_id)
    return device_local_account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionStatusReportRequest::release_device_local_account_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.device_local_account_id)
    clear_has_device_local_account_id();
    return device_local_account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportRequest::set_allocated_device_local_account_id(::std::string* device_local_account_id)
{
    if (device_local_account_id != NULL) {
        set_has_device_local_account_id();
    } else {
        clear_has_device_local_account_id();
    }
    device_local_account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_local_account_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}

// repeated .enterprise_management.AppStatus installed_apps = 5;
inline int SessionStatusReportRequest::installed_apps_size() const
{
    return installed_apps_.size();
}
inline void SessionStatusReportRequest::clear_installed_apps()
{
    installed_apps_.Clear();
}
inline const ::enterprise_management::AppStatus& SessionStatusReportRequest::installed_apps(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.installed_apps)
    return installed_apps_.Get(index);
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::mutable_installed_apps(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.installed_apps)
    return installed_apps_.Mutable(index);
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::add_installed_apps()
{
    // @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.installed_apps)
    return installed_apps_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>*
SessionStatusReportRequest::mutable_installed_apps()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.installed_apps)
    return &installed_apps_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>&
SessionStatusReportRequest::installed_apps() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.installed_apps)
    return installed_apps_;
}

// repeated .enterprise_management.AppStatus installed_extensions = 6;
inline int SessionStatusReportRequest::installed_extensions_size() const
{
    return installed_extensions_.size();
}
inline void SessionStatusReportRequest::clear_installed_extensions()
{
    installed_extensions_.Clear();
}
inline const ::enterprise_management::AppStatus& SessionStatusReportRequest::installed_extensions(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.installed_extensions)
    return installed_extensions_.Get(index);
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::mutable_installed_extensions(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.installed_extensions)
    return installed_extensions_.Mutable(index);
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::add_installed_extensions()
{
    // @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.installed_extensions)
    return installed_extensions_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>*
SessionStatusReportRequest::mutable_installed_extensions()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.installed_extensions)
    return &installed_extensions_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::AppStatus>&
SessionStatusReportRequest::installed_extensions() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.installed_extensions)
    return installed_extensions_;
}

// optional .enterprise_management.AndroidStatus android_status = 7;
inline bool SessionStatusReportRequest::has_android_status() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SessionStatusReportRequest::set_has_android_status()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void SessionStatusReportRequest::clear_has_android_status()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void SessionStatusReportRequest::clear_android_status()
{
    if (android_status_ != NULL)
        android_status_->::enterprise_management::AndroidStatus::Clear();
    clear_has_android_status();
}
inline const ::enterprise_management::AndroidStatus& SessionStatusReportRequest::android_status() const
{
// @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.android_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return android_status_ != NULL ? *android_status_ : *default_instance().android_status_;
#else
    return android_status_ != NULL ? *android_status_ : *default_instance_->android_status_;
#endif
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::mutable_android_status()
{
    set_has_android_status();
    if (android_status_ == NULL) {
        android_status_ = new ::enterprise_management::AndroidStatus;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.android_status)
    return android_status_;
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::release_android_status()
{
    // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.android_status)
    clear_has_android_status();
    ::enterprise_management::AndroidStatus* temp = android_status_;
    android_status_ = NULL;
    return temp;
}
inline void SessionStatusReportRequest::set_allocated_android_status(::enterprise_management::AndroidStatus* android_status)
{
    delete android_status_;
    android_status_ = android_status;
    if (android_status) {
        set_has_android_status();
    } else {
        clear_has_android_status();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.android_status)
}

// -------------------------------------------------------------------

// DeviceStatusReportResponse

// optional int32 error_code = 1;
inline bool DeviceStatusReportResponse::has_error_code() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStatusReportResponse::set_has_error_code()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceStatusReportResponse::clear_has_error_code()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceStatusReportResponse::clear_error_code()
{
    error_code_ = 0;
    clear_has_error_code();
}
inline ::google::protobuf::int32 DeviceStatusReportResponse::error_code() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportResponse.error_code)
    return error_code_;
}
inline void DeviceStatusReportResponse::set_error_code(::google::protobuf::int32 value)
{
    set_has_error_code();
    error_code_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool DeviceStatusReportResponse::has_error_message() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStatusReportResponse::set_has_error_message()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceStatusReportResponse::clear_has_error_message()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceStatusReportResponse::clear_error_message()
{
    error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_error_message();
}
inline const ::std::string& DeviceStatusReportResponse::error_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportResponse.error_message)
    return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportResponse::set_error_message(const ::std::string& value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline void DeviceStatusReportResponse::set_error_message(const char* value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline void DeviceStatusReportResponse::set_error_message(const char* value, size_t size)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline ::std::string* DeviceStatusReportResponse::mutable_error_message()
{
    set_has_error_message();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportResponse.error_message)
    return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceStatusReportResponse::release_error_message()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportResponse.error_message)
    clear_has_error_message();
    return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStatusReportResponse::set_allocated_error_message(::std::string* error_message)
{
    if (error_message != NULL) {
        set_has_error_message();
    } else {
        clear_has_error_message();
    }
    error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// SessionStatusReportResponse

// optional int32 error_code = 1;
inline bool SessionStatusReportResponse::has_error_code() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStatusReportResponse::set_has_error_code()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void SessionStatusReportResponse::clear_has_error_code()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStatusReportResponse::clear_error_code()
{
    error_code_ = 0;
    clear_has_error_code();
}
inline ::google::protobuf::int32 SessionStatusReportResponse::error_code() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportResponse.error_code)
    return error_code_;
}
inline void SessionStatusReportResponse::set_error_code(::google::protobuf::int32 value)
{
    set_has_error_code();
    error_code_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool SessionStatusReportResponse::has_error_message() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStatusReportResponse::set_has_error_message()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void SessionStatusReportResponse::clear_has_error_message()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStatusReportResponse::clear_error_message()
{
    error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_error_message();
}
inline const ::std::string& SessionStatusReportResponse::error_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportResponse.error_message)
    return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportResponse::set_error_message(const ::std::string& value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportResponse.error_message)
}
inline void SessionStatusReportResponse::set_error_message(const char* value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.SessionStatusReportResponse.error_message)
}
inline void SessionStatusReportResponse::set_error_message(const char* value, size_t size)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.SessionStatusReportResponse.error_message)
}
inline ::std::string* SessionStatusReportResponse::mutable_error_message()
{
    set_has_error_message();
    // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportResponse.error_message)
    return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionStatusReportResponse::release_error_message()
{
    // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportResponse.error_message)
    clear_has_error_message();
    return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatusReportResponse::set_allocated_error_message(::std::string* error_message)
{
    if (error_message != NULL) {
        set_has_error_message();
    } else {
        clear_has_error_message();
    }
    error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// DeviceAutoEnrollmentRequest

// optional int64 remainder = 1;
inline bool DeviceAutoEnrollmentRequest::has_remainder() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAutoEnrollmentRequest::set_has_remainder()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAutoEnrollmentRequest::clear_has_remainder()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAutoEnrollmentRequest::clear_remainder()
{
    remainder_ = GOOGLE_LONGLONG(0);
    clear_has_remainder();
}
inline ::google::protobuf::int64 DeviceAutoEnrollmentRequest::remainder() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.remainder)
    return remainder_;
}
inline void DeviceAutoEnrollmentRequest::set_remainder(::google::protobuf::int64 value)
{
    set_has_remainder();
    remainder_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.remainder)
}

// optional int64 modulus = 2;
inline bool DeviceAutoEnrollmentRequest::has_modulus() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAutoEnrollmentRequest::set_has_modulus()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceAutoEnrollmentRequest::clear_has_modulus()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceAutoEnrollmentRequest::clear_modulus()
{
    modulus_ = GOOGLE_LONGLONG(0);
    clear_has_modulus();
}
inline ::google::protobuf::int64 DeviceAutoEnrollmentRequest::modulus() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.modulus)
    return modulus_;
}
inline void DeviceAutoEnrollmentRequest::set_modulus(::google::protobuf::int64 value)
{
    set_has_modulus();
    modulus_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.modulus)
}

// -------------------------------------------------------------------

// DeviceAutoEnrollmentResponse

// optional int64 expected_modulus = 1;
inline bool DeviceAutoEnrollmentResponse::has_expected_modulus() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAutoEnrollmentResponse::set_has_expected_modulus()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAutoEnrollmentResponse::clear_has_expected_modulus()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAutoEnrollmentResponse::clear_expected_modulus()
{
    expected_modulus_ = GOOGLE_LONGLONG(0);
    clear_has_expected_modulus();
}
inline ::google::protobuf::int64 DeviceAutoEnrollmentResponse::expected_modulus() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentResponse.expected_modulus)
    return expected_modulus_;
}
inline void DeviceAutoEnrollmentResponse::set_expected_modulus(::google::protobuf::int64 value)
{
    set_has_expected_modulus();
    expected_modulus_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.expected_modulus)
}

// repeated bytes hash = 2;
inline int DeviceAutoEnrollmentResponse::hash_size() const
{
    return hash_.size();
}
inline void DeviceAutoEnrollmentResponse::clear_hash()
{
    hash_.Clear();
}
inline const ::std::string& DeviceAutoEnrollmentResponse::hash(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentResponse.hash)
    return hash_.Get(index);
}
inline ::std::string* DeviceAutoEnrollmentResponse::mutable_hash(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAutoEnrollmentResponse.hash)
    return hash_.Mutable(index);
}
inline void DeviceAutoEnrollmentResponse::set_hash(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.hash)
    hash_.Mutable(index)->assign(value);
}
inline void DeviceAutoEnrollmentResponse::set_hash(int index, const char* value)
{
    hash_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAutoEnrollmentResponse.hash)
}
inline void DeviceAutoEnrollmentResponse::set_hash(int index, const void* value, size_t size)
{
    hash_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAutoEnrollmentResponse.hash)
}
inline ::std::string* DeviceAutoEnrollmentResponse::add_hash()
{
    // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceAutoEnrollmentResponse.hash)
    return hash_.Add();
}
inline void DeviceAutoEnrollmentResponse::add_hash(const ::std::string& value)
{
    hash_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceAutoEnrollmentResponse.hash)
}
inline void DeviceAutoEnrollmentResponse::add_hash(const char* value)
{
    hash_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceAutoEnrollmentResponse.hash)
}
inline void DeviceAutoEnrollmentResponse::add_hash(const void* value, size_t size)
{
    hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceAutoEnrollmentResponse.hash)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DeviceAutoEnrollmentResponse::hash() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceAutoEnrollmentResponse.hash)
    return hash_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DeviceAutoEnrollmentResponse::mutable_hash()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceAutoEnrollmentResponse.hash)
    return &hash_;
}

// -------------------------------------------------------------------

// DeviceStateRetrievalRequest

// optional bytes server_backed_state_key = 1;
inline bool DeviceStateRetrievalRequest::has_server_backed_state_key() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStateRetrievalRequest::set_has_server_backed_state_key()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceStateRetrievalRequest::clear_has_server_backed_state_key()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceStateRetrievalRequest::clear_server_backed_state_key()
{
    server_backed_state_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_backed_state_key();
}
inline const ::std::string& DeviceStateRetrievalRequest::server_backed_state_key() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
    return server_backed_state_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStateRetrievalRequest::set_server_backed_state_key(const ::std::string& value)
{
    set_has_server_backed_state_key();
    server_backed_state_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline void DeviceStateRetrievalRequest::set_server_backed_state_key(const char* value)
{
    set_has_server_backed_state_key();
    server_backed_state_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline void DeviceStateRetrievalRequest::set_server_backed_state_key(const void* value, size_t size)
{
    set_has_server_backed_state_key();
    server_backed_state_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline ::std::string* DeviceStateRetrievalRequest::mutable_server_backed_state_key()
{
    set_has_server_backed_state_key();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
    return server_backed_state_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceStateRetrievalRequest::release_server_backed_state_key()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
    clear_has_server_backed_state_key();
    return server_backed_state_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStateRetrievalRequest::set_allocated_server_backed_state_key(::std::string* server_backed_state_key)
{
    if (server_backed_state_key != NULL) {
        set_has_server_backed_state_key();
    } else {
        clear_has_server_backed_state_key();
    }
    server_backed_state_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_backed_state_key);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}

// -------------------------------------------------------------------

// DeviceStateKeyUpdateRequest

// repeated bytes server_backed_state_key = 1;
inline int DeviceStateKeyUpdateRequest::server_backed_state_key_size() const
{
    return server_backed_state_key_.size();
}
inline void DeviceStateKeyUpdateRequest::clear_server_backed_state_key()
{
    server_backed_state_key_.Clear();
}
inline const ::std::string& DeviceStateKeyUpdateRequest::server_backed_state_key(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
    return server_backed_state_key_.Get(index);
}
inline ::std::string* DeviceStateKeyUpdateRequest::mutable_server_backed_state_key(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
    return server_backed_state_key_.Mutable(index);
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_key(int index, const ::std::string& value)
{
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
    server_backed_state_key_.Mutable(index)->assign(value);
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_key(int index, const char* value)
{
    server_backed_state_key_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_key(int index, const void* value, size_t size)
{
    server_backed_state_key_.Mutable(index)->assign(
        reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
}
inline ::std::string* DeviceStateKeyUpdateRequest::add_server_backed_state_key()
{
    // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
    return server_backed_state_key_.Add();
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_key(const ::std::string& value)
{
    server_backed_state_key_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_key(const char* value)
{
    server_backed_state_key_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_key(const void* value, size_t size)
{
    server_backed_state_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DeviceStateKeyUpdateRequest::server_backed_state_key() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
    return server_backed_state_key_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DeviceStateKeyUpdateRequest::mutable_server_backed_state_key()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_key)
    return &server_backed_state_key_;
}

// -------------------------------------------------------------------

// DeviceStateRetrievalResponse

// optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
inline bool DeviceStateRetrievalResponse::has_restore_mode() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStateRetrievalResponse::set_has_restore_mode()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceStateRetrievalResponse::clear_has_restore_mode()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceStateRetrievalResponse::clear_restore_mode()
{
    restore_mode_ = 0;
    clear_has_restore_mode();
}
inline ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::restore_mode() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.restore_mode)
    return static_cast<::enterprise_management::DeviceStateRetrievalResponse_RestoreMode>(restore_mode_);
}
inline void DeviceStateRetrievalResponse::set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value)
{
    assert(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode_IsValid(value));
    set_has_restore_mode();
    restore_mode_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalResponse.restore_mode)
}

// optional string management_domain = 2;
inline bool DeviceStateRetrievalResponse::has_management_domain() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStateRetrievalResponse::set_has_management_domain()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceStateRetrievalResponse::clear_has_management_domain()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceStateRetrievalResponse::clear_management_domain()
{
    management_domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_management_domain();
}
inline const ::std::string& DeviceStateRetrievalResponse::management_domain() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.management_domain)
    return management_domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStateRetrievalResponse::set_management_domain(const ::std::string& value)
{
    set_has_management_domain();
    management_domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline void DeviceStateRetrievalResponse::set_management_domain(const char* value)
{
    set_has_management_domain();
    management_domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline void DeviceStateRetrievalResponse::set_management_domain(const char* value, size_t size)
{
    set_has_management_domain();
    management_domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline ::std::string* DeviceStateRetrievalResponse::mutable_management_domain()
{
    set_has_management_domain();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.management_domain)
    return management_domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceStateRetrievalResponse::release_management_domain()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.management_domain)
    clear_has_management_domain();
    return management_domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceStateRetrievalResponse::set_allocated_management_domain(::std::string* management_domain)
{
    if (management_domain != NULL) {
        set_has_management_domain();
    } else {
        clear_has_management_domain();
    }
    management_domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), management_domain);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}

// optional .enterprise_management.DisabledState disabled_state = 3;
inline bool DeviceStateRetrievalResponse::has_disabled_state() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceStateRetrievalResponse::set_has_disabled_state()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void DeviceStateRetrievalResponse::clear_has_disabled_state()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceStateRetrievalResponse::clear_disabled_state()
{
    if (disabled_state_ != NULL)
        disabled_state_->::enterprise_management::DisabledState::Clear();
    clear_has_disabled_state();
}
inline const ::enterprise_management::DisabledState& DeviceStateRetrievalResponse::disabled_state() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return disabled_state_ != NULL ? *disabled_state_ : *default_instance().disabled_state_;
#else
    return disabled_state_ != NULL ? *disabled_state_ : *default_instance_->disabled_state_;
#endif
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::mutable_disabled_state()
{
    set_has_disabled_state();
    if (disabled_state_ == NULL) {
        disabled_state_ = new ::enterprise_management::DisabledState;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
    return disabled_state_;
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::release_disabled_state()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
    clear_has_disabled_state();
    ::enterprise_management::DisabledState* temp = disabled_state_;
    disabled_state_ = NULL;
    return temp;
}
inline void DeviceStateRetrievalResponse::set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state)
{
    delete disabled_state_;
    disabled_state_ = disabled_state;
    if (disabled_state) {
        set_has_disabled_state();
    } else {
        clear_has_disabled_state();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
}

// -------------------------------------------------------------------

// DevicePairingRequest

// optional string host_device_id = 1;
inline bool DevicePairingRequest::has_host_device_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DevicePairingRequest::set_has_host_device_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DevicePairingRequest::clear_has_host_device_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DevicePairingRequest::clear_host_device_id()
{
    host_device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_host_device_id();
}
inline const ::std::string& DevicePairingRequest::host_device_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DevicePairingRequest.host_device_id)
    return host_device_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicePairingRequest::set_host_device_id(const ::std::string& value)
{
    set_has_host_device_id();
    host_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DevicePairingRequest.host_device_id)
}
inline void DevicePairingRequest::set_host_device_id(const char* value)
{
    set_has_host_device_id();
    host_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DevicePairingRequest.host_device_id)
}
inline void DevicePairingRequest::set_host_device_id(const char* value, size_t size)
{
    set_has_host_device_id();
    host_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DevicePairingRequest.host_device_id)
}
inline ::std::string* DevicePairingRequest::mutable_host_device_id()
{
    set_has_host_device_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePairingRequest.host_device_id)
    return host_device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicePairingRequest::release_host_device_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DevicePairingRequest.host_device_id)
    clear_has_host_device_id();
    return host_device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicePairingRequest::set_allocated_host_device_id(::std::string* host_device_id)
{
    if (host_device_id != NULL) {
        set_has_host_device_id();
    } else {
        clear_has_host_device_id();
    }
    host_device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_device_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePairingRequest.host_device_id)
}

// optional string controller_device_id = 2;
inline bool DevicePairingRequest::has_controller_device_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DevicePairingRequest::set_has_controller_device_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DevicePairingRequest::clear_has_controller_device_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DevicePairingRequest::clear_controller_device_id()
{
    controller_device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_controller_device_id();
}
inline const ::std::string& DevicePairingRequest::controller_device_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DevicePairingRequest.controller_device_id)
    return controller_device_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicePairingRequest::set_controller_device_id(const ::std::string& value)
{
    set_has_controller_device_id();
    controller_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline void DevicePairingRequest::set_controller_device_id(const char* value)
{
    set_has_controller_device_id();
    controller_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline void DevicePairingRequest::set_controller_device_id(const char* value, size_t size)
{
    set_has_controller_device_id();
    controller_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline ::std::string* DevicePairingRequest::mutable_controller_device_id()
{
    set_has_controller_device_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePairingRequest.controller_device_id)
    return controller_device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicePairingRequest::release_controller_device_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DevicePairingRequest.controller_device_id)
    clear_has_controller_device_id();
    return controller_device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicePairingRequest::set_allocated_controller_device_id(::std::string* controller_device_id)
{
    if (controller_device_id != NULL) {
        set_has_controller_device_id();
    } else {
        clear_has_controller_device_id();
    }
    controller_device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), controller_device_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePairingRequest.controller_device_id)
}

// -------------------------------------------------------------------

// DevicePairingResponse

// optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
inline bool DevicePairingResponse::has_status_code() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DevicePairingResponse::set_has_status_code()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DevicePairingResponse::clear_has_status_code()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DevicePairingResponse::clear_status_code()
{
    status_code_ = 1;
    clear_has_status_code();
}
inline ::enterprise_management::DevicePairingResponse_StatusCode DevicePairingResponse::status_code() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DevicePairingResponse.status_code)
    return static_cast<::enterprise_management::DevicePairingResponse_StatusCode>(status_code_);
}
inline void DevicePairingResponse::set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value)
{
    assert(::enterprise_management::DevicePairingResponse_StatusCode_IsValid(value));
    set_has_status_code();
    status_code_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DevicePairingResponse.status_code)
}

// -------------------------------------------------------------------

// CheckDevicePairingRequest

// optional string host_device_id = 1;
inline bool CheckDevicePairingRequest::has_host_device_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckDevicePairingRequest::set_has_host_device_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void CheckDevicePairingRequest::clear_has_host_device_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void CheckDevicePairingRequest::clear_host_device_id()
{
    host_device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_host_device_id();
}
inline const ::std::string& CheckDevicePairingRequest::host_device_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingRequest.host_device_id)
    return host_device_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckDevicePairingRequest::set_host_device_id(const ::std::string& value)
{
    set_has_host_device_id();
    host_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline void CheckDevicePairingRequest::set_host_device_id(const char* value)
{
    set_has_host_device_id();
    host_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline void CheckDevicePairingRequest::set_host_device_id(const char* value, size_t size)
{
    set_has_host_device_id();
    host_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline ::std::string* CheckDevicePairingRequest::mutable_host_device_id()
{
    set_has_host_device_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.CheckDevicePairingRequest.host_device_id)
    return host_device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckDevicePairingRequest::release_host_device_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.CheckDevicePairingRequest.host_device_id)
    clear_has_host_device_id();
    return host_device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckDevicePairingRequest::set_allocated_host_device_id(::std::string* host_device_id)
{
    if (host_device_id != NULL) {
        set_has_host_device_id();
    } else {
        clear_has_host_device_id();
    }
    host_device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_device_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.CheckDevicePairingRequest.host_device_id)
}

// optional string controller_device_id = 2;
inline bool CheckDevicePairingRequest::has_controller_device_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckDevicePairingRequest::set_has_controller_device_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void CheckDevicePairingRequest::clear_has_controller_device_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void CheckDevicePairingRequest::clear_controller_device_id()
{
    controller_device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_controller_device_id();
}
inline const ::std::string& CheckDevicePairingRequest::controller_device_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingRequest.controller_device_id)
    return controller_device_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckDevicePairingRequest::set_controller_device_id(const ::std::string& value)
{
    set_has_controller_device_id();
    controller_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline void CheckDevicePairingRequest::set_controller_device_id(const char* value)
{
    set_has_controller_device_id();
    controller_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline void CheckDevicePairingRequest::set_controller_device_id(const char* value, size_t size)
{
    set_has_controller_device_id();
    controller_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline ::std::string* CheckDevicePairingRequest::mutable_controller_device_id()
{
    set_has_controller_device_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.CheckDevicePairingRequest.controller_device_id)
    return controller_device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckDevicePairingRequest::release_controller_device_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.CheckDevicePairingRequest.controller_device_id)
    clear_has_controller_device_id();
    return controller_device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckDevicePairingRequest::set_allocated_controller_device_id(::std::string* controller_device_id)
{
    if (controller_device_id != NULL) {
        set_has_controller_device_id();
    } else {
        clear_has_controller_device_id();
    }
    controller_device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), controller_device_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}

// -------------------------------------------------------------------

// CheckDevicePairingResponse

// optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
inline bool CheckDevicePairingResponse::has_status_code() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckDevicePairingResponse::set_has_status_code()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void CheckDevicePairingResponse::clear_has_status_code()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void CheckDevicePairingResponse::clear_status_code()
{
    status_code_ = 1;
    clear_has_status_code();
}
inline ::enterprise_management::CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::status_code() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingResponse.status_code)
    return static_cast<::enterprise_management::CheckDevicePairingResponse_StatusCode>(status_code_);
}
inline void CheckDevicePairingResponse::set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value)
{
    assert(::enterprise_management::CheckDevicePairingResponse_StatusCode_IsValid(value));
    set_has_status_code();
    status_code_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingResponse.status_code)
}

// -------------------------------------------------------------------

// RemoteCommand

// optional .enterprise_management.RemoteCommand.Type type = 1;
inline bool RemoteCommand::has_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteCommand::set_has_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void RemoteCommand::clear_has_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteCommand::clear_type()
{
    type_ = -1;
    clear_has_type();
}
inline ::enterprise_management::RemoteCommand_Type RemoteCommand::type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.type)
    return static_cast<::enterprise_management::RemoteCommand_Type>(type_);
}
inline void RemoteCommand::set_type(::enterprise_management::RemoteCommand_Type value)
{
    assert(::enterprise_management::RemoteCommand_Type_IsValid(value));
    set_has_type();
    type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.type)
}

// optional int64 command_id = 2;
inline bool RemoteCommand::has_command_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteCommand::set_has_command_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void RemoteCommand::clear_has_command_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteCommand::clear_command_id()
{
    command_id_ = GOOGLE_LONGLONG(0);
    clear_has_command_id();
}
inline ::google::protobuf::int64 RemoteCommand::command_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.command_id)
    return command_id_;
}
inline void RemoteCommand::set_command_id(::google::protobuf::int64 value)
{
    set_has_command_id();
    command_id_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.command_id)
}

// optional int64 age_of_command = 3;
inline bool RemoteCommand::has_age_of_command() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteCommand::set_has_age_of_command()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void RemoteCommand::clear_has_age_of_command()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteCommand::clear_age_of_command()
{
    age_of_command_ = GOOGLE_LONGLONG(0);
    clear_has_age_of_command();
}
inline ::google::protobuf::int64 RemoteCommand::age_of_command() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.age_of_command)
    return age_of_command_;
}
inline void RemoteCommand::set_age_of_command(::google::protobuf::int64 value)
{
    set_has_age_of_command();
    age_of_command_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.age_of_command)
}

// optional string payload = 4;
inline bool RemoteCommand::has_payload() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteCommand::set_has_payload()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void RemoteCommand::clear_has_payload()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteCommand::clear_payload()
{
    payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
}
inline const ::std::string& RemoteCommand::payload() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.payload)
    return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteCommand::set_payload(const ::std::string& value)
{
    set_has_payload();
    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.payload)
}
inline void RemoteCommand::set_payload(const char* value)
{
    set_has_payload();
    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.RemoteCommand.payload)
}
inline void RemoteCommand::set_payload(const char* value, size_t size)
{
    set_has_payload();
    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.RemoteCommand.payload)
}
inline ::std::string* RemoteCommand::mutable_payload()
{
    set_has_payload();
    // @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommand.payload)
    return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemoteCommand::release_payload()
{
    // @@protoc_insertion_point(field_release:enterprise_management.RemoteCommand.payload)
    clear_has_payload();
    return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteCommand::set_allocated_payload(::std::string* payload)
{
    if (payload != NULL) {
        set_has_payload();
    } else {
        clear_has_payload();
    }
    payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommand.payload)
}

// -------------------------------------------------------------------

// RemoteCommandResult

// optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
inline bool RemoteCommandResult::has_result() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteCommandResult::set_has_result()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void RemoteCommandResult::clear_has_result()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteCommandResult::clear_result()
{
    result_ = 0;
    clear_has_result();
}
inline ::enterprise_management::RemoteCommandResult_ResultType RemoteCommandResult::result() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.result)
    return static_cast<::enterprise_management::RemoteCommandResult_ResultType>(result_);
}
inline void RemoteCommandResult::set_result(::enterprise_management::RemoteCommandResult_ResultType value)
{
    assert(::enterprise_management::RemoteCommandResult_ResultType_IsValid(value));
    set_has_result();
    result_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.result)
}

// optional int64 command_id = 2;
inline bool RemoteCommandResult::has_command_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteCommandResult::set_has_command_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void RemoteCommandResult::clear_has_command_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteCommandResult::clear_command_id()
{
    command_id_ = GOOGLE_LONGLONG(0);
    clear_has_command_id();
}
inline ::google::protobuf::int64 RemoteCommandResult::command_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.command_id)
    return command_id_;
}
inline void RemoteCommandResult::set_command_id(::google::protobuf::int64 value)
{
    set_has_command_id();
    command_id_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.command_id)
}

// optional int64 timestamp = 3;
inline bool RemoteCommandResult::has_timestamp() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteCommandResult::set_has_timestamp()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void RemoteCommandResult::clear_has_timestamp()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteCommandResult::clear_timestamp()
{
    timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_timestamp();
}
inline ::google::protobuf::int64 RemoteCommandResult::timestamp() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.timestamp)
    return timestamp_;
}
inline void RemoteCommandResult::set_timestamp(::google::protobuf::int64 value)
{
    set_has_timestamp();
    timestamp_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.timestamp)
}

// optional string payload = 4;
inline bool RemoteCommandResult::has_payload() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteCommandResult::set_has_payload()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void RemoteCommandResult::clear_has_payload()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteCommandResult::clear_payload()
{
    payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
}
inline const ::std::string& RemoteCommandResult::payload() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.payload)
    return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteCommandResult::set_payload(const ::std::string& value)
{
    set_has_payload();
    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.payload)
}
inline void RemoteCommandResult::set_payload(const char* value)
{
    set_has_payload();
    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.RemoteCommandResult.payload)
}
inline void RemoteCommandResult::set_payload(const char* value, size_t size)
{
    set_has_payload();
    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.RemoteCommandResult.payload)
}
inline ::std::string* RemoteCommandResult::mutable_payload()
{
    set_has_payload();
    // @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommandResult.payload)
    return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemoteCommandResult::release_payload()
{
    // @@protoc_insertion_point(field_release:enterprise_management.RemoteCommandResult.payload)
    clear_has_payload();
    return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoteCommandResult::set_allocated_payload(::std::string* payload)
{
    if (payload != NULL) {
        set_has_payload();
    } else {
        clear_has_payload();
    }
    payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommandResult.payload)
}

// -------------------------------------------------------------------

// DeviceRemoteCommandRequest

// optional int64 last_command_unique_id = 1;
inline bool DeviceRemoteCommandRequest::has_last_command_unique_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRemoteCommandRequest::set_has_last_command_unique_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceRemoteCommandRequest::clear_has_last_command_unique_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceRemoteCommandRequest::clear_last_command_unique_id()
{
    last_command_unique_id_ = GOOGLE_LONGLONG(0);
    clear_has_last_command_unique_id();
}
inline ::google::protobuf::int64 DeviceRemoteCommandRequest::last_command_unique_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.last_command_unique_id)
    return last_command_unique_id_;
}
inline void DeviceRemoteCommandRequest::set_last_command_unique_id(::google::protobuf::int64 value)
{
    set_has_last_command_unique_id();
    last_command_unique_id_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceRemoteCommandRequest.last_command_unique_id)
}

// repeated .enterprise_management.RemoteCommandResult command_results = 2;
inline int DeviceRemoteCommandRequest::command_results_size() const
{
    return command_results_.size();
}
inline void DeviceRemoteCommandRequest::clear_command_results()
{
    command_results_.Clear();
}
inline const ::enterprise_management::RemoteCommandResult& DeviceRemoteCommandRequest::command_results(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.command_results)
    return command_results_.Get(index);
}
inline ::enterprise_management::RemoteCommandResult* DeviceRemoteCommandRequest::mutable_command_results(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandRequest.command_results)
    return command_results_.Mutable(index);
}
inline ::enterprise_management::RemoteCommandResult* DeviceRemoteCommandRequest::add_command_results()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandRequest.command_results)
    return command_results_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommandResult>*
DeviceRemoteCommandRequest::mutable_command_results()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandRequest.command_results)
    return &command_results_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommandResult>&
DeviceRemoteCommandRequest::command_results() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandRequest.command_results)
    return command_results_;
}

// -------------------------------------------------------------------

// DeviceRemoteCommandResponse

// repeated .enterprise_management.RemoteCommand commands = 1;
inline int DeviceRemoteCommandResponse::commands_size() const
{
    return commands_.size();
}
inline void DeviceRemoteCommandResponse::clear_commands()
{
    commands_.Clear();
}
inline const ::enterprise_management::RemoteCommand& DeviceRemoteCommandResponse::commands(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandResponse.commands)
    return commands_.Get(index);
}
inline ::enterprise_management::RemoteCommand* DeviceRemoteCommandResponse::mutable_commands(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandResponse.commands)
    return commands_.Mutable(index);
}
inline ::enterprise_management::RemoteCommand* DeviceRemoteCommandResponse::add_commands()
{
    // @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandResponse.commands)
    return commands_.Add();
}
inline ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommand>*
DeviceRemoteCommandResponse::mutable_commands()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandResponse.commands)
    return &commands_;
}
inline const ::google::protobuf::RepeatedPtrField<::enterprise_management::RemoteCommand>&
DeviceRemoteCommandResponse::commands() const
{
    // @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandResponse.commands)
    return commands_;
}

// -------------------------------------------------------------------

// DeviceAttributeUpdatePermissionRequest

// -------------------------------------------------------------------

// DeviceAttributeUpdatePermissionResponse

// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
inline bool DeviceAttributeUpdatePermissionResponse::has_result() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAttributeUpdatePermissionResponse::set_has_result()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAttributeUpdatePermissionResponse::clear_has_result()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAttributeUpdatePermissionResponse::clear_result()
{
    result_ = 0;
    clear_has_result();
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::result() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdatePermissionResponse.result)
    return static_cast<::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType>(result_);
}
inline void DeviceAttributeUpdatePermissionResponse::set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value)
{
    assert(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(value));
    set_has_result();
    result_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdatePermissionResponse.result)
}

// -------------------------------------------------------------------

// DeviceAttributeUpdateRequest

// optional string asset_id = 1;
inline bool DeviceAttributeUpdateRequest::has_asset_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAttributeUpdateRequest::set_has_asset_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAttributeUpdateRequest::clear_has_asset_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAttributeUpdateRequest::clear_asset_id()
{
    asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_asset_id();
}
inline const ::std::string& DeviceAttributeUpdateRequest::asset_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
    return asset_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceAttributeUpdateRequest::set_asset_id(const ::std::string& value)
{
    set_has_asset_id();
    asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline void DeviceAttributeUpdateRequest::set_asset_id(const char* value)
{
    set_has_asset_id();
    asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline void DeviceAttributeUpdateRequest::set_asset_id(const char* value, size_t size)
{
    set_has_asset_id();
    asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline ::std::string* DeviceAttributeUpdateRequest::mutable_asset_id()
{
    set_has_asset_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
    return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceAttributeUpdateRequest::release_asset_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
    clear_has_asset_id();
    return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceAttributeUpdateRequest::set_allocated_asset_id(::std::string* asset_id)
{
    if (asset_id != NULL) {
        set_has_asset_id();
    } else {
        clear_has_asset_id();
    }
    asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}

// optional string location = 2;
inline bool DeviceAttributeUpdateRequest::has_location() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAttributeUpdateRequest::set_has_location()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceAttributeUpdateRequest::clear_has_location()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceAttributeUpdateRequest::clear_location()
{
    location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_location();
}
inline const ::std::string& DeviceAttributeUpdateRequest::location() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateRequest.location)
    return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceAttributeUpdateRequest::set_location(const ::std::string& value)
{
    set_has_location();
    location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline void DeviceAttributeUpdateRequest::set_location(const char* value)
{
    set_has_location();
    location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline void DeviceAttributeUpdateRequest::set_location(const char* value, size_t size)
{
    set_has_location();
    location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline ::std::string* DeviceAttributeUpdateRequest::mutable_location()
{
    set_has_location();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAttributeUpdateRequest.location)
    return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceAttributeUpdateRequest::release_location()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceAttributeUpdateRequest.location)
    clear_has_location();
    return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceAttributeUpdateRequest::set_allocated_location(::std::string* location)
{
    if (location != NULL) {
        set_has_location();
    } else {
        clear_has_location();
    }
    location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceAttributeUpdateRequest.location)
}

// -------------------------------------------------------------------

// DeviceAttributeUpdateResponse

// optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
inline bool DeviceAttributeUpdateResponse::has_result() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAttributeUpdateResponse::set_has_result()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAttributeUpdateResponse::clear_has_result()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAttributeUpdateResponse::clear_result()
{
    result_ = 0;
    clear_has_result();
}
inline ::enterprise_management::DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::result() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateResponse.result)
    return static_cast<::enterprise_management::DeviceAttributeUpdateResponse_ResultType>(result_);
}
inline void DeviceAttributeUpdateResponse::set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value)
{
    assert(::enterprise_management::DeviceAttributeUpdateResponse_ResultType_IsValid(value));
    set_has_result();
    result_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateResponse.result)
}

// -------------------------------------------------------------------

// GcmIdUpdateRequest

// optional string gcm_id = 1;
inline bool GcmIdUpdateRequest::has_gcm_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GcmIdUpdateRequest::set_has_gcm_id()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void GcmIdUpdateRequest::clear_has_gcm_id()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void GcmIdUpdateRequest::clear_gcm_id()
{
    gcm_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_gcm_id();
}
inline const ::std::string& GcmIdUpdateRequest::gcm_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.GcmIdUpdateRequest.gcm_id)
    return gcm_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmIdUpdateRequest::set_gcm_id(const ::std::string& value)
{
    set_has_gcm_id();
    gcm_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline void GcmIdUpdateRequest::set_gcm_id(const char* value)
{
    set_has_gcm_id();
    gcm_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline void GcmIdUpdateRequest::set_gcm_id(const char* value, size_t size)
{
    set_has_gcm_id();
    gcm_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline ::std::string* GcmIdUpdateRequest::mutable_gcm_id()
{
    set_has_gcm_id();
    // @@protoc_insertion_point(field_mutable:enterprise_management.GcmIdUpdateRequest.gcm_id)
    return gcm_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmIdUpdateRequest::release_gcm_id()
{
    // @@protoc_insertion_point(field_release:enterprise_management.GcmIdUpdateRequest.gcm_id)
    clear_has_gcm_id();
    return gcm_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmIdUpdateRequest::set_allocated_gcm_id(::std::string* gcm_id)
{
    if (gcm_id != NULL) {
        set_has_gcm_id();
    } else {
        clear_has_gcm_id();
    }
    gcm_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gcm_id);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.GcmIdUpdateRequest.gcm_id)
}

// -------------------------------------------------------------------

// GcmIdUpdateResponse

// -------------------------------------------------------------------

// CheckAndroidManagementRequest

// -------------------------------------------------------------------

// CheckAndroidManagementResponse

// -------------------------------------------------------------------

// CertificateBasedDeviceRegisterRequest

// optional .enterprise_management.SignedData signed_request = 1;
inline bool CertificateBasedDeviceRegisterRequest::has_signed_request() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertificateBasedDeviceRegisterRequest::set_has_signed_request()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void CertificateBasedDeviceRegisterRequest::clear_has_signed_request()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void CertificateBasedDeviceRegisterRequest::clear_signed_request()
{
    if (signed_request_ != NULL)
        signed_request_->::enterprise_management::SignedData::Clear();
    clear_has_signed_request();
}
inline const ::enterprise_management::SignedData& CertificateBasedDeviceRegisterRequest::signed_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return signed_request_ != NULL ? *signed_request_ : *default_instance().signed_request_;
#else
    return signed_request_ != NULL ? *signed_request_ : *default_instance_->signed_request_;
#endif
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::mutable_signed_request()
{
    set_has_signed_request();
    if (signed_request_ == NULL) {
        signed_request_ = new ::enterprise_management::SignedData;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
    return signed_request_;
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::release_signed_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
    clear_has_signed_request();
    ::enterprise_management::SignedData* temp = signed_request_;
    signed_request_ = NULL;
    return temp;
}
inline void CertificateBasedDeviceRegisterRequest::set_allocated_signed_request(::enterprise_management::SignedData* signed_request)
{
    delete signed_request_;
    signed_request_ = signed_request;
    if (signed_request) {
        set_has_signed_request();
    } else {
        clear_has_signed_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
}

// -------------------------------------------------------------------

// CertificateBasedDeviceRegistrationData

// optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
inline bool CertificateBasedDeviceRegistrationData::has_certificate_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertificateBasedDeviceRegistrationData::set_has_certificate_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void CertificateBasedDeviceRegistrationData::clear_has_certificate_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void CertificateBasedDeviceRegistrationData::clear_certificate_type()
{
    certificate_type_ = 0;
    clear_has_certificate_type();
}
inline ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::certificate_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.certificate_type)
    return static_cast<::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType>(certificate_type_);
}
inline void CertificateBasedDeviceRegistrationData::set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value)
{
    assert(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType_IsValid(value));
    set_has_certificate_type();
    certificate_type_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.CertificateBasedDeviceRegistrationData.certificate_type)
}

// optional bytes device_certificate = 2;
inline bool CertificateBasedDeviceRegistrationData::has_device_certificate() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CertificateBasedDeviceRegistrationData::set_has_device_certificate()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void CertificateBasedDeviceRegistrationData::clear_has_device_certificate()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void CertificateBasedDeviceRegistrationData::clear_device_certificate()
{
    device_certificate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_device_certificate();
}
inline const ::std::string& CertificateBasedDeviceRegistrationData::device_certificate() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
    return device_certificate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CertificateBasedDeviceRegistrationData::set_device_certificate(const ::std::string& value)
{
    set_has_device_certificate();
    device_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline void CertificateBasedDeviceRegistrationData::set_device_certificate(const char* value)
{
    set_has_device_certificate();
    device_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline void CertificateBasedDeviceRegistrationData::set_device_certificate(const void* value, size_t size)
{
    set_has_device_certificate();
    device_certificate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline ::std::string* CertificateBasedDeviceRegistrationData::mutable_device_certificate()
{
    set_has_device_certificate();
    // @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
    return device_certificate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CertificateBasedDeviceRegistrationData::release_device_certificate()
{
    // @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
    clear_has_device_certificate();
    return device_certificate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_certificate(::std::string* device_certificate)
{
    if (device_certificate != NULL) {
        set_has_device_certificate();
    } else {
        clear_has_device_certificate();
    }
    device_certificate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_certificate);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}

// optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
inline bool CertificateBasedDeviceRegistrationData::has_device_register_request() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CertificateBasedDeviceRegistrationData::set_has_device_register_request()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void CertificateBasedDeviceRegistrationData::clear_has_device_register_request()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void CertificateBasedDeviceRegistrationData::clear_device_register_request()
{
    if (device_register_request_ != NULL)
        device_register_request_->::enterprise_management::DeviceRegisterRequest::Clear();
    clear_has_device_register_request();
}
inline const ::enterprise_management::DeviceRegisterRequest& CertificateBasedDeviceRegistrationData::device_register_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_register_request_ != NULL ? *device_register_request_ : *default_instance().device_register_request_;
#else
    return device_register_request_ != NULL ? *device_register_request_ : *default_instance_->device_register_request_;
#endif
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::mutable_device_register_request()
{
    set_has_device_register_request();
    if (device_register_request_ == NULL) {
        device_register_request_ = new ::enterprise_management::DeviceRegisterRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
    return device_register_request_;
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::release_device_register_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
    clear_has_device_register_request();
    ::enterprise_management::DeviceRegisterRequest* temp = device_register_request_;
    device_register_request_ = NULL;
    return temp;
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_register_request(::enterprise_management::DeviceRegisterRequest* device_register_request)
{
    delete device_register_request_;
    device_register_request_ = device_register_request;
    if (device_register_request) {
        set_has_device_register_request();
    } else {
        clear_has_device_register_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
}

// -------------------------------------------------------------------

// DeviceManagementRequest

// optional .enterprise_management.DeviceRegisterRequest register_request = 1;
inline bool DeviceManagementRequest::has_register_request() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceManagementRequest::set_has_register_request()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceManagementRequest::clear_has_register_request()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceManagementRequest::clear_register_request()
{
    if (register_request_ != NULL)
        register_request_->::enterprise_management::DeviceRegisterRequest::Clear();
    clear_has_register_request();
}
inline const ::enterprise_management::DeviceRegisterRequest& DeviceManagementRequest::register_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.register_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return register_request_ != NULL ? *register_request_ : *default_instance().register_request_;
#else
    return register_request_ != NULL ? *register_request_ : *default_instance_->register_request_;
#endif
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::mutable_register_request()
{
    set_has_register_request();
    if (register_request_ == NULL) {
        register_request_ = new ::enterprise_management::DeviceRegisterRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.register_request)
    return register_request_;
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::release_register_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.register_request)
    clear_has_register_request();
    ::enterprise_management::DeviceRegisterRequest* temp = register_request_;
    register_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_register_request(::enterprise_management::DeviceRegisterRequest* register_request)
{
    delete register_request_;
    register_request_ = register_request;
    if (register_request) {
        set_has_register_request();
    } else {
        clear_has_register_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.register_request)
}

// optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
inline bool DeviceManagementRequest::has_unregister_request() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceManagementRequest::set_has_unregister_request()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceManagementRequest::clear_has_unregister_request()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceManagementRequest::clear_unregister_request()
{
    if (unregister_request_ != NULL)
        unregister_request_->::enterprise_management::DeviceUnregisterRequest::Clear();
    clear_has_unregister_request();
}
inline const ::enterprise_management::DeviceUnregisterRequest& DeviceManagementRequest::unregister_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.unregister_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return unregister_request_ != NULL ? *unregister_request_ : *default_instance().unregister_request_;
#else
    return unregister_request_ != NULL ? *unregister_request_ : *default_instance_->unregister_request_;
#endif
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::mutable_unregister_request()
{
    set_has_unregister_request();
    if (unregister_request_ == NULL) {
        unregister_request_ = new ::enterprise_management::DeviceUnregisterRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.unregister_request)
    return unregister_request_;
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::release_unregister_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.unregister_request)
    clear_has_unregister_request();
    ::enterprise_management::DeviceUnregisterRequest* temp = unregister_request_;
    unregister_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_unregister_request(::enterprise_management::DeviceUnregisterRequest* unregister_request)
{
    delete unregister_request_;
    unregister_request_ = unregister_request;
    if (unregister_request) {
        set_has_unregister_request();
    } else {
        clear_has_unregister_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.unregister_request)
}

// optional .enterprise_management.DevicePolicyRequest policy_request = 3;
inline bool DeviceManagementRequest::has_policy_request() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceManagementRequest::set_has_policy_request()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void DeviceManagementRequest::clear_has_policy_request()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceManagementRequest::clear_policy_request()
{
    if (policy_request_ != NULL)
        policy_request_->::enterprise_management::DevicePolicyRequest::Clear();
    clear_has_policy_request();
}
inline const ::enterprise_management::DevicePolicyRequest& DeviceManagementRequest::policy_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.policy_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return policy_request_ != NULL ? *policy_request_ : *default_instance().policy_request_;
#else
    return policy_request_ != NULL ? *policy_request_ : *default_instance_->policy_request_;
#endif
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::mutable_policy_request()
{
    set_has_policy_request();
    if (policy_request_ == NULL) {
        policy_request_ = new ::enterprise_management::DevicePolicyRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.policy_request)
    return policy_request_;
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::release_policy_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.policy_request)
    clear_has_policy_request();
    ::enterprise_management::DevicePolicyRequest* temp = policy_request_;
    policy_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_policy_request(::enterprise_management::DevicePolicyRequest* policy_request)
{
    delete policy_request_;
    policy_request_ = policy_request;
    if (policy_request) {
        set_has_policy_request();
    } else {
        clear_has_policy_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.policy_request)
}

// optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
inline bool DeviceManagementRequest::has_device_status_report_request() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceManagementRequest::set_has_device_status_report_request()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void DeviceManagementRequest::clear_has_device_status_report_request()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceManagementRequest::clear_device_status_report_request()
{
    if (device_status_report_request_ != NULL)
        device_status_report_request_->::enterprise_management::DeviceStatusReportRequest::Clear();
    clear_has_device_status_report_request();
}
inline const ::enterprise_management::DeviceStatusReportRequest& DeviceManagementRequest::device_status_report_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_status_report_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_status_report_request_ != NULL ? *device_status_report_request_ : *default_instance().device_status_report_request_;
#else
    return device_status_report_request_ != NULL ? *device_status_report_request_ : *default_instance_->device_status_report_request_;
#endif
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::mutable_device_status_report_request()
{
    set_has_device_status_report_request();
    if (device_status_report_request_ == NULL) {
        device_status_report_request_ = new ::enterprise_management::DeviceStatusReportRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_status_report_request)
    return device_status_report_request_;
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::release_device_status_report_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_status_report_request)
    clear_has_device_status_report_request();
    ::enterprise_management::DeviceStatusReportRequest* temp = device_status_report_request_;
    device_status_report_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_device_status_report_request(::enterprise_management::DeviceStatusReportRequest* device_status_report_request)
{
    delete device_status_report_request_;
    device_status_report_request_ = device_status_report_request;
    if (device_status_report_request) {
        set_has_device_status_report_request();
    } else {
        clear_has_device_status_report_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_status_report_request)
}

// optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
inline bool DeviceManagementRequest::has_session_status_report_request() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceManagementRequest::set_has_session_status_report_request()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void DeviceManagementRequest::clear_has_session_status_report_request()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceManagementRequest::clear_session_status_report_request()
{
    if (session_status_report_request_ != NULL)
        session_status_report_request_->::enterprise_management::SessionStatusReportRequest::Clear();
    clear_has_session_status_report_request();
}
inline const ::enterprise_management::SessionStatusReportRequest& DeviceManagementRequest::session_status_report_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.session_status_report_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return session_status_report_request_ != NULL ? *session_status_report_request_ : *default_instance().session_status_report_request_;
#else
    return session_status_report_request_ != NULL ? *session_status_report_request_ : *default_instance_->session_status_report_request_;
#endif
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::mutable_session_status_report_request()
{
    set_has_session_status_report_request();
    if (session_status_report_request_ == NULL) {
        session_status_report_request_ = new ::enterprise_management::SessionStatusReportRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.session_status_report_request)
    return session_status_report_request_;
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::release_session_status_report_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.session_status_report_request)
    clear_has_session_status_report_request();
    ::enterprise_management::SessionStatusReportRequest* temp = session_status_report_request_;
    session_status_report_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_session_status_report_request(::enterprise_management::SessionStatusReportRequest* session_status_report_request)
{
    delete session_status_report_request_;
    session_status_report_request_ = session_status_report_request;
    if (session_status_report_request) {
        set_has_session_status_report_request();
    } else {
        clear_has_session_status_report_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.session_status_report_request)
}

// optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
inline bool DeviceManagementRequest::has_auto_enrollment_request() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceManagementRequest::set_has_auto_enrollment_request()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void DeviceManagementRequest::clear_has_auto_enrollment_request()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceManagementRequest::clear_auto_enrollment_request()
{
    if (auto_enrollment_request_ != NULL)
        auto_enrollment_request_->::enterprise_management::DeviceAutoEnrollmentRequest::Clear();
    clear_has_auto_enrollment_request();
}
inline const ::enterprise_management::DeviceAutoEnrollmentRequest& DeviceManagementRequest::auto_enrollment_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return auto_enrollment_request_ != NULL ? *auto_enrollment_request_ : *default_instance().auto_enrollment_request_;
#else
    return auto_enrollment_request_ != NULL ? *auto_enrollment_request_ : *default_instance_->auto_enrollment_request_;
#endif
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::mutable_auto_enrollment_request()
{
    set_has_auto_enrollment_request();
    if (auto_enrollment_request_ == NULL) {
        auto_enrollment_request_ = new ::enterprise_management::DeviceAutoEnrollmentRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
    return auto_enrollment_request_;
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::release_auto_enrollment_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
    clear_has_auto_enrollment_request();
    ::enterprise_management::DeviceAutoEnrollmentRequest* temp = auto_enrollment_request_;
    auto_enrollment_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_auto_enrollment_request(::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request)
{
    delete auto_enrollment_request_;
    auto_enrollment_request_ = auto_enrollment_request;
    if (auto_enrollment_request) {
        set_has_auto_enrollment_request();
    } else {
        clear_has_auto_enrollment_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
}

// optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
inline bool DeviceManagementRequest::has_cert_upload_request() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceManagementRequest::set_has_cert_upload_request()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void DeviceManagementRequest::clear_has_cert_upload_request()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceManagementRequest::clear_cert_upload_request()
{
    if (cert_upload_request_ != NULL)
        cert_upload_request_->::enterprise_management::DeviceCertUploadRequest::Clear();
    clear_has_cert_upload_request();
}
inline const ::enterprise_management::DeviceCertUploadRequest& DeviceManagementRequest::cert_upload_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.cert_upload_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return cert_upload_request_ != NULL ? *cert_upload_request_ : *default_instance().cert_upload_request_;
#else
    return cert_upload_request_ != NULL ? *cert_upload_request_ : *default_instance_->cert_upload_request_;
#endif
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::mutable_cert_upload_request()
{
    set_has_cert_upload_request();
    if (cert_upload_request_ == NULL) {
        cert_upload_request_ = new ::enterprise_management::DeviceCertUploadRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.cert_upload_request)
    return cert_upload_request_;
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::release_cert_upload_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.cert_upload_request)
    clear_has_cert_upload_request();
    ::enterprise_management::DeviceCertUploadRequest* temp = cert_upload_request_;
    cert_upload_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_cert_upload_request(::enterprise_management::DeviceCertUploadRequest* cert_upload_request)
{
    delete cert_upload_request_;
    cert_upload_request_ = cert_upload_request;
    if (cert_upload_request) {
        set_has_cert_upload_request();
    } else {
        clear_has_cert_upload_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.cert_upload_request)
}

// optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
inline bool DeviceManagementRequest::has_service_api_access_request() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceManagementRequest::set_has_service_api_access_request()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void DeviceManagementRequest::clear_has_service_api_access_request()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceManagementRequest::clear_service_api_access_request()
{
    if (service_api_access_request_ != NULL)
        service_api_access_request_->::enterprise_management::DeviceServiceApiAccessRequest::Clear();
    clear_has_service_api_access_request();
}
inline const ::enterprise_management::DeviceServiceApiAccessRequest& DeviceManagementRequest::service_api_access_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.service_api_access_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return service_api_access_request_ != NULL ? *service_api_access_request_ : *default_instance().service_api_access_request_;
#else
    return service_api_access_request_ != NULL ? *service_api_access_request_ : *default_instance_->service_api_access_request_;
#endif
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::mutable_service_api_access_request()
{
    set_has_service_api_access_request();
    if (service_api_access_request_ == NULL) {
        service_api_access_request_ = new ::enterprise_management::DeviceServiceApiAccessRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.service_api_access_request)
    return service_api_access_request_;
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::release_service_api_access_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.service_api_access_request)
    clear_has_service_api_access_request();
    ::enterprise_management::DeviceServiceApiAccessRequest* temp = service_api_access_request_;
    service_api_access_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_service_api_access_request(::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request)
{
    delete service_api_access_request_;
    service_api_access_request_ = service_api_access_request;
    if (service_api_access_request) {
        set_has_service_api_access_request();
    } else {
        clear_has_service_api_access_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.service_api_access_request)
}

// optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
inline bool DeviceManagementRequest::has_device_state_retrieval_request() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceManagementRequest::set_has_device_state_retrieval_request()
{
    _has_bits_[0] |= 0x00000100u;
}
inline void DeviceManagementRequest::clear_has_device_state_retrieval_request()
{
    _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceManagementRequest::clear_device_state_retrieval_request()
{
    if (device_state_retrieval_request_ != NULL)
        device_state_retrieval_request_->::enterprise_management::DeviceStateRetrievalRequest::Clear();
    clear_has_device_state_retrieval_request();
}
inline const ::enterprise_management::DeviceStateRetrievalRequest& DeviceManagementRequest::device_state_retrieval_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_state_retrieval_request_ != NULL ? *device_state_retrieval_request_ : *default_instance().device_state_retrieval_request_;
#else
    return device_state_retrieval_request_ != NULL ? *device_state_retrieval_request_ : *default_instance_->device_state_retrieval_request_;
#endif
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::mutable_device_state_retrieval_request()
{
    set_has_device_state_retrieval_request();
    if (device_state_retrieval_request_ == NULL) {
        device_state_retrieval_request_ = new ::enterprise_management::DeviceStateRetrievalRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
    return device_state_retrieval_request_;
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::release_device_state_retrieval_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
    clear_has_device_state_retrieval_request();
    ::enterprise_management::DeviceStateRetrievalRequest* temp = device_state_retrieval_request_;
    device_state_retrieval_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_device_state_retrieval_request(::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request)
{
    delete device_state_retrieval_request_;
    device_state_retrieval_request_ = device_state_retrieval_request;
    if (device_state_retrieval_request) {
        set_has_device_state_retrieval_request();
    } else {
        clear_has_device_state_retrieval_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
}

// optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
inline bool DeviceManagementRequest::has_device_state_key_update_request() const
{
    return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceManagementRequest::set_has_device_state_key_update_request()
{
    _has_bits_[0] |= 0x00000200u;
}
inline void DeviceManagementRequest::clear_has_device_state_key_update_request()
{
    _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceManagementRequest::clear_device_state_key_update_request()
{
    if (device_state_key_update_request_ != NULL)
        device_state_key_update_request_->::enterprise_management::DeviceStateKeyUpdateRequest::Clear();
    clear_has_device_state_key_update_request();
}
inline const ::enterprise_management::DeviceStateKeyUpdateRequest& DeviceManagementRequest::device_state_key_update_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_state_key_update_request_ != NULL ? *device_state_key_update_request_ : *default_instance().device_state_key_update_request_;
#else
    return device_state_key_update_request_ != NULL ? *device_state_key_update_request_ : *default_instance_->device_state_key_update_request_;
#endif
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::mutable_device_state_key_update_request()
{
    set_has_device_state_key_update_request();
    if (device_state_key_update_request_ == NULL) {
        device_state_key_update_request_ = new ::enterprise_management::DeviceStateKeyUpdateRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
    return device_state_key_update_request_;
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::release_device_state_key_update_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
    clear_has_device_state_key_update_request();
    ::enterprise_management::DeviceStateKeyUpdateRequest* temp = device_state_key_update_request_;
    device_state_key_update_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_device_state_key_update_request(::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request)
{
    delete device_state_key_update_request_;
    device_state_key_update_request_ = device_state_key_update_request;
    if (device_state_key_update_request) {
        set_has_device_state_key_update_request();
    } else {
        clear_has_device_state_key_update_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
}

// optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
inline bool DeviceManagementRequest::has_device_pairing_request() const
{
    return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceManagementRequest::set_has_device_pairing_request()
{
    _has_bits_[0] |= 0x00000400u;
}
inline void DeviceManagementRequest::clear_has_device_pairing_request()
{
    _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceManagementRequest::clear_device_pairing_request()
{
    if (device_pairing_request_ != NULL)
        device_pairing_request_->::enterprise_management::DevicePairingRequest::Clear();
    clear_has_device_pairing_request();
}
inline const ::enterprise_management::DevicePairingRequest& DeviceManagementRequest::device_pairing_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_pairing_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_pairing_request_ != NULL ? *device_pairing_request_ : *default_instance().device_pairing_request_;
#else
    return device_pairing_request_ != NULL ? *device_pairing_request_ : *default_instance_->device_pairing_request_;
#endif
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::mutable_device_pairing_request()
{
    set_has_device_pairing_request();
    if (device_pairing_request_ == NULL) {
        device_pairing_request_ = new ::enterprise_management::DevicePairingRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_pairing_request)
    return device_pairing_request_;
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::release_device_pairing_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_pairing_request)
    clear_has_device_pairing_request();
    ::enterprise_management::DevicePairingRequest* temp = device_pairing_request_;
    device_pairing_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_device_pairing_request(::enterprise_management::DevicePairingRequest* device_pairing_request)
{
    delete device_pairing_request_;
    device_pairing_request_ = device_pairing_request;
    if (device_pairing_request) {
        set_has_device_pairing_request();
    } else {
        clear_has_device_pairing_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_pairing_request)
}

// optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
inline bool DeviceManagementRequest::has_check_device_pairing_request() const
{
    return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceManagementRequest::set_has_check_device_pairing_request()
{
    _has_bits_[0] |= 0x00000800u;
}
inline void DeviceManagementRequest::clear_has_check_device_pairing_request()
{
    _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceManagementRequest::clear_check_device_pairing_request()
{
    if (check_device_pairing_request_ != NULL)
        check_device_pairing_request_->::enterprise_management::CheckDevicePairingRequest::Clear();
    clear_has_check_device_pairing_request();
}
inline const ::enterprise_management::CheckDevicePairingRequest& DeviceManagementRequest::check_device_pairing_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return check_device_pairing_request_ != NULL ? *check_device_pairing_request_ : *default_instance().check_device_pairing_request_;
#else
    return check_device_pairing_request_ != NULL ? *check_device_pairing_request_ : *default_instance_->check_device_pairing_request_;
#endif
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::mutable_check_device_pairing_request()
{
    set_has_check_device_pairing_request();
    if (check_device_pairing_request_ == NULL) {
        check_device_pairing_request_ = new ::enterprise_management::CheckDevicePairingRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
    return check_device_pairing_request_;
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::release_check_device_pairing_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
    clear_has_check_device_pairing_request();
    ::enterprise_management::CheckDevicePairingRequest* temp = check_device_pairing_request_;
    check_device_pairing_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_check_device_pairing_request(::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request)
{
    delete check_device_pairing_request_;
    check_device_pairing_request_ = check_device_pairing_request;
    if (check_device_pairing_request) {
        set_has_check_device_pairing_request();
    } else {
        clear_has_check_device_pairing_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
}

// optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
inline bool DeviceManagementRequest::has_remote_command_request() const
{
    return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceManagementRequest::set_has_remote_command_request()
{
    _has_bits_[0] |= 0x00001000u;
}
inline void DeviceManagementRequest::clear_has_remote_command_request()
{
    _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceManagementRequest::clear_remote_command_request()
{
    if (remote_command_request_ != NULL)
        remote_command_request_->::enterprise_management::DeviceRemoteCommandRequest::Clear();
    clear_has_remote_command_request();
}
inline const ::enterprise_management::DeviceRemoteCommandRequest& DeviceManagementRequest::remote_command_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.remote_command_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return remote_command_request_ != NULL ? *remote_command_request_ : *default_instance().remote_command_request_;
#else
    return remote_command_request_ != NULL ? *remote_command_request_ : *default_instance_->remote_command_request_;
#endif
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::mutable_remote_command_request()
{
    set_has_remote_command_request();
    if (remote_command_request_ == NULL) {
        remote_command_request_ = new ::enterprise_management::DeviceRemoteCommandRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.remote_command_request)
    return remote_command_request_;
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::release_remote_command_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.remote_command_request)
    clear_has_remote_command_request();
    ::enterprise_management::DeviceRemoteCommandRequest* temp = remote_command_request_;
    remote_command_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_remote_command_request(::enterprise_management::DeviceRemoteCommandRequest* remote_command_request)
{
    delete remote_command_request_;
    remote_command_request_ = remote_command_request;
    if (remote_command_request) {
        set_has_remote_command_request();
    } else {
        clear_has_remote_command_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.remote_command_request)
}

// optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
inline bool DeviceManagementRequest::has_device_attribute_update_permission_request() const
{
    return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceManagementRequest::set_has_device_attribute_update_permission_request()
{
    _has_bits_[0] |= 0x00002000u;
}
inline void DeviceManagementRequest::clear_has_device_attribute_update_permission_request()
{
    _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceManagementRequest::clear_device_attribute_update_permission_request()
{
    if (device_attribute_update_permission_request_ != NULL)
        device_attribute_update_permission_request_->::enterprise_management::DeviceAttributeUpdatePermissionRequest::Clear();
    clear_has_device_attribute_update_permission_request();
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& DeviceManagementRequest::device_attribute_update_permission_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_attribute_update_permission_request_ != NULL ? *device_attribute_update_permission_request_ : *default_instance().device_attribute_update_permission_request_;
#else
    return device_attribute_update_permission_request_ != NULL ? *device_attribute_update_permission_request_ : *default_instance_->device_attribute_update_permission_request_;
#endif
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::mutable_device_attribute_update_permission_request()
{
    set_has_device_attribute_update_permission_request();
    if (device_attribute_update_permission_request_ == NULL) {
        device_attribute_update_permission_request_ = new ::enterprise_management::DeviceAttributeUpdatePermissionRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
    return device_attribute_update_permission_request_;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::release_device_attribute_update_permission_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
    clear_has_device_attribute_update_permission_request();
    ::enterprise_management::DeviceAttributeUpdatePermissionRequest* temp = device_attribute_update_permission_request_;
    device_attribute_update_permission_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_device_attribute_update_permission_request(::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request)
{
    delete device_attribute_update_permission_request_;
    device_attribute_update_permission_request_ = device_attribute_update_permission_request;
    if (device_attribute_update_permission_request) {
        set_has_device_attribute_update_permission_request();
    } else {
        clear_has_device_attribute_update_permission_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
}

// optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
inline bool DeviceManagementRequest::has_device_attribute_update_request() const
{
    return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceManagementRequest::set_has_device_attribute_update_request()
{
    _has_bits_[0] |= 0x00004000u;
}
inline void DeviceManagementRequest::clear_has_device_attribute_update_request()
{
    _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceManagementRequest::clear_device_attribute_update_request()
{
    if (device_attribute_update_request_ != NULL)
        device_attribute_update_request_->::enterprise_management::DeviceAttributeUpdateRequest::Clear();
    clear_has_device_attribute_update_request();
}
inline const ::enterprise_management::DeviceAttributeUpdateRequest& DeviceManagementRequest::device_attribute_update_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_attribute_update_request_ != NULL ? *device_attribute_update_request_ : *default_instance().device_attribute_update_request_;
#else
    return device_attribute_update_request_ != NULL ? *device_attribute_update_request_ : *default_instance_->device_attribute_update_request_;
#endif
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::mutable_device_attribute_update_request()
{
    set_has_device_attribute_update_request();
    if (device_attribute_update_request_ == NULL) {
        device_attribute_update_request_ = new ::enterprise_management::DeviceAttributeUpdateRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
    return device_attribute_update_request_;
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::release_device_attribute_update_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
    clear_has_device_attribute_update_request();
    ::enterprise_management::DeviceAttributeUpdateRequest* temp = device_attribute_update_request_;
    device_attribute_update_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_device_attribute_update_request(::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request)
{
    delete device_attribute_update_request_;
    device_attribute_update_request_ = device_attribute_update_request;
    if (device_attribute_update_request) {
        set_has_device_attribute_update_request();
    } else {
        clear_has_device_attribute_update_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
}

// optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
inline bool DeviceManagementRequest::has_gcm_id_update_request() const
{
    return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceManagementRequest::set_has_gcm_id_update_request()
{
    _has_bits_[0] |= 0x00008000u;
}
inline void DeviceManagementRequest::clear_has_gcm_id_update_request()
{
    _has_bits_[0] &= ~0x00008000u;
}
inline void DeviceManagementRequest::clear_gcm_id_update_request()
{
    if (gcm_id_update_request_ != NULL)
        gcm_id_update_request_->::enterprise_management::GcmIdUpdateRequest::Clear();
    clear_has_gcm_id_update_request();
}
inline const ::enterprise_management::GcmIdUpdateRequest& DeviceManagementRequest::gcm_id_update_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return gcm_id_update_request_ != NULL ? *gcm_id_update_request_ : *default_instance().gcm_id_update_request_;
#else
    return gcm_id_update_request_ != NULL ? *gcm_id_update_request_ : *default_instance_->gcm_id_update_request_;
#endif
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::mutable_gcm_id_update_request()
{
    set_has_gcm_id_update_request();
    if (gcm_id_update_request_ == NULL) {
        gcm_id_update_request_ = new ::enterprise_management::GcmIdUpdateRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
    return gcm_id_update_request_;
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::release_gcm_id_update_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
    clear_has_gcm_id_update_request();
    ::enterprise_management::GcmIdUpdateRequest* temp = gcm_id_update_request_;
    gcm_id_update_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_gcm_id_update_request(::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request)
{
    delete gcm_id_update_request_;
    gcm_id_update_request_ = gcm_id_update_request;
    if (gcm_id_update_request) {
        set_has_gcm_id_update_request();
    } else {
        clear_has_gcm_id_update_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
}

// optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
inline bool DeviceManagementRequest::has_check_android_management_request() const
{
    return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceManagementRequest::set_has_check_android_management_request()
{
    _has_bits_[0] |= 0x00010000u;
}
inline void DeviceManagementRequest::clear_has_check_android_management_request()
{
    _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceManagementRequest::clear_check_android_management_request()
{
    if (check_android_management_request_ != NULL)
        check_android_management_request_->::enterprise_management::CheckAndroidManagementRequest::Clear();
    clear_has_check_android_management_request();
}
inline const ::enterprise_management::CheckAndroidManagementRequest& DeviceManagementRequest::check_android_management_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_android_management_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return check_android_management_request_ != NULL ? *check_android_management_request_ : *default_instance().check_android_management_request_;
#else
    return check_android_management_request_ != NULL ? *check_android_management_request_ : *default_instance_->check_android_management_request_;
#endif
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::mutable_check_android_management_request()
{
    set_has_check_android_management_request();
    if (check_android_management_request_ == NULL) {
        check_android_management_request_ = new ::enterprise_management::CheckAndroidManagementRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_android_management_request)
    return check_android_management_request_;
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::release_check_android_management_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_android_management_request)
    clear_has_check_android_management_request();
    ::enterprise_management::CheckAndroidManagementRequest* temp = check_android_management_request_;
    check_android_management_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_check_android_management_request(::enterprise_management::CheckAndroidManagementRequest* check_android_management_request)
{
    delete check_android_management_request_;
    check_android_management_request_ = check_android_management_request;
    if (check_android_management_request) {
        set_has_check_android_management_request();
    } else {
        clear_has_check_android_management_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_android_management_request)
}

// optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
inline bool DeviceManagementRequest::has_certificate_based_register_request() const
{
    return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceManagementRequest::set_has_certificate_based_register_request()
{
    _has_bits_[0] |= 0x00020000u;
}
inline void DeviceManagementRequest::clear_has_certificate_based_register_request()
{
    _has_bits_[0] &= ~0x00020000u;
}
inline void DeviceManagementRequest::clear_certificate_based_register_request()
{
    if (certificate_based_register_request_ != NULL)
        certificate_based_register_request_->::enterprise_management::CertificateBasedDeviceRegisterRequest::Clear();
    clear_has_certificate_based_register_request();
}
inline const ::enterprise_management::CertificateBasedDeviceRegisterRequest& DeviceManagementRequest::certificate_based_register_request() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return certificate_based_register_request_ != NULL ? *certificate_based_register_request_ : *default_instance().certificate_based_register_request_;
#else
    return certificate_based_register_request_ != NULL ? *certificate_based_register_request_ : *default_instance_->certificate_based_register_request_;
#endif
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::mutable_certificate_based_register_request()
{
    set_has_certificate_based_register_request();
    if (certificate_based_register_request_ == NULL) {
        certificate_based_register_request_ = new ::enterprise_management::CertificateBasedDeviceRegisterRequest;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
    return certificate_based_register_request_;
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::release_certificate_based_register_request()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
    clear_has_certificate_based_register_request();
    ::enterprise_management::CertificateBasedDeviceRegisterRequest* temp = certificate_based_register_request_;
    certificate_based_register_request_ = NULL;
    return temp;
}
inline void DeviceManagementRequest::set_allocated_certificate_based_register_request(::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request)
{
    delete certificate_based_register_request_;
    certificate_based_register_request_ = certificate_based_register_request;
    if (certificate_based_register_request) {
        set_has_certificate_based_register_request();
    } else {
        clear_has_certificate_based_register_request();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
}

// -------------------------------------------------------------------

// DeviceManagementResponse

// optional .enterprise_management.DeviceManagementResponse.ErrorCode error = 1 [default = SUCCESS];
inline bool DeviceManagementResponse::has_error() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceManagementResponse::set_has_error()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void DeviceManagementResponse::clear_has_error()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceManagementResponse::clear_error()
{
    error_ = 0;
    clear_has_error();
}
inline ::enterprise_management::DeviceManagementResponse_ErrorCode DeviceManagementResponse::error() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.error)
    return static_cast<::enterprise_management::DeviceManagementResponse_ErrorCode>(error_);
}
inline void DeviceManagementResponse::set_error(::enterprise_management::DeviceManagementResponse_ErrorCode value)
{
    assert(::enterprise_management::DeviceManagementResponse_ErrorCode_IsValid(value));
    set_has_error();
    error_ = value;
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceManagementResponse.error)
}

// optional string error_message = 2;
inline bool DeviceManagementResponse::has_error_message() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceManagementResponse::set_has_error_message()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void DeviceManagementResponse::clear_has_error_message()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceManagementResponse::clear_error_message()
{
    error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_error_message();
}
inline const ::std::string& DeviceManagementResponse::error_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.error_message)
    return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceManagementResponse::set_error_message(const ::std::string& value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:enterprise_management.DeviceManagementResponse.error_message)
}
inline void DeviceManagementResponse::set_error_message(const char* value)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceManagementResponse.error_message)
}
inline void DeviceManagementResponse::set_error_message(const char* value, size_t size)
{
    set_has_error_message();
    error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceManagementResponse.error_message)
}
inline ::std::string* DeviceManagementResponse::mutable_error_message()
{
    set_has_error_message();
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.error_message)
    return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceManagementResponse::release_error_message()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.error_message)
    clear_has_error_message();
    return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceManagementResponse::set_allocated_error_message(::std::string* error_message)
{
    if (error_message != NULL) {
        set_has_error_message();
    } else {
        clear_has_error_message();
    }
    error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.error_message)
}

// optional .enterprise_management.DeviceRegisterResponse register_response = 3;
inline bool DeviceManagementResponse::has_register_response() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceManagementResponse::set_has_register_response()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void DeviceManagementResponse::clear_has_register_response()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceManagementResponse::clear_register_response()
{
    if (register_response_ != NULL)
        register_response_->::enterprise_management::DeviceRegisterResponse::Clear();
    clear_has_register_response();
}
inline const ::enterprise_management::DeviceRegisterResponse& DeviceManagementResponse::register_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.register_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return register_response_ != NULL ? *register_response_ : *default_instance().register_response_;
#else
    return register_response_ != NULL ? *register_response_ : *default_instance_->register_response_;
#endif
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::mutable_register_response()
{
    set_has_register_response();
    if (register_response_ == NULL) {
        register_response_ = new ::enterprise_management::DeviceRegisterResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.register_response)
    return register_response_;
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::release_register_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.register_response)
    clear_has_register_response();
    ::enterprise_management::DeviceRegisterResponse* temp = register_response_;
    register_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_register_response(::enterprise_management::DeviceRegisterResponse* register_response)
{
    delete register_response_;
    register_response_ = register_response;
    if (register_response) {
        set_has_register_response();
    } else {
        clear_has_register_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.register_response)
}

// optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
inline bool DeviceManagementResponse::has_unregister_response() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceManagementResponse::set_has_unregister_response()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void DeviceManagementResponse::clear_has_unregister_response()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceManagementResponse::clear_unregister_response()
{
    if (unregister_response_ != NULL)
        unregister_response_->::enterprise_management::DeviceUnregisterResponse::Clear();
    clear_has_unregister_response();
}
inline const ::enterprise_management::DeviceUnregisterResponse& DeviceManagementResponse::unregister_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.unregister_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return unregister_response_ != NULL ? *unregister_response_ : *default_instance().unregister_response_;
#else
    return unregister_response_ != NULL ? *unregister_response_ : *default_instance_->unregister_response_;
#endif
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::mutable_unregister_response()
{
    set_has_unregister_response();
    if (unregister_response_ == NULL) {
        unregister_response_ = new ::enterprise_management::DeviceUnregisterResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.unregister_response)
    return unregister_response_;
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::release_unregister_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.unregister_response)
    clear_has_unregister_response();
    ::enterprise_management::DeviceUnregisterResponse* temp = unregister_response_;
    unregister_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_unregister_response(::enterprise_management::DeviceUnregisterResponse* unregister_response)
{
    delete unregister_response_;
    unregister_response_ = unregister_response;
    if (unregister_response) {
        set_has_unregister_response();
    } else {
        clear_has_unregister_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.unregister_response)
}

// optional .enterprise_management.DevicePolicyResponse policy_response = 5;
inline bool DeviceManagementResponse::has_policy_response() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceManagementResponse::set_has_policy_response()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void DeviceManagementResponse::clear_has_policy_response()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceManagementResponse::clear_policy_response()
{
    if (policy_response_ != NULL)
        policy_response_->::enterprise_management::DevicePolicyResponse::Clear();
    clear_has_policy_response();
}
inline const ::enterprise_management::DevicePolicyResponse& DeviceManagementResponse::policy_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.policy_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return policy_response_ != NULL ? *policy_response_ : *default_instance().policy_response_;
#else
    return policy_response_ != NULL ? *policy_response_ : *default_instance_->policy_response_;
#endif
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::mutable_policy_response()
{
    set_has_policy_response();
    if (policy_response_ == NULL) {
        policy_response_ = new ::enterprise_management::DevicePolicyResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.policy_response)
    return policy_response_;
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::release_policy_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.policy_response)
    clear_has_policy_response();
    ::enterprise_management::DevicePolicyResponse* temp = policy_response_;
    policy_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_policy_response(::enterprise_management::DevicePolicyResponse* policy_response)
{
    delete policy_response_;
    policy_response_ = policy_response;
    if (policy_response) {
        set_has_policy_response();
    } else {
        clear_has_policy_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.policy_response)
}

// optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
inline bool DeviceManagementResponse::has_device_status_report_response() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceManagementResponse::set_has_device_status_report_response()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void DeviceManagementResponse::clear_has_device_status_report_response()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceManagementResponse::clear_device_status_report_response()
{
    if (device_status_report_response_ != NULL)
        device_status_report_response_->::enterprise_management::DeviceStatusReportResponse::Clear();
    clear_has_device_status_report_response();
}
inline const ::enterprise_management::DeviceStatusReportResponse& DeviceManagementResponse::device_status_report_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_status_report_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_status_report_response_ != NULL ? *device_status_report_response_ : *default_instance().device_status_report_response_;
#else
    return device_status_report_response_ != NULL ? *device_status_report_response_ : *default_instance_->device_status_report_response_;
#endif
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::mutable_device_status_report_response()
{
    set_has_device_status_report_response();
    if (device_status_report_response_ == NULL) {
        device_status_report_response_ = new ::enterprise_management::DeviceStatusReportResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_status_report_response)
    return device_status_report_response_;
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::release_device_status_report_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_status_report_response)
    clear_has_device_status_report_response();
    ::enterprise_management::DeviceStatusReportResponse* temp = device_status_report_response_;
    device_status_report_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_device_status_report_response(::enterprise_management::DeviceStatusReportResponse* device_status_report_response)
{
    delete device_status_report_response_;
    device_status_report_response_ = device_status_report_response;
    if (device_status_report_response) {
        set_has_device_status_report_response();
    } else {
        clear_has_device_status_report_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_status_report_response)
}

// optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
inline bool DeviceManagementResponse::has_session_status_report_response() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceManagementResponse::set_has_session_status_report_response()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void DeviceManagementResponse::clear_has_session_status_report_response()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceManagementResponse::clear_session_status_report_response()
{
    if (session_status_report_response_ != NULL)
        session_status_report_response_->::enterprise_management::SessionStatusReportResponse::Clear();
    clear_has_session_status_report_response();
}
inline const ::enterprise_management::SessionStatusReportResponse& DeviceManagementResponse::session_status_report_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.session_status_report_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return session_status_report_response_ != NULL ? *session_status_report_response_ : *default_instance().session_status_report_response_;
#else
    return session_status_report_response_ != NULL ? *session_status_report_response_ : *default_instance_->session_status_report_response_;
#endif
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::mutable_session_status_report_response()
{
    set_has_session_status_report_response();
    if (session_status_report_response_ == NULL) {
        session_status_report_response_ = new ::enterprise_management::SessionStatusReportResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.session_status_report_response)
    return session_status_report_response_;
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::release_session_status_report_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.session_status_report_response)
    clear_has_session_status_report_response();
    ::enterprise_management::SessionStatusReportResponse* temp = session_status_report_response_;
    session_status_report_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_session_status_report_response(::enterprise_management::SessionStatusReportResponse* session_status_report_response)
{
    delete session_status_report_response_;
    session_status_report_response_ = session_status_report_response;
    if (session_status_report_response) {
        set_has_session_status_report_response();
    } else {
        clear_has_session_status_report_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.session_status_report_response)
}

// optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
inline bool DeviceManagementResponse::has_auto_enrollment_response() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceManagementResponse::set_has_auto_enrollment_response()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void DeviceManagementResponse::clear_has_auto_enrollment_response()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceManagementResponse::clear_auto_enrollment_response()
{
    if (auto_enrollment_response_ != NULL)
        auto_enrollment_response_->::enterprise_management::DeviceAutoEnrollmentResponse::Clear();
    clear_has_auto_enrollment_response();
}
inline const ::enterprise_management::DeviceAutoEnrollmentResponse& DeviceManagementResponse::auto_enrollment_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return auto_enrollment_response_ != NULL ? *auto_enrollment_response_ : *default_instance().auto_enrollment_response_;
#else
    return auto_enrollment_response_ != NULL ? *auto_enrollment_response_ : *default_instance_->auto_enrollment_response_;
#endif
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::mutable_auto_enrollment_response()
{
    set_has_auto_enrollment_response();
    if (auto_enrollment_response_ == NULL) {
        auto_enrollment_response_ = new ::enterprise_management::DeviceAutoEnrollmentResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
    return auto_enrollment_response_;
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::release_auto_enrollment_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
    clear_has_auto_enrollment_response();
    ::enterprise_management::DeviceAutoEnrollmentResponse* temp = auto_enrollment_response_;
    auto_enrollment_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_auto_enrollment_response(::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response)
{
    delete auto_enrollment_response_;
    auto_enrollment_response_ = auto_enrollment_response;
    if (auto_enrollment_response) {
        set_has_auto_enrollment_response();
    } else {
        clear_has_auto_enrollment_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
}

// optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
inline bool DeviceManagementResponse::has_cert_upload_response() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceManagementResponse::set_has_cert_upload_response()
{
    _has_bits_[0] |= 0x00000100u;
}
inline void DeviceManagementResponse::clear_has_cert_upload_response()
{
    _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceManagementResponse::clear_cert_upload_response()
{
    if (cert_upload_response_ != NULL)
        cert_upload_response_->::enterprise_management::DeviceCertUploadResponse::Clear();
    clear_has_cert_upload_response();
}
inline const ::enterprise_management::DeviceCertUploadResponse& DeviceManagementResponse::cert_upload_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.cert_upload_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return cert_upload_response_ != NULL ? *cert_upload_response_ : *default_instance().cert_upload_response_;
#else
    return cert_upload_response_ != NULL ? *cert_upload_response_ : *default_instance_->cert_upload_response_;
#endif
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::mutable_cert_upload_response()
{
    set_has_cert_upload_response();
    if (cert_upload_response_ == NULL) {
        cert_upload_response_ = new ::enterprise_management::DeviceCertUploadResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.cert_upload_response)
    return cert_upload_response_;
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::release_cert_upload_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.cert_upload_response)
    clear_has_cert_upload_response();
    ::enterprise_management::DeviceCertUploadResponse* temp = cert_upload_response_;
    cert_upload_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_cert_upload_response(::enterprise_management::DeviceCertUploadResponse* cert_upload_response)
{
    delete cert_upload_response_;
    cert_upload_response_ = cert_upload_response;
    if (cert_upload_response) {
        set_has_cert_upload_response();
    } else {
        clear_has_cert_upload_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.cert_upload_response)
}

// optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
inline bool DeviceManagementResponse::has_service_api_access_response() const
{
    return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceManagementResponse::set_has_service_api_access_response()
{
    _has_bits_[0] |= 0x00000200u;
}
inline void DeviceManagementResponse::clear_has_service_api_access_response()
{
    _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceManagementResponse::clear_service_api_access_response()
{
    if (service_api_access_response_ != NULL)
        service_api_access_response_->::enterprise_management::DeviceServiceApiAccessResponse::Clear();
    clear_has_service_api_access_response();
}
inline const ::enterprise_management::DeviceServiceApiAccessResponse& DeviceManagementResponse::service_api_access_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.service_api_access_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return service_api_access_response_ != NULL ? *service_api_access_response_ : *default_instance().service_api_access_response_;
#else
    return service_api_access_response_ != NULL ? *service_api_access_response_ : *default_instance_->service_api_access_response_;
#endif
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::mutable_service_api_access_response()
{
    set_has_service_api_access_response();
    if (service_api_access_response_ == NULL) {
        service_api_access_response_ = new ::enterprise_management::DeviceServiceApiAccessResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.service_api_access_response)
    return service_api_access_response_;
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::release_service_api_access_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.service_api_access_response)
    clear_has_service_api_access_response();
    ::enterprise_management::DeviceServiceApiAccessResponse* temp = service_api_access_response_;
    service_api_access_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_service_api_access_response(::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response)
{
    delete service_api_access_response_;
    service_api_access_response_ = service_api_access_response;
    if (service_api_access_response) {
        set_has_service_api_access_response();
    } else {
        clear_has_service_api_access_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.service_api_access_response)
}

// optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
inline bool DeviceManagementResponse::has_device_state_retrieval_response() const
{
    return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceManagementResponse::set_has_device_state_retrieval_response()
{
    _has_bits_[0] |= 0x00000400u;
}
inline void DeviceManagementResponse::clear_has_device_state_retrieval_response()
{
    _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceManagementResponse::clear_device_state_retrieval_response()
{
    if (device_state_retrieval_response_ != NULL)
        device_state_retrieval_response_->::enterprise_management::DeviceStateRetrievalResponse::Clear();
    clear_has_device_state_retrieval_response();
}
inline const ::enterprise_management::DeviceStateRetrievalResponse& DeviceManagementResponse::device_state_retrieval_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_state_retrieval_response_ != NULL ? *device_state_retrieval_response_ : *default_instance().device_state_retrieval_response_;
#else
    return device_state_retrieval_response_ != NULL ? *device_state_retrieval_response_ : *default_instance_->device_state_retrieval_response_;
#endif
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::mutable_device_state_retrieval_response()
{
    set_has_device_state_retrieval_response();
    if (device_state_retrieval_response_ == NULL) {
        device_state_retrieval_response_ = new ::enterprise_management::DeviceStateRetrievalResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
    return device_state_retrieval_response_;
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::release_device_state_retrieval_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
    clear_has_device_state_retrieval_response();
    ::enterprise_management::DeviceStateRetrievalResponse* temp = device_state_retrieval_response_;
    device_state_retrieval_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_device_state_retrieval_response(::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response)
{
    delete device_state_retrieval_response_;
    device_state_retrieval_response_ = device_state_retrieval_response;
    if (device_state_retrieval_response) {
        set_has_device_state_retrieval_response();
    } else {
        clear_has_device_state_retrieval_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
}

// optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
inline bool DeviceManagementResponse::has_device_pairing_response() const
{
    return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceManagementResponse::set_has_device_pairing_response()
{
    _has_bits_[0] |= 0x00000800u;
}
inline void DeviceManagementResponse::clear_has_device_pairing_response()
{
    _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceManagementResponse::clear_device_pairing_response()
{
    if (device_pairing_response_ != NULL)
        device_pairing_response_->::enterprise_management::DevicePairingResponse::Clear();
    clear_has_device_pairing_response();
}
inline const ::enterprise_management::DevicePairingResponse& DeviceManagementResponse::device_pairing_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_pairing_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_pairing_response_ != NULL ? *device_pairing_response_ : *default_instance().device_pairing_response_;
#else
    return device_pairing_response_ != NULL ? *device_pairing_response_ : *default_instance_->device_pairing_response_;
#endif
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::mutable_device_pairing_response()
{
    set_has_device_pairing_response();
    if (device_pairing_response_ == NULL) {
        device_pairing_response_ = new ::enterprise_management::DevicePairingResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_pairing_response)
    return device_pairing_response_;
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::release_device_pairing_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_pairing_response)
    clear_has_device_pairing_response();
    ::enterprise_management::DevicePairingResponse* temp = device_pairing_response_;
    device_pairing_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_device_pairing_response(::enterprise_management::DevicePairingResponse* device_pairing_response)
{
    delete device_pairing_response_;
    device_pairing_response_ = device_pairing_response;
    if (device_pairing_response) {
        set_has_device_pairing_response();
    } else {
        clear_has_device_pairing_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_pairing_response)
}

// optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
inline bool DeviceManagementResponse::has_check_device_pairing_response() const
{
    return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceManagementResponse::set_has_check_device_pairing_response()
{
    _has_bits_[0] |= 0x00001000u;
}
inline void DeviceManagementResponse::clear_has_check_device_pairing_response()
{
    _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceManagementResponse::clear_check_device_pairing_response()
{
    if (check_device_pairing_response_ != NULL)
        check_device_pairing_response_->::enterprise_management::CheckDevicePairingResponse::Clear();
    clear_has_check_device_pairing_response();
}
inline const ::enterprise_management::CheckDevicePairingResponse& DeviceManagementResponse::check_device_pairing_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return check_device_pairing_response_ != NULL ? *check_device_pairing_response_ : *default_instance().check_device_pairing_response_;
#else
    return check_device_pairing_response_ != NULL ? *check_device_pairing_response_ : *default_instance_->check_device_pairing_response_;
#endif
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::mutable_check_device_pairing_response()
{
    set_has_check_device_pairing_response();
    if (check_device_pairing_response_ == NULL) {
        check_device_pairing_response_ = new ::enterprise_management::CheckDevicePairingResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
    return check_device_pairing_response_;
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::release_check_device_pairing_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
    clear_has_check_device_pairing_response();
    ::enterprise_management::CheckDevicePairingResponse* temp = check_device_pairing_response_;
    check_device_pairing_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_check_device_pairing_response(::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response)
{
    delete check_device_pairing_response_;
    check_device_pairing_response_ = check_device_pairing_response;
    if (check_device_pairing_response) {
        set_has_check_device_pairing_response();
    } else {
        clear_has_check_device_pairing_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
}

// optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
inline bool DeviceManagementResponse::has_remote_command_response() const
{
    return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceManagementResponse::set_has_remote_command_response()
{
    _has_bits_[0] |= 0x00002000u;
}
inline void DeviceManagementResponse::clear_has_remote_command_response()
{
    _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceManagementResponse::clear_remote_command_response()
{
    if (remote_command_response_ != NULL)
        remote_command_response_->::enterprise_management::DeviceRemoteCommandResponse::Clear();
    clear_has_remote_command_response();
}
inline const ::enterprise_management::DeviceRemoteCommandResponse& DeviceManagementResponse::remote_command_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.remote_command_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return remote_command_response_ != NULL ? *remote_command_response_ : *default_instance().remote_command_response_;
#else
    return remote_command_response_ != NULL ? *remote_command_response_ : *default_instance_->remote_command_response_;
#endif
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::mutable_remote_command_response()
{
    set_has_remote_command_response();
    if (remote_command_response_ == NULL) {
        remote_command_response_ = new ::enterprise_management::DeviceRemoteCommandResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.remote_command_response)
    return remote_command_response_;
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::release_remote_command_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.remote_command_response)
    clear_has_remote_command_response();
    ::enterprise_management::DeviceRemoteCommandResponse* temp = remote_command_response_;
    remote_command_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_remote_command_response(::enterprise_management::DeviceRemoteCommandResponse* remote_command_response)
{
    delete remote_command_response_;
    remote_command_response_ = remote_command_response;
    if (remote_command_response) {
        set_has_remote_command_response();
    } else {
        clear_has_remote_command_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.remote_command_response)
}

// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
inline bool DeviceManagementResponse::has_device_attribute_update_permission_response() const
{
    return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceManagementResponse::set_has_device_attribute_update_permission_response()
{
    _has_bits_[0] |= 0x00004000u;
}
inline void DeviceManagementResponse::clear_has_device_attribute_update_permission_response()
{
    _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceManagementResponse::clear_device_attribute_update_permission_response()
{
    if (device_attribute_update_permission_response_ != NULL)
        device_attribute_update_permission_response_->::enterprise_management::DeviceAttributeUpdatePermissionResponse::Clear();
    clear_has_device_attribute_update_permission_response();
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& DeviceManagementResponse::device_attribute_update_permission_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_attribute_update_permission_response_ != NULL ? *device_attribute_update_permission_response_ : *default_instance().device_attribute_update_permission_response_;
#else
    return device_attribute_update_permission_response_ != NULL ? *device_attribute_update_permission_response_ : *default_instance_->device_attribute_update_permission_response_;
#endif
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::mutable_device_attribute_update_permission_response()
{
    set_has_device_attribute_update_permission_response();
    if (device_attribute_update_permission_response_ == NULL) {
        device_attribute_update_permission_response_ = new ::enterprise_management::DeviceAttributeUpdatePermissionResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
    return device_attribute_update_permission_response_;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::release_device_attribute_update_permission_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
    clear_has_device_attribute_update_permission_response();
    ::enterprise_management::DeviceAttributeUpdatePermissionResponse* temp = device_attribute_update_permission_response_;
    device_attribute_update_permission_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_device_attribute_update_permission_response(::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response)
{
    delete device_attribute_update_permission_response_;
    device_attribute_update_permission_response_ = device_attribute_update_permission_response;
    if (device_attribute_update_permission_response) {
        set_has_device_attribute_update_permission_response();
    } else {
        clear_has_device_attribute_update_permission_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
}

// optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
inline bool DeviceManagementResponse::has_device_attribute_update_response() const
{
    return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceManagementResponse::set_has_device_attribute_update_response()
{
    _has_bits_[0] |= 0x00008000u;
}
inline void DeviceManagementResponse::clear_has_device_attribute_update_response()
{
    _has_bits_[0] &= ~0x00008000u;
}
inline void DeviceManagementResponse::clear_device_attribute_update_response()
{
    if (device_attribute_update_response_ != NULL)
        device_attribute_update_response_->::enterprise_management::DeviceAttributeUpdateResponse::Clear();
    clear_has_device_attribute_update_response();
}
inline const ::enterprise_management::DeviceAttributeUpdateResponse& DeviceManagementResponse::device_attribute_update_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return device_attribute_update_response_ != NULL ? *device_attribute_update_response_ : *default_instance().device_attribute_update_response_;
#else
    return device_attribute_update_response_ != NULL ? *device_attribute_update_response_ : *default_instance_->device_attribute_update_response_;
#endif
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::mutable_device_attribute_update_response()
{
    set_has_device_attribute_update_response();
    if (device_attribute_update_response_ == NULL) {
        device_attribute_update_response_ = new ::enterprise_management::DeviceAttributeUpdateResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
    return device_attribute_update_response_;
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::release_device_attribute_update_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
    clear_has_device_attribute_update_response();
    ::enterprise_management::DeviceAttributeUpdateResponse* temp = device_attribute_update_response_;
    device_attribute_update_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_device_attribute_update_response(::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response)
{
    delete device_attribute_update_response_;
    device_attribute_update_response_ = device_attribute_update_response;
    if (device_attribute_update_response) {
        set_has_device_attribute_update_response();
    } else {
        clear_has_device_attribute_update_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
}

// optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
inline bool DeviceManagementResponse::has_gcm_id_update_response() const
{
    return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceManagementResponse::set_has_gcm_id_update_response()
{
    _has_bits_[0] |= 0x00010000u;
}
inline void DeviceManagementResponse::clear_has_gcm_id_update_response()
{
    _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceManagementResponse::clear_gcm_id_update_response()
{
    if (gcm_id_update_response_ != NULL)
        gcm_id_update_response_->::enterprise_management::GcmIdUpdateResponse::Clear();
    clear_has_gcm_id_update_response();
}
inline const ::enterprise_management::GcmIdUpdateResponse& DeviceManagementResponse::gcm_id_update_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return gcm_id_update_response_ != NULL ? *gcm_id_update_response_ : *default_instance().gcm_id_update_response_;
#else
    return gcm_id_update_response_ != NULL ? *gcm_id_update_response_ : *default_instance_->gcm_id_update_response_;
#endif
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::mutable_gcm_id_update_response()
{
    set_has_gcm_id_update_response();
    if (gcm_id_update_response_ == NULL) {
        gcm_id_update_response_ = new ::enterprise_management::GcmIdUpdateResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
    return gcm_id_update_response_;
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::release_gcm_id_update_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
    clear_has_gcm_id_update_response();
    ::enterprise_management::GcmIdUpdateResponse* temp = gcm_id_update_response_;
    gcm_id_update_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_gcm_id_update_response(::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response)
{
    delete gcm_id_update_response_;
    gcm_id_update_response_ = gcm_id_update_response;
    if (gcm_id_update_response) {
        set_has_gcm_id_update_response();
    } else {
        clear_has_gcm_id_update_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
}

// optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
inline bool DeviceManagementResponse::has_check_android_management_response() const
{
    return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceManagementResponse::set_has_check_android_management_response()
{
    _has_bits_[0] |= 0x00020000u;
}
inline void DeviceManagementResponse::clear_has_check_android_management_response()
{
    _has_bits_[0] &= ~0x00020000u;
}
inline void DeviceManagementResponse::clear_check_android_management_response()
{
    if (check_android_management_response_ != NULL)
        check_android_management_response_->::enterprise_management::CheckAndroidManagementResponse::Clear();
    clear_has_check_android_management_response();
}
inline const ::enterprise_management::CheckAndroidManagementResponse& DeviceManagementResponse::check_android_management_response() const
{
// @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_android_management_response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return check_android_management_response_ != NULL ? *check_android_management_response_ : *default_instance().check_android_management_response_;
#else
    return check_android_management_response_ != NULL ? *check_android_management_response_ : *default_instance_->check_android_management_response_;
#endif
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::mutable_check_android_management_response()
{
    set_has_check_android_management_response();
    if (check_android_management_response_ == NULL) {
        check_android_management_response_ = new ::enterprise_management::CheckAndroidManagementResponse;
    }
    // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_android_management_response)
    return check_android_management_response_;
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::release_check_android_management_response()
{
    // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_android_management_response)
    clear_has_check_android_management_response();
    ::enterprise_management::CheckAndroidManagementResponse* temp = check_android_management_response_;
    check_android_management_response_ = NULL;
    return temp;
}
inline void DeviceManagementResponse::set_allocated_check_android_management_response(::enterprise_management::CheckAndroidManagementResponse* check_android_management_response)
{
    delete check_android_management_response_;
    check_android_management_response_ = check_android_management_response;
    if (check_android_management_response) {
        set_has_check_android_management_response();
    } else {
        clear_has_check_android_management_response();
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_android_management_response)
}

#endif // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace enterprise_management

#ifndef SWIG
namespace google {
namespace protobuf {

    template <>
    struct is_proto_enum<::enterprise_management::DeviceRegisterRequest_Type> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceRegisterRequest_Flavor> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceRegisterResponse_DeviceMode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceServiceApiAccessRequest_DeviceType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::PolicyFetchRequest_SignatureType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceState_DeviceMode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::PolicyData_AssociationState> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::PolicyData_ManagementMode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::OBSOLETE_DeviceLocation_ErrorCode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::NetworkInterface_NetworkDeviceType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::NetworkState_ConnectionState> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceUser_UserType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::OsUpdateStatus_UpdateStatus> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceStateRetrievalResponse_RestoreMode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DevicePairingResponse_StatusCode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::CheckDevicePairingResponse_StatusCode> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::RemoteCommand_Type> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::RemoteCommandResult_ResultType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceAttributeUpdateResponse_ResultType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType> : ::google::protobuf::internal::true_type {
    };
    template <>
    struct is_proto_enum<::enterprise_management::DeviceManagementResponse_ErrorCode> : ::google::protobuf::internal::true_type {
    };

} // namespace protobuf
} // namespace google
#endif // SWIG

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_device_5fmanagement_5fbackend_2eproto__INCLUDED
