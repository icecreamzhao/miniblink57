// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fingerprint.proto

#ifndef PROTOBUF_fingerprint_2eproto__INCLUDED
#define PROTOBUF_fingerprint_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)

namespace autofill {
namespace risk {

    // Internal implementation detail -- do not call these.
    void protobuf_AddDesc_fingerprint_2eproto();
    void protobuf_AssignDesc_fingerprint_2eproto();
    void protobuf_ShutdownFile_fingerprint_2eproto();

    class Fingerprint;
    class Fingerprint_Dimension;
    class Fingerprint_MachineCharacteristics;
    class Fingerprint_MachineCharacteristics_Cpu;
    class Fingerprint_MachineCharacteristics_Graphics;
    class Fingerprint_MachineCharacteristics_Plugin;
    class Fingerprint_Metadata;
    class Fingerprint_Performance;
    class Fingerprint_TransientState;
    class Fingerprint_UserCharacteristics;
    class Fingerprint_UserCharacteristics_Location;
    class Fingerprint_UserCharacteristics_Vector;

    enum Fingerprint_MachineCharacteristics_BrowserFeature {
        Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN = 0,
        Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT = 1,
        Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE = 2
    };
    bool Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(int value);
    const Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
    const Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
    const int Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX + 1;

    // ===================================================================

    class Fingerprint_Dimension : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_Dimension();
        virtual ~Fingerprint_Dimension();

        Fingerprint_Dimension(const Fingerprint_Dimension& from);

        inline Fingerprint_Dimension& operator=(const Fingerprint_Dimension& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_Dimension& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_Dimension* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_Dimension* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_Dimension* New() const { return New(NULL); }

        Fingerprint_Dimension* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_Dimension& from);
        void MergeFrom(const Fingerprint_Dimension& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_Dimension* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 width = 1;
        bool has_width() const;
        void clear_width();
        static const int kWidthFieldNumber = 1;
        ::google::protobuf::int32 width() const;
        void set_width(::google::protobuf::int32 value);

        // optional int32 height = 2;
        bool has_height() const;
        void clear_height();
        static const int kHeightFieldNumber = 2;
        ::google::protobuf::int32 height() const;
        void set_height(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Dimension)
    private:
        inline void set_has_width();
        inline void clear_has_width();
        inline void set_has_height();
        inline void clear_has_height();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int32 width_;
        ::google::protobuf::int32 height_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_Dimension* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_MachineCharacteristics_Plugin : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_MachineCharacteristics_Plugin();
        virtual ~Fingerprint_MachineCharacteristics_Plugin();

        Fingerprint_MachineCharacteristics_Plugin(const Fingerprint_MachineCharacteristics_Plugin& from);

        inline Fingerprint_MachineCharacteristics_Plugin& operator=(const Fingerprint_MachineCharacteristics_Plugin& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_MachineCharacteristics_Plugin& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_MachineCharacteristics_Plugin* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Plugin* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_MachineCharacteristics_Plugin* New() const { return New(NULL); }

        Fingerprint_MachineCharacteristics_Plugin* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
        void MergeFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_MachineCharacteristics_Plugin* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional string name = 1;
        bool has_name() const;
        void clear_name();
        static const int kNameFieldNumber = 1;
        const ::std::string& name() const;
        void set_name(const ::std::string& value);
        void set_name(const char* value);
        void set_name(const char* value, size_t size);
        ::std::string* mutable_name();
        ::std::string* release_name();
        void set_allocated_name(::std::string* name);

        // optional string description = 2;
        bool has_description() const;
        void clear_description();
        static const int kDescriptionFieldNumber = 2;
        const ::std::string& description() const;
        void set_description(const ::std::string& value);
        void set_description(const char* value);
        void set_description(const char* value, size_t size);
        ::std::string* mutable_description();
        ::std::string* release_description();
        void set_allocated_description(::std::string* description);

        // repeated string mime_type = 3;
        int mime_type_size() const;
        void clear_mime_type();
        static const int kMimeTypeFieldNumber = 3;
        const ::std::string& mime_type(int index) const;
        ::std::string* mutable_mime_type(int index);
        void set_mime_type(int index, const ::std::string& value);
        void set_mime_type(int index, const char* value);
        void set_mime_type(int index, const char* value, size_t size);
        ::std::string* add_mime_type();
        void add_mime_type(const ::std::string& value);
        void add_mime_type(const char* value);
        void add_mime_type(const char* value, size_t size);
        const ::google::protobuf::RepeatedPtrField<::std::string>& mime_type() const;
        ::google::protobuf::RepeatedPtrField<::std::string>* mutable_mime_type();

        // optional string version = 4;
        bool has_version() const;
        void clear_version();
        static const int kVersionFieldNumber = 4;
        const ::std::string& version() const;
        void set_version(const ::std::string& value);
        void set_version(const char* value);
        void set_version(const char* value, size_t size);
        ::std::string* mutable_version();
        ::std::string* release_version();
        void set_allocated_version(::std::string* version);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    private:
        inline void set_has_name();
        inline void clear_has_name();
        inline void set_has_description();
        inline void clear_has_description();
        inline void set_has_version();
        inline void clear_has_version();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr name_;
        ::google::protobuf::internal::ArenaStringPtr description_;
        ::google::protobuf::RepeatedPtrField<::std::string> mime_type_;
        ::google::protobuf::internal::ArenaStringPtr version_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_MachineCharacteristics_Plugin* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_MachineCharacteristics_Cpu : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_MachineCharacteristics_Cpu();
        virtual ~Fingerprint_MachineCharacteristics_Cpu();

        Fingerprint_MachineCharacteristics_Cpu(const Fingerprint_MachineCharacteristics_Cpu& from);

        inline Fingerprint_MachineCharacteristics_Cpu& operator=(const Fingerprint_MachineCharacteristics_Cpu& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_MachineCharacteristics_Cpu& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_MachineCharacteristics_Cpu* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Cpu* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_MachineCharacteristics_Cpu* New() const { return New(NULL); }

        Fingerprint_MachineCharacteristics_Cpu* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
        void MergeFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_MachineCharacteristics_Cpu* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional string vendor_name = 1;
        bool has_vendor_name() const;
        void clear_vendor_name();
        static const int kVendorNameFieldNumber = 1;
        const ::std::string& vendor_name() const;
        void set_vendor_name(const ::std::string& value);
        void set_vendor_name(const char* value);
        void set_vendor_name(const char* value, size_t size);
        ::std::string* mutable_vendor_name();
        ::std::string* release_vendor_name();
        void set_allocated_vendor_name(::std::string* vendor_name);

        // optional string brand = 2;
        bool has_brand() const;
        void clear_brand();
        static const int kBrandFieldNumber = 2;
        const ::std::string& brand() const;
        void set_brand(const ::std::string& value);
        void set_brand(const char* value);
        void set_brand(const char* value, size_t size);
        ::std::string* mutable_brand();
        ::std::string* release_brand();
        void set_allocated_brand(::std::string* brand);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    private:
        inline void set_has_vendor_name();
        inline void clear_has_vendor_name();
        inline void set_has_brand();
        inline void clear_has_brand();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::internal::ArenaStringPtr vendor_name_;
        ::google::protobuf::internal::ArenaStringPtr brand_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_MachineCharacteristics_Cpu* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_MachineCharacteristics_Graphics : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_MachineCharacteristics_Graphics();
        virtual ~Fingerprint_MachineCharacteristics_Graphics();

        Fingerprint_MachineCharacteristics_Graphics(const Fingerprint_MachineCharacteristics_Graphics& from);

        inline Fingerprint_MachineCharacteristics_Graphics& operator=(const Fingerprint_MachineCharacteristics_Graphics& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_MachineCharacteristics_Graphics& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_MachineCharacteristics_Graphics* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Graphics* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_MachineCharacteristics_Graphics* New() const { return New(NULL); }

        Fingerprint_MachineCharacteristics_Graphics* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
        void MergeFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_MachineCharacteristics_Graphics* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional uint32 vendor_id = 1;
        bool has_vendor_id() const;
        void clear_vendor_id();
        static const int kVendorIdFieldNumber = 1;
        ::google::protobuf::uint32 vendor_id() const;
        void set_vendor_id(::google::protobuf::uint32 value);

        // optional uint32 device_id = 2;
        bool has_device_id() const;
        void clear_device_id();
        static const int kDeviceIdFieldNumber = 2;
        ::google::protobuf::uint32 device_id() const;
        void set_device_id(::google::protobuf::uint32 value);

        // optional string driver_version = 3;
        bool has_driver_version() const;
        void clear_driver_version();
        static const int kDriverVersionFieldNumber = 3;
        const ::std::string& driver_version() const;
        void set_driver_version(const ::std::string& value);
        void set_driver_version(const char* value);
        void set_driver_version(const char* value, size_t size);
        ::std::string* mutable_driver_version();
        ::std::string* release_driver_version();
        void set_allocated_driver_version(::std::string* driver_version);

        // optional string driver_date = 4;
        bool has_driver_date() const;
        void clear_driver_date();
        static const int kDriverDateFieldNumber = 4;
        const ::std::string& driver_date() const;
        void set_driver_date(const ::std::string& value);
        void set_driver_date(const char* value);
        void set_driver_date(const char* value, size_t size);
        ::std::string* mutable_driver_date();
        ::std::string* release_driver_date();
        void set_allocated_driver_date(::std::string* driver_date);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    private:
        inline void set_has_vendor_id();
        inline void clear_has_vendor_id();
        inline void set_has_device_id();
        inline void clear_has_device_id();
        inline void set_has_driver_version();
        inline void clear_has_driver_version();
        inline void set_has_driver_date();
        inline void clear_has_driver_date();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint32 vendor_id_;
        ::google::protobuf::uint32 device_id_;
        ::google::protobuf::internal::ArenaStringPtr driver_version_;
        ::google::protobuf::internal::ArenaStringPtr driver_date_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_MachineCharacteristics_Graphics* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_MachineCharacteristics : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_MachineCharacteristics();
        virtual ~Fingerprint_MachineCharacteristics();

        Fingerprint_MachineCharacteristics(const Fingerprint_MachineCharacteristics& from);

        inline Fingerprint_MachineCharacteristics& operator=(const Fingerprint_MachineCharacteristics& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_MachineCharacteristics& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_MachineCharacteristics* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_MachineCharacteristics* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_MachineCharacteristics* New() const { return New(NULL); }

        Fingerprint_MachineCharacteristics* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_MachineCharacteristics& from);
        void MergeFrom(const Fingerprint_MachineCharacteristics& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_MachineCharacteristics* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef Fingerprint_MachineCharacteristics_Plugin Plugin;
        typedef Fingerprint_MachineCharacteristics_Cpu Cpu;
        typedef Fingerprint_MachineCharacteristics_Graphics Graphics;

        typedef Fingerprint_MachineCharacteristics_BrowserFeature BrowserFeature;
        static const BrowserFeature FEATURE_UNKNOWN = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
        static const BrowserFeature DEPRECATED_FEATURE_AUTOCHECKOUT = Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT;
        static const BrowserFeature FEATURE_REQUEST_AUTOCOMPLETE = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
        static inline bool BrowserFeature_IsValid(int value)
        {
            return Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value);
        }
        static const BrowserFeature BrowserFeature_MIN = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN;
        static const BrowserFeature BrowserFeature_MAX = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX;
        static const int BrowserFeature_ARRAYSIZE = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE;

        // accessors -------------------------------------------------------

        // optional fixed64 user_and_device_name_hash = 1;
        bool has_user_and_device_name_hash() const;
        void clear_user_and_device_name_hash();
        static const int kUserAndDeviceNameHashFieldNumber = 1;
        ::google::protobuf::uint64 user_and_device_name_hash() const;
        void set_user_and_device_name_hash(::google::protobuf::uint64 value);

        // optional string operating_system_build = 2;
        bool has_operating_system_build() const;
        void clear_operating_system_build();
        static const int kOperatingSystemBuildFieldNumber = 2;
        const ::std::string& operating_system_build() const;
        void set_operating_system_build(const ::std::string& value);
        void set_operating_system_build(const char* value);
        void set_operating_system_build(const char* value, size_t size);
        ::std::string* mutable_operating_system_build();
        ::std::string* release_operating_system_build();
        void set_allocated_operating_system_build(::std::string* operating_system_build);

        // optional int64 browser_install_time_hours = 3;
        bool has_browser_install_time_hours() const;
        void clear_browser_install_time_hours();
        static const int kBrowserInstallTimeHoursFieldNumber = 3;
        ::google::protobuf::int64 browser_install_time_hours() const;
        void set_browser_install_time_hours(::google::protobuf::int64 value);

        // repeated string font = 4;
        int font_size() const;
        void clear_font();
        static const int kFontFieldNumber = 4;
        const ::std::string& font(int index) const;
        ::std::string* mutable_font(int index);
        void set_font(int index, const ::std::string& value);
        void set_font(int index, const char* value);
        void set_font(int index, const char* value, size_t size);
        ::std::string* add_font();
        void add_font(const ::std::string& value);
        void add_font(const char* value);
        void add_font(const char* value, size_t size);
        const ::google::protobuf::RepeatedPtrField<::std::string>& font() const;
        ::google::protobuf::RepeatedPtrField<::std::string>* mutable_font();

        // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
        int plugin_size() const;
        void clear_plugin();
        static const int kPluginFieldNumber = 5;
        const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& plugin(int index) const;
        ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* mutable_plugin(int index);
        ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* add_plugin();
        ::google::protobuf::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>*
        mutable_plugin();
        const ::google::protobuf::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>&
        plugin() const;

        // optional int64 utc_offset_ms = 6;
        bool has_utc_offset_ms() const;
        void clear_utc_offset_ms();
        static const int kUtcOffsetMsFieldNumber = 6;
        ::google::protobuf::int64 utc_offset_ms() const;
        void set_utc_offset_ms(::google::protobuf::int64 value);

        // optional string browser_language = 7;
        bool has_browser_language() const;
        void clear_browser_language();
        static const int kBrowserLanguageFieldNumber = 7;
        const ::std::string& browser_language() const;
        void set_browser_language(const ::std::string& value);
        void set_browser_language(const char* value);
        void set_browser_language(const char* value, size_t size);
        ::std::string* mutable_browser_language();
        ::std::string* release_browser_language();
        void set_allocated_browser_language(::std::string* browser_language);

        // repeated string requested_language = 8;
        int requested_language_size() const;
        void clear_requested_language();
        static const int kRequestedLanguageFieldNumber = 8;
        const ::std::string& requested_language(int index) const;
        ::std::string* mutable_requested_language(int index);
        void set_requested_language(int index, const ::std::string& value);
        void set_requested_language(int index, const char* value);
        void set_requested_language(int index, const char* value, size_t size);
        ::std::string* add_requested_language();
        void add_requested_language(const ::std::string& value);
        void add_requested_language(const char* value);
        void add_requested_language(const char* value, size_t size);
        const ::google::protobuf::RepeatedPtrField<::std::string>& requested_language() const;
        ::google::protobuf::RepeatedPtrField<::std::string>* mutable_requested_language();

        // optional string charset = 9;
        bool has_charset() const;
        void clear_charset();
        static const int kCharsetFieldNumber = 9;
        const ::std::string& charset() const;
        void set_charset(const ::std::string& value);
        void set_charset(const char* value);
        void set_charset(const char* value, size_t size);
        ::std::string* mutable_charset();
        ::std::string* release_charset();
        void set_allocated_charset(::std::string* charset);

        // optional int32 screen_count = 10;
        bool has_screen_count() const;
        void clear_screen_count();
        static const int kScreenCountFieldNumber = 10;
        ::google::protobuf::int32 screen_count() const;
        void set_screen_count(::google::protobuf::int32 value);

        // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
        bool has_screen_size() const;
        void clear_screen_size();
        static const int kScreenSizeFieldNumber = 11;
        const ::autofill::risk::Fingerprint_Dimension& screen_size() const;
        ::autofill::risk::Fingerprint_Dimension* mutable_screen_size();
        ::autofill::risk::Fingerprint_Dimension* release_screen_size();
        void set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size);

        // optional int32 screen_color_depth = 12;
        bool has_screen_color_depth() const;
        void clear_screen_color_depth();
        static const int kScreenColorDepthFieldNumber = 12;
        ::google::protobuf::int32 screen_color_depth() const;
        void set_screen_color_depth(::google::protobuf::int32 value);

        // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
        bool has_unavailable_screen_size() const;
        void clear_unavailable_screen_size();
        static const int kUnavailableScreenSizeFieldNumber = 13;
        const ::autofill::risk::Fingerprint_Dimension& unavailable_screen_size() const;
        ::autofill::risk::Fingerprint_Dimension* mutable_unavailable_screen_size();
        ::autofill::risk::Fingerprint_Dimension* release_unavailable_screen_size();
        void set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size);

        // optional string user_agent = 14;
        bool has_user_agent() const;
        void clear_user_agent();
        static const int kUserAgentFieldNumber = 14;
        const ::std::string& user_agent() const;
        void set_user_agent(const ::std::string& value);
        void set_user_agent(const char* value);
        void set_user_agent(const char* value, size_t size);
        ::std::string* mutable_user_agent();
        ::std::string* release_user_agent();
        void set_allocated_user_agent(::std::string* user_agent);

        // repeated int32 partition_size = 15;
        int partition_size_size() const;
        void clear_partition_size();
        static const int kPartitionSizeFieldNumber = 15;
        ::google::protobuf::int32 partition_size(int index) const;
        void set_partition_size(int index, ::google::protobuf::int32 value);
        void add_partition_size(::google::protobuf::int32 value);
        const ::google::protobuf::RepeatedField<::google::protobuf::int32>&
        partition_size() const;
        ::google::protobuf::RepeatedField<::google::protobuf::int32>*
        mutable_partition_size();

        // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
        bool has_cpu() const;
        void clear_cpu();
        static const int kCpuFieldNumber = 16;
        const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& cpu() const;
        ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* mutable_cpu();
        ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* release_cpu();
        void set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu);

        // optional int64 ram = 17;
        bool has_ram() const;
        void clear_ram();
        static const int kRamFieldNumber = 17;
        ::google::protobuf::int64 ram() const;
        void set_ram(::google::protobuf::int64 value);

        // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
        bool has_graphics_card() const;
        void clear_graphics_card();
        static const int kGraphicsCardFieldNumber = 18;
        const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& graphics_card() const;
        ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* mutable_graphics_card();
        ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* release_graphics_card();
        void set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card);

        // optional string browser_build = 19;
        bool has_browser_build() const;
        void clear_browser_build();
        static const int kBrowserBuildFieldNumber = 19;
        const ::std::string& browser_build() const;
        void set_browser_build(const ::std::string& value);
        void set_browser_build(const char* value);
        void set_browser_build(const char* value, size_t size);
        ::std::string* mutable_browser_build();
        ::std::string* release_browser_build();
        void set_allocated_browser_build(::std::string* browser_build);

        // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
        bool has_browser_feature() const;
        void clear_browser_feature();
        static const int kBrowserFeatureFieldNumber = 20;
        ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature browser_feature() const;
        void set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics)
    private:
        inline void set_has_user_and_device_name_hash();
        inline void clear_has_user_and_device_name_hash();
        inline void set_has_operating_system_build();
        inline void clear_has_operating_system_build();
        inline void set_has_browser_install_time_hours();
        inline void clear_has_browser_install_time_hours();
        inline void set_has_utc_offset_ms();
        inline void clear_has_utc_offset_ms();
        inline void set_has_browser_language();
        inline void clear_has_browser_language();
        inline void set_has_charset();
        inline void clear_has_charset();
        inline void set_has_screen_count();
        inline void clear_has_screen_count();
        inline void set_has_screen_size();
        inline void clear_has_screen_size();
        inline void set_has_screen_color_depth();
        inline void clear_has_screen_color_depth();
        inline void set_has_unavailable_screen_size();
        inline void clear_has_unavailable_screen_size();
        inline void set_has_user_agent();
        inline void clear_has_user_agent();
        inline void set_has_cpu();
        inline void clear_has_cpu();
        inline void set_has_ram();
        inline void clear_has_ram();
        inline void set_has_graphics_card();
        inline void clear_has_graphics_card();
        inline void set_has_browser_build();
        inline void clear_has_browser_build();
        inline void set_has_browser_feature();
        inline void clear_has_browser_feature();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::uint64 user_and_device_name_hash_;
        ::google::protobuf::internal::ArenaStringPtr operating_system_build_;
        ::google::protobuf::int64 browser_install_time_hours_;
        ::google::protobuf::RepeatedPtrField<::std::string> font_;
        ::google::protobuf::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin> plugin_;
        ::google::protobuf::int64 utc_offset_ms_;
        ::google::protobuf::internal::ArenaStringPtr browser_language_;
        ::google::protobuf::RepeatedPtrField<::std::string> requested_language_;
        ::google::protobuf::internal::ArenaStringPtr charset_;
        ::autofill::risk::Fingerprint_Dimension* screen_size_;
        ::google::protobuf::int32 screen_count_;
        ::google::protobuf::int32 screen_color_depth_;
        ::autofill::risk::Fingerprint_Dimension* unavailable_screen_size_;
        ::google::protobuf::internal::ArenaStringPtr user_agent_;
        ::google::protobuf::RepeatedField<::google::protobuf::int32> partition_size_;
        ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu_;
        ::google::protobuf::int64 ram_;
        ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card_;
        ::google::protobuf::internal::ArenaStringPtr browser_build_;
        int browser_feature_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_MachineCharacteristics* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_TransientState : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_TransientState();
        virtual ~Fingerprint_TransientState();

        Fingerprint_TransientState(const Fingerprint_TransientState& from);

        inline Fingerprint_TransientState& operator=(const Fingerprint_TransientState& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_TransientState& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_TransientState* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_TransientState* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_TransientState* New() const { return New(NULL); }

        Fingerprint_TransientState* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_TransientState& from);
        void MergeFrom(const Fingerprint_TransientState& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_TransientState* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
        bool has_inner_window_size() const;
        void clear_inner_window_size();
        static const int kInnerWindowSizeFieldNumber = 1;
        const ::autofill::risk::Fingerprint_Dimension& inner_window_size() const;
        ::autofill::risk::Fingerprint_Dimension* mutable_inner_window_size();
        ::autofill::risk::Fingerprint_Dimension* release_inner_window_size();
        void set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size);

        // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
        bool has_outer_window_size() const;
        void clear_outer_window_size();
        static const int kOuterWindowSizeFieldNumber = 2;
        const ::autofill::risk::Fingerprint_Dimension& outer_window_size() const;
        ::autofill::risk::Fingerprint_Dimension* mutable_outer_window_size();
        ::autofill::risk::Fingerprint_Dimension* release_outer_window_size();
        void set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.TransientState)
    private:
        inline void set_has_inner_window_size();
        inline void clear_has_inner_window_size();
        inline void set_has_outer_window_size();
        inline void clear_has_outer_window_size();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::autofill::risk::Fingerprint_Dimension* inner_window_size_;
        ::autofill::risk::Fingerprint_Dimension* outer_window_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_TransientState* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_Performance : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_Performance();
        virtual ~Fingerprint_Performance();

        Fingerprint_Performance(const Fingerprint_Performance& from);

        inline Fingerprint_Performance& operator=(const Fingerprint_Performance& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_Performance& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_Performance* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_Performance* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_Performance* New() const { return New(NULL); }

        Fingerprint_Performance* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_Performance& from);
        void MergeFrom(const Fingerprint_Performance& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_Performance* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional float bandwidth = 1;
        bool has_bandwidth() const;
        void clear_bandwidth();
        static const int kBandwidthFieldNumber = 1;
        float bandwidth() const;
        void set_bandwidth(float value);

        // optional bool metered = 2;
        bool has_metered() const;
        void clear_metered();
        static const int kMeteredFieldNumber = 2;
        bool metered() const;
        void set_metered(bool value);

        // optional string network_type = 3;
        bool has_network_type() const;
        void clear_network_type();
        static const int kNetworkTypeFieldNumber = 3;
        const ::std::string& network_type() const;
        void set_network_type(const ::std::string& value);
        void set_network_type(const char* value);
        void set_network_type(const char* value, size_t size);
        ::std::string* mutable_network_type();
        ::std::string* release_network_type();
        void set_allocated_network_type(::std::string* network_type);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Performance)
    private:
        inline void set_has_bandwidth();
        inline void clear_has_bandwidth();
        inline void set_has_metered();
        inline void clear_has_metered();
        inline void set_has_network_type();
        inline void clear_has_network_type();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        float bandwidth_;
        bool metered_;
        ::google::protobuf::internal::ArenaStringPtr network_type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_Performance* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_UserCharacteristics_Vector : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_UserCharacteristics_Vector();
        virtual ~Fingerprint_UserCharacteristics_Vector();

        Fingerprint_UserCharacteristics_Vector(const Fingerprint_UserCharacteristics_Vector& from);

        inline Fingerprint_UserCharacteristics_Vector& operator=(const Fingerprint_UserCharacteristics_Vector& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_UserCharacteristics_Vector& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_UserCharacteristics_Vector* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_UserCharacteristics_Vector* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_UserCharacteristics_Vector* New() const { return New(NULL); }

        Fingerprint_UserCharacteristics_Vector* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_UserCharacteristics_Vector& from);
        void MergeFrom(const Fingerprint_UserCharacteristics_Vector& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_UserCharacteristics_Vector* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int32 x = 1;
        bool has_x() const;
        void clear_x();
        static const int kXFieldNumber = 1;
        ::google::protobuf::int32 x() const;
        void set_x(::google::protobuf::int32 value);

        // optional int32 y = 2;
        bool has_y() const;
        void clear_y();
        static const int kYFieldNumber = 2;
        ::google::protobuf::int32 y() const;
        void set_y(::google::protobuf::int32 value);

        // optional int32 z = 3;
        bool has_z() const;
        void clear_z();
        static const int kZFieldNumber = 3;
        ::google::protobuf::int32 z() const;
        void set_z(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    private:
        inline void set_has_x();
        inline void clear_has_x();
        inline void set_has_y();
        inline void clear_has_y();
        inline void set_has_z();
        inline void clear_has_z();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int32 x_;
        ::google::protobuf::int32 y_;
        ::google::protobuf::int32 z_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_UserCharacteristics_Vector* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_UserCharacteristics_Location : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_UserCharacteristics_Location();
        virtual ~Fingerprint_UserCharacteristics_Location();

        Fingerprint_UserCharacteristics_Location(const Fingerprint_UserCharacteristics_Location& from);

        inline Fingerprint_UserCharacteristics_Location& operator=(const Fingerprint_UserCharacteristics_Location& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_UserCharacteristics_Location& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_UserCharacteristics_Location* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_UserCharacteristics_Location* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_UserCharacteristics_Location* New() const { return New(NULL); }

        Fingerprint_UserCharacteristics_Location* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_UserCharacteristics_Location& from);
        void MergeFrom(const Fingerprint_UserCharacteristics_Location& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_UserCharacteristics_Location* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional double altitude = 1;
        bool has_altitude() const;
        void clear_altitude();
        static const int kAltitudeFieldNumber = 1;
        double altitude() const;
        void set_altitude(double value);

        // optional double latitude = 2;
        bool has_latitude() const;
        void clear_latitude();
        static const int kLatitudeFieldNumber = 2;
        double latitude() const;
        void set_latitude(double value);

        // optional double longitude = 3;
        bool has_longitude() const;
        void clear_longitude();
        static const int kLongitudeFieldNumber = 3;
        double longitude() const;
        void set_longitude(double value);

        // optional double accuracy = 4;
        bool has_accuracy() const;
        void clear_accuracy();
        static const int kAccuracyFieldNumber = 4;
        double accuracy() const;
        void set_accuracy(double value);

        // optional int64 time_in_ms = 5;
        bool has_time_in_ms() const;
        void clear_time_in_ms();
        static const int kTimeInMsFieldNumber = 5;
        ::google::protobuf::int64 time_in_ms() const;
        void set_time_in_ms(::google::protobuf::int64 value);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Location)
    private:
        inline void set_has_altitude();
        inline void clear_has_altitude();
        inline void set_has_latitude();
        inline void clear_has_latitude();
        inline void set_has_longitude();
        inline void clear_has_longitude();
        inline void set_has_accuracy();
        inline void clear_has_accuracy();
        inline void set_has_time_in_ms();
        inline void clear_has_time_in_ms();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        double altitude_;
        double latitude_;
        double longitude_;
        double accuracy_;
        ::google::protobuf::int64 time_in_ms_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_UserCharacteristics_Location* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_UserCharacteristics : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_UserCharacteristics();
        virtual ~Fingerprint_UserCharacteristics();

        Fingerprint_UserCharacteristics(const Fingerprint_UserCharacteristics& from);

        inline Fingerprint_UserCharacteristics& operator=(const Fingerprint_UserCharacteristics& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_UserCharacteristics& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_UserCharacteristics* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_UserCharacteristics* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_UserCharacteristics* New() const { return New(NULL); }

        Fingerprint_UserCharacteristics* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_UserCharacteristics& from);
        void MergeFrom(const Fingerprint_UserCharacteristics& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_UserCharacteristics* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef Fingerprint_UserCharacteristics_Vector Vector;
        typedef Fingerprint_UserCharacteristics_Location Location;

        // accessors -------------------------------------------------------

        // optional float force = 1;
        bool has_force() const;
        void clear_force();
        static const int kForceFieldNumber = 1;
        float force() const;
        void set_force(float value);

        // optional float touch_width = 2;
        bool has_touch_width() const;
        void clear_touch_width();
        static const int kTouchWidthFieldNumber = 2;
        float touch_width() const;
        void set_touch_width(float value);

        // optional float touch_height = 3;
        bool has_touch_height() const;
        void clear_touch_height();
        static const int kTouchHeightFieldNumber = 3;
        float touch_height() const;
        void set_touch_height(float value);

        // optional int32 touch_rotation = 4;
        bool has_touch_rotation() const;
        void clear_touch_rotation();
        static const int kTouchRotationFieldNumber = 4;
        ::google::protobuf::int32 touch_rotation() const;
        void set_touch_rotation(::google::protobuf::int32 value);

        // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
        bool has_device_orientation() const;
        void clear_device_orientation();
        static const int kDeviceOrientationFieldNumber = 5;
        const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_orientation() const;
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_orientation();
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_orientation();
        void set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation);

        // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
        bool has_device_acceleration() const;
        void clear_device_acceleration();
        static const int kDeviceAccelerationFieldNumber = 6;
        const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_acceleration() const;
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_acceleration();
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_acceleration();
        void set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration);

        // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
        bool has_location() const;
        void clear_location();
        static const int kLocationFieldNumber = 7;
        const ::autofill::risk::Fingerprint_UserCharacteristics_Location& location() const;
        ::autofill::risk::Fingerprint_UserCharacteristics_Location* mutable_location();
        ::autofill::risk::Fingerprint_UserCharacteristics_Location* release_location();
        void set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics)
    private:
        inline void set_has_force();
        inline void clear_has_force();
        inline void set_has_touch_width();
        inline void clear_has_touch_width();
        inline void set_has_touch_height();
        inline void clear_has_touch_height();
        inline void set_has_touch_rotation();
        inline void clear_has_touch_rotation();
        inline void set_has_device_orientation();
        inline void clear_has_device_orientation();
        inline void set_has_device_acceleration();
        inline void clear_has_device_acceleration();
        inline void set_has_location();
        inline void clear_has_location();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        float force_;
        float touch_width_;
        float touch_height_;
        ::google::protobuf::int32 touch_rotation_;
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation_;
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration_;
        ::autofill::risk::Fingerprint_UserCharacteristics_Location* location_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_UserCharacteristics* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint_Metadata : public ::google::protobuf::MessageLite {
    public:
        Fingerprint_Metadata();
        virtual ~Fingerprint_Metadata();

        Fingerprint_Metadata(const Fingerprint_Metadata& from);

        inline Fingerprint_Metadata& operator=(const Fingerprint_Metadata& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint_Metadata& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint_Metadata* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint_Metadata* other);

        // implements Message ----------------------------------------------

        inline Fingerprint_Metadata* New() const { return New(NULL); }

        Fingerprint_Metadata* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint_Metadata& from);
        void MergeFrom(const Fingerprint_Metadata& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint_Metadata* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        // optional int64 timestamp_ms = 1;
        bool has_timestamp_ms() const;
        void clear_timestamp_ms();
        static const int kTimestampMsFieldNumber = 1;
        ::google::protobuf::int64 timestamp_ms() const;
        void set_timestamp_ms(::google::protobuf::int64 value);

        // optional uint64 obfuscated_gaia_id = 2;
        bool has_obfuscated_gaia_id() const;
        void clear_obfuscated_gaia_id();
        static const int kObfuscatedGaiaIdFieldNumber = 2;
        ::google::protobuf::uint64 obfuscated_gaia_id() const;
        void set_obfuscated_gaia_id(::google::protobuf::uint64 value);

        // optional int32 fingerprinter_version = 3;
        bool has_fingerprinter_version() const;
        void clear_fingerprinter_version();
        static const int kFingerprinterVersionFieldNumber = 3;
        ::google::protobuf::int32 fingerprinter_version() const;
        void set_fingerprinter_version(::google::protobuf::int32 value);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Metadata)
    private:
        inline void set_has_timestamp_ms();
        inline void clear_has_timestamp_ms();
        inline void set_has_obfuscated_gaia_id();
        inline void clear_has_obfuscated_gaia_id();
        inline void set_has_fingerprinter_version();
        inline void clear_has_fingerprinter_version();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::google::protobuf::int64 timestamp_ms_;
        ::google::protobuf::uint64 obfuscated_gaia_id_;
        ::google::protobuf::int32 fingerprinter_version_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint_Metadata* default_instance_;
    };
    // -------------------------------------------------------------------

    class Fingerprint : public ::google::protobuf::MessageLite {
    public:
        Fingerprint();
        virtual ~Fingerprint();

        Fingerprint(const Fingerprint& from);

        inline Fingerprint& operator=(const Fingerprint& from)
        {
            CopyFrom(from);
            return *this;
        }

        inline const ::std::string& unknown_fields() const
        {
            return _unknown_fields_.GetNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        inline ::std::string* mutable_unknown_fields()
        {
            return _unknown_fields_.MutableNoArena(
                &::google::protobuf::internal::GetEmptyStringAlreadyInited());
        }

        static const Fingerprint& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        // Returns the internal default instance pointer. This function can
        // return NULL thus should not be used by the user. This is intended
        // for Protobuf internal code. Please use default_instance() declared
        // above instead.
        static inline const Fingerprint* internal_default_instance()
        {
            return default_instance_;
        }
#endif

        GOOGLE_ATTRIBUTE_NOINLINE void Swap(Fingerprint* other);

        // implements Message ----------------------------------------------

        inline Fingerprint* New() const { return New(NULL); }

        Fingerprint* New(::google::protobuf::Arena* arena) const;
        void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
        void CopyFrom(const Fingerprint& from);
        void MergeFrom(const Fingerprint& from);
        void Clear();
        bool IsInitialized() const;

        int ByteSize() const;
        bool MergePartialFromCodedStream(
            ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
            ::google::protobuf::io::CodedOutputStream* output) const;
        void DiscardUnknownFields();
        int GetCachedSize() const { return _cached_size_; }

    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
        void InternalSwap(Fingerprint* other);

    private:
        inline ::google::protobuf::Arena* GetArenaNoVirtual() const
        {
            return _arena_ptr_;
        }
        inline ::google::protobuf::Arena* MaybeArenaPtr() const
        {
            return _arena_ptr_;
        }

    public:
        ::std::string GetTypeName() const;

        // nested types ----------------------------------------------------

        typedef Fingerprint_Dimension Dimension;
        typedef Fingerprint_MachineCharacteristics MachineCharacteristics;
        typedef Fingerprint_TransientState TransientState;
        typedef Fingerprint_Performance Performance;
        typedef Fingerprint_UserCharacteristics UserCharacteristics;
        typedef Fingerprint_Metadata Metadata;

        // accessors -------------------------------------------------------

        // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
        bool has_machine_characteristics() const;
        void clear_machine_characteristics();
        static const int kMachineCharacteristicsFieldNumber = 1;
        const ::autofill::risk::Fingerprint_MachineCharacteristics& machine_characteristics() const;
        ::autofill::risk::Fingerprint_MachineCharacteristics* mutable_machine_characteristics();
        ::autofill::risk::Fingerprint_MachineCharacteristics* release_machine_characteristics();
        void set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics);

        // optional .autofill.risk.Fingerprint.Performance performance = 2;
        bool has_performance() const;
        void clear_performance();
        static const int kPerformanceFieldNumber = 2;
        const ::autofill::risk::Fingerprint_Performance& performance() const;
        ::autofill::risk::Fingerprint_Performance* mutable_performance();
        ::autofill::risk::Fingerprint_Performance* release_performance();
        void set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance);

        // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
        bool has_user_characteristics() const;
        void clear_user_characteristics();
        static const int kUserCharacteristicsFieldNumber = 3;
        const ::autofill::risk::Fingerprint_UserCharacteristics& user_characteristics() const;
        ::autofill::risk::Fingerprint_UserCharacteristics* mutable_user_characteristics();
        ::autofill::risk::Fingerprint_UserCharacteristics* release_user_characteristics();
        void set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics);

        // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
        bool has_transient_state() const;
        void clear_transient_state();
        static const int kTransientStateFieldNumber = 4;
        const ::autofill::risk::Fingerprint_TransientState& transient_state() const;
        ::autofill::risk::Fingerprint_TransientState* mutable_transient_state();
        ::autofill::risk::Fingerprint_TransientState* release_transient_state();
        void set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state);

        // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
        bool has_metadata() const;
        void clear_metadata();
        static const int kMetadataFieldNumber = 5;
        const ::autofill::risk::Fingerprint_Metadata& metadata() const;
        ::autofill::risk::Fingerprint_Metadata* mutable_metadata();
        ::autofill::risk::Fingerprint_Metadata* release_metadata();
        void set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata);

        // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint)
    private:
        inline void set_has_machine_characteristics();
        inline void clear_has_machine_characteristics();
        inline void set_has_performance();
        inline void clear_has_performance();
        inline void set_has_user_characteristics();
        inline void clear_has_user_characteristics();
        inline void set_has_transient_state();
        inline void clear_has_transient_state();
        inline void set_has_metadata();
        inline void clear_has_metadata();

        ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
        ::google::protobuf::Arena* _arena_ptr_;

        ::google::protobuf::uint32 _has_bits_[1];
        mutable int _cached_size_;
        ::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics_;
        ::autofill::risk::Fingerprint_Performance* performance_;
        ::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics_;
        ::autofill::risk::Fingerprint_TransientState* transient_state_;
        ::autofill::risk::Fingerprint_Metadata* metadata_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        friend void protobuf_AddDesc_fingerprint_2eproto_impl();
#else
        friend void protobuf_AddDesc_fingerprint_2eproto();
#endif
        friend void protobuf_AssignDesc_fingerprint_2eproto();
        friend void protobuf_ShutdownFile_fingerprint_2eproto();

        void InitAsDefaultInstance();
        static Fingerprint* default_instance_;
    };
    // ===================================================================

    // ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
    // Fingerprint_Dimension

    // optional int32 width = 1;
    inline bool Fingerprint_Dimension::has_width() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_Dimension::set_has_width()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_Dimension::clear_has_width()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_Dimension::clear_width()
    {
        width_ = 0;
        clear_has_width();
    }
    inline ::google::protobuf::int32 Fingerprint_Dimension::width() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.width)
        return width_;
    }
    inline void Fingerprint_Dimension::set_width(::google::protobuf::int32 value)
    {
        set_has_width();
        width_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.width)
    }

    // optional int32 height = 2;
    inline bool Fingerprint_Dimension::has_height() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_Dimension::set_has_height()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_Dimension::clear_has_height()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_Dimension::clear_height()
    {
        height_ = 0;
        clear_has_height();
    }
    inline ::google::protobuf::int32 Fingerprint_Dimension::height() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.height)
        return height_;
    }
    inline void Fingerprint_Dimension::set_height(::google::protobuf::int32 value)
    {
        set_has_height();
        height_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.height)
    }

    // -------------------------------------------------------------------

    // Fingerprint_MachineCharacteristics_Plugin

    // optional string name = 1;
    inline bool Fingerprint_MachineCharacteristics_Plugin::has_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_has_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::clear_name()
    {
        name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_name();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Plugin::name() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
        return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_name(const ::std::string& value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_name(const char* value)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_name(const char* value, size_t size)
    {
        set_has_name();
        name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_name()
    {
        set_has_name();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
        return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::release_name()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
        clear_has_name();
        return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_name(::std::string* name)
    {
        if (name != NULL) {
            set_has_name();
        } else {
            clear_has_name();
        }
        name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
    }

    // optional string description = 2;
    inline bool Fingerprint_MachineCharacteristics_Plugin::has_description() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_has_description()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::clear_has_description()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::clear_description()
    {
        description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_description();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Plugin::description() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
        return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_description(const ::std::string& value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_description(const char* value)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_description(const char* value, size_t size)
    {
        set_has_description();
        description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_description()
    {
        set_has_description();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
        return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::release_description()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
        clear_has_description();
        return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_description(::std::string* description)
    {
        if (description != NULL) {
            set_has_description();
        } else {
            clear_has_description();
        }
        description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
    }

    // repeated string mime_type = 3;
    inline int Fingerprint_MachineCharacteristics_Plugin::mime_type_size() const
    {
        return mime_type_.size();
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::clear_mime_type()
    {
        mime_type_.Clear();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Plugin::mime_type(int index) const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
        return mime_type_.Get(index);
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type(int index)
    {
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
        return mime_type_.Mutable(index);
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const ::std::string& value)
    {
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
        mime_type_.Mutable(index)->assign(value);
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value)
    {
        mime_type_.Mutable(index)->assign(value);
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value, size_t size)
    {
        mime_type_.Mutable(index)->assign(
            reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::add_mime_type()
    {
        // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
        return mime_type_.Add();
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const ::std::string& value)
    {
        mime_type_.Add()->assign(value);
        // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value)
    {
        mime_type_.Add()->assign(value);
        // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value, size_t size)
    {
        mime_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    }
    inline const ::google::protobuf::RepeatedPtrField<::std::string>&
    Fingerprint_MachineCharacteristics_Plugin::mime_type() const
    {
        // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
        return mime_type_;
    }
    inline ::google::protobuf::RepeatedPtrField<::std::string>*
    Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type()
    {
        // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
        return &mime_type_;
    }

    // optional string version = 4;
    inline bool Fingerprint_MachineCharacteristics_Plugin::has_version() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_has_version()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::clear_has_version()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::clear_version()
    {
        version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_version();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Plugin::version() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
        return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_version(const ::std::string& value)
    {
        set_has_version();
        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_version(const char* value)
    {
        set_has_version();
        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_version(const char* value, size_t size)
    {
        set_has_version();
        version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_version()
    {
        set_has_version();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
        return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Plugin::release_version()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
        clear_has_version();
        return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_version(::std::string* version)
    {
        if (version != NULL) {
            set_has_version();
        } else {
            clear_has_version();
        }
        version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
    }

    // -------------------------------------------------------------------

    // Fingerprint_MachineCharacteristics_Cpu

    // optional string vendor_name = 1;
    inline bool Fingerprint_MachineCharacteristics_Cpu::has_vendor_name() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_has_vendor_name()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::clear_has_vendor_name()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::clear_vendor_name()
    {
        vendor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_vendor_name();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Cpu::vendor_name() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
        return vendor_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(const ::std::string& value)
    {
        set_has_vendor_name();
        vendor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(const char* value)
    {
        set_has_vendor_name();
        vendor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(const char* value, size_t size)
    {
        set_has_vendor_name();
        vendor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_vendor_name()
    {
        set_has_vendor_name();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
        return vendor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Cpu::release_vendor_name()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
        clear_has_vendor_name();
        return vendor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_vendor_name(::std::string* vendor_name)
    {
        if (vendor_name != NULL) {
            set_has_vendor_name();
        } else {
            clear_has_vendor_name();
        }
        vendor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor_name);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
    }

    // optional string brand = 2;
    inline bool Fingerprint_MachineCharacteristics_Cpu::has_brand() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_has_brand()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::clear_has_brand()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::clear_brand()
    {
        brand_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_brand();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Cpu::brand() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
        return brand_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_brand(const ::std::string& value)
    {
        set_has_brand();
        brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_brand(const char* value)
    {
        set_has_brand();
        brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_brand(const char* value, size_t size)
    {
        set_has_brand();
        brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_brand()
    {
        set_has_brand();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
        return brand_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Cpu::release_brand()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
        clear_has_brand();
        return brand_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_brand(::std::string* brand)
    {
        if (brand != NULL) {
            set_has_brand();
        } else {
            clear_has_brand();
        }
        brand_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), brand);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
    }

    // -------------------------------------------------------------------

    // Fingerprint_MachineCharacteristics_Graphics

    // optional uint32 vendor_id = 1;
    inline bool Fingerprint_MachineCharacteristics_Graphics::has_vendor_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_has_vendor_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_has_vendor_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_vendor_id()
    {
        vendor_id_ = 0u;
        clear_has_vendor_id();
    }
    inline ::google::protobuf::uint32 Fingerprint_MachineCharacteristics_Graphics::vendor_id() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
        return vendor_id_;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_vendor_id(::google::protobuf::uint32 value)
    {
        set_has_vendor_id();
        vendor_id_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
    }

    // optional uint32 device_id = 2;
    inline bool Fingerprint_MachineCharacteristics_Graphics::has_device_id() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_has_device_id()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_has_device_id()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_device_id()
    {
        device_id_ = 0u;
        clear_has_device_id();
    }
    inline ::google::protobuf::uint32 Fingerprint_MachineCharacteristics_Graphics::device_id() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
        return device_id_;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_device_id(::google::protobuf::uint32 value)
    {
        set_has_device_id();
        device_id_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
    }

    // optional string driver_version = 3;
    inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_version() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_has_driver_version()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_has_driver_version()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_version()
    {
        driver_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_driver_version();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Graphics::driver_version() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
        return driver_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(const ::std::string& value)
    {
        set_has_driver_version();
        driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(const char* value)
    {
        set_has_driver_version();
        driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(const char* value, size_t size)
    {
        set_has_driver_version();
        driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_version()
    {
        set_has_driver_version();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
        return driver_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_version()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
        clear_has_driver_version();
        return driver_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_version(::std::string* driver_version)
    {
        if (driver_version != NULL) {
            set_has_driver_version();
        } else {
            clear_has_driver_version();
        }
        driver_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_version);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
    }

    // optional string driver_date = 4;
    inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_date() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_has_driver_date()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_has_driver_date()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_date()
    {
        driver_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_driver_date();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics_Graphics::driver_date() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
        return driver_date_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(const ::std::string& value)
    {
        set_has_driver_date();
        driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(const char* value)
    {
        set_has_driver_date();
        driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(const char* value, size_t size)
    {
        set_has_driver_date();
        driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_date()
    {
        set_has_driver_date();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
        return driver_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_date()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
        clear_has_driver_date();
        return driver_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_date(::std::string* driver_date)
    {
        if (driver_date != NULL) {
            set_has_driver_date();
        } else {
            clear_has_driver_date();
        }
        driver_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_date);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
    }

    // -------------------------------------------------------------------

    // Fingerprint_MachineCharacteristics

    // optional fixed64 user_and_device_name_hash = 1;
    inline bool Fingerprint_MachineCharacteristics::has_user_and_device_name_hash() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_user_and_device_name_hash()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_user_and_device_name_hash()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_user_and_device_name_hash()
    {
        user_and_device_name_hash_ = GOOGLE_ULONGLONG(0);
        clear_has_user_and_device_name_hash();
    }
    inline ::google::protobuf::uint64 Fingerprint_MachineCharacteristics::user_and_device_name_hash() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
        return user_and_device_name_hash_;
    }
    inline void Fingerprint_MachineCharacteristics::set_user_and_device_name_hash(::google::protobuf::uint64 value)
    {
        set_has_user_and_device_name_hash();
        user_and_device_name_hash_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
    }

    // optional string operating_system_build = 2;
    inline bool Fingerprint_MachineCharacteristics::has_operating_system_build() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_operating_system_build()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_operating_system_build()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_operating_system_build()
    {
        operating_system_build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_operating_system_build();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics::operating_system_build() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
        return operating_system_build_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_operating_system_build(const ::std::string& value)
    {
        set_has_operating_system_build();
        operating_system_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
    }
    inline void Fingerprint_MachineCharacteristics::set_operating_system_build(const char* value)
    {
        set_has_operating_system_build();
        operating_system_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
    }
    inline void Fingerprint_MachineCharacteristics::set_operating_system_build(const char* value, size_t size)
    {
        set_has_operating_system_build();
        operating_system_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::mutable_operating_system_build()
    {
        set_has_operating_system_build();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
        return operating_system_build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::release_operating_system_build()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
        clear_has_operating_system_build();
        return operating_system_build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_operating_system_build(::std::string* operating_system_build)
    {
        if (operating_system_build != NULL) {
            set_has_operating_system_build();
        } else {
            clear_has_operating_system_build();
        }
        operating_system_build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operating_system_build);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
    }

    // optional int64 browser_install_time_hours = 3;
    inline bool Fingerprint_MachineCharacteristics::has_browser_install_time_hours() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_browser_install_time_hours()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_browser_install_time_hours()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_browser_install_time_hours()
    {
        browser_install_time_hours_ = GOOGLE_LONGLONG(0);
        clear_has_browser_install_time_hours();
    }
    inline ::google::protobuf::int64 Fingerprint_MachineCharacteristics::browser_install_time_hours() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
        return browser_install_time_hours_;
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_install_time_hours(::google::protobuf::int64 value)
    {
        set_has_browser_install_time_hours();
        browser_install_time_hours_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
    }

    // repeated string font = 4;
    inline int Fingerprint_MachineCharacteristics::font_size() const
    {
        return font_.size();
    }
    inline void Fingerprint_MachineCharacteristics::clear_font()
    {
        font_.Clear();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics::font(int index) const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.font)
        return font_.Get(index);
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::mutable_font(int index)
    {
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
        return font_.Mutable(index);
    }
    inline void Fingerprint_MachineCharacteristics::set_font(int index, const ::std::string& value)
    {
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.font)
        font_.Mutable(index)->assign(value);
    }
    inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value)
    {
        font_.Mutable(index)->assign(value);
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
    }
    inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value, size_t size)
    {
        font_.Mutable(index)->assign(
            reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::add_font()
    {
        // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
        return font_.Add();
    }
    inline void Fingerprint_MachineCharacteristics::add_font(const ::std::string& value)
    {
        font_.Add()->assign(value);
        // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.font)
    }
    inline void Fingerprint_MachineCharacteristics::add_font(const char* value)
    {
        font_.Add()->assign(value);
        // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
    }
    inline void Fingerprint_MachineCharacteristics::add_font(const char* value, size_t size)
    {
        font_.Add()->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
    }
    inline const ::google::protobuf::RepeatedPtrField<::std::string>&
    Fingerprint_MachineCharacteristics::font() const
    {
        // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
        return font_;
    }
    inline ::google::protobuf::RepeatedPtrField<::std::string>*
    Fingerprint_MachineCharacteristics::mutable_font()
    {
        // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
        return &font_;
    }

    // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
    inline int Fingerprint_MachineCharacteristics::plugin_size() const
    {
        return plugin_.size();
    }
    inline void Fingerprint_MachineCharacteristics::clear_plugin()
    {
        plugin_.Clear();
    }
    inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& Fingerprint_MachineCharacteristics::plugin(int index) const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
        return plugin_.Get(index);
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::mutable_plugin(int index)
    {
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
        return plugin_.Mutable(index);
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::add_plugin()
    {
        // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
        return plugin_.Add();
    }
    inline ::google::protobuf::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>*
    Fingerprint_MachineCharacteristics::mutable_plugin()
    {
        // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
        return &plugin_;
    }
    inline const ::google::protobuf::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>&
    Fingerprint_MachineCharacteristics::plugin() const
    {
        // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
        return plugin_;
    }

    // optional int64 utc_offset_ms = 6;
    inline bool Fingerprint_MachineCharacteristics::has_utc_offset_ms() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_utc_offset_ms()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_utc_offset_ms()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_utc_offset_ms()
    {
        utc_offset_ms_ = GOOGLE_LONGLONG(0);
        clear_has_utc_offset_ms();
    }
    inline ::google::protobuf::int64 Fingerprint_MachineCharacteristics::utc_offset_ms() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
        return utc_offset_ms_;
    }
    inline void Fingerprint_MachineCharacteristics::set_utc_offset_ms(::google::protobuf::int64 value)
    {
        set_has_utc_offset_ms();
        utc_offset_ms_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
    }

    // optional string browser_language = 7;
    inline bool Fingerprint_MachineCharacteristics::has_browser_language() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_browser_language()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_browser_language()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_browser_language()
    {
        browser_language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_browser_language();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics::browser_language() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
        return browser_language_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_language(const ::std::string& value)
    {
        set_has_browser_language();
        browser_language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_language(const char* value)
    {
        set_has_browser_language();
        browser_language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_language(const char* value, size_t size)
    {
        set_has_browser_language();
        browser_language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::mutable_browser_language()
    {
        set_has_browser_language();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
        return browser_language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::release_browser_language()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
        clear_has_browser_language();
        return browser_language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_browser_language(::std::string* browser_language)
    {
        if (browser_language != NULL) {
            set_has_browser_language();
        } else {
            clear_has_browser_language();
        }
        browser_language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), browser_language);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
    }

    // repeated string requested_language = 8;
    inline int Fingerprint_MachineCharacteristics::requested_language_size() const
    {
        return requested_language_.size();
    }
    inline void Fingerprint_MachineCharacteristics::clear_requested_language()
    {
        requested_language_.Clear();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics::requested_language(int index) const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
        return requested_language_.Get(index);
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::mutable_requested_language(int index)
    {
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
        return requested_language_.Mutable(index);
    }
    inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const ::std::string& value)
    {
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
        requested_language_.Mutable(index)->assign(value);
    }
    inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value)
    {
        requested_language_.Mutable(index)->assign(value);
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    }
    inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value, size_t size)
    {
        requested_language_.Mutable(index)->assign(
            reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::add_requested_language()
    {
        // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
        return requested_language_.Add();
    }
    inline void Fingerprint_MachineCharacteristics::add_requested_language(const ::std::string& value)
    {
        requested_language_.Add()->assign(value);
        // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    }
    inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value)
    {
        requested_language_.Add()->assign(value);
        // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    }
    inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value, size_t size)
    {
        requested_language_.Add()->assign(reinterpret_cast<const char*>(value), size);
        // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    }
    inline const ::google::protobuf::RepeatedPtrField<::std::string>&
    Fingerprint_MachineCharacteristics::requested_language() const
    {
        // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
        return requested_language_;
    }
    inline ::google::protobuf::RepeatedPtrField<::std::string>*
    Fingerprint_MachineCharacteristics::mutable_requested_language()
    {
        // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
        return &requested_language_;
    }

    // optional string charset = 9;
    inline bool Fingerprint_MachineCharacteristics::has_charset() const
    {
        return (_has_bits_[0] & 0x00000100u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_charset()
    {
        _has_bits_[0] |= 0x00000100u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_charset()
    {
        _has_bits_[0] &= ~0x00000100u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_charset()
    {
        charset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_charset();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics::charset() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.charset)
        return charset_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_charset(const ::std::string& value)
    {
        set_has_charset();
        charset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.charset)
    }
    inline void Fingerprint_MachineCharacteristics::set_charset(const char* value)
    {
        set_has_charset();
        charset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.charset)
    }
    inline void Fingerprint_MachineCharacteristics::set_charset(const char* value, size_t size)
    {
        set_has_charset();
        charset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.charset)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::mutable_charset()
    {
        set_has_charset();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.charset)
        return charset_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::release_charset()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.charset)
        clear_has_charset();
        return charset_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_charset(::std::string* charset)
    {
        if (charset != NULL) {
            set_has_charset();
        } else {
            clear_has_charset();
        }
        charset_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), charset);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.charset)
    }

    // optional int32 screen_count = 10;
    inline bool Fingerprint_MachineCharacteristics::has_screen_count() const
    {
        return (_has_bits_[0] & 0x00000200u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_screen_count()
    {
        _has_bits_[0] |= 0x00000200u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_screen_count()
    {
        _has_bits_[0] &= ~0x00000200u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_screen_count()
    {
        screen_count_ = 0;
        clear_has_screen_count();
    }
    inline ::google::protobuf::int32 Fingerprint_MachineCharacteristics::screen_count() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
        return screen_count_;
    }
    inline void Fingerprint_MachineCharacteristics::set_screen_count(::google::protobuf::int32 value)
    {
        set_has_screen_count();
        screen_count_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
    }

    // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
    inline bool Fingerprint_MachineCharacteristics::has_screen_size() const
    {
        return (_has_bits_[0] & 0x00000400u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_screen_size()
    {
        _has_bits_[0] |= 0x00000400u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_screen_size()
    {
        _has_bits_[0] &= ~0x00000400u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_screen_size()
    {
        if (screen_size_ != NULL)
            screen_size_->::autofill::risk::Fingerprint_Dimension::Clear();
        clear_has_screen_size();
    }
    inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::screen_size() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return screen_size_ != NULL ? *screen_size_ : *default_instance().screen_size_;
#else
        return screen_size_ != NULL ? *screen_size_ : *default_instance_->screen_size_;
#endif
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_screen_size()
    {
        set_has_screen_size();
        if (screen_size_ == NULL) {
            screen_size_ = new ::autofill::risk::Fingerprint_Dimension;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
        return screen_size_;
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_screen_size()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
        clear_has_screen_size();
        ::autofill::risk::Fingerprint_Dimension* temp = screen_size_;
        screen_size_ = NULL;
        return temp;
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size)
    {
        delete screen_size_;
        screen_size_ = screen_size;
        if (screen_size) {
            set_has_screen_size();
        } else {
            clear_has_screen_size();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
    }

    // optional int32 screen_color_depth = 12;
    inline bool Fingerprint_MachineCharacteristics::has_screen_color_depth() const
    {
        return (_has_bits_[0] & 0x00000800u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_screen_color_depth()
    {
        _has_bits_[0] |= 0x00000800u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_screen_color_depth()
    {
        _has_bits_[0] &= ~0x00000800u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_screen_color_depth()
    {
        screen_color_depth_ = 0;
        clear_has_screen_color_depth();
    }
    inline ::google::protobuf::int32 Fingerprint_MachineCharacteristics::screen_color_depth() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
        return screen_color_depth_;
    }
    inline void Fingerprint_MachineCharacteristics::set_screen_color_depth(::google::protobuf::int32 value)
    {
        set_has_screen_color_depth();
        screen_color_depth_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
    }

    // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
    inline bool Fingerprint_MachineCharacteristics::has_unavailable_screen_size() const
    {
        return (_has_bits_[0] & 0x00001000u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_unavailable_screen_size()
    {
        _has_bits_[0] |= 0x00001000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_unavailable_screen_size()
    {
        _has_bits_[0] &= ~0x00001000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_unavailable_screen_size()
    {
        if (unavailable_screen_size_ != NULL)
            unavailable_screen_size_->::autofill::risk::Fingerprint_Dimension::Clear();
        clear_has_unavailable_screen_size();
    }
    inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::unavailable_screen_size() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return unavailable_screen_size_ != NULL ? *unavailable_screen_size_ : *default_instance().unavailable_screen_size_;
#else
        return unavailable_screen_size_ != NULL ? *unavailable_screen_size_ : *default_instance_->unavailable_screen_size_;
#endif
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_unavailable_screen_size()
    {
        set_has_unavailable_screen_size();
        if (unavailable_screen_size_ == NULL) {
            unavailable_screen_size_ = new ::autofill::risk::Fingerprint_Dimension;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
        return unavailable_screen_size_;
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_unavailable_screen_size()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
        clear_has_unavailable_screen_size();
        ::autofill::risk::Fingerprint_Dimension* temp = unavailable_screen_size_;
        unavailable_screen_size_ = NULL;
        return temp;
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size)
    {
        delete unavailable_screen_size_;
        unavailable_screen_size_ = unavailable_screen_size;
        if (unavailable_screen_size) {
            set_has_unavailable_screen_size();
        } else {
            clear_has_unavailable_screen_size();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
    }

    // optional string user_agent = 14;
    inline bool Fingerprint_MachineCharacteristics::has_user_agent() const
    {
        return (_has_bits_[0] & 0x00002000u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_user_agent()
    {
        _has_bits_[0] |= 0x00002000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_user_agent()
    {
        _has_bits_[0] &= ~0x00002000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_user_agent()
    {
        user_agent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_user_agent();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics::user_agent() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
        return user_agent_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_user_agent(const ::std::string& value)
    {
        set_has_user_agent();
        user_agent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
    }
    inline void Fingerprint_MachineCharacteristics::set_user_agent(const char* value)
    {
        set_has_user_agent();
        user_agent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
    }
    inline void Fingerprint_MachineCharacteristics::set_user_agent(const char* value, size_t size)
    {
        set_has_user_agent();
        user_agent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::mutable_user_agent()
    {
        set_has_user_agent();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
        return user_agent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::release_user_agent()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
        clear_has_user_agent();
        return user_agent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_user_agent(::std::string* user_agent)
    {
        if (user_agent != NULL) {
            set_has_user_agent();
        } else {
            clear_has_user_agent();
        }
        user_agent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_agent);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
    }

    // repeated int32 partition_size = 15;
    inline int Fingerprint_MachineCharacteristics::partition_size_size() const
    {
        return partition_size_.size();
    }
    inline void Fingerprint_MachineCharacteristics::clear_partition_size()
    {
        partition_size_.Clear();
    }
    inline ::google::protobuf::int32 Fingerprint_MachineCharacteristics::partition_size(int index) const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
        return partition_size_.Get(index);
    }
    inline void Fingerprint_MachineCharacteristics::set_partition_size(int index, ::google::protobuf::int32 value)
    {
        partition_size_.Set(index, value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
    }
    inline void Fingerprint_MachineCharacteristics::add_partition_size(::google::protobuf::int32 value)
    {
        partition_size_.Add(value);
        // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
    }
    inline const ::google::protobuf::RepeatedField<::google::protobuf::int32>&
    Fingerprint_MachineCharacteristics::partition_size() const
    {
        // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
        return partition_size_;
    }
    inline ::google::protobuf::RepeatedField<::google::protobuf::int32>*
    Fingerprint_MachineCharacteristics::mutable_partition_size()
    {
        // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
        return &partition_size_;
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
    inline bool Fingerprint_MachineCharacteristics::has_cpu() const
    {
        return (_has_bits_[0] & 0x00008000u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_cpu()
    {
        _has_bits_[0] |= 0x00008000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_cpu()
    {
        _has_bits_[0] &= ~0x00008000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_cpu()
    {
        if (cpu_ != NULL)
            cpu_->::autofill::risk::Fingerprint_MachineCharacteristics_Cpu::Clear();
        clear_has_cpu();
    }
    inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& Fingerprint_MachineCharacteristics::cpu() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return cpu_ != NULL ? *cpu_ : *default_instance().cpu_;
#else
        return cpu_ != NULL ? *cpu_ : *default_instance_->cpu_;
#endif
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::mutable_cpu()
    {
        set_has_cpu();
        if (cpu_ == NULL) {
            cpu_ = new ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
        return cpu_;
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::release_cpu()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
        clear_has_cpu();
        ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* temp = cpu_;
        cpu_ = NULL;
        return temp;
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu)
    {
        delete cpu_;
        cpu_ = cpu;
        if (cpu) {
            set_has_cpu();
        } else {
            clear_has_cpu();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
    }

    // optional int64 ram = 17;
    inline bool Fingerprint_MachineCharacteristics::has_ram() const
    {
        return (_has_bits_[0] & 0x00010000u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_ram()
    {
        _has_bits_[0] |= 0x00010000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_ram()
    {
        _has_bits_[0] &= ~0x00010000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_ram()
    {
        ram_ = GOOGLE_LONGLONG(0);
        clear_has_ram();
    }
    inline ::google::protobuf::int64 Fingerprint_MachineCharacteristics::ram() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.ram)
        return ram_;
    }
    inline void Fingerprint_MachineCharacteristics::set_ram(::google::protobuf::int64 value)
    {
        set_has_ram();
        ram_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.ram)
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
    inline bool Fingerprint_MachineCharacteristics::has_graphics_card() const
    {
        return (_has_bits_[0] & 0x00020000u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_graphics_card()
    {
        _has_bits_[0] |= 0x00020000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_graphics_card()
    {
        _has_bits_[0] &= ~0x00020000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_graphics_card()
    {
        if (graphics_card_ != NULL)
            graphics_card_->::autofill::risk::Fingerprint_MachineCharacteristics_Graphics::Clear();
        clear_has_graphics_card();
    }
    inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& Fingerprint_MachineCharacteristics::graphics_card() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return graphics_card_ != NULL ? *graphics_card_ : *default_instance().graphics_card_;
#else
        return graphics_card_ != NULL ? *graphics_card_ : *default_instance_->graphics_card_;
#endif
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::mutable_graphics_card()
    {
        set_has_graphics_card();
        if (graphics_card_ == NULL) {
            graphics_card_ = new ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
        return graphics_card_;
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::release_graphics_card()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
        clear_has_graphics_card();
        ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* temp = graphics_card_;
        graphics_card_ = NULL;
        return temp;
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card)
    {
        delete graphics_card_;
        graphics_card_ = graphics_card;
        if (graphics_card) {
            set_has_graphics_card();
        } else {
            clear_has_graphics_card();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
    }

    // optional string browser_build = 19;
    inline bool Fingerprint_MachineCharacteristics::has_browser_build() const
    {
        return (_has_bits_[0] & 0x00040000u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_browser_build()
    {
        _has_bits_[0] |= 0x00040000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_browser_build()
    {
        _has_bits_[0] &= ~0x00040000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_browser_build()
    {
        browser_build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_browser_build();
    }
    inline const ::std::string& Fingerprint_MachineCharacteristics::browser_build() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
        return browser_build_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_build(const ::std::string& value)
    {
        set_has_browser_build();
        browser_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_build(const char* value)
    {
        set_has_browser_build();
        browser_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_build(const char* value, size_t size)
    {
        set_has_browser_build();
        browser_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::mutable_browser_build()
    {
        set_has_browser_build();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
        return browser_build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_MachineCharacteristics::release_browser_build()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
        clear_has_browser_build();
        return browser_build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_MachineCharacteristics::set_allocated_browser_build(::std::string* browser_build)
    {
        if (browser_build != NULL) {
            set_has_browser_build();
        } else {
            clear_has_browser_build();
        }
        browser_build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), browser_build);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
    inline bool Fingerprint_MachineCharacteristics::has_browser_feature() const
    {
        return (_has_bits_[0] & 0x00080000u) != 0;
    }
    inline void Fingerprint_MachineCharacteristics::set_has_browser_feature()
    {
        _has_bits_[0] |= 0x00080000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_has_browser_feature()
    {
        _has_bits_[0] &= ~0x00080000u;
    }
    inline void Fingerprint_MachineCharacteristics::clear_browser_feature()
    {
        browser_feature_ = 0;
        clear_has_browser_feature();
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::browser_feature() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
        return static_cast<::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature>(browser_feature_);
    }
    inline void Fingerprint_MachineCharacteristics::set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value)
    {
        assert(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value));
        set_has_browser_feature();
        browser_feature_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
    }

    // -------------------------------------------------------------------

    // Fingerprint_TransientState

    // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
    inline bool Fingerprint_TransientState::has_inner_window_size() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_TransientState::set_has_inner_window_size()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_TransientState::clear_has_inner_window_size()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_TransientState::clear_inner_window_size()
    {
        if (inner_window_size_ != NULL)
            inner_window_size_->::autofill::risk::Fingerprint_Dimension::Clear();
        clear_has_inner_window_size();
    }
    inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::inner_window_size() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.inner_window_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return inner_window_size_ != NULL ? *inner_window_size_ : *default_instance().inner_window_size_;
#else
        return inner_window_size_ != NULL ? *inner_window_size_ : *default_instance_->inner_window_size_;
#endif
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_inner_window_size()
    {
        set_has_inner_window_size();
        if (inner_window_size_ == NULL) {
            inner_window_size_ = new ::autofill::risk::Fingerprint_Dimension;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.inner_window_size)
        return inner_window_size_;
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_inner_window_size()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.inner_window_size)
        clear_has_inner_window_size();
        ::autofill::risk::Fingerprint_Dimension* temp = inner_window_size_;
        inner_window_size_ = NULL;
        return temp;
    }
    inline void Fingerprint_TransientState::set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size)
    {
        delete inner_window_size_;
        inner_window_size_ = inner_window_size;
        if (inner_window_size) {
            set_has_inner_window_size();
        } else {
            clear_has_inner_window_size();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.inner_window_size)
    }

    // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
    inline bool Fingerprint_TransientState::has_outer_window_size() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_TransientState::set_has_outer_window_size()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_TransientState::clear_has_outer_window_size()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_TransientState::clear_outer_window_size()
    {
        if (outer_window_size_ != NULL)
            outer_window_size_->::autofill::risk::Fingerprint_Dimension::Clear();
        clear_has_outer_window_size();
    }
    inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::outer_window_size() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.outer_window_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return outer_window_size_ != NULL ? *outer_window_size_ : *default_instance().outer_window_size_;
#else
        return outer_window_size_ != NULL ? *outer_window_size_ : *default_instance_->outer_window_size_;
#endif
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_outer_window_size()
    {
        set_has_outer_window_size();
        if (outer_window_size_ == NULL) {
            outer_window_size_ = new ::autofill::risk::Fingerprint_Dimension;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.outer_window_size)
        return outer_window_size_;
    }
    inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_outer_window_size()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.outer_window_size)
        clear_has_outer_window_size();
        ::autofill::risk::Fingerprint_Dimension* temp = outer_window_size_;
        outer_window_size_ = NULL;
        return temp;
    }
    inline void Fingerprint_TransientState::set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size)
    {
        delete outer_window_size_;
        outer_window_size_ = outer_window_size;
        if (outer_window_size) {
            set_has_outer_window_size();
        } else {
            clear_has_outer_window_size();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.outer_window_size)
    }

    // -------------------------------------------------------------------

    // Fingerprint_Performance

    // optional float bandwidth = 1;
    inline bool Fingerprint_Performance::has_bandwidth() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_Performance::set_has_bandwidth()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_Performance::clear_has_bandwidth()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_Performance::clear_bandwidth()
    {
        bandwidth_ = 0;
        clear_has_bandwidth();
    }
    inline float Fingerprint_Performance::bandwidth() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.bandwidth)
        return bandwidth_;
    }
    inline void Fingerprint_Performance::set_bandwidth(float value)
    {
        set_has_bandwidth();
        bandwidth_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.bandwidth)
    }

    // optional bool metered = 2;
    inline bool Fingerprint_Performance::has_metered() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_Performance::set_has_metered()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_Performance::clear_has_metered()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_Performance::clear_metered()
    {
        metered_ = false;
        clear_has_metered();
    }
    inline bool Fingerprint_Performance::metered() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.metered)
        return metered_;
    }
    inline void Fingerprint_Performance::set_metered(bool value)
    {
        set_has_metered();
        metered_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.metered)
    }

    // optional string network_type = 3;
    inline bool Fingerprint_Performance::has_network_type() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint_Performance::set_has_network_type()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint_Performance::clear_has_network_type()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint_Performance::clear_network_type()
    {
        network_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
        clear_has_network_type();
    }
    inline const ::std::string& Fingerprint_Performance::network_type() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.network_type)
        return network_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_Performance::set_network_type(const ::std::string& value)
    {
        set_has_network_type();
        network_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.network_type)
    }
    inline void Fingerprint_Performance::set_network_type(const char* value)
    {
        set_has_network_type();
        network_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
        // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.Performance.network_type)
    }
    inline void Fingerprint_Performance::set_network_type(const char* value, size_t size)
    {
        set_has_network_type();
        network_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
            ::std::string(reinterpret_cast<const char*>(value), size));
        // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.Performance.network_type)
    }
    inline ::std::string* Fingerprint_Performance::mutable_network_type()
    {
        set_has_network_type();
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.Performance.network_type)
        return network_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline ::std::string* Fingerprint_Performance::release_network_type()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.Performance.network_type)
        clear_has_network_type();
        return network_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    inline void Fingerprint_Performance::set_allocated_network_type(::std::string* network_type)
    {
        if (network_type != NULL) {
            set_has_network_type();
        } else {
            clear_has_network_type();
        }
        network_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network_type);
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.Performance.network_type)
    }

    // -------------------------------------------------------------------

    // Fingerprint_UserCharacteristics_Vector

    // optional int32 x = 1;
    inline bool Fingerprint_UserCharacteristics_Vector::has_x() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Vector::set_has_x()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_UserCharacteristics_Vector::clear_has_x()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_UserCharacteristics_Vector::clear_x()
    {
        x_ = 0;
        clear_has_x();
    }
    inline ::google::protobuf::int32 Fingerprint_UserCharacteristics_Vector::x() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
        return x_;
    }
    inline void Fingerprint_UserCharacteristics_Vector::set_x(::google::protobuf::int32 value)
    {
        set_has_x();
        x_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
    }

    // optional int32 y = 2;
    inline bool Fingerprint_UserCharacteristics_Vector::has_y() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Vector::set_has_y()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_UserCharacteristics_Vector::clear_has_y()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_UserCharacteristics_Vector::clear_y()
    {
        y_ = 0;
        clear_has_y();
    }
    inline ::google::protobuf::int32 Fingerprint_UserCharacteristics_Vector::y() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
        return y_;
    }
    inline void Fingerprint_UserCharacteristics_Vector::set_y(::google::protobuf::int32 value)
    {
        set_has_y();
        y_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
    }

    // optional int32 z = 3;
    inline bool Fingerprint_UserCharacteristics_Vector::has_z() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Vector::set_has_z()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint_UserCharacteristics_Vector::clear_has_z()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint_UserCharacteristics_Vector::clear_z()
    {
        z_ = 0;
        clear_has_z();
    }
    inline ::google::protobuf::int32 Fingerprint_UserCharacteristics_Vector::z() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
        return z_;
    }
    inline void Fingerprint_UserCharacteristics_Vector::set_z(::google::protobuf::int32 value)
    {
        set_has_z();
        z_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
    }

    // -------------------------------------------------------------------

    // Fingerprint_UserCharacteristics_Location

    // optional double altitude = 1;
    inline bool Fingerprint_UserCharacteristics_Location::has_altitude() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_has_altitude()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_has_altitude()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_altitude()
    {
        altitude_ = 0;
        clear_has_altitude();
    }
    inline double Fingerprint_UserCharacteristics_Location::altitude() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
        return altitude_;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_altitude(double value)
    {
        set_has_altitude();
        altitude_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
    }

    // optional double latitude = 2;
    inline bool Fingerprint_UserCharacteristics_Location::has_latitude() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_has_latitude()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_has_latitude()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_latitude()
    {
        latitude_ = 0;
        clear_has_latitude();
    }
    inline double Fingerprint_UserCharacteristics_Location::latitude() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
        return latitude_;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_latitude(double value)
    {
        set_has_latitude();
        latitude_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
    }

    // optional double longitude = 3;
    inline bool Fingerprint_UserCharacteristics_Location::has_longitude() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_has_longitude()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_has_longitude()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_longitude()
    {
        longitude_ = 0;
        clear_has_longitude();
    }
    inline double Fingerprint_UserCharacteristics_Location::longitude() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
        return longitude_;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_longitude(double value)
    {
        set_has_longitude();
        longitude_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
    }

    // optional double accuracy = 4;
    inline bool Fingerprint_UserCharacteristics_Location::has_accuracy() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_has_accuracy()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_has_accuracy()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_accuracy()
    {
        accuracy_ = 0;
        clear_has_accuracy();
    }
    inline double Fingerprint_UserCharacteristics_Location::accuracy() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
        return accuracy_;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_accuracy(double value)
    {
        set_has_accuracy();
        accuracy_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
    }

    // optional int64 time_in_ms = 5;
    inline bool Fingerprint_UserCharacteristics_Location::has_time_in_ms() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_has_time_in_ms()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_has_time_in_ms()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void Fingerprint_UserCharacteristics_Location::clear_time_in_ms()
    {
        time_in_ms_ = GOOGLE_LONGLONG(0);
        clear_has_time_in_ms();
    }
    inline ::google::protobuf::int64 Fingerprint_UserCharacteristics_Location::time_in_ms() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
        return time_in_ms_;
    }
    inline void Fingerprint_UserCharacteristics_Location::set_time_in_ms(::google::protobuf::int64 value)
    {
        set_has_time_in_ms();
        time_in_ms_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
    }

    // -------------------------------------------------------------------

    // Fingerprint_UserCharacteristics

    // optional float force = 1;
    inline bool Fingerprint_UserCharacteristics::has_force() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_UserCharacteristics::set_has_force()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_UserCharacteristics::clear_has_force()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_UserCharacteristics::clear_force()
    {
        force_ = 0;
        clear_has_force();
    }
    inline float Fingerprint_UserCharacteristics::force() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.force)
        return force_;
    }
    inline void Fingerprint_UserCharacteristics::set_force(float value)
    {
        set_has_force();
        force_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.force)
    }

    // optional float touch_width = 2;
    inline bool Fingerprint_UserCharacteristics::has_touch_width() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_UserCharacteristics::set_has_touch_width()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_UserCharacteristics::clear_has_touch_width()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_UserCharacteristics::clear_touch_width()
    {
        touch_width_ = 0;
        clear_has_touch_width();
    }
    inline float Fingerprint_UserCharacteristics::touch_width() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
        return touch_width_;
    }
    inline void Fingerprint_UserCharacteristics::set_touch_width(float value)
    {
        set_has_touch_width();
        touch_width_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
    }

    // optional float touch_height = 3;
    inline bool Fingerprint_UserCharacteristics::has_touch_height() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint_UserCharacteristics::set_has_touch_height()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint_UserCharacteristics::clear_has_touch_height()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint_UserCharacteristics::clear_touch_height()
    {
        touch_height_ = 0;
        clear_has_touch_height();
    }
    inline float Fingerprint_UserCharacteristics::touch_height() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
        return touch_height_;
    }
    inline void Fingerprint_UserCharacteristics::set_touch_height(float value)
    {
        set_has_touch_height();
        touch_height_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
    }

    // optional int32 touch_rotation = 4;
    inline bool Fingerprint_UserCharacteristics::has_touch_rotation() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void Fingerprint_UserCharacteristics::set_has_touch_rotation()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void Fingerprint_UserCharacteristics::clear_has_touch_rotation()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void Fingerprint_UserCharacteristics::clear_touch_rotation()
    {
        touch_rotation_ = 0;
        clear_has_touch_rotation();
    }
    inline ::google::protobuf::int32 Fingerprint_UserCharacteristics::touch_rotation() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
        return touch_rotation_;
    }
    inline void Fingerprint_UserCharacteristics::set_touch_rotation(::google::protobuf::int32 value)
    {
        set_has_touch_rotation();
        touch_rotation_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
    inline bool Fingerprint_UserCharacteristics::has_device_orientation() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void Fingerprint_UserCharacteristics::set_has_device_orientation()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void Fingerprint_UserCharacteristics::clear_has_device_orientation()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void Fingerprint_UserCharacteristics::clear_device_orientation()
    {
        if (device_orientation_ != NULL)
            device_orientation_->::autofill::risk::Fingerprint_UserCharacteristics_Vector::Clear();
        clear_has_device_orientation();
    }
    inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_orientation() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return device_orientation_ != NULL ? *device_orientation_ : *default_instance().device_orientation_;
#else
        return device_orientation_ != NULL ? *device_orientation_ : *default_instance_->device_orientation_;
#endif
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_orientation()
    {
        set_has_device_orientation();
        if (device_orientation_ == NULL) {
            device_orientation_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Vector;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
        return device_orientation_;
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_orientation()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
        clear_has_device_orientation();
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_orientation_;
        device_orientation_ = NULL;
        return temp;
    }
    inline void Fingerprint_UserCharacteristics::set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation)
    {
        delete device_orientation_;
        device_orientation_ = device_orientation;
        if (device_orientation) {
            set_has_device_orientation();
        } else {
            clear_has_device_orientation();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
    inline bool Fingerprint_UserCharacteristics::has_device_acceleration() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void Fingerprint_UserCharacteristics::set_has_device_acceleration()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void Fingerprint_UserCharacteristics::clear_has_device_acceleration()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void Fingerprint_UserCharacteristics::clear_device_acceleration()
    {
        if (device_acceleration_ != NULL)
            device_acceleration_->::autofill::risk::Fingerprint_UserCharacteristics_Vector::Clear();
        clear_has_device_acceleration();
    }
    inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_acceleration() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return device_acceleration_ != NULL ? *device_acceleration_ : *default_instance().device_acceleration_;
#else
        return device_acceleration_ != NULL ? *device_acceleration_ : *default_instance_->device_acceleration_;
#endif
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_acceleration()
    {
        set_has_device_acceleration();
        if (device_acceleration_ == NULL) {
            device_acceleration_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Vector;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
        return device_acceleration_;
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_acceleration()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
        clear_has_device_acceleration();
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_acceleration_;
        device_acceleration_ = NULL;
        return temp;
    }
    inline void Fingerprint_UserCharacteristics::set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration)
    {
        delete device_acceleration_;
        device_acceleration_ = device_acceleration;
        if (device_acceleration) {
            set_has_device_acceleration();
        } else {
            clear_has_device_acceleration();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
    inline bool Fingerprint_UserCharacteristics::has_location() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void Fingerprint_UserCharacteristics::set_has_location()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void Fingerprint_UserCharacteristics::clear_has_location()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void Fingerprint_UserCharacteristics::clear_location()
    {
        if (location_ != NULL)
            location_->::autofill::risk::Fingerprint_UserCharacteristics_Location::Clear();
        clear_has_location();
    }
    inline const ::autofill::risk::Fingerprint_UserCharacteristics_Location& Fingerprint_UserCharacteristics::location() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return location_ != NULL ? *location_ : *default_instance().location_;
#else
        return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::mutable_location()
    {
        set_has_location();
        if (location_ == NULL) {
            location_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Location;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.location)
        return location_;
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::release_location()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.location)
        clear_has_location();
        ::autofill::risk::Fingerprint_UserCharacteristics_Location* temp = location_;
        location_ = NULL;
        return temp;
    }
    inline void Fingerprint_UserCharacteristics::set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location)
    {
        delete location_;
        location_ = location;
        if (location) {
            set_has_location();
        } else {
            clear_has_location();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.location)
    }

    // -------------------------------------------------------------------

    // Fingerprint_Metadata

    // optional int64 timestamp_ms = 1;
    inline bool Fingerprint_Metadata::has_timestamp_ms() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint_Metadata::set_has_timestamp_ms()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint_Metadata::clear_has_timestamp_ms()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint_Metadata::clear_timestamp_ms()
    {
        timestamp_ms_ = GOOGLE_LONGLONG(0);
        clear_has_timestamp_ms();
    }
    inline ::google::protobuf::int64 Fingerprint_Metadata::timestamp_ms() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.timestamp_ms)
        return timestamp_ms_;
    }
    inline void Fingerprint_Metadata::set_timestamp_ms(::google::protobuf::int64 value)
    {
        set_has_timestamp_ms();
        timestamp_ms_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.timestamp_ms)
    }

    // optional uint64 obfuscated_gaia_id = 2;
    inline bool Fingerprint_Metadata::has_obfuscated_gaia_id() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint_Metadata::set_has_obfuscated_gaia_id()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint_Metadata::clear_has_obfuscated_gaia_id()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint_Metadata::clear_obfuscated_gaia_id()
    {
        obfuscated_gaia_id_ = GOOGLE_ULONGLONG(0);
        clear_has_obfuscated_gaia_id();
    }
    inline ::google::protobuf::uint64 Fingerprint_Metadata::obfuscated_gaia_id() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
        return obfuscated_gaia_id_;
    }
    inline void Fingerprint_Metadata::set_obfuscated_gaia_id(::google::protobuf::uint64 value)
    {
        set_has_obfuscated_gaia_id();
        obfuscated_gaia_id_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
    }

    // optional int32 fingerprinter_version = 3;
    inline bool Fingerprint_Metadata::has_fingerprinter_version() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint_Metadata::set_has_fingerprinter_version()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint_Metadata::clear_has_fingerprinter_version()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint_Metadata::clear_fingerprinter_version()
    {
        fingerprinter_version_ = 0;
        clear_has_fingerprinter_version();
    }
    inline ::google::protobuf::int32 Fingerprint_Metadata::fingerprinter_version() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
        return fingerprinter_version_;
    }
    inline void Fingerprint_Metadata::set_fingerprinter_version(::google::protobuf::int32 value)
    {
        set_has_fingerprinter_version();
        fingerprinter_version_ = value;
        // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
    }

    // -------------------------------------------------------------------

    // Fingerprint

    // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
    inline bool Fingerprint::has_machine_characteristics() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Fingerprint::set_has_machine_characteristics()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Fingerprint::clear_has_machine_characteristics()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Fingerprint::clear_machine_characteristics()
    {
        if (machine_characteristics_ != NULL)
            machine_characteristics_->::autofill::risk::Fingerprint_MachineCharacteristics::Clear();
        clear_has_machine_characteristics();
    }
    inline const ::autofill::risk::Fingerprint_MachineCharacteristics& Fingerprint::machine_characteristics() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.machine_characteristics)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return machine_characteristics_ != NULL ? *machine_characteristics_ : *default_instance().machine_characteristics_;
#else
        return machine_characteristics_ != NULL ? *machine_characteristics_ : *default_instance_->machine_characteristics_;
#endif
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::mutable_machine_characteristics()
    {
        set_has_machine_characteristics();
        if (machine_characteristics_ == NULL) {
            machine_characteristics_ = new ::autofill::risk::Fingerprint_MachineCharacteristics;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.machine_characteristics)
        return machine_characteristics_;
    }
    inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::release_machine_characteristics()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.machine_characteristics)
        clear_has_machine_characteristics();
        ::autofill::risk::Fingerprint_MachineCharacteristics* temp = machine_characteristics_;
        machine_characteristics_ = NULL;
        return temp;
    }
    inline void Fingerprint::set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics)
    {
        delete machine_characteristics_;
        machine_characteristics_ = machine_characteristics;
        if (machine_characteristics) {
            set_has_machine_characteristics();
        } else {
            clear_has_machine_characteristics();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.machine_characteristics)
    }

    // optional .autofill.risk.Fingerprint.Performance performance = 2;
    inline bool Fingerprint::has_performance() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void Fingerprint::set_has_performance()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void Fingerprint::clear_has_performance()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void Fingerprint::clear_performance()
    {
        if (performance_ != NULL)
            performance_->::autofill::risk::Fingerprint_Performance::Clear();
        clear_has_performance();
    }
    inline const ::autofill::risk::Fingerprint_Performance& Fingerprint::performance() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.performance)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return performance_ != NULL ? *performance_ : *default_instance().performance_;
#else
        return performance_ != NULL ? *performance_ : *default_instance_->performance_;
#endif
    }
    inline ::autofill::risk::Fingerprint_Performance* Fingerprint::mutable_performance()
    {
        set_has_performance();
        if (performance_ == NULL) {
            performance_ = new ::autofill::risk::Fingerprint_Performance;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.performance)
        return performance_;
    }
    inline ::autofill::risk::Fingerprint_Performance* Fingerprint::release_performance()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.performance)
        clear_has_performance();
        ::autofill::risk::Fingerprint_Performance* temp = performance_;
        performance_ = NULL;
        return temp;
    }
    inline void Fingerprint::set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance)
    {
        delete performance_;
        performance_ = performance;
        if (performance) {
            set_has_performance();
        } else {
            clear_has_performance();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.performance)
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
    inline bool Fingerprint::has_user_characteristics() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void Fingerprint::set_has_user_characteristics()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void Fingerprint::clear_has_user_characteristics()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void Fingerprint::clear_user_characteristics()
    {
        if (user_characteristics_ != NULL)
            user_characteristics_->::autofill::risk::Fingerprint_UserCharacteristics::Clear();
        clear_has_user_characteristics();
    }
    inline const ::autofill::risk::Fingerprint_UserCharacteristics& Fingerprint::user_characteristics() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.user_characteristics)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return user_characteristics_ != NULL ? *user_characteristics_ : *default_instance().user_characteristics_;
#else
        return user_characteristics_ != NULL ? *user_characteristics_ : *default_instance_->user_characteristics_;
#endif
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::mutable_user_characteristics()
    {
        set_has_user_characteristics();
        if (user_characteristics_ == NULL) {
            user_characteristics_ = new ::autofill::risk::Fingerprint_UserCharacteristics;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.user_characteristics)
        return user_characteristics_;
    }
    inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::release_user_characteristics()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.user_characteristics)
        clear_has_user_characteristics();
        ::autofill::risk::Fingerprint_UserCharacteristics* temp = user_characteristics_;
        user_characteristics_ = NULL;
        return temp;
    }
    inline void Fingerprint::set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics)
    {
        delete user_characteristics_;
        user_characteristics_ = user_characteristics;
        if (user_characteristics) {
            set_has_user_characteristics();
        } else {
            clear_has_user_characteristics();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.user_characteristics)
    }

    // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
    inline bool Fingerprint::has_transient_state() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void Fingerprint::set_has_transient_state()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void Fingerprint::clear_has_transient_state()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void Fingerprint::clear_transient_state()
    {
        if (transient_state_ != NULL)
            transient_state_->::autofill::risk::Fingerprint_TransientState::Clear();
        clear_has_transient_state();
    }
    inline const ::autofill::risk::Fingerprint_TransientState& Fingerprint::transient_state() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.transient_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return transient_state_ != NULL ? *transient_state_ : *default_instance().transient_state_;
#else
        return transient_state_ != NULL ? *transient_state_ : *default_instance_->transient_state_;
#endif
    }
    inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::mutable_transient_state()
    {
        set_has_transient_state();
        if (transient_state_ == NULL) {
            transient_state_ = new ::autofill::risk::Fingerprint_TransientState;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.transient_state)
        return transient_state_;
    }
    inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::release_transient_state()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.transient_state)
        clear_has_transient_state();
        ::autofill::risk::Fingerprint_TransientState* temp = transient_state_;
        transient_state_ = NULL;
        return temp;
    }
    inline void Fingerprint::set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state)
    {
        delete transient_state_;
        transient_state_ = transient_state;
        if (transient_state) {
            set_has_transient_state();
        } else {
            clear_has_transient_state();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.transient_state)
    }

    // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
    inline bool Fingerprint::has_metadata() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void Fingerprint::set_has_metadata()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void Fingerprint::clear_has_metadata()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void Fingerprint::clear_metadata()
    {
        if (metadata_ != NULL)
            metadata_->::autofill::risk::Fingerprint_Metadata::Clear();
        clear_has_metadata();
    }
    inline const ::autofill::risk::Fingerprint_Metadata& Fingerprint::metadata() const
    {
        // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
        return metadata_ != NULL ? *metadata_ : *default_instance().metadata_;
#else
        return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
#endif
    }
    inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::mutable_metadata()
    {
        set_has_metadata();
        if (metadata_ == NULL) {
            metadata_ = new ::autofill::risk::Fingerprint_Metadata;
        }
        // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.metadata)
        return metadata_;
    }
    inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::release_metadata()
    {
        // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.metadata)
        clear_has_metadata();
        ::autofill::risk::Fingerprint_Metadata* temp = metadata_;
        metadata_ = NULL;
        return temp;
    }
    inline void Fingerprint::set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata)
    {
        delete metadata_;
        metadata_ = metadata;
        if (metadata) {
            set_has_metadata();
        } else {
            clear_has_metadata();
        }
        // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.metadata)
    }

#endif // !PROTOBUF_INLINE_NOT_IN_HEADERS
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

} // namespace risk
} // namespace autofill

#ifndef SWIG
namespace google {
namespace protobuf {

    template <>
    struct is_proto_enum<::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature> : ::google::protobuf::internal::true_type {
    };

} // namespace protobuf
} // namespace google
#endif // SWIG

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_fingerprint_2eproto__INCLUDED
